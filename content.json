{"meta":{"title":"Victor","subtitle":"개발 노트","description":"개발 노트","author":"ckck803","url":"https://ckck803.github.io","root":"/"},"pages":[],"posts":[{"title":"쓰레드와 메모리구조","slug":"computer-science/os/thread/thread-memory","date":"2024-03-02T21:16:13.000Z","updated":"2024-03-03T05:49:58.462Z","comments":true,"path":"2024/03/03/computer-science/os/thread/thread-memory/","link":"","permalink":"https://ckck803.github.io/2024/03/03/computer-science/os/thread/thread-memory/","excerpt":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 참고 https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4 쓰레드 메모리 구조프로세스내 Code, Data, Heap 영역은 모든 쓰레드가 공유해서 사용하고 각 쓰레드 별로 Stack 영역이 생성됩니다.","text":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 참고 https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4 쓰레드 메모리 구조프로세스내 Code, Data, Heap 영역은 모든 쓰레드가 공유해서 사용하고 각 쓰레드 별로 Stack 영역이 생성됩니다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"tags":[]},{"title":"Vue3 - Component 간 통신","slug":"vue/vue3/vue3-component-communication","date":"2024-03-02T11:31:46.000Z","updated":"2024-11-23T16:53:10.959Z","comments":true,"path":"2024/03/02/vue/vue3/vue3-component-communication/","link":"","permalink":"https://ckck803.github.io/2024/03/02/vue/vue3/vue3-component-communication/","excerpt":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 Component 간 통신 - PropsVue 에서는 상위 컴포넌트에서 하위 컴포넌트로 통신하기 위한 방법으로 Props 를 제공합니다. Props 를 통해 상위 컴포넌트에서 하위 컴포넌트로 데이터를 내려줍니다. 하위 컴포넌트에서 전달 받은 Props 를 사용하기 위해v-bind 를 이용해 Props 이름&#x3D;”상위컴포넌트의 데이터이름“ 형식으로 Props 를 매팽해 줍니다. &lt;div id=&quot;app&quot;&gt; &lt;app-header v-bind:title=&quot;appTitle&quot;&gt;&lt;/app-header&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Vue.createApp(&#123; data() &#123; return &#123; appTitle: &#x27;프롭스 넘기기&#x27; &#125; &#125;, components: &#123; // &#x27;컴포넌트 이름&#x27;: 컴포넌트 내용 &#x27;app-header&#x27;: &#123; template: &#x27;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&#x27;, props: [&#x27;title&#x27;] &#125; &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt; Component 간 통신 - Event하위 컴포넌트에서 상위 컴포넌트와 통신하기 위한 방법으로는 Event 를 제공합니다. &lt;div id=&quot;app&quot;&gt; &lt;app-content v-on:refresh=&quot;showAlert&quot;&gt;&lt;/app-content&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var appContents = &#123; template: ` &lt;p&gt; &lt;button v-on:click=&quot;sendEvent&quot;&gt;갱신&lt;/button&gt; &lt;/p&gt; `, methods: &#123; sendEvent() &#123; this.$emit(&#x27;refresh&#x27;); &#125; &#125; &#125; // Root 컴포넌트 Vue.createApp(&#123; methods: &#123; showAlert() &#123; alert(&#x27;새로고침&#x27;) &#125; &#125;, components: &#123; // &#x27;컴포넌트 이름&#x27;: 컴포넌트 내용 &#x27;app-content&#x27;: appContents &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt;","text":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 Component 간 통신 - PropsVue 에서는 상위 컴포넌트에서 하위 컴포넌트로 통신하기 위한 방법으로 Props 를 제공합니다. Props 를 통해 상위 컴포넌트에서 하위 컴포넌트로 데이터를 내려줍니다. 하위 컴포넌트에서 전달 받은 Props 를 사용하기 위해v-bind 를 이용해 Props 이름&#x3D;”상위컴포넌트의 데이터이름“ 형식으로 Props 를 매팽해 줍니다. &lt;div id=&quot;app&quot;&gt; &lt;app-header v-bind:title=&quot;appTitle&quot;&gt;&lt;/app-header&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Vue.createApp(&#123; data() &#123; return &#123; appTitle: &#x27;프롭스 넘기기&#x27; &#125; &#125;, components: &#123; // &#x27;컴포넌트 이름&#x27;: 컴포넌트 내용 &#x27;app-header&#x27;: &#123; template: &#x27;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&#x27;, props: [&#x27;title&#x27;] &#125; &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt; Component 간 통신 - Event하위 컴포넌트에서 상위 컴포넌트와 통신하기 위한 방법으로는 Event 를 제공합니다. &lt;div id=&quot;app&quot;&gt; &lt;app-content v-on:refresh=&quot;showAlert&quot;&gt;&lt;/app-content&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var appContents = &#123; template: ` &lt;p&gt; &lt;button v-on:click=&quot;sendEvent&quot;&gt;갱신&lt;/button&gt; &lt;/p&gt; `, methods: &#123; sendEvent() &#123; this.$emit(&#x27;refresh&#x27;); &#125; &#125; &#125; // Root 컴포넌트 Vue.createApp(&#123; methods: &#123; showAlert() &#123; alert(&#x27;새로고침&#x27;) &#125; &#125;, components: &#123; // &#x27;컴포넌트 이름&#x27;: 컴포넌트 내용 &#x27;app-content&#x27;: appContents &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt; 같은 레벨의 컴포넌트간 데이터 통신&lt;div id=&quot;app&quot;&gt; &lt;app-header v-bind:app-title=&quot;message&quot;&gt;&lt;/app-header&gt; &lt;app-content v-on:login=&quot;receive&quot;&gt;&lt;/app-content&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var appHeader = &#123; props: [&#x27;appTitle&#x27;], template: `&lt;h1&gt;&#123;&#123;appTitle&#125;&#125;&lt;/h1&gt;`, &#125; var appContents = &#123; template: ` &lt;p&gt; &lt;button v-on:click=&quot;sendEvent&quot;&gt;로그인&lt;/button&gt; &lt;/p&gt; `, methods: &#123; sendEvent() &#123; this.$emit(&#x27;login&#x27;); &#125; &#125; &#125; // Root 컴포넌트 Vue.createApp(&#123; data() &#123; return &#123; message: &#x27;&#x27; &#125; &#125;, methods: &#123; receive() &#123; console.log(&quot;받았다.&quot;) this.message = &quot;로그인 됨&quot; &#125; &#125;, components: &#123; // &#x27;컴포넌트 이름&#x27;: 컴포넌트 내용 &#x27;app-header&#x27;: appHeader, &#x27;app-content&#x27;: appContents &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue3","slug":"Frontend/Vue3","permalink":"https://ckck803.github.io/categories/Frontend/Vue3/"}],"tags":[]},{"title":"Vue3 - Component","slug":"vue/vue3/vue3-component","date":"2024-03-01T11:31:46.000Z","updated":"2024-11-23T16:53:15.445Z","comments":true,"path":"2024/03/01/vue/vue3/vue3-component/","link":"","permalink":"https://ckck803.github.io/2024/03/01/vue/vue3/vue3-component/","excerpt":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 ComponentComponent 란 하나의 화면을 여러개의 블록으로 나눌 수 있는 단위입니다. Component 를 통해 빠르게 화면을 구조화할 수 있고 코드 재사용성이 늘어납니다. Vue 에서는 Component 를 이용한 개발을 지원합니다. 한 페이지에서 하위 컴포넌트 생성components 내 template 을 이용하면 상위 컴포넌트에서 바로 하위 컴포넌트 내용을 정의할 수 있습니다. Vue.createApp(&#123; components: &#123; // &#x27;컴포넌트 이름&#x27;: 컴포넌트 내용 &#x27;app-header&#x27;: &#123; template: &#x27;&lt;h1&gt;컴포넌트 이름&lt;/h1&gt;&#x27; &#125; &#125;&#125;).mount(&#x27;#app&#x27;) 정의된 하위 컴포넌트는 컴포넌트 이름을 통해 상위 컴포넌트에서 사용할 수 있습니다. &lt;div id=&quot;app&quot;&gt; &lt;app-header&gt;&lt;/app-header&gt;&lt;/div&gt;","text":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 ComponentComponent 란 하나의 화면을 여러개의 블록으로 나눌 수 있는 단위입니다. Component 를 통해 빠르게 화면을 구조화할 수 있고 코드 재사용성이 늘어납니다. Vue 에서는 Component 를 이용한 개발을 지원합니다. 한 페이지에서 하위 컴포넌트 생성components 내 template 을 이용하면 상위 컴포넌트에서 바로 하위 컴포넌트 내용을 정의할 수 있습니다. Vue.createApp(&#123; components: &#123; // &#x27;컴포넌트 이름&#x27;: 컴포넌트 내용 &#x27;app-header&#x27;: &#123; template: &#x27;&lt;h1&gt;컴포넌트 이름&lt;/h1&gt;&#x27; &#125; &#125;&#125;).mount(&#x27;#app&#x27;) 정의된 하위 컴포넌트는 컴포넌트 이름을 통해 상위 컴포넌트에서 사용할 수 있습니다. &lt;div id=&quot;app&quot;&gt; &lt;app-header&gt;&lt;/app-header&gt;&lt;/div&gt; 별도의 파일로 Component 생성vue 파일을 이용해 하위 컴포넌트를 생성할 수 있습니다. &lt;template&gt; &lt;h1&gt;&#123;&#123; appTitle &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;changeTitle&quot;&gt;변경&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [&#x27;appTitle&#x27;], methods: &#123; changeTitle() &#123; this.$emit(&#x27;change&#x27;); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 상위 Component 에서 하위 Component 를 사용하기 위해서는 import 를 이용해 하위 vue 파일에 정의된 Component 를 가져와 components 에 등록해야합니다. // import 컴포넌트이름 from &#x27;./컴포넌트 경로&#x27;import AppHeader from &quot;./components/AppHeader.vue&quot;;export default &#123; // 하위 컴포넌트 등록 components: &#123; AppHeader, &#125;, data() &#123; return &#123; message: &quot;앱 헤더 컴포넌트&quot;, &#125;; &#125;, methods: &#123; changeMessage() &#123; this.message = &quot;변경됨&quot;; &#125;, &#125;,&#125;; 위와 마찬가지로 상위 컴포넌트에서는 등록된 컴포넌트 이름을 이용해 사용할 수 있습니다. &lt;template&gt; &lt;AppHeader v-bind:appTitle=&quot;message&quot; v-on:change=&quot;changeMessage&quot;&gt; &lt;/AppHeader&gt;&lt;/template&gt;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue3","slug":"Frontend/Vue3","permalink":"https://ckck803.github.io/categories/Frontend/Vue3/"}],"tags":[]},{"title":"Vue3 - Instance","slug":"vue/vue3/vue3-instance","date":"2024-03-01T03:31:46.000Z","updated":"2024-11-23T16:53:32.428Z","comments":true,"path":"2024/03/01/vue/vue3/vue3-instance/","link":"","permalink":"https://ckck803.github.io/2024/03/01/vue/vue3/vue3-instance/","excerpt":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 Vue 3 Instance 와 속성Vue.createApp(&#123; template: , data: , methods: , created: , watch: ,&#125;); methods&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;addCount&quot;&gt;+&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Vue.createApp(&#123; data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; addCount() &#123; this.count++; &#125; &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt; Vue Directivev-for&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Vue.createApp(&#123; data() &#123; return &#123; items: [&#x27;삼성&#x27;, &#x27;네이버&#x27;, &#x27;인프런&#x27;] &#125; &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt;","text":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 Vue 3 Instance 와 속성Vue.createApp(&#123; template: , data: , methods: , created: , watch: ,&#125;); methods&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;addCount&quot;&gt;+&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Vue.createApp(&#123; data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; addCount() &#123; this.count++; &#125; &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt; Vue Directivev-for&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Vue.createApp(&#123; data() &#123; return &#123; items: [&#x27;삼성&#x27;, &#x27;네이버&#x27;, &#x27;인프런&#x27;] &#125; &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue3","slug":"Frontend/Vue3","permalink":"https://ckck803.github.io/categories/Frontend/Vue3/"}],"tags":[]},{"title":"Vue3 - Composition API","slug":"vue/vue3/vue3-composition-api","date":"2024-03-01T02:31:46.000Z","updated":"2024-11-23T16:53:28.493Z","comments":true,"path":"2024/03/01/vue/vue3/vue3-composition-api/","link":"","permalink":"https://ckck803.github.io/2024/03/01/vue/vue3/vue3-composition-api/","excerpt":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 Composition API 로 리펙토링Composition API 적용 전export default &#123; methods: &#123; logText() &#123; this.pas &#125; &#125; data() &#123; return &#123; username: &#x27;&#x27;, password: &#x27;&#x27;, &#125; &#125;, methods: &#123; submitForm() &#123; // event.preventDefault(); const data = &#123; username: this.username, password: this.password, &#125; axios.post(&#x27;https://jsonplaceholder.typicode.com/users/&#x27;, data) .then(response =&gt; &#123; console.log(response) &#125;); // console.log(&#x27;제출됨&#x27;) &#125; &#125;&#125; Composition API 적용 후export default &#123; setup() &#123; // data var username = ref(&#x27;&#x27;); var password = ref(&#x27;&#x27;); // methods var submitForm = () =&gt; &#123; axios.post(&#x27;https://jsonplaceholder.typicode.com/users/&#x27;, &#123; username: username.value, password: password.value &#125;).then(response =&gt; &#123; console.log(response); &#125;) &#125; return &#123; username, password, submitForm &#125; &#125;,&#125;","text":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 Composition API 로 리펙토링Composition API 적용 전export default &#123; methods: &#123; logText() &#123; this.pas &#125; &#125; data() &#123; return &#123; username: &#x27;&#x27;, password: &#x27;&#x27;, &#125; &#125;, methods: &#123; submitForm() &#123; // event.preventDefault(); const data = &#123; username: this.username, password: this.password, &#125; axios.post(&#x27;https://jsonplaceholder.typicode.com/users/&#x27;, data) .then(response =&gt; &#123; console.log(response) &#125;); // console.log(&#x27;제출됨&#x27;) &#125; &#125;&#125; Composition API 적용 후export default &#123; setup() &#123; // data var username = ref(&#x27;&#x27;); var password = ref(&#x27;&#x27;); // methods var submitForm = () =&gt; &#123; axios.post(&#x27;https://jsonplaceholder.typicode.com/users/&#x27;, &#123; username: username.value, password: password.value &#125;).then(response =&gt; &#123; console.log(response); &#125;) &#125; return &#123; username, password, submitForm &#125; &#125;,&#125;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue3","slug":"Frontend/Vue3","permalink":"https://ckck803.github.io/categories/Frontend/Vue3/"}],"tags":[]},{"title":"Vue3 - Reactivity","slug":"vue/vue3/vue3-reactivity","date":"2024-03-01T00:31:46.000Z","updated":"2024-11-23T16:53:37.698Z","comments":true,"path":"2024/03/01/vue/vue3/vue3-reactivity/","link":"","permalink":"https://ckck803.github.io/2024/03/01/vue/vue3/vue3-reactivity/","excerpt":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 ReactivityProxy 참고 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy set target 객체 property 객체내 속성 value 전달 받는 값 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;!-- &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt; --&gt;&lt;script&gt; var data = &#123; message: 10 &#125; function render(sth) &#123; var div = document.querySelector(&#x27;#app&#x27;); div.innerHTML = sth; &#125; var app = new Proxy(data, &#123; get() &#123; console.log(&#x27;값 접근&#x27;) &#125;, set(target, prop, value) &#123; console.log(&#x27;값 갱신&#x27;) target[prop] = value render(value) &#125; &#125;)&lt;/script&gt; app.message = &#x27;hello vue&#x27;;","text":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 ReactivityProxy 참고 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy set target 객체 property 객체내 속성 value 전달 받는 값 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;!-- &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt; --&gt;&lt;script&gt; var data = &#123; message: 10 &#125; function render(sth) &#123; var div = document.querySelector(&#x27;#app&#x27;); div.innerHTML = sth; &#125; var app = new Proxy(data, &#123; get() &#123; console.log(&#x27;값 접근&#x27;) &#125;, set(target, prop, value) &#123; console.log(&#x27;값 갱신&#x27;) target[prop] = value render(value) &#125; &#125;)&lt;/script&gt; app.message = &#x27;hello vue&#x27;;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue3","slug":"Frontend/Vue3","permalink":"https://ckck803.github.io/categories/Frontend/Vue3/"}],"tags":[]},{"title":"Vue3 - 시작하기","slug":"vue/vue3/vue3-start","date":"2024-02-29T21:31:46.000Z","updated":"2024-11-23T16:53:46.134Z","comments":true,"path":"2024/03/01/vue/vue3/vue3-start/","link":"","permalink":"https://ckck803.github.io/2024/03/01/vue/vue3/vue3-start/","excerpt":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 CDN 으로 시작하기&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt; const &#123; createApp &#125; = Vue createApp(&#123; data() &#123; return &#123; message: &#x27;Hello Vue!&#x27; &#125; &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt;","text":"목차 Vue3 - Component 간 통신 Vue3 - Component Vue3 - Composition API Vue3 - Instance Vue3 - Reactivity Vue3 - 시작하기 CDN 으로 시작하기&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt; const &#123; createApp &#125; = Vue createApp(&#123; data() &#123; return &#123; message: &#x27;Hello Vue!&#x27; &#125; &#125; &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue3","slug":"Frontend/Vue3","permalink":"https://ckck803.github.io/categories/Frontend/Vue3/"}],"tags":[]},{"title":"Vue - Router","slug":"vue/vue/vue-router","date":"2024-02-28T11:10:40.000Z","updated":"2024-11-23T16:52:47.323Z","comments":true,"path":"2024/02/28/vue/vue/vue-router/","link":"","permalink":"https://ckck803.github.io/2024/02/28/vue/vue/vue-router/","excerpt":"라이브러리 설치npm install vue-router import &#123;createWebHistory, createRouter&#125; from &quot;vue-router&quot;;const routes = [ &#123; path: &quot;/&quot;, name: &quot;home&quot;, component: () =&gt; import(&#x27;../pages/ChatRoom.vue&#x27;) &#125;]const router = createRouter(&#123; history: createWebHistory(), routes&#125;)export default router; import &#123; createApp &#125; from &#x27;vue&#x27;import &#x27;./style.css&#x27;import App from &#x27;./App.vue&#x27;import router from &quot;./router/router.ts&quot;;createApp(App) .use(router) .mount(&#x27;#app&#x27;) &lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;template&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;&lt;style scoped&gt;.logo &#123; height: 6em; padding: 1.5em; will-change: filter; transition: filter 300ms;&#125;.logo:hover &#123; filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123; filter: drop-shadow(0 0 2em #42b883aa);&#125;&lt;/style&gt;","text":"라이브러리 설치npm install vue-router import &#123;createWebHistory, createRouter&#125; from &quot;vue-router&quot;;const routes = [ &#123; path: &quot;/&quot;, name: &quot;home&quot;, component: () =&gt; import(&#x27;../pages/ChatRoom.vue&#x27;) &#125;]const router = createRouter(&#123; history: createWebHistory(), routes&#125;)export default router; import &#123; createApp &#125; from &#x27;vue&#x27;import &#x27;./style.css&#x27;import App from &#x27;./App.vue&#x27;import router from &quot;./router/router.ts&quot;;createApp(App) .use(router) .mount(&#x27;#app&#x27;) &lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;template&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;&lt;style scoped&gt;.logo &#123; height: 6em; padding: 1.5em; will-change: filter; transition: filter 300ms;&#125;.logo:hover &#123; filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123; filter: drop-shadow(0 0 2em #42b883aa);&#125;&lt;/style&gt;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue","slug":"Frontend/Vue","permalink":"https://ckck803.github.io/categories/Frontend/Vue/"}],"tags":[]},{"title":"Spring - 의존성 주입 방식","slug":"spring/spring-core/spring-dependency-injection","date":"2024-02-26T15:14:19.000Z","updated":"2024-11-23T07:52:24.167Z","comments":true,"path":"2024/02/27/spring/spring-core/spring-dependency-injection/","link":"","permalink":"https://ckck803.github.io/2024/02/27/spring/spring-core/spring-dependency-injection/","excerpt":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - Spring 컨테이너 스프링 의존성 주입 (Dependency Injection) 의존성 주입은 객체간의 의존성을 관리하기 위한 디자인 패턴 한 객체가 직접 의존성하는 다른 객체를 생성하거나 관리하지 않고, 프레임워크와 같은 외부로부터 필요한 의존성을 주입받는방식 입니다. 이를 통해 객체간 의존성을 수정하기 위해 직접 코드를 수정할 필요가 없어 객체간 결합도 를 낮춰줍니다. 스프링에서는 스프링 컨테이너가 객체의 의존성을 관리하고 주입해줍니다. 이때, 스프링 컨테이너가 의존성을 관리 및 주입을 위해 관리하는 객체들을 스프링 Bean 이라 부릅니다. 스프링에서 의존성 주입을 위해서는 우선, 스프링 컨테이너에 객체들을 스프링 Bean 으로 등록해야 합나다. 의존성 주입은 스프링 Bean 으로 등록된 객체들을 기준으로 주입이 이뤄집니다. 스프링에서 의존성 주입을 위해 @Autowired와 @Inject 를 사용하고 생성자, Setter, 필드, 메소드 에 붙일 수 있습니다. 위 어노테이션이 객체의 의존성을 주입할때는 타입을 기준으로 주입합니다.","text":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - Spring 컨테이너 스프링 의존성 주입 (Dependency Injection) 의존성 주입은 객체간의 의존성을 관리하기 위한 디자인 패턴 한 객체가 직접 의존성하는 다른 객체를 생성하거나 관리하지 않고, 프레임워크와 같은 외부로부터 필요한 의존성을 주입받는방식 입니다. 이를 통해 객체간 의존성을 수정하기 위해 직접 코드를 수정할 필요가 없어 객체간 결합도 를 낮춰줍니다. 스프링에서는 스프링 컨테이너가 객체의 의존성을 관리하고 주입해줍니다. 이때, 스프링 컨테이너가 의존성을 관리 및 주입을 위해 관리하는 객체들을 스프링 Bean 이라 부릅니다. 스프링에서 의존성 주입을 위해서는 우선, 스프링 컨테이너에 객체들을 스프링 Bean 으로 등록해야 합나다. 의존성 주입은 스프링 Bean 으로 등록된 객체들을 기준으로 주입이 이뤄집니다. 스프링에서 의존성 주입을 위해 @Autowired와 @Inject 를 사용하고 생성자, Setter, 필드, 메소드 에 붙일 수 있습니다. 위 어노테이션이 객체의 의존성을 주입할때는 타입을 기준으로 주입합니다. 의존성 주입방식1. 생성자 주입 생성자를 통한 의존성 주입 방식은 스프링에서 가장 권장하는 방식입니다. 스프링 컨테이너가 Bean 을 생성할때 객체의 생성자를 이용해 의존관계를 주입하는 방식입니다. 생성자를 통한 의존관계 주입은 객체 생성시 단 한번만 호출돼 객체간 의존관계의 불변성이 보장됩니다. 초기화 시점에 의존관계가 설정되고 변경되지 않기 때문에 final 키워드를 사용할 수 있습니다. 또한, 생성자를 통한 의존 관계 주입시 생성자가 1개인 경우 @Autowried 를 생략할 수 있습니다. @Componentpublic class OrderServiceImpl implements OrderService &#123; private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; @Autowired // 생성자가 1개일 경우 생략 가능 public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) &#123; this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; &#125;&#125; 2. Setter 주입 의존관계의 변경이 있을때 사용하는 방식 Setter 메소드를 이용해 객체의 의존 관계를 주입하는 방법입니다. 변경 가능성이 있는 의존관계에 사용합니다. 값이 초기화 후 의존관게가 변경될 수 있어 final 키워드 사용이 불가능 합니다 @Componentpublic class OrderServiceImpl implements OrderService &#123; private MemberRepository memberRepository; private DiscountPolicy discountPolicy; @Autowired public void setMemberRepository(MemberRepository memberRepository) &#123; this.memberRepository = memberRepository; &#125; @Autowired public void setDiscountPolicy(DiscountPolicy discountPolicy) &#123; this.discountPolicy = discountPolicy; &#125;&#125; 3. 필드 주입 DI 프레임워크를 통한 의존 관계 주입 필드에 직접 의존관계를 주입하는 방식입니다. 필드 주입은 DI 프레임워크가 없으면 의존 관계를 주입할 수 없습니다. 또한 필드 주입방식은 테스트 시 의존관계가 있는 객체에 접근할 수 없어 테스트하기 어렵습니다. @Componentpublic class OrderServiceImpl implements OrderService &#123; @Autowired private MemberRepository memberRepository; @Autowired private DiscountPolicy discountPolicy;&#125; 4. 메서드 주입일반 메소드를 이용해 의존 관계를 주입하는 방식입니다. 메소드에 @Autowired 를 붙여 의존 객체를 주입합니다. @Componentpublic class OrderServiceImpl implements OrderService &#123; private MemberRepository memberRepository; private DiscountPolicy discountPolicy; @Autowired public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) &#123; this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Core","slug":"Spring/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring/Spring-Core/"}],"tags":[]},{"title":"Vite 환경에서 tsconfig Path 사용하기","slug":"react/vite/tsconfig-vite","date":"2024-02-23T21:31:46.000Z","updated":"2024-11-23T16:46:05.429Z","comments":true,"path":"2024/02/24/react/vite/tsconfig-vite/","link":"","permalink":"https://ckck803.github.io/2024/02/24/react/vite/tsconfig-vite/","excerpt":"라이브러리 설치npm install vite-tsconfig-paths import react from &quot;@vitejs/plugin-react&quot;;import &#123;defineConfig&#125; from &quot;vite&quot;;import EnvironmentPlugin from &quot;vite-plugin-environment&quot;;import tsconfigPaths from &quot;vite-tsconfig-paths&quot;;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ react(), tsconfigPaths(), ], resolve: &#123; alias: &#123;&#125;, &#125;, build : &#123; outDir: &quot;./build&quot;, &#125;, server : &#123; port: Number(process.env.PORT || 3000), &#125;, define : &#123;&#125;,&#125;);","text":"라이브러리 설치npm install vite-tsconfig-paths import react from &quot;@vitejs/plugin-react&quot;;import &#123;defineConfig&#125; from &quot;vite&quot;;import EnvironmentPlugin from &quot;vite-plugin-environment&quot;;import tsconfigPaths from &quot;vite-tsconfig-paths&quot;;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ react(), tsconfigPaths(), ], resolve: &#123; alias: &#123;&#125;, &#125;, build : &#123; outDir: &quot;./build&quot;, &#125;, server : &#123; port: Number(process.env.PORT || 3000), &#125;, define : &#123;&#125;,&#125;);","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vite","slug":"Frontend/Vite","permalink":"https://ckck803.github.io/categories/Frontend/Vite/"}],"tags":[]},{"title":"Vuex - Helper 함수","slug":"vue/vuex/vuex-helper","date":"2024-02-16T11:10:40.000Z","updated":"2024-11-23T16:53:58.881Z","comments":true,"path":"2024/02/16/vue/vuex/vuex-helper/","link":"","permalink":"https://ckck803.github.io/2024/02/16/vue/vuex/vuex-helper/","excerpt":"mapStatemapGetters","text":"mapStatemapGetters","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue3","slug":"Frontend/Vue3","permalink":"https://ckck803.github.io/categories/Frontend/Vue3/"}],"tags":[]},{"title":"Vuex 시작하기","slug":"vue/vuex/vuex-start","date":"2024-02-15T11:10:40.000Z","updated":"2024-11-23T16:54:03.998Z","comments":true,"path":"2024/02/15/vue/vuex/vuex-start/","link":"","permalink":"https://ckck803.github.io/2024/02/15/vue/vuex/vuex-start/","excerpt":"라이브러리 등록# Vue 3 npm install vuex --save# Vue 2npm install vuex@3.6.2 --save Store 생성 Vue 2 에서 Store 생성 const Store = new Vuex.Store(&#123; state: &#123;&#125;, getters: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;,&#125;) Vue 3 에서 Store 생성 import &#123; createStore &#125; from &quot;vuex&quot;;export default createStore(&#123; state: &#123;&#125;, getters: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;,&#125;); Store 등록 Vue 2 에서 Store 등록","text":"라이브러리 등록# Vue 3 npm install vuex --save# Vue 2npm install vuex@3.6.2 --save Store 생성 Vue 2 에서 Store 생성 const Store = new Vuex.Store(&#123; state: &#123;&#125;, getters: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;,&#125;) Vue 3 에서 Store 생성 import &#123; createStore &#125; from &quot;vuex&quot;;export default createStore(&#123; state: &#123;&#125;, getters: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;,&#125;); Store 등록 Vue 2 에서 Store 등록 import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &quot;./store/store&quot;;new Vue(&#123; el: &#x27;#app&#x27;, store, render: h =&gt; h(App)&#125;) Vue 3 에서 Store 등록 import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;createApp(App).use(store).use(router).mount(&quot;#app&quot;);","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue3","slug":"Frontend/Vue3","permalink":"https://ckck803.github.io/categories/Frontend/Vue3/"}],"tags":[]},{"title":"Vue - 시작하기","slug":"vue/vue/vue-start","date":"2024-01-16T11:10:40.000Z","updated":"2024-11-23T16:52:52.617Z","comments":true,"path":"2024/01/16/vue/vue/vue-start/","link":"","permalink":"https://ckck803.github.io/2024/01/16/vue/vue/vue-start/","excerpt":"라이브러리 설치npm install vue -g 프로젝트 생성vue create &lt;생성할 프로젝트 이름&gt; Vue CLI v5.0.8? Please pick a preset: (Use arrow keys)❯ Default ([Vue 3] babel, eslint) Default ([Vue 2] babel, eslint) Manually select features Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed) ◉ Babel ◉ TypeScript ◯ Progressive Web App (PWA) Support❯◉ Router ◉ Vuex ◯ CSS Pre-processors ◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: Babel, TS, Router, Vuex, Linter? Choose a version of Vue.js that you want to start the project with 3.x? Use class-style component syntax? No? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes? Use history mode for router? (Requires proper server setup for index fallback in production) Yes? Pick a linter / formatter config: Prettier? Pick additional lint features: Lint on save? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? (y/N) n","text":"라이브러리 설치npm install vue -g 프로젝트 생성vue create &lt;생성할 프로젝트 이름&gt; Vue CLI v5.0.8? Please pick a preset: (Use arrow keys)❯ Default ([Vue 3] babel, eslint) Default ([Vue 2] babel, eslint) Manually select features Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed) ◉ Babel ◉ TypeScript ◯ Progressive Web App (PWA) Support❯◉ Router ◉ Vuex ◯ CSS Pre-processors ◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: Babel, TS, Router, Vuex, Linter? Choose a version of Vue.js that you want to start the project with 3.x? Use class-style component syntax? No? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes? Use history mode for router? (Requires proper server setup for index fallback in production) Yes? Pick a linter / formatter config: Prettier? Pick additional lint features: Lint on save? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? (y/N) n","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue","slug":"Frontend/Vue","permalink":"https://ckck803.github.io/categories/Frontend/Vue/"}],"tags":[]},{"title":"Spring Security - SecurityContextRepository","slug":"spring/spring-security/security/SecurityContextRepository","date":"2024-01-16T11:10:40.000Z","updated":"2024-02-26T16:20:25.476Z","comments":true,"path":"2024/01/16/spring/spring-security/security/SecurityContextRepository/","link":"","permalink":"https://ckck803.github.io/2024/01/16/spring/spring-security/security/SecurityContextRepository/","excerpt":"SecurityContextRepository SecurityContextRepository 는 SecurityContext 를 저장하고 검색하기 위한 저장소입니다. Spring Security 에서는 인증 후 생성된 SecurityContext 를 저장하고 관리하기 위해 SecurityContextRepository 인터페이스를 제공합니다. public interface SecurityContextRepository &#123; @Deprecated SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder); default DeferredSecurityContext loadDeferredContext(HttpServletRequest request) &#123; Supplier&lt;SecurityContext&gt; supplier = () -&gt; loadContext(new HttpRequestResponseHolder(request, null)); return new SupplierDeferredSecurityContext(SingletonSupplier.of(supplier), SecurityContextHolder.getContextHolderStrategy()); &#125; // 변경된 보안 컨텍스트를 저장합니다. 주로 사용자가 인증되면 새로운 보안 컨텍스트를 저장하는 데 사용됩니다. void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response); // 현재 요청에서 보안 컨텍스트가 존재하는지 확인합니다. boolean containsContext(HttpServletRequest request);&#125; Session 에 저장 - HttpSessionSecurityContextRepository HttpSessionSecurityContextRepository 는 Session 에 SecurityContext 정보를 저장합니다. @Overridepublic void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) &#123; SaveContextOnUpdateOrErrorResponseWrapper responseWrapper = WebUtils.getNativeResponse(response, SaveContextOnUpdateOrErrorResponseWrapper.class); if (responseWrapper == null) &#123; saveContextInHttpSession(context, request); return; &#125; responseWrapper.saveContext(context);&#125;private void saveContextInHttpSession(SecurityContext context, HttpServletRequest request) &#123; if (isTransient(context) || isTransient(context.getAuthentication())) &#123; return; &#125; SecurityContext emptyContext = generateNewContext(); if (emptyContext.equals(context)) &#123; HttpSession session = request.getSession(false); removeContextFromSession(context, session); &#125; else &#123; boolean createSession = this.allowSessionCreation; HttpSession session = request.getSession(createSession); setContextInSession(context, session); &#125;&#125; Request 객체에 저장 - RequestAttributeSecurityContextRepository RequestAttributeSecurityContextRepository 는 Request 객체에 SecurityContext 정보를 저장하는 객체입니다.","text":"SecurityContextRepository SecurityContextRepository 는 SecurityContext 를 저장하고 검색하기 위한 저장소입니다. Spring Security 에서는 인증 후 생성된 SecurityContext 를 저장하고 관리하기 위해 SecurityContextRepository 인터페이스를 제공합니다. public interface SecurityContextRepository &#123; @Deprecated SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder); default DeferredSecurityContext loadDeferredContext(HttpServletRequest request) &#123; Supplier&lt;SecurityContext&gt; supplier = () -&gt; loadContext(new HttpRequestResponseHolder(request, null)); return new SupplierDeferredSecurityContext(SingletonSupplier.of(supplier), SecurityContextHolder.getContextHolderStrategy()); &#125; // 변경된 보안 컨텍스트를 저장합니다. 주로 사용자가 인증되면 새로운 보안 컨텍스트를 저장하는 데 사용됩니다. void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response); // 현재 요청에서 보안 컨텍스트가 존재하는지 확인합니다. boolean containsContext(HttpServletRequest request);&#125; Session 에 저장 - HttpSessionSecurityContextRepository HttpSessionSecurityContextRepository 는 Session 에 SecurityContext 정보를 저장합니다. @Overridepublic void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) &#123; SaveContextOnUpdateOrErrorResponseWrapper responseWrapper = WebUtils.getNativeResponse(response, SaveContextOnUpdateOrErrorResponseWrapper.class); if (responseWrapper == null) &#123; saveContextInHttpSession(context, request); return; &#125; responseWrapper.saveContext(context);&#125;private void saveContextInHttpSession(SecurityContext context, HttpServletRequest request) &#123; if (isTransient(context) || isTransient(context.getAuthentication())) &#123; return; &#125; SecurityContext emptyContext = generateNewContext(); if (emptyContext.equals(context)) &#123; HttpSession session = request.getSession(false); removeContextFromSession(context, session); &#125; else &#123; boolean createSession = this.allowSessionCreation; HttpSession session = request.getSession(createSession); setContextInSession(context, session); &#125;&#125; Request 객체에 저장 - RequestAttributeSecurityContextRepository RequestAttributeSecurityContextRepository 는 Request 객체에 SecurityContext 정보를 저장하는 객체입니다. RequestAttributeSecurityContextRepository 는 요청 정보에 SecurityContext 를 저장하기 때문에 요청이 끝나게 되면 SecurityContext 정보도 같이 사라지게 됩니다. @Overridepublic void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) &#123; request.setAttribute(this.requestAttributeName, context);&#125; 여러개의 Request 객체에 저장 - DelegatingSecurityContextRepository여러개의 SecurityContextRepository 를 사용하기 위해 Spring Security 에서는 DelegatingSecurityContextRepository 를 제공합니다. 다음과 같이 여러개의 SecurityContextRepository 객체를 인자로 해 DelegatingSecurityContextRepository 객체를 생성할 수 있습니다. @Beanpublic SecurityContextRepository securityContextRepository() &#123; return new DelegatingSecurityContextRepository( new RequestAttributeSecurityContextRepository(), new HttpSessionSecurityContextRepository() );&#125; DelegatingSecurityContextRepository 또한 같은 SecurityContextRepository 인터페이스를 통해 생성된 구현체라 사용하는 방식의 차이는 없습니다. 다만, 내부적으로 여러개의 SecurityContextRepository 를 한번씩 실행시키는 방식으로 로직을 수행합니다. @Overridepublic SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) &#123; SecurityContext result = null; for (SecurityContextRepository delegate : this.delegates) &#123; SecurityContext delegateResult = delegate.loadContext(requestResponseHolder); if (result == null || delegate.containsContext(requestResponseHolder.getRequest())) &#123; result = delegateResult; &#125; &#125; return result;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"}]},{"title":"Spring Security - SecurityContextPersistenceFilter 와 SecurityContextHolderFilter","slug":"spring/spring-security/security/filter/SecurityContextPersistenceFilter","date":"2024-01-16T11:10:40.000Z","updated":"2024-02-26T16:27:49.415Z","comments":true,"path":"2024/01/16/spring/spring-security/security/filter/SecurityContextPersistenceFilter/","link":"","permalink":"https://ckck803.github.io/2024/01/16/spring/spring-security/security/filter/SecurityContextPersistenceFilter/","excerpt":"SecurityContextPersistenceFilterSecurityContextPersistenceFilter 에서는 인증을 위해 SecurityContextRepository 에 저장된 SecurityContext 정보를 가져와 인증 처리를 하고 SecurityContext 정보를 SecurityContextRepository 에 저장합니다. SecurityContextHolderFilterSecurityContextHolderFilter 에서는 인증을 위해 SecurityContextRepository 에 저장된 SecurityContext 정보를 가져와 인증 처리를 하지만 SecurityContextPersistenceFilter 와는 다르게 SecurityContextRepository 에 저장하지는 않습니다.","text":"SecurityContextPersistenceFilterSecurityContextPersistenceFilter 에서는 인증을 위해 SecurityContextRepository 에 저장된 SecurityContext 정보를 가져와 인증 처리를 하고 SecurityContext 정보를 SecurityContextRepository 에 저장합니다. SecurityContextHolderFilterSecurityContextHolderFilter 에서는 인증을 위해 SecurityContextRepository 에 저장된 SecurityContext 정보를 가져와 인증 처리를 하지만 SecurityContextPersistenceFilter 와는 다르게 SecurityContextRepository 에 저장하지는 않습니다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Filter","slug":"Spring/Spring-Security/Filter","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Filter/"}],"tags":[]},{"title":"Django - App 생성하기","slug":"django/django/create_app","date":"2023-12-09T11:47:30.000Z","updated":"2024-02-18T16:47:07.426Z","comments":true,"path":"2023/12/09/django/django/create_app/","link":"","permalink":"https://ckck803.github.io/2023/12/09/django/django/create_app/","excerpt":"목차 Django - App 생성하기 Django - 장고 시작하기 장고 앱 만들기장고 App 생성은 manage.py 가 있는 프로젝트 폴더에서 startapp 명령어를 사용합니다. startapp 명령어를 사용해 hello_world 라는 이름의 앱을 만들어 줍니다. python manage.py startapp hello_world view.py 작성하기앱 폴더 내에 views.py 파일에 다음과 같은 코드를 작성해줍니다. from django.http import HttpResponsedef hello(request): return HttpResponse(&quot;Hello, world. You&#x27;re at the hello_world index.&quot;)# Create your views here.] url.py 작성하기","text":"목차 Django - App 생성하기 Django - 장고 시작하기 장고 앱 만들기장고 App 생성은 manage.py 가 있는 프로젝트 폴더에서 startapp 명령어를 사용합니다. startapp 명령어를 사용해 hello_world 라는 이름의 앱을 만들어 줍니다. python manage.py startapp hello_world view.py 작성하기앱 폴더 내에 views.py 파일에 다음과 같은 코드를 작성해줍니다. from django.http import HttpResponsedef hello(request): return HttpResponse(&quot;Hello, world. You&#x27;re at the hello_world index.&quot;)# Create your views here.] url.py 작성하기프로젝트 폴더내 url.py 파일을 열어 /hello 경로와 해당 경로로 들어왔을때 보여줄 view 를 추가해줍니다. from hello_world.views import hellourlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;hello/&#x27;, hello),] 서비스 확인하기localhost:8080/hello 로 접속하면 위 view.py 에서 작성한 내용이 보이는 것을 확인할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 장고 시작하기","slug":"django/django/start_django","date":"2023-12-09T11:47:30.000Z","updated":"2024-02-18T16:47:07.427Z","comments":true,"path":"2023/12/09/django/django/start_django/","link":"","permalink":"https://ckck803.github.io/2023/12/09/django/django/start_django/","excerpt":"목차 Django - App 생성하기 Django - 장고 시작하기 장고 설치하기pip install django 장고 프로젝트 생성하기 - django-admindjango 를 설치하면 django-admin 명령어를 사용할 수 있습니다. 설치된 django-admin 에 startproject 명령어를 사용하면 새롭게 장고 프로젝트를 시작할 수 있습니다. django-admin startproject mysite 장고 서버 실행하기 - manage.py새로운 장고 프로젝트에 들어가면 manage.py 파일이 있습니다. runserver 명령어를 사용하면 장고 서버를 실행할 수 있습니다.","text":"목차 Django - App 생성하기 Django - 장고 시작하기 장고 설치하기pip install django 장고 프로젝트 생성하기 - django-admindjango 를 설치하면 django-admin 명령어를 사용할 수 있습니다. 설치된 django-admin 에 startproject 명령어를 사용하면 새롭게 장고 프로젝트를 시작할 수 있습니다. django-admin startproject mysite 장고 서버 실행하기 - manage.py새로운 장고 프로젝트에 들어가면 manage.py 파일이 있습니다. runserver 명령어를 사용하면 장고 서버를 실행할 수 있습니다. python manage.py runserver","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"React Query - 캐싱 라이프 사이클","slug":"react/react-query/react-query-cache-stale","date":"2023-10-22T11:10:40.000Z","updated":"2024-11-23T16:47:28.904Z","comments":true,"path":"2023/10/22/react/react-query/react-query-cache-stale/","link":"","permalink":"https://ckck803.github.io/2023/10/22/react/react-query/react-query-cache-stale/","excerpt":"목차 React Query - 캐싱 라이프 사이클 React Query - React Devtools 사용하기 React Query - 시작하기 cache 와 stale 설정const queryClient = new QueryClient(&#123; defaultOptions: &#123; queries: &#123; staleTime: 1000 * 60, cacheTime: 1000 * 60 * 5, &#125; &#125;,&#125;);const App = (&#123; Component, pageProps &#125;: AppProps) =&gt; &#123; return ( &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;/QueryClientProvider&gt; );&#125;; cacheReact Query 는 설정한 cacheTime 만큼 데이터를 메모리에 저장해 놓습니다. 다시 이야기 하자면 React Query 에서의 Cache 는 QueryCache 객체의 queries 배열과 queriesInMap 객체의 Query 객체가 존재하는 것을 말합니다. cache 라이프 사이클 - fresh 와 stalestale 은 React Query 에서 cache 에 저장된 데이터 상태를 의미합니다. cache 에 저장된 데이터가 staleTime 만큼은 fresh 한 상태로 있다가 그 후에는 stale 상태로 넘어갑니다. stale 상태의 데이터는 cache 에 오랫동안 저장돼 있어 refetch 가 필요한 상태임을 의미합니다. React Query 에서는 stale 상태의 데이터가 특정 조건을 만족하면 refetching 이 일어나도록 합니다.","text":"목차 React Query - 캐싱 라이프 사이클 React Query - React Devtools 사용하기 React Query - 시작하기 cache 와 stale 설정const queryClient = new QueryClient(&#123; defaultOptions: &#123; queries: &#123; staleTime: 1000 * 60, cacheTime: 1000 * 60 * 5, &#125; &#125;,&#125;);const App = (&#123; Component, pageProps &#125;: AppProps) =&gt; &#123; return ( &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;/QueryClientProvider&gt; );&#125;; cacheReact Query 는 설정한 cacheTime 만큼 데이터를 메모리에 저장해 놓습니다. 다시 이야기 하자면 React Query 에서의 Cache 는 QueryCache 객체의 queries 배열과 queriesInMap 객체의 Query 객체가 존재하는 것을 말합니다. cache 라이프 사이클 - fresh 와 stalestale 은 React Query 에서 cache 에 저장된 데이터 상태를 의미합니다. cache 에 저장된 데이터가 staleTime 만큼은 fresh 한 상태로 있다가 그 후에는 stale 상태로 넘어갑니다. stale 상태의 데이터는 cache 에 오랫동안 저장돼 있어 refetch 가 필요한 상태임을 의미합니다. React Query 에서는 stale 상태의 데이터가 특정 조건을 만족하면 refetching 이 일어나도록 합니다.","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"React Query","slug":"Frontend/React-Query","permalink":"https://ckck803.github.io/categories/Frontend/React-Query/"}],"tags":[]},{"title":"React Query - React Devtools 사용하기","slug":"react/react-query/react-query-devtools","date":"2023-10-22T11:10:40.000Z","updated":"2024-11-23T16:47:32.419Z","comments":true,"path":"2023/10/22/react/react-query/react-query-devtools/","link":"","permalink":"https://ckck803.github.io/2023/10/22/react/react-query/react-query-devtools/","excerpt":"목차 React Query - 캐싱 라이프 사이클 React Query - React Devtools 사용하기 React Query - 시작하기 의존성 추가$ npm i @tanstack/react-query-devtools# or$ yarn add @tanstack/react-query-devtools ReactQueryDevtoolsimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom/client&#x27;import App from &#x27;./App.tsx&#x27;import &#123; ReactQueryDevtools &#125; from &#x27;@tanstack/react-query-devtools&#x27;import &#123;QueryClient, QueryClientProvider &#125; from &#x27;@tanstack/react-query&#x27;const queryClient = new QueryClient()ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;)!).render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;App /&gt; &lt;ReactQueryDevtools initialIsOpen=&#123;false&#125; /&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;,)","text":"목차 React Query - 캐싱 라이프 사이클 React Query - React Devtools 사용하기 React Query - 시작하기 의존성 추가$ npm i @tanstack/react-query-devtools# or$ yarn add @tanstack/react-query-devtools ReactQueryDevtoolsimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom/client&#x27;import App from &#x27;./App.tsx&#x27;import &#123; ReactQueryDevtools &#125; from &#x27;@tanstack/react-query-devtools&#x27;import &#123;QueryClient, QueryClientProvider &#125; from &#x27;@tanstack/react-query&#x27;const queryClient = new QueryClient()ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;)!).render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;App /&gt; &lt;ReactQueryDevtools initialIsOpen=&#123;false&#125; /&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;,)","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"React Query","slug":"Frontend/React-Query","permalink":"https://ckck803.github.io/categories/Frontend/React-Query/"}],"tags":[]},{"title":"React Query - 시작하기","slug":"react/react-query/react-query-start","date":"2023-10-22T11:10:40.000Z","updated":"2024-11-23T16:47:35.741Z","comments":true,"path":"2023/10/22/react/react-query/react-query-start/","link":"","permalink":"https://ckck803.github.io/2023/10/22/react/react-query/react-query-start/","excerpt":"목차 React Query - 캐싱 라이프 사이클 React Query - React Devtools 사용하기 React Query - 시작하기 참고 공식문서 https://tanstack.com/query/v4/docs/react/quick-start 의존성 추가$ npm i @tanstack/react-query# or$ yarn add @tanstack/react-query Providerimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import App from &quot;./App.tsx&quot;;import &#123; QueryClient, QueryClientProvider &#125; from &quot;@tanstack/react-query&quot;;const queryClient = new QueryClient();ReactDOM.createRoot(document.getElementById(&quot;root&quot;)!).render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;App /&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;); useQuery","text":"목차 React Query - 캐싱 라이프 사이클 React Query - React Devtools 사용하기 React Query - 시작하기 참고 공식문서 https://tanstack.com/query/v4/docs/react/quick-start 의존성 추가$ npm i @tanstack/react-query# or$ yarn add @tanstack/react-query Providerimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import App from &quot;./App.tsx&quot;;import &#123; QueryClient, QueryClientProvider &#125; from &quot;@tanstack/react-query&quot;;const queryClient = new QueryClient();ReactDOM.createRoot(document.getElementById(&quot;root&quot;)!).render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;App /&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;); useQueryimport React from &quot;react&quot;;import axios from &quot;axios&quot;;import &#123; useQuery &#125; from &quot;@tanstack/react-query&quot;;const App = () =&gt; &#123; const &#123; isLoading, error, data &#125; = useQuery(&#123; queryKey: [&quot;repoData&quot;], queryFn: () =&gt; axios .get(&quot;https://api.github.com/repos/TanStack/query&quot;) .then((res) =&gt; res.data), &#125;); if (isLoading) return &quot;Loading...&quot;; if (error) return &quot;An error has occurred: &quot; + error.message; return ( &lt;div&gt; &lt;h1&gt;&#123;data.name&#125;&lt;/h1&gt; &lt;p&gt;&#123;data.description&#125;&lt;/p&gt; &lt;strong&gt;👀 &#123;data.subscribers_count&#125;&lt;/strong&gt;&#123;&quot; &quot;&#125; &lt;strong&gt;✨ &#123;data.stargazers_count&#125;&lt;/strong&gt;&#123;&quot; &quot;&#125; &lt;strong&gt;🍴 &#123;data.forks_count&#125;&lt;/strong&gt; &lt;/div&gt; );&#125;;export default App;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"React Query","slug":"Frontend/React-Query","permalink":"https://ckck803.github.io/categories/Frontend/React-Query/"}],"tags":[]},{"title":"JPA - 더티 체킹과 업데이트 그리고 벌크 연산","slug":"jpa/jpa-update","date":"2023-09-07T19:31:46.000Z","updated":"2024-02-18T16:59:48.431Z","comments":true,"path":"2023/09/08/jpa/jpa-update/","link":"","permalink":"https://ckck803.github.io/2023/09/08/jpa/jpa-update/","excerpt":"JPA 에서의 업데이트 - 더티 체킹 Entity 에 대한 더티 체킹 을 통한 업데이트가 이뤄집니다. JPA 에서는 Entity 를 업데이트 하기 위한 메소드가 별도로 존재하지 않습니다. JPA 에서의 업데이트는 엔티티 변경 과 더티 체킹 을 통해 업데이트가 이뤄집니다. JPA 에서 엔티티를 변경하기 위해서는 변경하고자 하는 엔티티를 조회한 후 해당 엔티티의 값을 변경하면 트랜잭션을 커밋할 때 변경 감지(Dirty Checking) 가 동작해서 데이터베이스에 UPDATE SQL 이 실행하는 방식으로 Entity 에 대한 변경을 반영합니다. @Override@Transactionalpublic ItemDto.Response modifyItemPrice(Long id, ItemDto.Request itemDto) &#123; // 1. 변경하고자 하는 Entity 를 조회합니다. Optional&lt;Item&gt; optionalItem = itemRepository.findById(id); if (optionalItem.isPresent()) &#123; Item item = optionalItem.get(); // 2. Entity 의 값을 변경합니다. item.updatePrice(itemDto.getPrice()); return ItemDto.Response.toDto(item); &#125; else &#123; throw new RuntimeException(&quot;Item not found&quot;); &#125;&#125; Update 쿼리문 발생update item set item_type_id=?, modified_date=?, name=?, price=?, version=? where id=? and version=? 더티체크를 통한 업데이트의 한계더티 체킹을 통한 업데이트는 변경된 Entity 개수만큼 Update 문을 실행합니다. 그렇기 때문에 변경된 Entity 가 100개라면 100번의 Update 문이 실행되는 문제점이 있습니다.","text":"JPA 에서의 업데이트 - 더티 체킹 Entity 에 대한 더티 체킹 을 통한 업데이트가 이뤄집니다. JPA 에서는 Entity 를 업데이트 하기 위한 메소드가 별도로 존재하지 않습니다. JPA 에서의 업데이트는 엔티티 변경 과 더티 체킹 을 통해 업데이트가 이뤄집니다. JPA 에서 엔티티를 변경하기 위해서는 변경하고자 하는 엔티티를 조회한 후 해당 엔티티의 값을 변경하면 트랜잭션을 커밋할 때 변경 감지(Dirty Checking) 가 동작해서 데이터베이스에 UPDATE SQL 이 실행하는 방식으로 Entity 에 대한 변경을 반영합니다. @Override@Transactionalpublic ItemDto.Response modifyItemPrice(Long id, ItemDto.Request itemDto) &#123; // 1. 변경하고자 하는 Entity 를 조회합니다. Optional&lt;Item&gt; optionalItem = itemRepository.findById(id); if (optionalItem.isPresent()) &#123; Item item = optionalItem.get(); // 2. Entity 의 값을 변경합니다. item.updatePrice(itemDto.getPrice()); return ItemDto.Response.toDto(item); &#125; else &#123; throw new RuntimeException(&quot;Item not found&quot;); &#125;&#125; Update 쿼리문 발생update item set item_type_id=?, modified_date=?, name=?, price=?, version=? where id=? and version=? 더티체크를 통한 업데이트의 한계더티 체킹을 통한 업데이트는 변경된 Entity 개수만큼 Update 문을 실행합니다. 그렇기 때문에 변경된 Entity 가 100개라면 100번의 Update 문이 실행되는 문제점이 있습니다. 그래서 JPA 에서는 벌크 연산을 통해 한번에 여러 Entity 를 변경할 수 있도록 지원합니다. 벌크 연산을 통한 업데이트벌크 연산을 통한 업데이트의 한계벌크 연상의 경우 JPA 를 통해서 업데이트하는 방식이 아니기 때문에 EntityManager 에서 캐싱해놓은 데이터와 DB 에 저장된 데이터의 불일치가 발생합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"Service Discovery 패턴","slug":"computer-science/network/ServiceDiscovery","date":"2023-06-30T14:16:32.000Z","updated":"2024-02-18T16:19:54.518Z","comments":true,"path":"2023/06/30/computer-science/network/ServiceDiscovery/","link":"","permalink":"https://ckck803.github.io/2023/06/30/computer-science/network/ServiceDiscovery/","excerpt":"참고 https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/ https:&#x2F;&#x2F;velog.io&#x2F;@hoonki&#x2F;마이크로서비스-패턴-서비스-디스커버리 Service Discovery 패턴이 등장하게 된 배경기존 서비스 인스턴스의 개수와 IP 가 고정적이였던 온 프레미스 환경과 달리 MSA 환경에서는 Application 들이 AutoScaling 을 하면서 동적으로 줄었다가 늘어나면서 IP 자체도 동적으로 바뀌게 됐습니다. Client 나 Gateway 입장에서 서비스 인스턴스들이 동적으로 늘었는지 줄었는지에 대한 파악을 하기가 어려운 문제가 있었고 그에 따른 LoadBalancing 하는데 어려움이 있었습니다. Service Discovery 패턴에서는 Service EndPoint 를 조회 및 관리하기 위한 Service Registry 가 있습니다. MSA 의 각 서비스들은 Service Registry 에 자신의 EndPoint 들을 등록합니다. Service EndPoint 를 접근하는 방식에 따라 두가지로 나뉘게 됩니다. 첫번째는 Client-Side Discovery 두번째는 Server-Side Discovery 패턴이 있습니다. 출처: https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/ Client Side DiscoveryMSA 내 한 서비스가 다른 서비스를 호출할때 Service Registry 로 부터 EndPoint 를 조회한 후 해당 서비스를 호출하는 방식입니다.","text":"참고 https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/ https:&#x2F;&#x2F;velog.io&#x2F;@hoonki&#x2F;마이크로서비스-패턴-서비스-디스커버리 Service Discovery 패턴이 등장하게 된 배경기존 서비스 인스턴스의 개수와 IP 가 고정적이였던 온 프레미스 환경과 달리 MSA 환경에서는 Application 들이 AutoScaling 을 하면서 동적으로 줄었다가 늘어나면서 IP 자체도 동적으로 바뀌게 됐습니다. Client 나 Gateway 입장에서 서비스 인스턴스들이 동적으로 늘었는지 줄었는지에 대한 파악을 하기가 어려운 문제가 있었고 그에 따른 LoadBalancing 하는데 어려움이 있었습니다. Service Discovery 패턴에서는 Service EndPoint 를 조회 및 관리하기 위한 Service Registry 가 있습니다. MSA 의 각 서비스들은 Service Registry 에 자신의 EndPoint 들을 등록합니다. Service EndPoint 를 접근하는 방식에 따라 두가지로 나뉘게 됩니다. 첫번째는 Client-Side Discovery 두번째는 Server-Side Discovery 패턴이 있습니다. 출처: https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/ Client Side DiscoveryMSA 내 한 서비스가 다른 서비스를 호출할때 Service Registry 로 부터 EndPoint 를 조회한 후 해당 서비스를 호출하는 방식입니다. 출처: https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/ Server Side DiscoveryServer Side Discovery 패턴은 기존 Client Side Discovery 와는 다르게 Service Registry 앞에 Load Balancer 를 두는 형태를 띄고 있습니다. Server Side Discovery 는 Client Side Discovery 와 다르게 각 서비스간의 호출시에는 Load Balancer 를 통해 호출을 하게 되고 Load Balancer 가 Service Registry 에 등록된 EndPoint 들을 확인한 후 라우팅하는 방식입니다. Server Side Discovery 패턴의 장점은 각각의 서비스 들에게 DNS 를 부여해 Domain 이름으로 호출할 수 있는 장점이 있고 Client Side Discovery 와는 달리 서비스 호출에 Load Balancer 를 거쳐야 하는 문제가 있어 Network Hop 이 늘어나는 단점이 있습니다. 쿠버네티스에서는 Server Side Discovery 를 제공합니다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"}],"tags":[]},{"title":"Spring Cloud - Eureka 에 Service 등록하기","slug":"spring/spring-cloud/service-discovery/spring-cloud-eureka-client","date":"2023-06-29T18:31:31.000Z","updated":"2024-02-26T15:34:43.596Z","comments":true,"path":"2023/06/30/spring/spring-cloud/service-discovery/spring-cloud-eureka-client/","link":"","permalink":"https://ckck803.github.io/2023/06/30/spring/spring-cloud/service-discovery/spring-cloud-eureka-client/","excerpt":"목차 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 참고 https://cloud.spring.io/spring-cloud-netflix/reference/html/ https://coe.gitbook.io/guide/service-discovery/eureka Service 등록하기implementation &#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27; @EnableDiscoveryClient@SpringBootApplication@EnableDiscoveryClientpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125;&#125; Eureka 서버에 등록을 위한 Properties 설정 추가eureka.client.register-with-eureka 값을 true 로 줌으로써 Eureka 서버에 등록하도록 설정합니다.","text":"목차 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 참고 https://cloud.spring.io/spring-cloud-netflix/reference/html/ https://coe.gitbook.io/guide/service-discovery/eureka Service 등록하기implementation &#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27; @EnableDiscoveryClient@SpringBootApplication@EnableDiscoveryClientpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125;&#125; Eureka 서버에 등록을 위한 Properties 설정 추가eureka.client.register-with-eureka 값을 true 로 줌으로써 Eureka 서버에 등록하도록 설정합니다. Service 를 등록하기 위해 eureka.client.service-url.defaultZone 를 이용해 Eureka 서버의 주소를 설정합니다. eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka Eureka Server 에 등록된 Service 확인하기","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Service Discovery","slug":"Spring/Spring-Cloud/Service-Discovery","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Service-Discovery/"}],"tags":[]},{"title":"Spring Cloud - Service Discovery Server (Eureka)","slug":"spring/spring-cloud/service-discovery/spring-cloud-eureka-server","date":"2023-06-29T17:31:31.000Z","updated":"2024-02-26T15:34:54.442Z","comments":true,"path":"2023/06/30/spring/spring-cloud/service-discovery/spring-cloud-eureka-server/","link":"","permalink":"https://ckck803.github.io/2023/06/30/spring/spring-cloud/service-discovery/spring-cloud-eureka-server/","excerpt":"목차 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 참고 https://cloud.spring.io/spring-cloud-netflix/reference/html/ https://coe.gitbook.io/guide/service-discovery/eureka 사용하는 Spring Cloud 버전plugins &#123; id &#x27;org.springframework.boot&#x27; version &#x27;2.4.5&#x27; id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.11.RELEASE&#x27; id &#x27;java&#x27;&#125;group = &#x27;com.example&#x27;version = &#x27;0.0.1-SNAPSHOT&#x27;sourceCompatibility = &#x27;11&#x27;repositories &#123; mavenCentral()&#125;ext &#123; set(&#x27;springCloudVersion&#x27;, &quot;2020.0.2&quot;)&#125;dependencies &#123; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27;&#125;dependencyManagement &#123; imports &#123; mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot; &#125;&#125;test &#123; useJUnitPlatform()&#125; Spring Cloud EurekaMSA (Micro Service Architecture) 에서는 각 서비스를 관리하기 위해서 Service Discovery Server 가 필요합니다. Spring Cloud 에서는 Service Discovery 를 위해 Eureka 를 사용한다. Discovery Server (Eureka)implementation &#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-server&#x27;","text":"목차 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 참고 https://cloud.spring.io/spring-cloud-netflix/reference/html/ https://coe.gitbook.io/guide/service-discovery/eureka 사용하는 Spring Cloud 버전plugins &#123; id &#x27;org.springframework.boot&#x27; version &#x27;2.4.5&#x27; id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.11.RELEASE&#x27; id &#x27;java&#x27;&#125;group = &#x27;com.example&#x27;version = &#x27;0.0.1-SNAPSHOT&#x27;sourceCompatibility = &#x27;11&#x27;repositories &#123; mavenCentral()&#125;ext &#123; set(&#x27;springCloudVersion&#x27;, &quot;2020.0.2&quot;)&#125;dependencies &#123; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27;&#125;dependencyManagement &#123; imports &#123; mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot; &#125;&#125;test &#123; useJUnitPlatform()&#125; Spring Cloud EurekaMSA (Micro Service Architecture) 에서는 각 서비스를 관리하기 위해서 Service Discovery Server 가 필요합니다. Spring Cloud 에서는 Service Discovery 를 위해 Eureka 를 사용한다. Discovery Server (Eureka)implementation &#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-server&#x27; @EnableEurekaServerDiscovery Server 로 작동하기 위해 @EnableEurekaServer 어노테이션을 추가하여 Eureka Server 를 구성합니다. @SpringBootApplication@EnableEurekaServerpublic class DiscoveryServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DiscoveryServiceApplication.class, args); &#125;&#125; Properties 설정 추가 eureka.client.register-with-eureka 레지스트리 서버에 본인을 등록할지 여부를 설정합니다. eureka.client.fetch-registry 레지스트리 정보를 가져올지 여부를 설정합니다. spring: application: name: discoveryserviceeureka: client: register-with-eureka: false fetch-registry: false","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Service Discovery","slug":"Spring/Spring-Cloud/Service-Discovery","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Service-Discovery/"}],"tags":[]},{"title":"Spring Batch - 배치 설정 (application.properties)","slug":"spring/spring-batch/spring-batch-batch-properties","date":"2023-06-28T06:25:35.000Z","updated":"2024-02-26T15:30:51.765Z","comments":true,"path":"2023/06/28/spring/spring-batch/spring-batch-batch-properties/","link":"","permalink":"https://ckck803.github.io/2023/06/28/spring/spring-batch/spring-batch-batch-properties/","excerpt":"배치 잡의 실행 여부를 설정# Spring Boot 가 자동으로 실행시키는 Batch Job 을 실행시키도록 한다.spring.batch.job.enabled: true # default# Spring Boot 가 자동으로 실행시키는 Batch Job 을 실행하지 않도록 한다.spring.batch.job.enabled: false 배치 잡의 재시작 여부를 설정# 기본이 true, 재시작을 허용한다.spring.batch.job.restartable: true# 재시작을 허용하지 않는다spring.batch.job.restartable: false 실행할 배치 잡의 이름을 지정스프링 배치는 실행시 기본적으로 모든 Job 을 실행시킵니다. spring.batch.job.names 를 이용해 지정 Job 만 실행하도록 설정할 수 있습니다. 프로그램 실행시 특정 Job 을 전달받아 실행시키고 싶을 경우 spring.batch.job.names: $&#123;job.name:NONE&#125; 로 설정하면 외부에서 주입받은 Job 이름을 이용해 실행시킬 수 있습니다. 만일 전달받은 값이 없으면 아무 Job 도 실행시키지 않습니다. :NONE 은 프로퍼티 표현 중 하나로 전달받은 값이 없을 경우 NONE 으로 대체한다는 의미이다. # Hard Coding 방식spring.batch.job.names: springJob1# Binding 을 사용한 방식spring.batch.job.names: $&#123;job.name:NONE&#125;","text":"배치 잡의 실행 여부를 설정# Spring Boot 가 자동으로 실행시키는 Batch Job 을 실행시키도록 한다.spring.batch.job.enabled: true # default# Spring Boot 가 자동으로 실행시키는 Batch Job 을 실행하지 않도록 한다.spring.batch.job.enabled: false 배치 잡의 재시작 여부를 설정# 기본이 true, 재시작을 허용한다.spring.batch.job.restartable: true# 재시작을 허용하지 않는다spring.batch.job.restartable: false 실행할 배치 잡의 이름을 지정스프링 배치는 실행시 기본적으로 모든 Job 을 실행시킵니다. spring.batch.job.names 를 이용해 지정 Job 만 실행하도록 설정할 수 있습니다. 프로그램 실행시 특정 Job 을 전달받아 실행시키고 싶을 경우 spring.batch.job.names: $&#123;job.name:NONE&#125; 로 설정하면 외부에서 주입받은 Job 이름을 이용해 실행시킬 수 있습니다. 만일 전달받은 값이 없으면 아무 Job 도 실행시키지 않습니다. :NONE 은 프로퍼티 표현 중 하나로 전달받은 값이 없을 경우 NONE 으로 대체한다는 의미이다. # Hard Coding 방식spring.batch.job.names: springJob1# Binding 을 사용한 방식spring.batch.job.names: $&#123;job.name:NONE&#125; 실행시킬 Job 을 지정하는 방법 어플리케이션 실행시 Program arguments 로 Job 이름 입력한다. --job.name=helloJob 하나 이상의 Job 을 실행할 경우 쉼표로 구분해서 입력 한다. --job.name=helloJob,simpleJob 어플리케이션 실행시점에 Argument 로 넘겨서 Binding 되도록 한다. 인텔리제이에서 Program Argument 를 이용한 Job 실행 배치 메타 데이터 저장을 위한 테이블 스키마 자동 생성여부를 설정spring.batch.jdbc.initialize-schema: alwaysspring.batch.jdbc.initialize-schema: embedded # defaultspring.batch.jdbc.initialize-schema: never 배치 잡에서 생성되는 메타 데이터 테이블 Prefix 를 설정spring.batch.jdbc.table-prefix: DEMO 배치 잡에서 허용하는 실패 횟수를 설정# 배치 잡에서 허용하는 실패 횟수를 설정한다. default: 3spring.batch.job.failures-allowed: 3","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"쿠버네티스 - ServiceAccount","slug":"k8s/config/ServiceAccount","date":"2023-06-11T01:31:46.000Z","updated":"2024-02-18T16:19:54.536Z","comments":true,"path":"2023/06/11/k8s/config/ServiceAccount/","link":"","permalink":"https://ckck803.github.io/2023/06/11/k8s/config/ServiceAccount/","excerpt":"목차 쿠버네티스 - Secret 쿠버네티스 - ConfigMap 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s 참고 https://findstar.pe.kr/2023/04/09/access-k8s-api-from-pod/ https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ https://kubernetes.io/ko/docs/reference/access-authn-authz/service-accounts-admin/ ServiceAccount ServiceAccount 는 쿠버네티스 API 서버와 통신하고 클러스터 내의 다른 리소스에 접근하기 위한 인증 정보를 제공합니다. ServiceAccount 는 Pod 가 Kubernetes API Server 에 인증 하기 위한 Account 입니다. 때문에 Pod 를 생성할때 ServiceAccount 를 할당해야 하며 지정하지 않을 경우 default 가 자동으로 할당됩니다. Rule 과 RuleBinding 을 이용해 ServiceAccount 에 권한을 부여함으로써 Pod 가 다른 리소스에 접근할 수 있게 해줍니다. ServiceAccount 는 Namespace 단위로 생성되는 리소스며 다른 Namespace 에서 정의된 ServiceAccount 를 사용할 수 없습니다.","text":"목차 쿠버네티스 - Secret 쿠버네티스 - ConfigMap 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s 참고 https://findstar.pe.kr/2023/04/09/access-k8s-api-from-pod/ https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ https://kubernetes.io/ko/docs/reference/access-authn-authz/service-accounts-admin/ ServiceAccount ServiceAccount 는 쿠버네티스 API 서버와 통신하고 클러스터 내의 다른 리소스에 접근하기 위한 인증 정보를 제공합니다. ServiceAccount 는 Pod 가 Kubernetes API Server 에 인증 하기 위한 Account 입니다. 때문에 Pod 를 생성할때 ServiceAccount 를 할당해야 하며 지정하지 않을 경우 default 가 자동으로 할당됩니다. Rule 과 RuleBinding 을 이용해 ServiceAccount 에 권한을 부여함으로써 Pod 가 다른 리소스에 접근할 수 있게 해줍니다. ServiceAccount 는 Namespace 단위로 생성되는 리소스며 다른 Namespace 에서 정의된 ServiceAccount 를 사용할 수 없습니다. ServiceAccount 생성하기매니페스트 내 kind: ServiceAccount 를 사용하여 ServiceAccount를 생성할 수 있습니다. apiVersion: v1kind: ServiceAccountmetadata: annotations: description: ServiceAccount 에 대한 설명 name: &lt;ServiceAccount 이름&gt; namespace: &lt;ServiceAccount 를 사용할 Namespace&gt; Token 생성v1.22 이전 버전의 쿠버네티스 버전은 쿠버네티스 API에 액세스하기 위한 장기 자격 증명을 자동으로 생성했다. 이 이전 메커니즘은 실행 중인 파드에 마운트할 수 있는 토큰 시크릿을 생성하는 것을 기반으로 했다. 쿠버네티스 v1.27을 포함한 최신 버전에서는, API 자격 증명이 토큰리퀘스트 API를 사용하여 직접 획득되고, 예상 볼륨을 사용하여 파드에 마운트된다. 이 방법을 사용하여 획득한 토큰은 수명이 제한되어 있으며, 마운트된 파드가 삭제되면 자동으로 무효화된다. 예를 들어 만료되지 않는 토큰이 필요한 경우 서비스 어카운트 토큰 시크릿을 수동으로 생성할 수 있다. 그러나 대신 TokenRequest 서브리소스를 사용하여 API에 액세스하기 위한 토큰을 얻는 것을 권장한다. kubectl create token &lt;ServiceAccount Name&gt; Secret 생성apiVersion: v1kind: Secretmetadata: name: &lt;Secret Name&gt; namespace: mbc-add-dev annotations: kubernetes.io/service-account.name: &lt;ServiceAccount Name&gt;type: kubernetes.io/service-account-token RuleapiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: name: kubectl-prometheus-alertmanager-role namespace: mbc-add-devrules:- apiGroups: - apps resourceNames: - prometheus-alertmanager - alertmanager resources: - statefulsets - statefulsets/scale verbs: - get - patch - list - watch - update RoleBindingapiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: name: kubectl-prometheus-alertmanager-rolebinding namespace: mbc-add-devroleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: &lt;Role Name&gt;subjects:- kind: ServiceAccount name: &lt;Service Account Name&gt; namespace: mbc-add-dev","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Config","slug":"Kubernetes/Config","permalink":"https://ckck803.github.io/categories/Kubernetes/Config/"}],"tags":[]},{"title":"Istio - istioctl2","slug":"k8s/istio/istio-istioctl2","date":"2023-05-25T23:31:46.000Z","updated":"2024-02-18T16:19:54.538Z","comments":true,"path":"2023/05/26/k8s/istio/istio-istioctl2/","link":"","permalink":"https://ckck803.github.io/2023/05/26/k8s/istio/istio-istioctl2/","excerpt":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Istio - istioctl Istio 란? 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ istioctl 설치Mac 을 사용하는 경우 HomeBrew 를 이용해 istioctl 을 설치할 수 있습니다. brew install istioctl 다른 OS 를 사용하거나 특정 버전의 Istio 를 사용하고 싶은 경우 다음과 같이 Istio 버전을 Setting 한 후 해당 버전을 내려받아 사용할 수 있습니다. export ISTIO_VERSION=1.14.5curl -L https://istio.io/downloadIstio | ISTIO_VERSION=$ISTIO_VERSION TARGET_ARCH=x86_64 sh -","text":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Istio - istioctl Istio 란? 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ istioctl 설치Mac 을 사용하는 경우 HomeBrew 를 이용해 istioctl 을 설치할 수 있습니다. brew install istioctl 다른 OS 를 사용하거나 특정 버전의 Istio 를 사용하고 싶은 경우 다음과 같이 Istio 버전을 Setting 한 후 해당 버전을 내려받아 사용할 수 있습니다. export ISTIO_VERSION=1.14.5curl -L https://istio.io/downloadIstio | ISTIO_VERSION=$ISTIO_VERSION TARGET_ARCH=x86_64 sh - Istio Profile 설치istioctl install --set profile=demo --set hub=gcr.io/istio-release kubectl apply -f samples/addons 설치된 Istio Resource Kiali외부에서 접근이 가능하도록 Kiali Service 를 ClusterIP 에서 LoadBalancer 로 변경합니다 kubectl patch svc kiali -n istio-system -p &#x27;&#123;&quot;spec&quot;: &#123;&quot;type&quot;: &quot;LoadBalancer&quot;&#125;&#125;&#x27; LoadBalancer 로 변경 되면서 EXTERNAL-IP 가 추가된 것을 확인할 수 있습니다. EXTERNAL-IP 를 이용해 접근하면 Kiali Dashboard 로 접근할 수 있습니다. Jaeger외부에서 접근이 가능하도록 Jaeger Service 를 ClusterIP 에서 LoadBalancer 로 변경합니다. kubectl patch svc tracing -n istio-system -p &#x27;&#123;&quot;spec&quot;: &#123;&quot;type&quot;: &quot;LoadBalancer&quot;&#125;&#125;&#x27; LoadBalancer 로 변경 되면서 EXTERNAL-IP 가 추가된 것을 확인할 수 있다. EXTERNAL-IP 를 이용해 접근하면 Jaeger Dashboard 로 접근할 수 있습니다. Sidecar Injection 방법 Istioctl kube-inject Command 를 이용하는 방법 kubectl apply -f &lt;(istioctl kube-inject -f Deployment.yml) Namespace 에 istio-injection 을 enabled 로 설정하는 방법 kubectl label namespace tutorial istio-injection=enabled Tutorialkubectl create namespace tutorial Deployment 를 설치 할때 istioctl kube-inject 명령어를 통해 Istio Container 가 Pod 내에 설치되도록 설정합니다. kubectl apply -f &lt;(istioctl kube-inject -f customer/kubernetes/Deployment.yml) -n tutorialkubectl create -f customer/kubernetes/Service.yml -n tutorial Pod 가 생성될때 내부에 Istio Container 가 생성된 것을 확인할 수 있습니다. Istio Gateway 설치 및 Customer 서비스 라우팅(VirtualService) 설정apiVersion: networking.istio.io/v1alpha3kind: Gatewaymetadata: name: customer-gatewayspec: selector: istio: ingressgateway # use istio default controller servers: - port: number: 80 name: http protocol: HTTP hosts: - &quot;*&quot;---apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: customer-gatewayspec: hosts: - &quot;*&quot; gateways: - customer-gateway http: - match: - uri: prefix: /customer rewrite: uri: / route: - destination: host: customer port: number: 8080 kubectl apply -f customer/kubernetes/Gateway.yml -n tutorial kubectl apply -f &lt;(istioctl kube-inject -f preference/kubernetes/Deployment.yml) -n tutorialkubectl create -f preference/kubernetes/Service.yml -n tutorialkubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment.yml) -n tutorialkubectl create -f recommendation/kubernetes/Service.yml -n tutorial Istio - Traffic Routingkubectl apply -f &lt;(istioctl kube-inject -f recommendation/kubernetes/Deployment-v2.yml) -n tutorial kubectl scale --replicas=2 deployment/recommendation-v2 -n tutorialkubectl get po -n tutorial kubectl get VirtualService -n tutorial -o yamlkubectl get DestinationRule -n tutorial -o yaml Istio Timeout &amp; RetryTimeout 설정kubectl apply -f - &lt;&lt;EOF apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-order-network-rule namespace: tutorial spec: hosts: - order http: - route: - destination: host: order timeout: 3sEOF Siege 생성kubectl apply -f - &lt;&lt;EOFapiVersion: v1kind: Podmetadata: name: siege namespace: tutorialspec: containers: - name: siege image: apexacme/siege-nginxEOF kubectl exec -it siege -c siege -n tutorial -- /bin/bashsiege -c1 -t2S -v --content-type &quot;application/json&quot; &#x27;http://order:8080/orders POST &#123;&quot;productId&quot;: &quot;1001&quot;, &quot;qty&quot;:5&#125;&#x27; siege -c30 -t20S -v --content-type &quot;application/json&quot; &#x27;http://order:8080/orders POST &#123;&quot;productId&quot;: &quot;1001&quot;, &quot;qty&quot;:5&#125;&#x27; Order 서비스에 ‘Retry’ Rule 추가kubectl apply -f - &lt;&lt;EOF apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: vs-order-network-rule namespace: tutorial spec: hosts: - order http: - route: - destination: host: order timeout: 3s retries: attempts: 3 perTryTimeout: 2s retryOn: 5xx,retriable-4xx,gateway-error,connect-failure,refused-streamEOF apiVersion: networking.k8s.io/v1kind: &quot;Ingress&quot;metadata: name: &quot;shopping-ingress&quot; namespace: &quot;istio-system&quot; annotations: nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot; ingressclass.kubernetes.io/is-default-class: &quot;true&quot;spec: ingressClassName: nginx rules: - host: &quot;kiali.service.com&quot; http: paths: - path: / pathType: Prefix backend: service: name: kiali port: number: 20001 - host: &quot;prom.service.com&quot; http: paths: - path: / pathType: Prefix backend: service: name: prometheus port: number: 9090 - host: &quot;gra.service.com&quot; http: paths: - path: / pathType: Prefix backend: service: name: grafana port: number: 3000 - host: &quot;tracing.service.com&quot; http: paths: - path: / pathType: Prefix backend: service: name: tracing port: number: 80 Prometheus&#x2F;Grafana기반 K8s 통합 모니터링kubectl create ns shopkubectl label namespace shop istio-injection=enabledkubectl apply -f https://raw.githubusercontent.com/acmexii/demo/master/edu/order-liveness.yaml -n shopkubectl expose deploy order --port=8080 -n shopkubectl apply -f https://raw.githubusercontent.com/acmexii/demo/master/edu/delivery-rediness-v1.yaml -n shopkubectl expose deploy delivery --port=8080 -n shop# Client Pod deploykubectl apply -f https://raw.githubusercontent.com/acmexii/demo/master/edu/siege-pod.yaml -n shop kubectl patch service/prometheus -n istio-system -p &#x27;&#123;&quot;spec&quot;: &#123;&quot;type&quot;: &quot;LoadBalancer&quot;&#125;&#125;&#x27; kubectl patch service/grafana -n istio-system -p &#x27;&#123;&quot;spec&quot;: &#123;&quot;type&quot;: &quot;LoadBalancer&quot;&#125;&#125;&#x27; Istio 삭제 방법cd istio-$ISTIO_VERSIONkubectl delete -f samples/addonsistioctl manifest generate --set profile=demo | kubectl delete --ignore-not-found=true -f - kubectl delete namespace istio-system","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Istio","slug":"Kubernetes/Istio","permalink":"https://ckck803.github.io/categories/Kubernetes/Istio/"}],"tags":[]},{"title":"쿠버네티스 - CustomResource","slug":"k8s/CustomResource/CustomResource","date":"2023-05-18T01:31:46.000Z","updated":"2024-02-18T16:19:54.535Z","comments":true,"path":"2023/05/18/k8s/CustomResource/CustomResource/","link":"","permalink":"https://ckck803.github.io/2023/05/18/k8s/CustomResource/CustomResource/","excerpt":"참고 https://frozenpond.tistory.com/111 CustomResourceCustom Resource는 쿠버네티스에서 사용자가 정의한 리소스를 나타냅니다. 이는 일반적으로 클러스터 내에 존재하지 않는 기본 리소스의 새로운 종류를 정의하고, 이를 통해 사용자의 애플리케이션에 특화된 동작을 수행할 수 있도록 합니다. Custom Resource 는 클러스터 상태의 일부로서 존재하며, 일반적인 리소스와 동일한 방식으로 쿠버네티스 API를 통해 작동합니다. 예를 들어, 사용자는 Custom Resource 를 생성, 조회, 수정 및 삭제할 수 있습니다. Custom Resource 를 사용하기 위해 먼저 Custom Resource Definition(CRD) 을 정의해야 합니다. CRD는 Custom Resource 의 스키마를 설명하는 쿠버네티스 API 개체입니다. 이를 통해 Custom Resource 의 구조, 필드 및 기타 특성을 정의할 수 있습니다. CRD는 일종의 템플릿으로서, Custom Resource 의 정의를 기반으로 생성됩니다. CRD를 생성하면 쿠버네티스 API 서버가 새로운 Custom Resource 타입을 이해하고 처리할 수 있게 됩니다. Custom Resource Definition 을 작성한 후, 사용자는 해당 정의를 사용하여 Custom Resource 인스턴스를 생성하고 관리할 수 있습니다. Custom Resource 인스턴스는 일반적으로 YAML 또는 JSON 형식으로 정의되며, 클러스터에 배포됩니다. 이후 Custom Resource 는 클러스터 내에서 다른 리소스와 유사하게 다룰 수 있으며, 사용자는 쿠버네티스 API를 사용하여 Custom Resource 를 조작할 수 있습니다. Custom Resource 와 Custom Resource Definition 은 쿠버네티스의 확장성과 유연성을 높여줍니다. 사용자는 쿠버네티스 API를 통해 고유한 리소스 유형을 정의하고 제어할 수 있으며, 이를 통해 자신의 애플리케이션을 더욱 쉽게 관리할 수 있습니다.","text":"참고 https://frozenpond.tistory.com/111 CustomResourceCustom Resource는 쿠버네티스에서 사용자가 정의한 리소스를 나타냅니다. 이는 일반적으로 클러스터 내에 존재하지 않는 기본 리소스의 새로운 종류를 정의하고, 이를 통해 사용자의 애플리케이션에 특화된 동작을 수행할 수 있도록 합니다. Custom Resource 는 클러스터 상태의 일부로서 존재하며, 일반적인 리소스와 동일한 방식으로 쿠버네티스 API를 통해 작동합니다. 예를 들어, 사용자는 Custom Resource 를 생성, 조회, 수정 및 삭제할 수 있습니다. Custom Resource 를 사용하기 위해 먼저 Custom Resource Definition(CRD) 을 정의해야 합니다. CRD는 Custom Resource 의 스키마를 설명하는 쿠버네티스 API 개체입니다. 이를 통해 Custom Resource 의 구조, 필드 및 기타 특성을 정의할 수 있습니다. CRD는 일종의 템플릿으로서, Custom Resource 의 정의를 기반으로 생성됩니다. CRD를 생성하면 쿠버네티스 API 서버가 새로운 Custom Resource 타입을 이해하고 처리할 수 있게 됩니다. Custom Resource Definition 을 작성한 후, 사용자는 해당 정의를 사용하여 Custom Resource 인스턴스를 생성하고 관리할 수 있습니다. Custom Resource 인스턴스는 일반적으로 YAML 또는 JSON 형식으로 정의되며, 클러스터에 배포됩니다. 이후 Custom Resource 는 클러스터 내에서 다른 리소스와 유사하게 다룰 수 있으며, 사용자는 쿠버네티스 API를 사용하여 Custom Resource 를 조작할 수 있습니다. Custom Resource 와 Custom Resource Definition 은 쿠버네티스의 확장성과 유연성을 높여줍니다. 사용자는 쿠버네티스 API를 통해 고유한 리소스 유형을 정의하고 제어할 수 있으며, 이를 통해 자신의 애플리케이션을 더욱 쉽게 관리할 수 있습니다. CustomResourceDefinitionapiVersion: apiextensions.k8s.io/v1 를 이용해 CustomResourceDefinition 을 생성할 수 있다. apiVersion: apiextensions.k8s.io/v1kind: CustomResourceDefinitionmetadata: # name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt; name: crontabs.stable.example.comspec: # group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt; group: stable.example.com # list of versions supported by this CustomResourceDefinition versions: - name: v1 # Each version can be enabled/disabled by Served flag. served: true # One and only one version must be marked as the storage version. storage: true schema: openAPIV3Schema: type: object properties: spec: type: object properties: cronSpec: type: string image: type: string replicas: type: integer # either Namespaced or Cluster scope: Namespaced names: # plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt; plural: crontabs # singular name to be used as an alias on the CLI and for display singular: crontab # kind is normally the CamelCased singular type. Your resource manifests use this. kind: CronTab # shortNames allow shorter string to match your resource on the CLI shortNames: - ct Kubernetes Operator","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Custom","slug":"Kubernetes/Custom","permalink":"https://ckck803.github.io/categories/Kubernetes/Custom/"}],"tags":[]},{"title":"쿠버네티스 - CA (Cluster Autoscaler)","slug":"k8s/autoscaler/ca","date":"2023-05-18T01:31:46.000Z","updated":"2024-02-18T16:19:54.535Z","comments":true,"path":"2023/05/18/k8s/autoscaler/ca/","link":"","permalink":"https://ckck803.github.io/2023/05/18/k8s/autoscaler/ca/","excerpt":"목차 쿠버네티스 - HPA (Horizontal Pod Autoscaler) 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s CA","text":"목차 쿠버네티스 - HPA (Horizontal Pod Autoscaler) 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s CA","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Autoscaler","slug":"Kubernetes/Autoscaler","permalink":"https://ckck803.github.io/categories/Kubernetes/Autoscaler/"}],"tags":[]},{"title":"쿠버네티스 - VPA (Vertical Pod Autoscaler)","slug":"k8s/autoscaler/vpa","date":"2023-05-17T22:31:46.000Z","updated":"2024-02-18T16:19:54.536Z","comments":true,"path":"2023/05/18/k8s/autoscaler/vpa/","link":"","permalink":"https://ckck803.github.io/2023/05/18/k8s/autoscaler/vpa/","excerpt":"목차 쿠버네티스 - HPA (Horizontal Pod Autoscaler) 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s VPA","text":"목차 쿠버네티스 - HPA (Horizontal Pod Autoscaler) 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s VPA","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Autoscaler","slug":"Kubernetes/Autoscaler","permalink":"https://ckck803.github.io/categories/Kubernetes/Autoscaler/"}],"tags":[]},{"title":"쿠버네티스 - HPA (Horizontal Pod Autoscaler)","slug":"k8s/autoscaler/hpa","date":"2023-05-17T21:31:46.000Z","updated":"2024-02-18T16:19:54.536Z","comments":true,"path":"2023/05/18/k8s/autoscaler/hpa/","link":"","permalink":"https://ckck803.github.io/2023/05/18/k8s/autoscaler/hpa/","excerpt":"목차 쿠버네티스 - VPA (Vertical Pod Autoscaler) 쿠버네티스 - HPA (Horizontal Pod Autoscaler) HPAHPA (Horizontal Pod Autoscaler)는 Kubernetes 클러스터에서 자동으로 파드 수를 조정하는 기능입니다. HPA는 애플리케이션의 수요에 따라 파드의 수를 스케일 업 또는 스케일 다운하여 애플리케이션의 가용성과 성능을 유지하는 데 도움이 됩니다. HPA는 리소스 사용량을 기반으로 파드의 수를 동적으로 조정합니다. 일반적으로 CPU 사용률 또는 커스텀 메트릭을 기반으로 합니다. HPA는 설정된 임계값과 현재 리소스 사용량을 비교하여 파드 수를 조정합니다. HPA를 설정하려면 다음 단계를 수행해야 합니다: HPA를 적용할 리소스를 선택합니다. 대부분의 경우 Deployment 또는 ReplicaSet과 같은 컨트롤러 리소스를 선택합니다. HPA 정의를 작성합니다. HPA 정의에는 스케일링 대상 리소스, 스케일링 조건, 스케일링 조정량 등이 포함됩니다. 예를 들어, CPU 사용률이 80%를 초과하면 파드 수를 2배로 스케일 업할 수 있도록 설정할 수 있습니다. HPA를 적용합니다. HPA를 적용하면 Kubernetes는 지정된 간격으로 리소스 사용량을 확인하고 스케일링 결정을 내립니다. HPA는 애플리케이션의 부하가 증가하면 파드 수를 자동으로 늘리고, 부하가 감소하면 파드 수를 줄여 리소스를 효율적으로 관리합니다. 이를 통해 애플리케이션의 가용성과 성능을 최적화할 수 있습니다.","text":"목차 쿠버네티스 - VPA (Vertical Pod Autoscaler) 쿠버네티스 - HPA (Horizontal Pod Autoscaler) HPAHPA (Horizontal Pod Autoscaler)는 Kubernetes 클러스터에서 자동으로 파드 수를 조정하는 기능입니다. HPA는 애플리케이션의 수요에 따라 파드의 수를 스케일 업 또는 스케일 다운하여 애플리케이션의 가용성과 성능을 유지하는 데 도움이 됩니다. HPA는 리소스 사용량을 기반으로 파드의 수를 동적으로 조정합니다. 일반적으로 CPU 사용률 또는 커스텀 메트릭을 기반으로 합니다. HPA는 설정된 임계값과 현재 리소스 사용량을 비교하여 파드 수를 조정합니다. HPA를 설정하려면 다음 단계를 수행해야 합니다: HPA를 적용할 리소스를 선택합니다. 대부분의 경우 Deployment 또는 ReplicaSet과 같은 컨트롤러 리소스를 선택합니다. HPA 정의를 작성합니다. HPA 정의에는 스케일링 대상 리소스, 스케일링 조건, 스케일링 조정량 등이 포함됩니다. 예를 들어, CPU 사용률이 80%를 초과하면 파드 수를 2배로 스케일 업할 수 있도록 설정할 수 있습니다. HPA를 적용합니다. HPA를 적용하면 Kubernetes는 지정된 간격으로 리소스 사용량을 확인하고 스케일링 결정을 내립니다. HPA는 애플리케이션의 부하가 증가하면 파드 수를 자동으로 늘리고, 부하가 감소하면 파드 수를 줄여 리소스를 효율적으로 관리합니다. 이를 통해 애플리케이션의 가용성과 성능을 최적화할 수 있습니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Autoscaler","slug":"Kubernetes/Autoscaler","permalink":"https://ckck803.github.io/categories/Kubernetes/Autoscaler/"}],"tags":[]},{"title":"MySQL - 테이블 스키마 조회","slug":"mysql/command","date":"2023-05-10T16:16:13.000Z","updated":"2024-02-18T16:19:54.542Z","comments":true,"path":"2023/05/11/mysql/command/","link":"","permalink":"https://ckck803.github.io/2023/05/11/mysql/command/","excerpt":"Comment 조회select COLUMN_NAME, COLUMN_COMMENT, IS_NULLABLE, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, COLUMN_TYPE from information_schema.`COLUMNS` where TABLE_NAME = &#x27;테이블명&#x27;","text":"Comment 조회select COLUMN_NAME, COLUMN_COMMENT, IS_NULLABLE, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, COLUMN_TYPE from information_schema.`COLUMNS` where TABLE_NAME = &#x27;테이블명&#x27;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"MySQL","slug":"Develop/MySQL","permalink":"https://ckck803.github.io/categories/Develop/MySQL/"}],"tags":[]},{"title":"Spring Batch - ItemStream","slug":"spring/spring-batch/chunk/spring-batch-ItemStream","date":"2023-05-10T04:25:35.000Z","updated":"2024-02-26T15:28:08.006Z","comments":true,"path":"2023/05/10/spring/spring-batch/chunk/spring-batch-ItemStream/","link":"","permalink":"https://ckck803.github.io/2023/05/10/spring/spring-batch/chunk/spring-batch-ItemStream/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ItemStreamItemStream 은 ItemReader 와 ItemWriter 처리 과정 중 상태를 저장하고 오류가 발생하면 해당 상태를 참조하여 실패한 곳에서 재시작 하도록 지원합니다. 리소스를 열고 닫아야 하며 입출력 장치 초기화 등의 작업을 해야 하는 경우 사용합니다. public interface ItemStream &#123; void open(ExecutionContext executionContext) throws ItemStreamException; void update(ExecutionContext executionContext) throws ItemStreamException; void close() throws ItemStreamException;&#125;","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ItemStreamItemStream 은 ItemReader 와 ItemWriter 처리 과정 중 상태를 저장하고 오류가 발생하면 해당 상태를 참조하여 실패한 곳에서 재시작 하도록 지원합니다. 리소스를 열고 닫아야 하며 입출력 장치 초기화 등의 작업을 해야 하는 경우 사용합니다. public interface ItemStream &#123; void open(ExecutionContext executionContext) throws ItemStreamException; void update(ExecutionContext executionContext) throws ItemStreamException; void close() throws ItemStreamException;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"},{"name":"Chunk","slug":"Spring/Spring-Batch/Step/Chunk","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/Chunk/"}],"tags":[]},{"title":"쿠버네티스 - Secret","slug":"k8s/config/secret","date":"2023-05-10T01:31:46.000Z","updated":"2024-02-18T16:19:54.537Z","comments":true,"path":"2023/05/10/k8s/config/secret/","link":"","permalink":"https://ckck803.github.io/2023/05/10/k8s/config/secret/","excerpt":"목차 쿠버네티스 - Secret 쿠버네티스 - ConfigMap 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s Secret 쿠버네티스(Secret)는 애플리케이션에서 민감한 데이터를 안전하게 저장하고 관리하기 위한 리소스 Secret은 기본적으로 ConfigMap과 유사한 방식으로 동작하지만, 암호화된 형태로 데이터를 저장하여 더 높은 보안 수준을 제공합니다. Secret은 애플리케이션에서 사용되는 비밀번호, API 토큰, 데이터베이스 자격증명 등과 같은 중요한 정보를 저장할 수 있습니다. 이러한 데이터는 애플리케이션의 컨테이너 이미지와 분리되어, 보안성을 유지하면서 애플리케이션을 배포하고 관리할 수 있습니다. Secret은 Base64 인코딩을 사용하여 데이터를 인코딩하고, 쿠버네티스 클러스터 내부에서 저장됩니다. 이를 통해 데이터는 안전하게 저장되며, 컨테이너 내부에서 필요할 때만 디코딩하여 사용됩니다. Secret은 YAML 또는 JSON 형식으로 정의되며, 쿠버네티스 클러스터에 생성 및 적용됩니다. Secret을 생성한 후에는 해당 Secret을 사용하려는 Pod의 컨테이너에 마운트하거나 환경 변수로 설정할 수 있습니다. 이렇게 하면 애플리케이션은 Secret에서 정의된 중요한 정보를 사용할 수 있습니다. 예를 들어, Secret에서 “db_password”라는 키에 대한 값으로 “mysecretpassword”를 설정하면, 애플리케이션은 이 값을 디코딩하여 데이터베이스 비밀번호로 사용할 수 있습니다. Secret은 ConfigMap과 마찬가지로 클러스터나 네임스페이스 수준에서 변경 및 관리할 수 있으므로, 변경된 비밀번호는 애플리케이션을 다시 시작하지 않고도 즉시 적용될 수 있습니다.","text":"목차 쿠버네티스 - Secret 쿠버네티스 - ConfigMap 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s Secret 쿠버네티스(Secret)는 애플리케이션에서 민감한 데이터를 안전하게 저장하고 관리하기 위한 리소스 Secret은 기본적으로 ConfigMap과 유사한 방식으로 동작하지만, 암호화된 형태로 데이터를 저장하여 더 높은 보안 수준을 제공합니다. Secret은 애플리케이션에서 사용되는 비밀번호, API 토큰, 데이터베이스 자격증명 등과 같은 중요한 정보를 저장할 수 있습니다. 이러한 데이터는 애플리케이션의 컨테이너 이미지와 분리되어, 보안성을 유지하면서 애플리케이션을 배포하고 관리할 수 있습니다. Secret은 Base64 인코딩을 사용하여 데이터를 인코딩하고, 쿠버네티스 클러스터 내부에서 저장됩니다. 이를 통해 데이터는 안전하게 저장되며, 컨테이너 내부에서 필요할 때만 디코딩하여 사용됩니다. Secret은 YAML 또는 JSON 형식으로 정의되며, 쿠버네티스 클러스터에 생성 및 적용됩니다. Secret을 생성한 후에는 해당 Secret을 사용하려는 Pod의 컨테이너에 마운트하거나 환경 변수로 설정할 수 있습니다. 이렇게 하면 애플리케이션은 Secret에서 정의된 중요한 정보를 사용할 수 있습니다. 예를 들어, Secret에서 “db_password”라는 키에 대한 값으로 “mysecretpassword”를 설정하면, 애플리케이션은 이 값을 디코딩하여 데이터베이스 비밀번호로 사용할 수 있습니다. Secret은 ConfigMap과 마찬가지로 클러스터나 네임스페이스 수준에서 변경 및 관리할 수 있으므로, 변경된 비밀번호는 애플리케이션을 다시 시작하지 않고도 즉시 적용될 수 있습니다. kubectl describe secret/db-user-pass Name: db-user-passNamespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Type: OpaqueData====password.txt: 7 bytesusername.txt: 5 bytes ubectl get secret/db-user-pass -o yaml apiVersion: v1data: password.txt: cTJ3M2U0cg== username.txt: YWRtaW4=kind: Secretmetadata: creationTimestamp: &quot;2023-06-12T18:05:52Z&quot; name: db-user-pass namespace: default resourceVersion: &quot;54274&quot; uid: 45ac61f5-9c32-4d40-9823-d7c5edaba1edtype: Opaque apiVersion: v1kind: Podmetadata: name: alpine-envspec: containers: - name: alpine image: alpine command: [&quot;sleep&quot;] args: [&quot;100000&quot;] env: - name: DB_USERNAME valueFrom: secretKeyRef: name: db-user-pass key: username.txt - name: DB_PASSWORD valueFrom: secretKeyRef: name: db-user-pass key: password.txt","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Config","slug":"Kubernetes/Config","permalink":"https://ckck803.github.io/categories/Kubernetes/Config/"}],"tags":[]},{"title":"MySQL - 사용자 추가","slug":"mysql/user","date":"2023-05-09T16:16:13.000Z","updated":"2024-02-18T16:19:54.542Z","comments":true,"path":"2023/05/10/mysql/user/","link":"","permalink":"https://ckck803.github.io/2023/05/10/mysql/user/","excerpt":"사용자 추가create user &#x27;[userid]&#x27;;-- localhost 에서만 접속할 수 있는 계정 생성create user &#x27;[userid]&#x27;@&#x27;localhost&#x27; identified by &#x27;[비밀번호]&#x27;;-- 외부에서 접근 가능한 계정 생성create user &#x27;[userid]&#x27;@&#x27;%&#x27; identified by &#x27;[비밀번호]&#x27;; 권한 부여하기-- select 권한 부여grant select privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- update 권한 부여grant update privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- insert 권한 부여grant insert privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- delete 권한 부여grant delete privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- select, update, insert 권한 부여grant select, update, insert privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;; 특정 데이터 베이스에 대한 접근 부여-- [Database 명] 데이터베이스에 select 권한 부여grant select privileges on [Database 명].* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;; User 에 따른 데이터 베이스 접근 부여-- localhost User 에게 전체 권한 부여grant all privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- 외부접근 User 에게 전체 권한 부여grant all privileges on *.* to &#x27;[userid]&#x27;@&#x27;%&#x27; identified by &#x27;[비밀번호]&#x27;;","text":"사용자 추가create user &#x27;[userid]&#x27;;-- localhost 에서만 접속할 수 있는 계정 생성create user &#x27;[userid]&#x27;@&#x27;localhost&#x27; identified by &#x27;[비밀번호]&#x27;;-- 외부에서 접근 가능한 계정 생성create user &#x27;[userid]&#x27;@&#x27;%&#x27; identified by &#x27;[비밀번호]&#x27;; 권한 부여하기-- select 권한 부여grant select privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- update 권한 부여grant update privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- insert 권한 부여grant insert privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- delete 권한 부여grant delete privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- select, update, insert 권한 부여grant select, update, insert privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;; 특정 데이터 베이스에 대한 접근 부여-- [Database 명] 데이터베이스에 select 권한 부여grant select privileges on [Database 명].* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;; User 에 따른 데이터 베이스 접근 부여-- localhost User 에게 전체 권한 부여grant all privileges on *.* to &#x27;[userid]&#x27;@localhost identified by &#x27;[비밀번호]&#x27;;-- 외부접근 User 에게 전체 권한 부여grant all privileges on *.* to &#x27;[userid]&#x27;@&#x27;%&#x27; identified by &#x27;[비밀번호]&#x27;;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"MySQL","slug":"Develop/MySQL","permalink":"https://ckck803.github.io/categories/Develop/MySQL/"}],"tags":[]},{"title":"Spring Batch - ItemWriter","slug":"spring/spring-batch/chunk/spring-batch-ItemWriter","date":"2023-05-09T06:25:35.000Z","updated":"2024-02-26T15:28:11.544Z","comments":true,"path":"2023/05/09/spring/spring-batch/chunk/spring-batch-ItemWriter/","link":"","permalink":"https://ckck803.github.io/2023/05/09/spring/spring-batch/chunk/spring-batch-ItemWriter/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ItemWriterItemWriter는 스텝에서 처리한 데이터를 출력하는 역할을 합니다. ItemWriter는 스텝에서 처리한 모든 데이터를 한 번에 출력하며, 출력 대상은 일반적으로 데이터베이스, 파일 또는 메시징 시스템과 같은 외부 저장소입니다. ItemWriter는 일반적으로 데이터베이스에 대한 INSERT, UPDATE 또는 DELETE 쿼리를 실행하거나, 파일에 대한 출력을 수행하거나, 메시징 시스템의 큐 또는 주제에 데이터를 전송하는 데 사용됩니다. Spring Batch는 다양한 유형의 ItemWriter를 제공합니다. 일반적으로 사용되는 ItemWriter 유형은 다음과 같습니다. JdbcBatchItemWriter: JDBC를 사용하여 데이터베이스에 대한 배치 INSERT, UPDATE 또는 DELETE 쿼리를 실행하는 데 사용됩니다. JpaItemWriter: JPA를 사용하여 데이터를 저장하는 데 사용됩니다. FlatFileItemWriter: CSV, 고정 길이 또는 구분 기호로 구분된 파일에 데이터를 씁니다. StaxEventItemWriter: XML 형식으로 데이터를 씁니다. JmsItemWriter: JMS 대기열에 데이터를 전송합니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ItemWriterItemWriter는 스텝에서 처리한 데이터를 출력하는 역할을 합니다. ItemWriter는 스텝에서 처리한 모든 데이터를 한 번에 출력하며, 출력 대상은 일반적으로 데이터베이스, 파일 또는 메시징 시스템과 같은 외부 저장소입니다. ItemWriter는 일반적으로 데이터베이스에 대한 INSERT, UPDATE 또는 DELETE 쿼리를 실행하거나, 파일에 대한 출력을 수행하거나, 메시징 시스템의 큐 또는 주제에 데이터를 전송하는 데 사용됩니다. Spring Batch는 다양한 유형의 ItemWriter를 제공합니다. 일반적으로 사용되는 ItemWriter 유형은 다음과 같습니다. JdbcBatchItemWriter: JDBC를 사용하여 데이터베이스에 대한 배치 INSERT, UPDATE 또는 DELETE 쿼리를 실행하는 데 사용됩니다. JpaItemWriter: JPA를 사용하여 데이터를 저장하는 데 사용됩니다. FlatFileItemWriter: CSV, 고정 길이 또는 구분 기호로 구분된 파일에 데이터를 씁니다. StaxEventItemWriter: XML 형식으로 데이터를 씁니다. JmsItemWriter: JMS 대기열에 데이터를 전송합니다. ItemWriter 인터페이스public interface ItemWriter &#123; public void open(Serializable checkpoint) throws Exception; public void close() throws Exception; public void writeItems(List&lt;Object&gt; items) throws Exception; public Serializable checkpointInfo() throws Exception; &#125; ItemWriter 구현체JdbcBatchItemWriterJdbcBatchItemWriter는 Spring Batch 프레임워크에서 제공하는 ItemWriter 인터페이스를 구현한 클래스 중 하나입니다. JDBC 데이터베이스와 상호 작용하는 데 사용됩니다. 이 ItemWriter는 여러 개의 항목을 받아서 배치 작업으로 일괄 처리할 수 있습니다. 일괄 처리는 내부적으로 트랜잭션으로 묶여 처리되므로 모든 항목이 성공적으로 쓰여지거나 모든 항목이 롤백됩니다. JdbcBatchItemWriter는 다음과 같은 방식으로 작동합니다. 쓰기 전용 연결을 가져옵니다. 모든 항목을 배치로 그룹화합니다. 배치 내의 모든 항목을 PreparedStatementSetter를 사용하여 PreparedStatement 객체에 매핑합니다. PreparedStatement 객체를 실행합니다. 결과를 확인하고 배치 작업 내의 모든 항목이 성공적으로 처리되었는지 확인합니다. 결과를 반환하고 쓰기 전용 연결을 반환합니다. JdbcBatchItemWriter는 대량의 데이터를 처리해야하는 경우 유용합니다. 이를 통해 데이터베이스 작업 수를 줄이고 성능을 높일 수 있습니다. JpaItemWriterpaItemWriter는 Spring Batch 프레임워크에서 제공하는 ItemWriter 인터페이스를 구현한 클래스 중 하나입니다. JPA(Java Persistence API)를 사용하여 객체를 데이터베이스에 쓰는 데 사용됩니다. 이 ItemWriter는 여러 개의 항목을 받아서 배치 작업으로 일괄 처리할 수 있습니다. 일괄 처리는 내부적으로 트랜잭션으로 묶여 처리되므로 모든 항목이 성공적으로 쓰여지거나 모든 항목이 롤백됩니다. JpaItemWriter는 다음과 같은 방식으로 작동합니다. 쓰기 전용 EntityManager를 가져옵니다. 모든 항목을 배치로 그룹화합니다. 배치 내의 모든 항목을 EntityManager를 사용하여 영속화합니다. EntityManager의 flush() 메서드를 호출하여 변경 사항을 데이터베이스에 적용합니다. 결과를 확인하고 배치 작업 내의 모든 항목이 성공적으로 처리되었는지 확인합니다. 결과를 반환하고 쓰기 전용 EntityManager를 반환합니다. JpaItemWriter는 JPA를 사용하여 객체를 데이터베이스에 쓰는 데 유용합니다. 이를 통해 객체 그래프를 쉽게 저장할 수 있고, 복잡한 쿼리 작성을 피할 수 있습니다. 또한 JPA의 일관성과 트랜잭션 관리 기능을 활용할 수 있습니다. FlatFileItemWriterFlatFileItemWriter는 Spring Batch 프레임워크에서 제공하는 ItemWriter 인터페이스를 구현한 클래스 중 하나입니다. 이 클래스는 CSV, TSV, 고정 너비 파일 등과 같은 평면 파일을 생성하는 데 사용됩니다. FlatFileItemWriter는 데이터를 출력할 파일 이름 및 위치, 필드 구분자, 줄 바꿈 문자 등 출력 파일의 형식을 지정할 수 있는 다양한 설정 옵션을 제공합니다. 이 클래스는 또한 ItemWriter 인터페이스의 write() 메서드를 구현하여 ItemReader에서 읽은 데이터를 출력 파일에 쓰는 데 사용됩니다. FlatFileItemWriter를 사용하려면 다음과 같은 단계를 수행해야 합니다. FlatFileItemWriter를 구성합니다. 이 구성 단계에서는 출력 파일의 이름, 위치, 필드 구분자, 줄 바꿈 문자 등 출력 파일의 형식을 지정합니다. ItemReader에서 데이터를 읽어와 ItemProcessor에서 처리합니다. FlatFileItemWriter.write() 메서드를 호출하여 처리된 데이터를 출력 파일에 씁니다. 이 메서드는 쓰기 작업을 버퍼링하고, 일정한 크기가 될 때마다 출력 파일에 씁니다. 쓰기 작업이 완료되면 FlatFileItemWriter.close() 메서드를 호출하여 출력 파일을 닫습니다. FlatFileItemWriter는 대용량 데이터 파일을 생성하는 데 적합합니다. 이를 통해 파일 생성 및 처리 속도를 높일 수 있습니다. StaxEventItemWriterStaxEventItemWriter는 Spring Batch 프레임워크에서 제공하는 ItemWriter 인터페이스를 구현한 클래스 중 하나입니다. 이 클래스는 XML 형식으로 데이터를 출력하는 데 사용됩니다. StaxEventItemWriter는 StAX(Streaming API for XML)를 사용하여 XML 문서를 생성합니다. 이 클래스는 XML 스트림을 작성하는 데 필요한 설정을 제공합니다. 예를 들어 출력 파일 이름, 루트 엘리먼트 이름, 네임스페이스 등을 지정할 수 있습니다. StaxEventItemWriter를 사용하려면 다음과 같은 단계를 수행해야 합니다. StaxEventItemWriter를 구성합니다. 이 구성 단계에서는 출력 파일 이름, 루트 엘리먼트 이름, 네임스페이스 등을 지정합니다. ItemReader에서 데이터를 읽어와 ItemProcessor에서 처리합니다. StaxEventItemWriter.write() 메서드를 호출하여 처리된 데이터를 XML 형식으로 출력 파일에 씁니다. 이 메서드는 쓰기 작업을 버퍼링하고, 일정한 크기가 될 때마다 출력 파일에 씁니다. 쓰기 작업이 완료되면 StaxEventItemWriter.close() 메서드를 호출하여 출력 파일을 닫습니다. StaxEventItemWriter는 대용량 XML 파일을 생성하는 데 적합합니다. 이를 통해 파일 생성 및 처리 속도를 높일 수 있습니다. 또한, StaxEventItemWriter는 다른 XML 라이브러리보다 메모리 사용량이 적으며, 대규모 XML 문서를 처리하는 데 최적화되어 있습니다. JmsItemWriterJmsItemWriter는 Spring Batch 프레임워크에서 제공하는 ItemWriter 인터페이스를 구현한 클래스 중 하나입니다. 이 클래스는 Java Messaging Service(JMS)를 사용하여 메시지를 보내는 데 사용됩니다. JmsItemWriter는 JMS 목적지를 구성하는 데 필요한 설정을 제공합니다. 예를 들어 연결 팩토리, 목적지 이름, 전송 모드 등을 지정할 수 있습니다. JmsItemWriter를 사용하려면 다음과 같은 단계를 수행해야 합니다. JmsItemWriter를 구성합니다. 이 구성 단계에서는 연결 팩토리, 목적지 이름, 전송 모드 등을 지정합니다. ItemReader에서 데이터를 읽어와 ItemProcessor에서 처리합니다. JmsItemWriter.write() 메서드를 호출하여 처리된 데이터를 JMS 메시지로 보냅니다. 쓰기 작업이 완료되면 JmsItemWriter.close() 메서드를 호출하여 JMS 리소스를 닫습니다. JmsItemWriter는 대용량 메시지를 처리하는 데 적합합니다. 이를 통해 메시지 전송 속도를 높일 수 있습니다. 또한, JmsItemWriter는 JMS 기반 시스템과 연동하여 데이터를 전송하는 데 유용합니다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"},{"name":"Chunk","slug":"Spring/Spring-Batch/Step/Chunk","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/Chunk/"}],"tags":[]},{"title":"Spring Batch - ItemProcessor","slug":"spring/spring-batch/chunk/spring-batch-ItemProcessor","date":"2023-05-09T05:25:35.000Z","updated":"2024-02-26T15:29:57.670Z","comments":true,"path":"2023/05/09/spring/spring-batch/chunk/spring-batch-ItemProcessor/","link":"","permalink":"https://ckck803.github.io/2023/05/09/spring/spring-batch/chunk/spring-batch-ItemProcessor/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ItemProcessorItemProcessor는 Step 내에서 사용될 데이터를 변환 또는 가공하는 역할을 합니다. ItemReader가 읽어온 데이터를 ItemProcessor가 받아들여 처리하고, 처리한 결과를 ItemWriter에 전달합니다. ItemProcessor는 일반적으로 데이터 변환, 유효성 검사, 필터링 또는 데이터 가공과 같은 작업을 수행하는 데 사용됩니다. 예를 들어, ItemProcessor를 사용하여 입력 데이터의 길이를 제한하거나, 데이터를 수정하거나, 유효성을 검사하거나, 데이터를 필터링할 수 있습니다. ItemProcessor는 단일 입력 값을 받아 처리 결과를 반환하는 단순한 함수형 인터페이스인 ItemProcessor&lt;T, S&gt;를 구현합니다. 여기서 T는 입력 유형이고, S는 출력 유형입니다. ItemProcessor는 스텝 처리 과정에서 중요한 역할을 합니다. 데이터를 변환 또는 가공하여 ItemWriter가 처리할 수 있는 형식으로 변환하므로, 대용량 데이터 세트를 효율적으로 처리하는 데 매우 유용합니다. 또한, ItemProcessor를 사용하여 데이터 유효성 검사 및 데이터 가공 작업을 수행하여 데이터 품질을 유지하고, 필요한 작업을 수행할 수 있습니다. ItemProcessor 인터페이스","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ItemProcessorItemProcessor는 Step 내에서 사용될 데이터를 변환 또는 가공하는 역할을 합니다. ItemReader가 읽어온 데이터를 ItemProcessor가 받아들여 처리하고, 처리한 결과를 ItemWriter에 전달합니다. ItemProcessor는 일반적으로 데이터 변환, 유효성 검사, 필터링 또는 데이터 가공과 같은 작업을 수행하는 데 사용됩니다. 예를 들어, ItemProcessor를 사용하여 입력 데이터의 길이를 제한하거나, 데이터를 수정하거나, 유효성을 검사하거나, 데이터를 필터링할 수 있습니다. ItemProcessor는 단일 입력 값을 받아 처리 결과를 반환하는 단순한 함수형 인터페이스인 ItemProcessor&lt;T, S&gt;를 구현합니다. 여기서 T는 입력 유형이고, S는 출력 유형입니다. ItemProcessor는 스텝 처리 과정에서 중요한 역할을 합니다. 데이터를 변환 또는 가공하여 ItemWriter가 처리할 수 있는 형식으로 변환하므로, 대용량 데이터 세트를 효율적으로 처리하는 데 매우 유용합니다. 또한, ItemProcessor를 사용하여 데이터 유효성 검사 및 데이터 가공 작업을 수행하여 데이터 품질을 유지하고, 필요한 작업을 수행할 수 있습니다. ItemProcessor 인터페이스public interface ItemProcessor &#123; public Object processItem(Object item) throws Exception;&#125; ItemProccesor 구현체 종류ClassifierCompoisteItemProcessorClassifierCompositeItemProcessor는 Spring Batch의 ItemProcessor 인터페이스를 구현한 클래스로, 다중 프로세싱 전략을 적용할 수 있도록 설계된 컴포지트(Composite) 패턴의 구현체입니다. ClassifierCompositeItemProcessor는 Classifier라는 인터페이스를 구현하고 있습니다. Classifier는 하나의 입력 값을 기반으로 여러 개의 출력 값을 생성할 수 있는 기능을 제공합니다. ClassifierCompositeItemProcessor는 이 기능을 활용하여 하나의 입력 항목을 여러 개의 ItemProcessor에 전달하여 처리할 수 있습니다. CmopositeItemProcessorCustomItemProcessor","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"},{"name":"Chunk","slug":"Spring/Spring-Batch/Step/Chunk","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/Chunk/"}],"tags":[]},{"title":"Spring Batch - ItemReader","slug":"spring/spring-batch/chunk/spring-batch-ItemReader","date":"2023-05-09T04:25:35.000Z","updated":"2024-02-26T15:28:04.223Z","comments":true,"path":"2023/05/09/spring/spring-batch/chunk/spring-batch-ItemReader/","link":"","permalink":"https://ckck803.github.io/2023/05/09/spring/spring-batch/chunk/spring-batch-ItemReader/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ItemReaderItemReader는 스텝 내에서 사용될 데이터를 읽는 역할을 합니다. ItemReader는 스텝이 시작될 때 호출되며, 데이터 소스에서 데이터를 읽어 Chunk 단위로 ItemProcessor에 전달합니다. ItemReader는 일반적으로 파일, 데이터베이스 또는 메시징 시스템과 같은 외부 데이터 소스에서 데이터를 읽는 데 사용됩니다. Spring Batch는 다양한 유형의 ItemReader를 지원하며, 일반적으로 사용되는 ItemReader 유형은 다음과 같습니다. FlatFileItemReader: CSV, 고정 길이 또는 구분 기호로 구분된 파일에서 데이터를 읽는 데 사용됩니다. JdbcCursorItemReader: JDBC 쿼리를 실행하고 ResultSet에서 데이터를 읽는 데 사용됩니다. JpaPagingItemReader: JPA를 사용하여 페이징 처리를 수행하고 데이터를 읽는 데 사용됩니다. StaxEventItemReader: XML 데이터를 읽는 데 사용됩니다. JmsItemReader: JMS 대기열에서 데이터를 읽는 데 사용됩니다. 다수의 구현체들이 ItemReader 와 ItemStream 을 동시에 구현하고 있습니다. ItemStream 은 파일의 스트림을 열거나 종료, DB 커넥션을 열거나 종료, 출력 장치 초기화 등의 작업을 진행합니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ItemReaderItemReader는 스텝 내에서 사용될 데이터를 읽는 역할을 합니다. ItemReader는 스텝이 시작될 때 호출되며, 데이터 소스에서 데이터를 읽어 Chunk 단위로 ItemProcessor에 전달합니다. ItemReader는 일반적으로 파일, 데이터베이스 또는 메시징 시스템과 같은 외부 데이터 소스에서 데이터를 읽는 데 사용됩니다. Spring Batch는 다양한 유형의 ItemReader를 지원하며, 일반적으로 사용되는 ItemReader 유형은 다음과 같습니다. FlatFileItemReader: CSV, 고정 길이 또는 구분 기호로 구분된 파일에서 데이터를 읽는 데 사용됩니다. JdbcCursorItemReader: JDBC 쿼리를 실행하고 ResultSet에서 데이터를 읽는 데 사용됩니다. JpaPagingItemReader: JPA를 사용하여 페이징 처리를 수행하고 데이터를 읽는 데 사용됩니다. StaxEventItemReader: XML 데이터를 읽는 데 사용됩니다. JmsItemReader: JMS 대기열에서 데이터를 읽는 데 사용됩니다. 다수의 구현체들이 ItemReader 와 ItemStream 을 동시에 구현하고 있습니다. ItemStream 은 파일의 스트림을 열거나 종료, DB 커넥션을 열거나 종료, 출력 장치 초기화 등의 작업을 진행합니다. ItemReader 인터페이스public interface ItemReader&lt;T&gt; &#123; @Nullable T read() throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException;&#125; ItemReader 구현체FlatFileItemReaderFlatFileItemReader는 파일에서 데이터를 읽어오기 위해 사용됩니다. 입력 파일은 다양한 형식의 텍스트 파일일 수 있으며, 일반적으로 CSV(Comma-Separated Values) 또는 고정 길이 형식의 파일을 처리하는 데 사용됩니다. FlatFileItemReader는 Spring의 Resource 추상화를 사용하여 파일에 대한 참조를 가져오며, 구성 가능한 구분자 및 헤더&#x2F;푸터 처리 기능을 제공합니다. 또한, 파일의 각 레코드를 Java 객체로 변환하여 반환할 수 있으므로, 이를 통해 다른 스프링 배치 구성 요소에서 사용할 수 있는 유용한 데이터 모델을 만들 수 있습니다. FlatFileItemReaderBuilder saveState(boolean saveState) FlatFileItemReader의 상태를 저장할지 여부를 설정합니다. true로 설정하면 상태가 저장되어 재시작 시 이전 상태로 복구됩니다. name(String name) FlatFileItemReader의 이름을 설정합니다. 이 이름은 스텝 구성에서 사용될 수 있습니다. maxItemCount(int maxItemCount) 최대 읽기 아이템 수를 설정합니다. 이 값을 설정하면 지정된 수만큼 아이템을 읽은 후 리더가 끝납니다. currentItemCount(int currentItemCount) 현재 읽은 아이템 수를 설정합니다. 이 값을 설정하면 리더가 재시작될 때 이전 상태로 복구됩니다. addComment(String comment) 주석(comment)을 추가합니다. 이 주석은 읽기 프로세스의 로깅이나 디버깅에 사용될 수 있습니다. comments(String... comments 다중 주석(comments)을 추가합니다. recordSeparatorPolicy(RecordSeparatorPolicy policy) 레코드 구분 정책(RecordSeparatorPolicy)을 설정합니다. 레코드 구분 정책은 행 사이의 구분자를 기반으로 레코드를 식별하는 데 사용됩니다. bufferedReaderFactory(BufferedReaderFactory factory) BufferedReaderFactory를 설정하여 FlatFileItemReader에서 사용할 BufferedReader를 생성합니다. 사용자 지정 BufferedReader를 사용할 수 있습니다. resource(Resource resource) 읽을 리소스(Resource)를 설정합니다. 파일 시스템 경로, 클래스패스 리소스 등을 지정할 수 있습니다. strict(boolean strict) 엄격 모드(strict mode)를 설정합니다. 엄격 모드에서는 입력 행에 예상되는 필드 수보다 적은 필드가 있는 경우 예외가 발생합니다. encoding(String encoding) 읽을 파일의 인코딩을 설정합니다. linesToSkip(int linesToSkip) 읽기 시작 시 건너뛸 행 수를 설정합니다. 파일의 처음 몇 행을 건너뛰고 데이터를 읽을지 결정할 수 있습니다. skippedLinesCallback(LineCallbackHandler callback) 건너뛴 행에 대한 콜백 처리를 설정합니다. 건너뛴 행의 내용을 처리할 수 있습니다. lineMapper(LineMapper&lt;T&gt; lineMapper) 행을 도메인 객체로 매핑하는 LineMapper를 설정합니다. fieldSetMapper(FieldSetMapper&lt;T&gt; mapper) FieldSetMapper를 설정하여 필드 세트를 도메인 객체로 매핑합니다. lineTokenizer(LineTokenizer tokenizer) 행을 필드로 분리하는 LineTokenizer를 설정합니다. public DelimitedBuilder&lt;T&gt; delimited() 구분자(delimiter) 기반의 필드 구성을 위한 DelimitedBuilder를 반환합니다. public FixedLengthBuilder&lt;T&gt; fixedLength() 고정 길이 필드 구성을 위한 FixedLengthBuilder를 반환합니다. 고정 길이 필드는 특정 위치에서 고정된 길이로 값을 추출합니다. targetType(Class&lt;? extends T&gt; targetType 읽은 데이터를 매핑할 도메인 객체의 타입을 설정합니다. 제네릭 타입으로 지정된 타입을 사용합니다. prototypeBeanName(String prototypeBeanName) 프로토타입 빈의 이름을 설정합니다. 프로토타입 빈은 매번 생성되는 빈으로, 상태를 공유하지 않습니다. beanFactory(BeanFactory beanFactory) BeanFactory를 설정합니다. FlatFileItemReader가 빈을 생성할 때 사용됩니다. customEditors(Map&lt;Class&lt;?&gt;, PropertyEditor&gt; customEditors) 사용자 정의 PropertyEditor를 설정합니다. 특정 타입의 프로퍼티에 대한 변환을 사용자가 정의한 PropertyEditor로 수행할 수 있습니다. distanceLimit(int distanceLimit) 거리 제한(distance limit)을 설정합니다. 거리 제한은 필드 추출 시 최대 길이를 제한하는 데 사용됩니다. beanMapperStrict(boolean beanMapperStrict) BeanMapper의 엄격 모드를 설정합니다. 엄격 모드에서는 필드 매핑 오류가 발생하면 예외가 발생합니다. public FlatFileItemReader&lt;T&gt; build() 설정된 값들을 기반으로 FlatFileItemReader를 생성합니다. private void updateTokenizerValidation(Object tokenizer, int index) 토큰화기(Tokenizer)의 유효성을 업데이트하는 내부 메소드입니다. 일반적으로 사용자는 이 메소드를 직접 호출할 필요는 없습니다. JdbcCursorItemReaderJdbcCursorItemReader는 Spring Batch 프레임워크에서 제공하는 ItemReader의 구현체 중 하나로, JDBC를 사용하여 데이터베이스에서 데이터를 읽어오기 위해 사용됩니다. JdbcCursorItemReader는 SQL 쿼리를 실행하고 결과 집합을 커서(cursor)를 사용하여 가져옵니다. 이 커서는 결과 집합을 한 번에 전체적으로 가져오지 않고, 필요한 부분만 가져올 수 있도록 합니다. 이는 대규모 데이터베이스 작업에서 효율적으로 메모리를 사용할 수 있도록 도와줍니다. JdbcCursorItemReader는 구성 가능한 SQL 쿼리, 매개 변수 바인딩, 페이징 및 정렬을 지원합니다. 또한, 데이터베이스의 각 레코드를 Java 객체로 변환하여 반환할 수 있으므로, 이를 통해 다른 스프링 배치 구성 요소에서 사용할 수 있는 유용한 데이터 모델을 만들 수 있습니다. JdbcCursorItemReaderBuilder saveState(boolean saveState) JdbcCursorItemReader의 상태를 저장할지 여부를 설정합니다. true로 설정하면 상태가 저장되어 재시작 시 이전 상태로 복구됩니다. name(String name) JdbcCursorItemReader의 이름을 설정합니다. 이 이름은 스텝 구성에서 사용될 수 있습니다. maxItemCount(int maxItemCount) 최대 읽기 아이템 수를 설정합니다. 이 값을 설정하면 지정된 수만큼 아이템을 읽은 후 리더가 끝납니다. currentItemCount(int currentItemCount) 현재 읽은 아이템 수를 설정합니다. 이 값을 설정하면 리더가 재시작될 때 이전 상태로 복구됩니다. dataSource(DataSource dataSource) 사용할 데이터 소스(DataSource)를 설정합니다. JDBC 연결을 수행할 때 사용됩니다. fetchSize(int fetchSize) 한 번에 가져올 레코드 수(fetch size)를 설정합니다. 큰 데이터셋을 처리할 때 성능을 향상시키는 데 도움이 됩니다. maxRows(int maxRows) 최대 반환되는 행 수를 제한합니다. queryTimeout(int queryTimeout) 쿼리 실행 시 타임아웃 시간을 설정합니다. ignoreWarnings(boolean ignoreWarnings) 경고(warning)를 무시할지 여부를 설정합니다. verifyCursorPosition(boolean verifyCursorPosition) 커서 위치를 확인할지 여부를 설정합니다. 커서 위치 확인은 읽기 진행 중 커서가 정상적인 위치에 있는지 확인하는 작업입니다. driverSupportsAbsolute(boolean driverSupportsAbsolute) 드라이버가 절대 커서 위치를 지원하는지 여부를 설정합니다. useSharedExtendedConnection(boolean useSharedExtendedConnection) 공유 확장 연결(shared extended connection)을 사용할지 여부를 설정합니다. preparedStatementSetter(PreparedStatementSetter preparedStatementSetter) PreparedStatementSetter를 설정하여 SQL 문에 인수를 바인딩합니다. queryArguments(Object... args) SQL 쿼리의 인수를 설정합니다. 가변 인수로 전달되며, 쿼리에 매핑되는 순서대로 인수를 제공합니다. queryArguments(Object[] args, int[] types) SQL 쿼리의 인수와 해당 인수의 JDBC 타입을 설정합니다. queryArguments(List&lt;?&gt; args) SQL 쿼리의 인수를 설정합니다. List 형태로 인수를 전달합니다. sql(String sql) 실행할 SQL 문을 설정합니다. rowMapper(RowMapper&lt;T&gt; rowMapper) RowMapper를 설정하여 ResultSet의 행을 도메인 객체로 매핑합니다. beanRowMapper(Class&lt;T&gt; mappedClass) BeanRowMapper를 설정하여 ResultSet의 행을 지정된 도메인 객체 타입으로 매핑합니다. JpaPagingItemReaderJpaPagingItemReader는 Spring Batch 프레임워크에서 제공하는 ItemReader의 구현체 중 하나로, JPA(Java Persistence API)를 사용하여 데이터베이스에서 페이지별로 데이터를 읽어오기 위해 사용됩니다. JpaPagingItemReader는 Spring Data JPA를 기반으로 구현되어 있으며, 페이징 및 정렬을 지원합니다. 이는 대규모 데이터베이스 작업에서 효율적으로 메모리를 사용할 수 있도록 도와줍니다. JpaPagingItemReader는 구성 가능한 JPA 쿼리, 매개 변수 바인딩, 페이징 및 정렬을 지원합니다. 또한, 데이터베이스의 각 레코드를 Java 객체로 변환하여 반환할 수 있으므로, 이를 통해 다른 스프링 배치 구성 요소에서 사용할 수 있는 유용한 데이터 모델을 만들 수 있습니다. JpaPagingItemReaderBuilder saveState(boolean saveState) JpaPagingItemReader의 상태를 저장할지 여부를 설정합니다. true로 설정하면 상태가 저장되어 재시작 시 이전 상태로 복구됩니다. name(String name) JpaPagingItemReader의 이름을 설정합니다. 이 이름은 스텝 구성에서 사용될 수 있습니다. maxItemCount(int maxItemCount) 최대 읽기 아이템 수를 설정합니다. 이 값을 설정하면 지정된 수만큼 아이템을 읽은 후 리더가 끝납니다. currentItemCount(int currentItemCount) 현재 읽은 아이템 수를 설정합니다. 이 값을 설정하면 리더가 재시작될 때 이전 상태로 복구됩니다. pageSize(int pageSize) 한 페이지에서 읽을 아이템 수를 설정합니다. 페이지마다 일괄 처리될 아이템 수를 제어하는 데 사용됩니다. parameterValues(Map&lt;String, Object&gt; parameterValues) JPA 쿼리의 매개변수 값을 설정합니다. 매개변수 이름과 값을 매핑하는 맵을 전달합니다. queryProvider(JpaQueryProvider queryProvider) JpaQueryProvider를 설정하여 JPA 쿼리를 제공합니다. JpaQueryProvider는 데이터베이스와 관련된 쿼리를 생성하는 인터페이스입니다. queryString(String queryString) 직접 쿼리 문자열을 설정합니다. JPA 쿼리를 직접 지정하고자 할 때 사용됩니다. transacted(boolean transacted) 트랜잭션 처리 여부를 설정합니다. true로 설정하면 리더는 트랜잭션 내에서 실행됩니다. entityManagerFactory(EntityManagerFactory entityManagerFactory) 사용할 EntityManagerFactory를 설정합니다. JPA 연결을 수행할 때 사용됩니다. build() 설정된 값들을 기반으로 JpaPagingItemReader를 생성합니다. StaxEventItemReaderStaxEventItemReader는 Spring Batch 프레임워크에서 제공하는 ItemReader의 구현체 중 하나로, XML 문서에서 데이터를 읽어오기 위해 사용됩니다. StaxEventItemReader는 XML을 파싱하는 데에 StAX(Streaming API for XML)를 사용합니다. 이를 통해 대용량 XML 파일을 효율적으로 처리할 수 있으며, 메모리 사용량을 줄일 수 있습니다. StaxEventItemReader는 구성 가능한 XML 스키마, 태그 이름 및 XPath를 지원합니다. 또한, XML의 각 노드를 Java 객체로 변환하여 반환할 수 있으므로, 이를 통해 다른 스프링 배치 구성 요소에서 사용할 수 있는 유용한 데이터 모델을 만들 수 있습니다. StaxEventItemReaderBuilder saveState(boolean saveState) StaxEventItemReader의 상태를 저장할지 여부를 설정합니다. true로 설정하면 상태가 저장되어 재시작 시 이전 상태로 복구됩니다. name(String name) StaxEventItemReader의 이름을 설정합니다. 이 이름은 스텝 구성에서 사용될 수 있습니다. maxItemCount(int maxItemCount) 최대 읽기 아이템 수를 설정합니다. 이 값을 설정하면 지정된 수만큼 아이템을 읽은 후 리더가 끝납니다. currentItemCount(int currentItemCount) 현재 읽은 아이템 수를 설정합니다. 이 값을 설정하면 리더가 재시작될 때 이전 상태로 복구됩니다. resource(Resource resource) 읽을 XML 리소스(Resource)를 설정합니다. unmarshaller(Unmarshaller unmarshaller) Unmarshaller를 설정하여 XML을 도메인 객체로 언마샬링합니다. addFragmentRootElements(String... fragmentRootElements) 파편(fragment)의 루트 엘리먼트를 추가합니다. 지정된 엘리먼트 이름의 하위 요소를 아이템으로 처리합니다. addFragmentRootElements(List&lt;String&gt; fragmentRootElements) 파편(fragment)의 루트 엘리먼트를 추가합니다. 지정된 엘리먼트 이름의 하위 요소를 아이템으로 처리합니다. List 형태로 엘리먼트 이름을 전달합니다. strict(boolean strict) 엄격 모드(strict mode)를 설정합니다. 엄격 모드에서는 XML 구조에 대한 검증이 수행되며, 오류가 발생하면 예외가 발생합니다. xmlInputFactory(XMLInputFactory xmlInpzutFactory) 사용할 XMLInputFactory를 설정합니다. StAX 이벤트 리더를 생성하는 데 사용됩니다. encoding(String encoding) XML 인코딩을 설정합니다. 읽을 XML의 인코딩을 지정할 수 있습니다. build() 설정된 값들을 기반으로 StaxEventItemReader를 생성합니다. JmsItemReader JmsItemReaderBuilder 에 의해 생성되는 ItemReader의 구현체 중 하나 JMS(Java Message Service)를 사용하여 메시지 큐에서 데이터를 읽어오기 위해 사용됩니다. JmsItemReader는 구성 가능한 JMS 목적지(destination), 메시지 선택자(selector), 메시지 수신 타임아웃(timeout) 등을 지원합니다. 이를 통해 메시지 큐에서 필요한 데이터를 선택적으로 읽어오거나, 메시지 큐에서 일정 시간 이내에 수신되지 않은 메시지를 자동으로 처리할 수 있습니다. JmsItemReader는 메시지를 Java 객체로 변환하여 반환할 수 있으므로, 이를 통해 다른 스프링 배치 구성 요소에서 사용할 수 있는 유용한 데이터 모델을 만들 수 있습니다. JmsItemReaderBuilder jmsTemplate(JmsOperations jmsTemplate) 사용할 JmsOperations (일반적으로 JmsTemplate)를 설정합니다. JmsOperations는 JMS 메시지를 송수신하는 데 사용되는 인터페이스입니다. JmsItemReader는 이 JmsOperations를 사용하여 메시지를 읽어옵니다. itemType(Class&lt;? extends T&gt; itemType) 읽어올 JMS 메시지를 매핑할 도메인 객체의 클래스를 설정합니다. itemType으로 지정된 클래스에 대한 매핑이 수행됩니다. build() 설정된 값들을 기반으로 JmsItemReader를 생성합니다. JdbcPagingItemReader JdbcPagingItemReaderBuilder 에 의해 생성되는 ItemReader의 구현체 JdbcPagingItemReader는 JDBC를 사용하여 페이징 방식으로 데이터를 읽어오는 Spring Batch의 리더입니다. 주로 관계형 데이터베이스에서 대량의 데이터를 페이징 처리하여 처리할 때 사용됩니다. JdbcPagingItemReader는 페이지마다 일괄 처리될 아이템 수를 지정하여 데이터를 효율적으로 처리할 수 있습니다. 각 페이지에서는 지정된 수의 아이템을 데이터베이스로부터 조회하여 처리하며, 페이지마다 커서를 이동시키면서 데이터를 읽어옵니다. JdbcPagingItemReader는 다음과 같은 핵심 구성 요소를 가지고 있습니다: DataSource: 데이터베이스 연결 정보를 제공하는 객체로, JdbcPagingItemReader가 데이터베이스에 접근할 때 사용됩니다. PagingQueryProvider: 페이지별로 실행할 SQL 쿼리를 동적으로 생성하는 역할을 합니다. 데이터베이스의 유형에 따라 적절한 QueryProvider를 선택하여 사용할 수 있습니다. RowMapper: JdbcPagingItemReader가 조회한 각 행을 도메인 객체로 매핑하는 역할을 합니다. RowMapper는 Spring의 RowMapper 인터페이스를 구현하여 작성하며, 매핑 로직을 정의합니다. JdbcPagingItemReader를 구성할 때는 다음과 같은 단계를 따릅니다: DataSource 설정: JdbcPagingItemReader의 데이터베이스 연결 정보를 설정합니다. Spring의 DataSource 인터페이스를 구현한 객체를 제공해야 합니다. PagingQueryProvider 설정: 데이터베이스 유형에 따라 적절한 PagingQueryProvider를 선택하고 설정합니다. 이 QueryProvider는 페이지별로 실행될 SQL 쿼리를 동적으로 생성합니다. 대표적으로 JdbcPagingItemReader에서는 SqlPagingQueryProviderFactoryBean을 사용하여 QueryProvider를 설정합니다. RowMapper 설정: 조회한 각 행을 매핑할 RowMapper를 구현하고 설정합니다. 각 행을 도메인 객체로 변환하는 매핑 로직을 정의합니다. 기타 설정: fetchSize, pageSize, parameterValues 등 JdbcPagingItemReader의 동작에 영향을 주는 추가 설정을 수행합니다. JdbcPagingItemReader 생성: 위에서 구성한 값들을 사용하여 JdbcPagingItemReader 객체를 생성합니다. JdbcPagingItemReader는 Spring Batch의 스텝 구성에서 리더로 사용되며, 청크 단위로 데이터를 읽어옵니다. 각 청크에서는 JdbcPagingItemReader가 페이지별로 지정된 수의 아이템을 데이터베이스에서 조회하여 처리합니다. JdbcPagingItemReaderBuilder saveState(boolean saveState) JdbcPagingItemReader의 상태를 저장할지 여부를 설정합니다. true로 설정하면 상태가 저장되어 재시작 시 이전 상태로 복구됩니다. name(String name) JdbcPagingItemReader의 이름을 설정합니다. 이 이름은 스텝 구성에서 사용될 수 있습니다. maxItemCount(int maxItemCount) 최대 읽기 아이템 수를 설정합니다. 이 값을 설정하면 지정된 수만큼 아이템을 읽은 후 리더가 끝납니다. currentItemCount(int currentItemCount) 현재 읽은 아이템 수를 설정합니다. 이 값을 설정하면 리더가 재시작될 때 이전 상태로 복구됩니다. dataSource(DataSource dataSource) 사용할 DataSource를 설정합니다. JdbcPagingItemReader는 데이터베이스 연결을 수행할 때 이 DataSource를 사용합니다. fetchSize(int fetchSize) 데이터베이스로부터 한 번에 가져올 행의 수를 설정합니다. rowMapper(RowMapper&lt;T&gt; rowMapper) 각 행을 도메인 객체로 매핑하는 RowMapper를 설정합니다. beanRowMapper(Class&lt;T&gt; mappedClass) 도메인 객체의 클래스를 기반으로 BeanPropertyRowMapper를 생성하여 RowMapper로 설정합니다. parameterValues(Map&lt;String, Object&gt; parameterValues) SQL 쿼리의 매개변수 값을 설정합니다. 매개변수 이름과 값을 매핑하는 맵을 전달합니다. pageSize(int pageSize) 한 페이지에서 읽을 아이템 수를 설정합니다. 페이지마다 일괄 처리될 아이템 수를 제어하는 데 사용됩니다. groupClause(String groupClause) SQL 쿼리의 GROUP BY 절을 설정합니다. selectClause(String selectClause) SQL 쿼리의 SELECT 절을 설정합니다. fromClause(String fromClause) SQL 쿼리의 FROM 절을 설정합니다. whereClause(String whereClause) SQL 쿼리의 WHERE 절을 설정합니다. sortKeys(Map&lt;String, Order&gt; sortKeys) SQL 쿼리의 정렬 키를 설정합니다. 맵으로 정렬 키와 정렬 방식(Order)을 지정합니다. queryProvider(PagingQueryProvider provider) PagingQueryProvider를 설정하여 SQL 쿼리를 제공합니다. JdbcPagingItemReader는 페이징 쿼리를 동적으로 생성하기 위해 이 QueryProvider를 사용합니다. build() 설정된 값들을 기반으로 JdbcPagingItemReader를 생성합니다. private PagingQueryProvider determineQueryProvider(DataSource dataSource) DataSource를 기반으로 PagingQueryProvider를 결정합니다. 데이터베이스 유형에 따라 적합한 QueryProvider를 선택하여 반환합니다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"},{"name":"Chunk","slug":"Spring/Spring-Batch/Step/Chunk","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/Chunk/"}],"tags":[]},{"title":"Spring Batch - ChunkProvider 와 ChunkProcessor","slug":"spring/spring-batch/chunk/spring-batch-ChunkProvider_ChunkProcessor","date":"2023-05-09T03:25:35.000Z","updated":"2024-02-26T15:27:55.184Z","comments":true,"path":"2023/05/09/spring/spring-batch/chunk/spring-batch-ChunkProvider_ChunkProcessor/","link":"","permalink":"https://ckck803.github.io/2023/05/09/spring/spring-batch/chunk/spring-batch-ChunkProvider_ChunkProcessor/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ChunkProviderChunkProvider는 ItemReader에서 읽어온 데이터를 Chunk 단위로 분할하여 ItemProcessor 및 ItemWriter에 전달하는 객체 ChunkProvider는 스텝을 실행할 때 Chunk&lt;I&gt; 객체를 만들고 Chunk의 크기를 지정합니다. 예를 들어, Chunk의 크기를 10으로 설정하면, ItemReader에서 10개의 데이터를 읽어와서 ItemProcessor 와 ItemWriter에 전달합니다. 이러한 과정을 Chunk 단위로 반복하여 모든 데이터를 처리합니다. ChunkProvider는 ItemReader에서 반환된 모든 데이터를 저장하지 않고, Chunk 단위로 처리하기 때문에 대용량 데이터를 처리하는 데 매우 효율적입니다. 이를 통해 메모리 사용량을 최소화하고, 처리 속도를 향상시킬 수 있습니다. Spring Batch에서는 기본적으로 SimpleChunkProvider를 제공합니다. SimpleChunkProvider는 Chunk의 크기를 지정하고, ItemReader에서 읽어온 데이터를 Chunk 단위로 분할하여 ItemProcessor 및 ItemWriter에 전달합니다. 또한, SimpleChunkProvider는 실패 시 롤백을 수행할 수 있도록 구성할 수 있습니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ChunkProviderChunkProvider는 ItemReader에서 읽어온 데이터를 Chunk 단위로 분할하여 ItemProcessor 및 ItemWriter에 전달하는 객체 ChunkProvider는 스텝을 실행할 때 Chunk&lt;I&gt; 객체를 만들고 Chunk의 크기를 지정합니다. 예를 들어, Chunk의 크기를 10으로 설정하면, ItemReader에서 10개의 데이터를 읽어와서 ItemProcessor 와 ItemWriter에 전달합니다. 이러한 과정을 Chunk 단위로 반복하여 모든 데이터를 처리합니다. ChunkProvider는 ItemReader에서 반환된 모든 데이터를 저장하지 않고, Chunk 단위로 처리하기 때문에 대용량 데이터를 처리하는 데 매우 효율적입니다. 이를 통해 메모리 사용량을 최소화하고, 처리 속도를 향상시킬 수 있습니다. Spring Batch에서는 기본적으로 SimpleChunkProvider를 제공합니다. SimpleChunkProvider는 Chunk의 크기를 지정하고, ItemReader에서 읽어온 데이터를 Chunk 단위로 분할하여 ItemProcessor 및 ItemWriter에 전달합니다. 또한, SimpleChunkProvider는 실패 시 롤백을 수행할 수 있도록 구성할 수 있습니다. ChunkProvider는 Chunk 기반 스텝의 핵심 역할을 수행하므로, ChunkProvider의 구현 방식은 대용량 데이터 처리 성능에 큰 영향을 미칩니다. 최적의 ChunkProvider 구현 방식을 선택하여 대용량 데이터 처리를 효율적으로 수행할 수 있습니다. ChunkProvider 인터페이스public interface ChunkProvider&lt;T&gt; &#123; Chunk&lt;T&gt; provide(StepContribution contribution) throws Exception; void postProcess(StepContribution contribution, Chunk&lt;T&gt; chunk);&#125; SimpleChunkProvider@Overridepublic Chunk&lt;I&gt; provide(final StepContribution contribution) throws Exception &#123; // Chunk 객체를 생성한다. final Chunk&lt;I&gt; inputs = new Chunk&lt;&gt;(); // Chunk Size 만큼 repeatOperations 를 이용해 read() 를 호출한다. repeatOperations.iterate(new RepeatCallback() &#123; @Override public RepeatStatus doInIteration(final RepeatContext context) throws Exception &#123; I item = null; Timer.Sample sample = Timer.start(Metrics.globalRegistry); String status = BatchMetrics.STATUS_SUCCESS; try &#123; // ItemReader 를 이용해 Item 을 하나씩 읽는다. item = read(contribution, inputs); &#125; catch (SkipOverflowException e) &#123; // read() tells us about an excess of skips by throwing an // exception status = BatchMetrics.STATUS_FAILURE; return RepeatStatus.FINISHED; &#125; finally &#123; stopTimer(sample, contribution.getStepExecution(), status); &#125; // 더 이상 읽을 Item 이 없을 경우 반복문 종료 및 전체 Chunk 프로세스 종료 if (item == null) &#123; inputs.setEnd(); return RepeatStatus.FINISHED; &#125; // Chunk 에 ItemReader 로부터 읽은 Item 을 Chunk Size 만큼 저장한다 inputs.add(item); contribution.incrementReadCount(); return RepeatStatus.CONTINUABLE; &#125; &#125;); return inputs;&#125; ChunkProcessorChunkProcessor 는 Chunk 단위로 ItemProcessor 를 사용해 Item 을 변형, 가공, 필터링하고 ItemWriter 를 사용해 Chunk 데이터를 저장 및 출력한 후 스텝의 실행 결과를 반환하는 역할을 수행합니다. Chunk&lt;O&gt; 객체를 만들고 ChunkProvider 로부터 전달 받은 Chunk&lt;I&gt; 의 Item 을 한 건씩 처리한 후에 Chunk&lt;O&gt; 에 저장합니다. ChunkProcessor 는 ChunkProvider 에서 전달받은 Chunk 를 이용하여 ItemProcessor 와 ItemWriter 를 실행하고, 스텝의 실행 결과를 반환하는 역할을 수행합니다. ChunkProcessor 는 각 Chunk에서 ItemProcessor 를 이용하여 데이터를 처리하고, 처리 결과를 ItemWriter 를 통해 출력합니다. 처리 결과는 Chunk 단위로 모아서 스텝의 실행 결과를 결정합니다. Spring Batch에서는 기본적으로 SimpleChunkProcessor 를 제공합니다. SimpleChunkProcessor 는 ChunkProvider 에서 Chunk 단위로 전달받은 데이터를 ItemProcessor 및 ItemWriter 에 전달하여 처리하고, 스텝의 실행 결과를 반환합니다. 또한, SimpleChunkProcessor 는 실패 시 롤백을 수행할 수 있도록 구성할 수 있습니다. ItemWriter 처리가 완료되면 Chunk 트랜잭션이 종료되고 Step 반복문에서 ChunkOrientedTasklet 이 새롭게 실행됩니다. ItemWriter 는 Chunk 사이즈만큼 데이터를 Commit 하기 때문에 Chunk 사이즈는 곧 Commit Interval 이 됩니다. ChunkProcessor는 대용량 데이터 처리 성능에 큰 영향을 미치므로, 최적의 ChunkProcessor 구현 방식을 선택하여 대용량 데이터 처리를 효율적으로 수행할 수 있습니다. public interface ChunkProcessor&lt;I&gt; &#123; void process(StepContribution contribution, Chunk&lt;I&gt; chunk) throws Exception;&#125; SimpleChunkProcessor@Overridepublic final void process(StepContribution contribution, Chunk&lt;I&gt; inputs) throws Exception &#123; // Allow temporary state to be stored in the user data field initializeUserData(inputs); // If there is no input we don&#x27;t have to do anything more if (isComplete(inputs)) &#123; return; &#125; // ItemProcessor 객체를 이용해 Item 을 처리한 후 Chunk&lt;O&gt; 로 반환한다. Chunk&lt;O&gt; outputs = transform(contribution, inputs); // ItemProcessor 객체를 이용해 Item 을 Filtering 된 Item 들을 저장한다. contribution.incrementFilterCount(getFilterCount(inputs, outputs)); // ItemWriter 객체를 이용해 Item 들을 저잫아거나 출력한다. write(contribution, inputs, getAdjustedOutputs(inputs, outputs));&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"},{"name":"Chunk","slug":"Spring/Spring-Batch/Step/Chunk","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/Chunk/"}],"tags":[]},{"title":"Spring Batch - ChunkOrientedTasklet","slug":"spring/spring-batch/chunk/spring-batch-ChunkOrientedTasklet","date":"2023-05-09T02:25:35.000Z","updated":"2024-02-26T15:27:51.161Z","comments":true,"path":"2023/05/09/spring/spring-batch/chunk/spring-batch-ChunkOrientedTasklet/","link":"","permalink":"https://ckck803.github.io/2023/05/09/spring/spring-batch/chunk/spring-batch-ChunkOrientedTasklet/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ChunkOrientedTasklet ChunkOrientedTasklet은 Tasklet 인터페이스를 구현체로 Chunk 지향 처리를 담당하는 도메인 객체 ChunkOrientedTasklet은 이 execute() 메서드 내에서 ItemReader, ItemProcessor 및 ItemWriter를 사용하여 Chunk 지향 처리를 수행합니다. TaskletStep 에 의해 반복적으로 실행되며 ChunkOrientedTasklet 이 실행될 때마다 매번 새로운 Transaction 이 생성되어 처리가 이뤄집니다. 예외가 발생할 경우 해당 Chunk 는 Rollback 되며 이전에 Commit 한 Chunk 는 완료된 상태가 유지됩니다. 내부적으로 ItemReader 를 핸들링하는 ChunkProvider 와 ItemProcessor, ItemWriter 를 핸들링하는 ChunkProcessor 타입의 구현체를 갖습니다. ChunkOrientedTasklet 흐름","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder ChunkOrientedTasklet ChunkOrientedTasklet은 Tasklet 인터페이스를 구현체로 Chunk 지향 처리를 담당하는 도메인 객체 ChunkOrientedTasklet은 이 execute() 메서드 내에서 ItemReader, ItemProcessor 및 ItemWriter를 사용하여 Chunk 지향 처리를 수행합니다. TaskletStep 에 의해 반복적으로 실행되며 ChunkOrientedTasklet 이 실행될 때마다 매번 새로운 Transaction 이 생성되어 처리가 이뤄집니다. 예외가 발생할 경우 해당 Chunk 는 Rollback 되며 이전에 Commit 한 Chunk 는 완료된 상태가 유지됩니다. 내부적으로 ItemReader 를 핸들링하는 ChunkProvider 와 ItemProcessor, ItemWriter 를 핸들링하는 ChunkProcessor 타입의 구현체를 갖습니다. ChunkOrientedTasklet 흐름TaskletStep 이 ChunkOrientedTasklet 객체의 execute 메소드를 호출하면 ChunkProvider 객체를 호출하게 됩니다. ChunkProvider 는 ItemReader 객체를 이용해 Item 들을 설정된 Chunk 사이즈만큼 반복해서 읽어온 후 ChunkOrientedTasklet 객체로 반환합니다. ChunkOrientedTasklet 객체는 ChunkProcessor 객체를 호출해 읽어온 Item 들을 처리합니다. ChunkProcessor 객체는 ItemProcessor 객체를 이용해 전달받은 Item 객체에 데이터 처리를 진행하고 ItemWriter 에 처리 결과를 전달합니다. ItemWriter 는 전달 받은 Item 들을 출력하거나 저장한 후 다시 ChunkProcessor 객체를 통해 Item 을 읽어오는 작업을 하게 된다. ChunkOrientedTasklet 은 이러한 반복적인 작업은 읽을 Item 이 없을때까지 Chunk 단위로 반복합니다. ChunkOrientedTasklet 소스코드... 생략// chunkProcessor 객체private final ChunkProcessor&lt;I&gt; chunkProcessor;// chunkProvider 객체private final ChunkProvider&lt;I&gt; chunkProvider;@Nullable@Overridepublic RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; @SuppressWarnings(&quot;unchecked&quot;) // Chunk 처리 중 예외가 발생해 재 시도를 할 경우 다시 데이터를 읽지 않고 버퍼에 담아 놓았던 데이터를 가져옵니다. Chunk&lt;I&gt; inputs = (Chunk&lt;I&gt;) chunkContext.getAttribute(INPUTS_KEY); if (inputs == null) &#123; // ChunkProvider 객체를 이용해 Item 을 Chunk Size 만큼 반복해서 읽은 다음 Chunk&lt;I&gt; 객체에 저장해 반환합니다. inputs = chunkProvider.provide(contribution); if (buffering) &#123; chunkContext.setAttribute(INPUTS_KEY, inputs); &#125; &#125; // ChunkProcessor 를 이용해 ChunkProvider 로 부터 읽은 Chunk&lt;I&gt; 의 아이템 개수만큼 데이터를 가공하고 저장합니다. chunkProcessor.process(contribution, inputs); chunkProvider.postProcess(contribution, inputs); // Allow a message coming back from the processor to say that we // are not done yet if (inputs.isBusy()) &#123; logger.debug(&quot;Inputs still busy&quot;); return RepeatStatus.CONTINUABLE; &#125; // Chunk 단위 입출력이 완료되면 버퍼에 저장한 Chunk 데이터를 삭제합니다. chunkContext.removeAttribute(INPUTS_KEY); chunkContext.setComplete(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Inputs not busy, ended: &quot; + inputs.isEnd()); &#125; // 읽을 Item 이 더 존재하는지 체크합니다. // 읽을 Item 이 더 있을 경우 Chunk 프로세스를 반복하고 // 읽을 Item 이 없을 경우 RepeatStatus.FINISHED 를 반환해 Chunk 프로세스를 종료합니다. return RepeatStatus.continueIf(!inputs.isEnd());&#125;... 생략 ChunkOrientedTasklet 장점ChunkOrientedTasklet은 Chunk 지향 처리에서 처리할 수 있는 모든 항목을 읽고 처리하고 나서야 다음 스텝으로 진행합니다. 따라서 ChunkOrientedTasklet은 대용량 데이터 세트를 처리하는 데 매우 유용합니다. 메모리 부족 문제를 방지하기 위해 ChunkOrientedTasklet은 항목을 조각 단위로 처리하며, 처리할 각 조각의 크기는 설정할 수 있습니다. Spring Batch에서 ChunkOrientedTasklet은 스텝 처리를 수행하는 방법 중 하나이며, 일괄 처리 작업을 조각 단위로 처리할 수 있도록 해줍니다. 이를 통해 대용량 데이터 세트를 처리할 때 메모리 부족 문제를 방지하고 처리 속도를 향상시킬 수 있습니다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"},{"name":"Chunk","slug":"Spring/Spring-Batch/Step/Chunk","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/Chunk/"}],"tags":[]},{"title":"Spring Batch - Chunk 기반 Step","slug":"spring/spring-batch/chunk/spring-batch-Chunk","date":"2023-05-09T01:25:35.000Z","updated":"2024-02-26T15:27:47.013Z","comments":true,"path":"2023/05/09/spring/spring-batch/chunk/spring-batch-Chunk/","link":"","permalink":"https://ckck803.github.io/2023/05/09/spring/spring-batch/chunk/spring-batch-Chunk/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Chunk Chunk 란 여러개의 아이템을 묶은 하나의 덩어리, 블록을 의미합니다. 한번에 하나씩 아이템 입력을 받아 Chunk 단위의 덩어리로 만든 후 Chunk 단위로 트랜잭션을 처리합니다. 즉, Chunk 단위의 Commit 과 Rollback 이 이루어지게 됩니다. 일반적으로 대용량의 데이터를 한번에 처리하는 것이 아닌 Chunk 단위로 쪼개어서 더 이상 처리할 데이터가 없을 때까지 반복해서 입출력하는데 사용됩니다. Chunk는 대용량 데이터를 처리하는 데 사용되는 방법 중 하나입니다. Chunk 지향 처리는 일괄 처리 작업을 조각 단위로 분할하여 처리하며, 각 조각은 스텝 내에서 개별적으로 처리됩니다. 예를 들어, 1000개의 항목이있는 데이터 세트가 있다면, Chunk 처리를 사용하여 이 데이터를 100개씩 10 조각으로 분할 할 수 있습니다. Chunk는 큰 데이터 세트를 처리 할 때 매우 유용합니다. 데이터를 조각으로 나누어 처리하므로 메모리 부족 문제가 발생하지 않습니다. 대신 Chunk는 데이터를 작은 묶음으로 나누어 처리하고 일부 묶음이 완료되면 다음 묶음으로 이동합니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Chunk Chunk 란 여러개의 아이템을 묶은 하나의 덩어리, 블록을 의미합니다. 한번에 하나씩 아이템 입력을 받아 Chunk 단위의 덩어리로 만든 후 Chunk 단위로 트랜잭션을 처리합니다. 즉, Chunk 단위의 Commit 과 Rollback 이 이루어지게 됩니다. 일반적으로 대용량의 데이터를 한번에 처리하는 것이 아닌 Chunk 단위로 쪼개어서 더 이상 처리할 데이터가 없을 때까지 반복해서 입출력하는데 사용됩니다. Chunk는 대용량 데이터를 처리하는 데 사용되는 방법 중 하나입니다. Chunk 지향 처리는 일괄 처리 작업을 조각 단위로 분할하여 처리하며, 각 조각은 스텝 내에서 개별적으로 처리됩니다. 예를 들어, 1000개의 항목이있는 데이터 세트가 있다면, Chunk 처리를 사용하여 이 데이터를 100개씩 10 조각으로 분할 할 수 있습니다. Chunk는 큰 데이터 세트를 처리 할 때 매우 유용합니다. 데이터를 조각으로 나누어 처리하므로 메모리 부족 문제가 발생하지 않습니다. 대신 Chunk는 데이터를 작은 묶음으로 나누어 처리하고 일부 묶음이 완료되면 다음 묶음으로 이동합니다. Spring Batch에서 Chunk는 ItemReader, ItemProcessor 및 ItemWriter로 구성됩니다. ItemReader는 데이터를 읽고 ItemProcessor는 데이터를 가공하고 ItemWriter는 결과를 저장합니다. Chunk 지향 처리를 사용하면 각 스텝에서 처리 할 데이터 레코드의 수를 지정할 수 있으므로 처리 속도를 향상시킬 수 있습니다. Chunk 입력기와 출력기입력기를 통해 Item 을 하나하나씩 읽어들여 Chunk 에 저장한 후 처리가 완료 됐을때 Item 들을 한번에 출력기로 내보낸다. Chunk&lt;I&gt; 와 Chunk&lt;O&gt;Chunk&lt;I&gt; 는 ItemReader 로 읽은 하나의 아이템을 Chunk 에서 정한 개수만큼 반복해서 저장하는 타입입니다. Chunk&lt;O&gt; 는 ItemReader 로부터 전달받은 Chunk&lt;I&gt; 를 참조해서 ItemProcessor 에서 적절하게 가공 및 핕러링한 후 ItemWriter 에 전달하는 타입입니다. Chunk 아키텍처ItemReader 가 Source 로부터 Item 을 읽은 후 Chunk&lt;I&gt; 에 저장합니다. 설정된 Chunk Size 만큼 Item 을 읽었을 후에는 ItemProcessor 에 Chunk&lt;I&gt; 에 저장된 Item 들을 inputs 객체로 전달합니다. ItemProcessor 는 Iterator 를 이용해 전달받은 inputs 에 저장된 Item 들에 대한 데이터 처리를 한 후 Chunk&lt;O&gt; 에 처리 결과를 전달합니다. Chunk&lt;O&gt; 은 ItemWriter 에 처리 결과를 전달합니다. ItemWriter 객체는 데이터를 쓰거나 저장하는 역할을 진행합니다. Chunk 예시 코드@Beanpublic Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .&lt;String, String&gt;chunk(2) // ItemReader .reader(new ListItemReader&lt;&gt;(Arrays.asList(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;,&quot;item4&quot;, &quot;item5&quot;, &quot;item6&quot;))) // ItemProcessor .processor(new ItemProcessor&lt;String, String&gt;() &#123; @Override public String process(String item) throws Exception &#123; Thread.sleep(300); System.out.println(item); return &quot;my_&quot; + item; &#125; &#125;) // ItemWriter .writer(new ItemWriter&lt;String&gt;() &#123; @Override public void write(List&lt;? extends String&gt; items) throws Exception &#123; Thread.sleep(1000); System.out.println(items); &#125; &#125;) .build();&#125; Lambda 로 표현@Beanpublic Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .&lt;String, String&gt;chunk(2) .reader(new ListItemReader&lt;&gt;(Arrays.asList(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;,&quot;item4&quot;, &quot;item5&quot;, &quot;item6&quot;))) .processor((ItemProcessor&lt;String, String&gt;) item -&gt; &#123; Thread.sleep(300); System.out.println(item); return &quot;my_&quot; + item; &#125;) .writer(items -&gt; &#123; Thread.sleep(1000); System.out.println(items); &#125;) .build();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"},{"name":"Chunk","slug":"Spring/Spring-Batch/Step/Chunk","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/Chunk/"}],"tags":[]},{"title":"Circuit Breaker","slug":"k8s/istio/circuit-breaker","date":"2023-05-08T03:31:46.000Z","updated":"2024-02-18T16:19:54.538Z","comments":true,"path":"2023/05/08/k8s/istio/circuit-breaker/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/istio/circuit-breaker/","excerpt":"Circuit Breaker분산 시스템에서 Circuit Breaker 는 일종의 예외 처리 메커니즘으로, 서비스 호출의 실패, 지연 등을 모니터링하고, 이를 감지하면 해당 서비스의 호출을 일시 중단시키는 역할을 합니다. 분산 시스템에서는 여러 대의 서버로 구성되어 있기 때문에, 서비스 간의 호출은 시스템의 다른 부분과 독립적으로 처리됩니다. 따라서, 서비스 호출 시에 실패가 발생하면 이를 처리하는 데 시간이 걸리고, 이를 무한정 대기하게 된다면 전체 시스템의 성능에 악영향을 미칠 수 있습니다. 이 때, Circuit Breaker는 이러한 지연을 방지하기 위해 호출을 일시 중단시킵니다. 이후, 일정 시간 동안 호출을 차단한 뒤, 정상적으로 작동하면 다시 호출을 허용합니다. Circuit Breaker 는 분산 시스템에서 안정성을 보장하기 위한 매우 중요한 요소 중 하나입니다. Circuit Breaker 가 없다면, 서비스 호출 실패와 지연에 대한 처리가 지연되어 시스템 전체의 성능에 영향을 미칠 가능성이 높습니다. Circuit Breaker 는 분산 시스템에서 발생할 수 있는 여러 가지 문제를 빠르게 감지하고, 시스템 전체의 안정성을 유지할 수 있도록 도와줍니다.","text":"Circuit Breaker분산 시스템에서 Circuit Breaker 는 일종의 예외 처리 메커니즘으로, 서비스 호출의 실패, 지연 등을 모니터링하고, 이를 감지하면 해당 서비스의 호출을 일시 중단시키는 역할을 합니다. 분산 시스템에서는 여러 대의 서버로 구성되어 있기 때문에, 서비스 간의 호출은 시스템의 다른 부분과 독립적으로 처리됩니다. 따라서, 서비스 호출 시에 실패가 발생하면 이를 처리하는 데 시간이 걸리고, 이를 무한정 대기하게 된다면 전체 시스템의 성능에 악영향을 미칠 수 있습니다. 이 때, Circuit Breaker는 이러한 지연을 방지하기 위해 호출을 일시 중단시킵니다. 이후, 일정 시간 동안 호출을 차단한 뒤, 정상적으로 작동하면 다시 호출을 허용합니다. Circuit Breaker 는 분산 시스템에서 안정성을 보장하기 위한 매우 중요한 요소 중 하나입니다. Circuit Breaker 가 없다면, 서비스 호출 실패와 지연에 대한 처리가 지연되어 시스템 전체의 성능에 영향을 미칠 가능성이 높습니다. Circuit Breaker 는 분산 시스템에서 발생할 수 있는 여러 가지 문제를 빠르게 감지하고, 시스템 전체의 안정성을 유지할 수 있도록 도와줍니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Istio","slug":"Kubernetes/Istio","permalink":"https://ckck803.github.io/categories/Kubernetes/Istio/"}],"tags":[]},{"title":"Istio - DestinationRule","slug":"k8s/istio/istio-destinationrule","date":"2023-05-08T03:31:46.000Z","updated":"2024-02-18T16:19:54.538Z","comments":true,"path":"2023/05/08/k8s/istio/istio-destinationrule/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/istio/istio-destinationrule/","excerpt":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 참고 https://istio.io/latest/docs/ops/deployment/architecture/ https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/ https://happycloud-lee.tistory.com/104 DestinationRule DestinationRule은 서비스 요청이 특정 서비스 버전 또는 인스턴스로 라우팅되도록 지정하는 규칙을 정의하는 리소스 DestinationRule은 Istio 서비스 메시에서 트래픽을 관리하는 중요한 요소 중 하나입니다. 이를 사용하여 서비스를 라우팅할 때 사용할 서비스 버전, 인스턴스 및 연결 방식을 지정할 수 있습니다. DestinationRule은 Istio의 다른 기능과 통합됩니다. 예를 들어, VirtualService와 함께 사용하여 특정 경로 및 트래픽 유형에 대한 규칙을 지정할 수 있습니다. 또한, 서비스 인스턴스의 로드 밸런싱 및 서킷 브레이커와 같은 기능도 DestinationRule을 사용하여 정의할 수 있습니다. 서비스 이름: 규칙을 적용할 대상 서비스의 이름을 지정합니다. 서비스 버전: 규칙을 적용할 대상 서비스의 버전을 지정합니다. 서비스 서브셋: 대상 서비스의 서브셋을 지정하여 트래픽을 특정 서브셋으로 라우팅할 수 있습니다. 연결 풀: 서비스 요청에 사용될 연결 풀을 정의합니다. 예를 들어, 서비스 인스턴스의 최대 연결 수 및 연결 유지 시간 등을 지정할 수 있습니다. 트래픽 정책: 대상 서비스의 트래픽을 제어하는 정책을 정의합니다. 예를 들어, 연결 시간 초과 및 연결 오류를 처리하는 방법 등을 정의할 수 있습니다.","text":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 참고 https://istio.io/latest/docs/ops/deployment/architecture/ https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/ https://happycloud-lee.tistory.com/104 DestinationRule DestinationRule은 서비스 요청이 특정 서비스 버전 또는 인스턴스로 라우팅되도록 지정하는 규칙을 정의하는 리소스 DestinationRule은 Istio 서비스 메시에서 트래픽을 관리하는 중요한 요소 중 하나입니다. 이를 사용하여 서비스를 라우팅할 때 사용할 서비스 버전, 인스턴스 및 연결 방식을 지정할 수 있습니다. DestinationRule은 Istio의 다른 기능과 통합됩니다. 예를 들어, VirtualService와 함께 사용하여 특정 경로 및 트래픽 유형에 대한 규칙을 지정할 수 있습니다. 또한, 서비스 인스턴스의 로드 밸런싱 및 서킷 브레이커와 같은 기능도 DestinationRule을 사용하여 정의할 수 있습니다. 서비스 이름: 규칙을 적용할 대상 서비스의 이름을 지정합니다. 서비스 버전: 규칙을 적용할 대상 서비스의 버전을 지정합니다. 서비스 서브셋: 대상 서비스의 서브셋을 지정하여 트래픽을 특정 서브셋으로 라우팅할 수 있습니다. 연결 풀: 서비스 요청에 사용될 연결 풀을 정의합니다. 예를 들어, 서비스 인스턴스의 최대 연결 수 및 연결 유지 시간 등을 지정할 수 있습니다. 트래픽 정책: 대상 서비스의 트래픽을 제어하는 정책을 정의합니다. 예를 들어, 연결 시간 초과 및 연결 오류를 처리하는 방법 등을 정의할 수 있습니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Istio","slug":"Kubernetes/Istio","permalink":"https://ckck803.github.io/categories/Kubernetes/Istio/"}],"tags":[]},{"title":"Istio - Locality Load Balancing (지역 로드 밸런싱)","slug":"k8s/istio/istio-locality_load_balacing","date":"2023-05-08T03:31:46.000Z","updated":"2024-02-18T16:19:54.539Z","comments":true,"path":"2023/05/08/k8s/istio/istio-locality_load_balacing/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/istio/istio-locality_load_balacing/","excerpt":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 참고 https://istio.io/latest/docs/ops/deployment/architecture/ https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/ https://happycloud-lee.tistory.com/104 http://itnp.kr/post/istio-circuit-break https://istiobyexample.dev/locality-load-balancing/ Istio - Locality Load Balancing Istio 의 Locality Load Balance 는 서비스 요청을 지역적으로 분산시키는 기능을 제공합니다. Locality Load Balance는 서비스 요청이 클러스터 내에서 발생할 때 해당 요청이 가장 가까운 지역의 서비스 인스턴스에 배정되도록 보장합니다. 이를 통해 클라이언트와 서비스 인스턴스 사이의 대기 시간을 줄이고, 네트워크 대역폭을 절약하며, 네트워크 병목 현상을 방지할 수 있습니다. Locality Load Balance는 Istio의 Envoy 프록시에서 구현됩니다. Envoy는 클러스터 내의 모든 서비스 인스턴스에 대한 위치 정보를 유지 관리하며, 클러스터의 지리적 분포를 파악하여 요청을 지역적으로 분산시킵니다. Locality Load Balance는 또한 Istio의 트래픽 관리 기능과 통합됩니다. Istio는 트래픽 관리 규칙을 정의하여 특정 서비스 인스턴스가 특정 지역에서만 처리되도록 할 수 있습니다. 이를 통해 서비스의 가용성을 높이고, 서비스 인스턴스 간의 부하를 균형있게 분산시킬 수 있습니다.","text":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 참고 https://istio.io/latest/docs/ops/deployment/architecture/ https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/ https://happycloud-lee.tistory.com/104 http://itnp.kr/post/istio-circuit-break https://istiobyexample.dev/locality-load-balancing/ Istio - Locality Load Balancing Istio 의 Locality Load Balance 는 서비스 요청을 지역적으로 분산시키는 기능을 제공합니다. Locality Load Balance는 서비스 요청이 클러스터 내에서 발생할 때 해당 요청이 가장 가까운 지역의 서비스 인스턴스에 배정되도록 보장합니다. 이를 통해 클라이언트와 서비스 인스턴스 사이의 대기 시간을 줄이고, 네트워크 대역폭을 절약하며, 네트워크 병목 현상을 방지할 수 있습니다. Locality Load Balance는 Istio의 Envoy 프록시에서 구현됩니다. Envoy는 클러스터 내의 모든 서비스 인스턴스에 대한 위치 정보를 유지 관리하며, 클러스터의 지리적 분포를 파악하여 요청을 지역적으로 분산시킵니다. Locality Load Balance는 또한 Istio의 트래픽 관리 기능과 통합됩니다. Istio는 트래픽 관리 규칙을 정의하여 특정 서비스 인스턴스가 특정 지역에서만 처리되도록 할 수 있습니다. 이를 통해 서비스의 가용성을 높이고, 서비스 인스턴스 간의 부하를 균형있게 분산시킬 수 있습니다. 모든 AZ 로 istiod 확장apiVersion: apps/v1kind: Deploymentmetadata: name: istiod namespace: istio-systemspec: template: spec: topologySpreadConstraints: - maxSkew: 1 topologyKey: topology.kubernetes.io/zone whenUnsatisfiable: ScheduleAnyway labelSelector: matchLabels: app: istiod trafficPolicy 설정Envoy Proxy에서 Locality Load Balancing을 사용하도록 설정합니다. 이를 위해서는 Istio의 서비스 메쉬 구성에서 trafficPolicy 를 설정합니다. 예를 들어, 다음과 같이 trafficPolicy 를 설정할 수 있습니다: my-service는 사용자가 지역별로 분류하려는 대상 서비스 이름입니다. apiVersion: networking.istio.io/v1alpha3kind: DestinationRulemetadata: name: my-servicespec: host: my-service trafficPolicy: loadBalancer: localityLbSetting: enabled: true 필요한 경우 Envoy Proxy에서 사용할 지역 정보를 정의합니다. 이를 위해 Istio에서는 ServiceEntry를 사용할 수 있습니다. 예를 들어, 다음과 같이 ServiceEntry를 정의할 수 있습니다: apiVersion: networking.istio.io/v1alpha3kind: ServiceEntrymetadata: name: us-eastspec: hosts: - us-east.example.com ports: - number: 80 name: http protocol: HTTP location: MESH_INTERNAL resolution: DNS endpoints: - address: 10.1.2.3 Istio를 사용하여 EKS 클러스터에서 AZ 간 데이터 전송 비용 해결 https://aws.amazon.com/ko/blogs/containers/addressing-latency-and-data-transfer-costs-on-eks-using-istio/ https://istio.io/latest/docs/reference/config/networking/destination-rule/ 토폴로지 인식 라우팅이 기본적으로 지원되므로 Istio를 사용하여 동일한 가용 영역 내에서 포드 또는 서비스로 트래픽을 라우팅할 수 있습니다. cat &lt;&lt;EOF&gt;&gt; destinationrule.yamlapiVersion: networking.istio.io/v1alpha3kind: DestinationRulemetadata: name: zip-lookup-service-local # 적용을 위한 namespace namespace: octank-travel-nsspec: host: zip-lookup-service-local trafficPolicy: outlierDetection: consecutiveErrors: 7 interval: 30s baseEjectionTime: 30sEOF skcc-dev-mbc-cms-aurora : 1 인스턴스 - db.t3.medium(2 vCPUs 4GB, Storage불명)skcc-uat-vitality-cms-aurora : 2 인스턴스 - db.t3.medium(2 vCPUs 4GB, Storage불명)skcc-prd-vitality-cms-aurora : 2 인스턴스 - db.r5.xlarge(2vCPU, 32GB, Storage불명) DB에서 다음과 같이 암호화&#x2F;복호화 하고 있습니다.AES-128 비트 인코딩&#x2F;디코딩 이용하는거 같네요. 복호화 AES_DECRYPT(unhex(암호화된값),‘암호화 키값’)암호화 hex(AES_ENCRYPT(암호화할값,‘암호화 키값’) CMS DEV&#x2F;UAT RDS: db.t3.medium –&gt; 2vCPU, 4GB, Storage불명, AWS Aurora MySQL(5.7.mysql_aurora.2.07.7)CMS PRD RDS: db.r5.xlarge –&gt; 2vCPU, 32GB, Storage불명, AWS Aurora MySQL(5.7.mysql_aurora.2.07.7)암호화: AES-256","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Istio","slug":"Kubernetes/Istio","permalink":"https://ckck803.github.io/categories/Kubernetes/Istio/"}],"tags":[]},{"title":"Istio - Sidecar Injection","slug":"k8s/istio/istio-injection","date":"2023-05-08T01:31:46.000Z","updated":"2024-02-18T16:19:54.538Z","comments":true,"path":"2023/05/08/k8s/istio/istio-injection/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/istio/istio-injection/","excerpt":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 참고 https://istio.io/latest/docs/ops/deployment/architecture/ https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/ https://happycloud-lee.tistory.com/104 Istio Sidecar injectionIstio는 Pod 안에 Envoy proxy container 를 Sidecar 패턴으로 생성하여 Service Mesh (discovery, connect, monitor) 를 합니다. Pod안에 Proxy container를 삽입하는것을 Sidecar Injection 이라고 부릅니다. Istio 에서 Sidecar Injection 은 Kubernetes 의 MutatingAdmissionWebhook 을 사용하여 구현됩니다. 이것은 Kubernetes의 API Server에 대한 요청 처리 중에 사용되며, 새로운 Pod가 생성될 때 Istio가 Sidecar Proxy 컨테이너를 자동으로 추가하는 것을 가능하게 합니다. Istio가 Sidecar를 주입하는 방식은 크게 두 가지 방법이 있습니다. 첫 번째는 자동 주입 방식으로, 이는 기존의 Kubernetes 오브젝트에 Istio의 Sidecar Proxy를 자동으로 추가합니다. 이를 위해서는 Istio의 설치 시 Kubernetes 리소스를 수정해야 합니다. 두 번째 방식은 수동 주입 방식으로, 이는 기존의 Kubernetes 오브젝트에 Istio의 Sidecar Proxy를 수동으로 추가해야 합니다. Sidecar 자동 주입 방식","text":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 참고 https://istio.io/latest/docs/ops/deployment/architecture/ https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/ https://happycloud-lee.tistory.com/104 Istio Sidecar injectionIstio는 Pod 안에 Envoy proxy container 를 Sidecar 패턴으로 생성하여 Service Mesh (discovery, connect, monitor) 를 합니다. Pod안에 Proxy container를 삽입하는것을 Sidecar Injection 이라고 부릅니다. Istio 에서 Sidecar Injection 은 Kubernetes 의 MutatingAdmissionWebhook 을 사용하여 구현됩니다. 이것은 Kubernetes의 API Server에 대한 요청 처리 중에 사용되며, 새로운 Pod가 생성될 때 Istio가 Sidecar Proxy 컨테이너를 자동으로 추가하는 것을 가능하게 합니다. Istio가 Sidecar를 주입하는 방식은 크게 두 가지 방법이 있습니다. 첫 번째는 자동 주입 방식으로, 이는 기존의 Kubernetes 오브젝트에 Istio의 Sidecar Proxy를 자동으로 추가합니다. 이를 위해서는 Istio의 설치 시 Kubernetes 리소스를 수정해야 합니다. 두 번째 방식은 수동 주입 방식으로, 이는 기존의 Kubernetes 오브젝트에 Istio의 Sidecar Proxy를 수동으로 추가해야 합니다. Sidecar 자동 주입 방식kubectl label ns &lt;namespace&gt; istio-injection=enabled Envoy 프록시 생성 확인생성된 Pod 내에서 istio-proxy Container 가 생성된 것을 확인할 수 있다. Containers: istio-proxy: Container ID: containerd://cfcaaef4b26c5dc0083b88e3e4e2464c5b2fb0e2d9d9288a7891d66c577db127 Image: docker.io/istio/proxyv2:1.14.1 Image ID: docker.io/istio/proxyv2@sha256:df69c1a7af7c0113424a48f5075ac6d0894123ec926fdb315e849b4f04e39616 Port: 15090/TCP Host Port: 0/TCP Sidecar 자동 주입 방식 제거kubectl label ns &lt;namespace&gt; istio-injection- kubectl get mutatingwebhookconfiguration -o yaml NAME WEBHOOKS AGEistio-sidecar-injector 4 313d","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Istio","slug":"Kubernetes/Istio","permalink":"https://ckck803.github.io/categories/Kubernetes/Istio/"}],"tags":[]},{"title":"Istio - istioctl","slug":"k8s/istio/istio-istioctl","date":"2023-05-07T23:31:46.000Z","updated":"2024-02-18T16:19:54.538Z","comments":true,"path":"2023/05/08/k8s/istio/istio-istioctl/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/istio/istio-istioctl/","excerpt":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Istio - istioctl Istio 란? 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ Istioctl 설치brew install istioctl Istio Profile 확인istioctl profile list 특정 Profile 설치","text":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Istio - istioctl Istio 란? 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ Istioctl 설치brew install istioctl Istio Profile 확인istioctl profile list 특정 Profile 설치istioctl install --set profile=demo Profile 제거istioctl uninstall --purge Proxy Config 확인istioctl proxy-status Proxy 상태 확인istioctl ps cluster 정보istioctl proxy-config clusters &lt;pod 이름&gt; -n &lt;namespace&gt; endpoints 정보istioctl proxy-config endpoints &lt;pod 이름&gt; -n &lt;namespace&gt; istioctl proxy-config endpoints &lt;pod 이름&gt; -n &lt;namespace&gt; --cluster &lt;cluster 정보&gt; -o yaml hostStatuses:... 생략 locality: region: ap-northeast-2 zone: ap-northeast-2a... 생략 locality: region: ap-northeast-2 zone: ap-northeast-2c listener 정보istioctl proxy-config endpoints activity-5c6cfc9986-t2snx route 정보istioctl proxy-config route","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Istio","slug":"Kubernetes/Istio","permalink":"https://ckck803.github.io/categories/Kubernetes/Istio/"}],"tags":[]},{"title":"Spring Batch - 24. FlowJob","slug":"spring/spring-batch/flow/spring-batch-24-FlowJob","date":"2023-05-07T23:25:35.000Z","updated":"2024-02-26T15:28:21.913Z","comments":true,"path":"2023/05/08/spring/spring-batch/flow/spring-batch-24-FlowJob/","link":"","permalink":"https://ckck803.github.io/2023/05/08/spring/spring-batch/flow/spring-batch-24-FlowJob/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/step/spring-batch-23-JobStep Post not found: spring/spring-batch/step/spring-batch-22-Tasklet Post not found: spring/spring-batch/step/spring-batch-21-TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing FlowJobFlowJob은 일련의 스텝으로 구성됩니다. 각 스텝은 Tasklet 또는 Chunk 지향 스텝으로 구성될 수 있습니다. Tasklet은 일련의 작업을 수행하는 데 사용되며, Chunk 지향 스텝은 대량의 데이터를 처리할 때 사용됩니다. FlowJob은 각 스텝이 성공적으로 완료되면 다음 스텝으로 이동하도록 작동합니다. 각 스텝은 성공, 실패 또는 종료와 같은 결과를 반환합니다. 이 결과를 기반으로 FlowJob은 다음 스텝으로 이동하거나 작업을 중지할 수 있습니다. FlowJob은 각 스텝의 결과에 따라 다른 스텝으로 이동하거나 작업을 중지하도록 구성할 수 있습니다. 이를 통해 Spring Batch 사용자는 FlowJob을 사용하여 유연하고 복잡한 Batch 작업을 쉽게 구현할 수 있습니다. 또한, FlowJob은 분기와 조건 분기를 지원하여 작업 흐름을 더욱 세밀하게 제어할 수 있습니다. 예를 들어, 분기를 사용하여 성공 또는 실패에 따라 다른 작업을 실행하거나, 조건 분기를 사용하여 입력 데이터의 특성에 따라 다른 작업을 실행할 수 있습니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/step/spring-batch-23-JobStep Post not found: spring/spring-batch/step/spring-batch-22-Tasklet Post not found: spring/spring-batch/step/spring-batch-21-TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing FlowJobFlowJob은 일련의 스텝으로 구성됩니다. 각 스텝은 Tasklet 또는 Chunk 지향 스텝으로 구성될 수 있습니다. Tasklet은 일련의 작업을 수행하는 데 사용되며, Chunk 지향 스텝은 대량의 데이터를 처리할 때 사용됩니다. FlowJob은 각 스텝이 성공적으로 완료되면 다음 스텝으로 이동하도록 작동합니다. 각 스텝은 성공, 실패 또는 종료와 같은 결과를 반환합니다. 이 결과를 기반으로 FlowJob은 다음 스텝으로 이동하거나 작업을 중지할 수 있습니다. FlowJob은 각 스텝의 결과에 따라 다른 스텝으로 이동하거나 작업을 중지하도록 구성할 수 있습니다. 이를 통해 Spring Batch 사용자는 FlowJob을 사용하여 유연하고 복잡한 Batch 작업을 쉽게 구현할 수 있습니다. 또한, FlowJob은 분기와 조건 분기를 지원하여 작업 흐름을 더욱 세밀하게 제어할 수 있습니다. 예를 들어, 분기를 사용하여 성공 또는 실패에 따라 다른 작업을 실행하거나, 조건 분기를 사용하여 입력 데이터의 특성에 따라 다른 작업을 실행할 수 있습니다. FlowJobBuilderpublic class FlowJobBuilder extends JobBuilderHelper&lt;FlowJobBuilder&gt; &#123; private Flow flow; public FlowJobBuilder(JobBuilderHelper&lt;?&gt; parent) &#123; super(parent); &#125; public JobFlowBuilder start(Flow flow) &#123; return new JobFlowBuilder(this, flow); &#125; public JobFlowBuilder start(Step step) &#123; return new JobFlowBuilder(this, step); &#125; protected FlowJobBuilder flow(Flow flow) &#123; this.flow = flow; return this; &#125; public Job build() &#123; FlowJob job = new FlowJob(); job.setName(getName()); job.setFlow(flow); super.enhance(job); try &#123; job.afterPropertiesSet(); &#125; catch (Exception e) &#123; throw new StepBuilderException(e); &#125; return job; &#125;&#125; public class JobFlowBuilder extends FlowBuilder&lt;FlowJobBuilder&gt; &#123; private FlowJobBuilder parent; public JobFlowBuilder(FlowJobBuilder parent) &#123; super(parent.getName()); this.parent = parent; &#125; public JobFlowBuilder(FlowJobBuilder parent, Step step) &#123; super(parent.getName()); this.parent = parent; start(step); &#125; public JobFlowBuilder(FlowJobBuilder parent, JobExecutionDecider decider) &#123; super(parent.getName()); this.parent = parent; start(decider); &#125; public JobFlowBuilder(FlowJobBuilder parent, Flow flow) &#123; super(parent.getName()); this.parent = parent; start(flow); &#125; @Override public FlowJobBuilder build() &#123; Flow flow = flow(); if(flow instanceof InitializingBean) &#123; try &#123; ((InitializingBean) flow).afterPropertiesSet(); &#125; catch (Exception e) &#123; throw new FlowBuilderException(e); &#125; &#125; parent.flow(flow); return parent; &#125;&#125; FlowBuilder @Beanpublic Job batchJob() &#123; return jobBuilderFactory.get(&quot;batchJob&quot;) .start(step1()) // step1 이 COMPELETED 상태일 경우 step2 를 실행한다. .on(&quot;COMPLETED&quot;).to(step2()) .from(step1()) // step1 이 FAILED 상태일 경우 step2 를 실행한다. .on(&quot;FAILED&quot;).to(step3()) .end() .build();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"}],"tags":[]},{"title":"CNCF (Cloud Native Computing Foundation)","slug":"k8s/cncf","date":"2023-05-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.536Z","comments":true,"path":"2023/05/08/k8s/cncf/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/cncf/","excerpt":"공식 홈페이지 https://www.cncf.io/ CNCF 란CNCF(Cloud Native Computing Foundation)는 Linux 재단( Linux Foundation)의 하위 조직으로, 클라우드 네이티브 컴퓨팅을 지원하고 발전시키는 오픈소스 프로젝트의 생태계를 관리하고 유지보수하는 비영리 단체입니다. CNCF는 클라우드 네이티브 애플리케이션을 위한 오픈소스 기술의 개발, 유지보수, 보급을 촉진하고 있으며, 이를 위해 Kubernetes, Prometheus, Envoy, CoreDNS, containerd 등 다양한 프로젝트를 관리하고 있습니다. 이러한 기술들은 모두 클라우드 네이티브 애플리케이션의 구축, 배포, 운영을 위해 필요한 기반 기술을 제공하고 있습니다. CNCF는 이러한 오픈소스 프로젝트의 개발, 운영, 확장을 지원하며, 이를 통해 클라우드 네이티브 컴퓨팅 생태계를 확장하고 발전시키고 있습니다. 또한 CNCF는 이러한 프로젝트를 사용하는 사용자 및 개발자 커뮤니티를 지원하고, 교육 및 인증 등 다양한 활동을 통해 클라우드 네이티브 기술의 활용과 보급을 촉진하고 있습니다.","text":"공식 홈페이지 https://www.cncf.io/ CNCF 란CNCF(Cloud Native Computing Foundation)는 Linux 재단( Linux Foundation)의 하위 조직으로, 클라우드 네이티브 컴퓨팅을 지원하고 발전시키는 오픈소스 프로젝트의 생태계를 관리하고 유지보수하는 비영리 단체입니다. CNCF는 클라우드 네이티브 애플리케이션을 위한 오픈소스 기술의 개발, 유지보수, 보급을 촉진하고 있으며, 이를 위해 Kubernetes, Prometheus, Envoy, CoreDNS, containerd 등 다양한 프로젝트를 관리하고 있습니다. 이러한 기술들은 모두 클라우드 네이티브 애플리케이션의 구축, 배포, 운영을 위해 필요한 기반 기술을 제공하고 있습니다. CNCF는 이러한 오픈소스 프로젝트의 개발, 운영, 확장을 지원하며, 이를 통해 클라우드 네이티브 컴퓨팅 생태계를 확장하고 발전시키고 있습니다. 또한 CNCF는 이러한 프로젝트를 사용하는 사용자 및 개발자 커뮤니티를 지원하고, 교육 및 인증 등 다양한 활동을 통해 클라우드 네이티브 기술의 활용과 보급을 촉진하고 있습니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Helm","slug":"Kubernetes/Helm","permalink":"https://ckck803.github.io/categories/Kubernetes/Helm/"}],"tags":[]},{"title":"Helm","slug":"k8s/helm/helm","date":"2023-05-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.537Z","comments":true,"path":"2023/05/08/k8s/helm/helm/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/helm/helm/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ Helm 이란Helm은 Kubernetes 애플리케이션 배포 관리 도구입니다. Helm은 패키지화된 Kubernetes 리소스를 쉽게 배포하고 관리할 수 있도록 해주는 툴입니다. Helm은 chart 라는 것을 사용하여 Kubernetes 리소스를 패키지화합니다. Chart는 애플리케이션의 구성과 릴리즈 정보를 포함하고 있습니다. Chart를 사용하면 애플리케이션을 배포하고 업데이트하는 프로세스를 쉽게 자동화할 수 있습니다. Helm은 또한 Helm Repositories 라는 것을 제공합니다. 이는 Helm Charts를 저장하고 공유할 수 있는 저장소입니다. 공개 또는 비공개 저장소를 사용하여 애플리케이션을 더 쉽게 배포하고 공유할 수 있습니다. Helm은 Kubernetes의 많은 기능을 지원합니다. 예를 들어, Helm은 릴리즈를 롤백하는 기능을 제공하며, 릴리즈 히스토리를 추적할 수 있습니다. 또한 Helm은 템플릿을 사용하여 리소스를 더 쉽게 생성할 수 있습니다.","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ Helm 이란Helm은 Kubernetes 애플리케이션 배포 관리 도구입니다. Helm은 패키지화된 Kubernetes 리소스를 쉽게 배포하고 관리할 수 있도록 해주는 툴입니다. Helm은 chart 라는 것을 사용하여 Kubernetes 리소스를 패키지화합니다. Chart는 애플리케이션의 구성과 릴리즈 정보를 포함하고 있습니다. Chart를 사용하면 애플리케이션을 배포하고 업데이트하는 프로세스를 쉽게 자동화할 수 있습니다. Helm은 또한 Helm Repositories 라는 것을 제공합니다. 이는 Helm Charts를 저장하고 공유할 수 있는 저장소입니다. 공개 또는 비공개 저장소를 사용하여 애플리케이션을 더 쉽게 배포하고 공유할 수 있습니다. Helm은 Kubernetes의 많은 기능을 지원합니다. 예를 들어, Helm은 릴리즈를 롤백하는 기능을 제공하며, 릴리즈 히스토리를 추적할 수 있습니다. 또한 Helm은 템플릿을 사용하여 리소스를 더 쉽게 생성할 수 있습니다. 요약하자면, Helm은 Kubernetes 애플리케이션을 배포하고 관리하기 위한 유용한 도구입니다. Helm을 사용하면 애플리케이션 배포를 더 쉽게 자동화할 수 있습니다. Helm 설치curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3chmod 700 get_helm.sh./get_helm.sh brew 를 이용한 설치brew install helm","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Helm","slug":"Kubernetes/Helm","permalink":"https://ckck803.github.io/categories/Kubernetes/Helm/"}],"tags":[]},{"title":"Istio 란?","slug":"k8s/istio/istio","date":"2023-05-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.539Z","comments":true,"path":"2023/05/08/k8s/istio/istio/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/istio/istio/","excerpt":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ https://gruuuuu.github.io/cloud/service-mesh-istio/ Istio 란? Istio는 서비스 매쉬 (Service Mesh) 를 구현하기 위한 오픈소스 플랫폼 서비스 매쉬는 마이크로서비스 아키텍처에서 많은 서비스 인스턴스들이 동작하는 환경에서, 서비스들 간의 통신을 관리하고 모니터링할 수 있도록 해주는 기술 입니다. Istio는 Kubernetes 환경에서 동작하며, 다양한 기능을 제공합니다. 예를 들어, 서비스 간의 통신 보안, 트래픽 라우팅, 부하 분산, 서비스 간의 장애 처리 등을 제공합니다. 이러한 기능을 통해 서비스 매쉬를 쉽게 구현할 수 있고, 서비스들 간의 통신 관리를 간편하게 할 수 있습니다. Istio Architecture","text":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ https://gruuuuu.github.io/cloud/service-mesh-istio/ Istio 란? Istio는 서비스 매쉬 (Service Mesh) 를 구현하기 위한 오픈소스 플랫폼 서비스 매쉬는 마이크로서비스 아키텍처에서 많은 서비스 인스턴스들이 동작하는 환경에서, 서비스들 간의 통신을 관리하고 모니터링할 수 있도록 해주는 기술 입니다. Istio는 Kubernetes 환경에서 동작하며, 다양한 기능을 제공합니다. 예를 들어, 서비스 간의 통신 보안, 트래픽 라우팅, 부하 분산, 서비스 간의 장애 처리 등을 제공합니다. 이러한 기능을 통해 서비스 매쉬를 쉽게 구현할 수 있고, 서비스들 간의 통신 관리를 간편하게 할 수 있습니다. Istio Architecture 구성 요소 설명 Envoy Proxy 각각의 서비스 인스턴스 사이에 위치하며, 서비스 간의 통신을 관리합니다. Envoy Proxy 는 트래픽 라우팅, 부하 분산, 서비스 간의 보안, 회복성 및 가시성을 제공합니다. Mixer Envoy Proxy 에서 수집된 데이터를 수집하고 처리합니다. Istio 정책 엔진과 통신하여 보안, 로깅, 모니터링 등의 기능을 제공합니다. Pilot 서비스 간의 통신을 관리하며, Envoy 프록시에 대한 구성 정보를 제공합니다. Istio Pilot은 서비스 간의 통신 규칙을 설정하고, 트래픽 라우팅 규칙을 구성합니다. Citadel 보안 기능을 제공합니다. Citadel은 서비스 인증, 인가, 암호화 및 상호 TLS(mTLS) 연결을 설정하는 데 사용됩니다. Galley Istio 구성 관리 및 유효성 검사를 담당합니다. Galley는 Istio 리소스의 유효성을 검사하고, Istio 구성 변경 사항을 감지하여 Istio Pilot 및 Citadel과 동기화합니다. Envoy ProxyIstio 서비스 메쉬의 Data Plane 을 구성하는 컴포넌트입니다. Envoy는 서비스 인스턴스 간의 통신을 중개하고, 트래픽 라우팅, 부하 분산, 모니터링, 보안 등의 기능을 제공합니다. Envoy는 Istio에서 Sidecar 패턴 을 사용해 각 Kubernetes 애플리케이션 Pod 내에서 하나의 컨테이너로 실행되며 Pod의 내부 트래픽을 중재하고 관리하기 때문에, 각 Pod의 내부에서 애플리케이션과 함께 실행됩니다. Istio 는 Envoy 를 이용해 트래픽 동작에 대한 데이터를 attribute 으로 추출 할 수 있고 Mixer 에서 정책을 관리하는데 사용할 수 있으며, 모니터링 시스템(Prometheus, Grafana 등) 에 보내져 전체 mesh의 동작에 대한 정보를 관리할 수 있다. Sidecar 패턴Sidecar는 컨테이너화된 애플리케이션에서 다양한 기능을 제공하는 디자인 패턴입니다. 이 패턴은 애플리케이션과 함께 실행되는 작은 독립적인 프로세스를 의미합니다. 이 프로세스는 애플리케이션의 라이프 사이클과 함께 실행되며, 애플리케이션과 함께 노드에 배치됩니다. Sidecar는 애플리케이션의 요구사항에 따라 여러 가지 기능을 제공할 수 있습니다. 일반적으로, Sidecar는 네트워크 트래픽 관리, 로깅, 모니터링, 보안 등의 기능을 수행합니다. Sidecar 패턴은 애플리케이션과 Sidecar 간의 통신을 통해 이러한 기능을 제공합니다. Sidecar 패턴은 서비스 매쉬 구축에 매우 유용합니다. 각 서비스 인스턴스에 대한 Sidecar를 배치하여, 서비스 간의 통신을 추적하고 제어할 수 있습니다. 이를 통해, 서비스 매쉬는 부하 분산, 트래픽 라우팅, 보안, 모니터링 등의 기능을 제공할 수 있습니다. Istiod - Istio DaemonIstiod는 Istio의 Control Plane 을 담당하는 컴포넌트 중 하나입니다. 이전 버전에서는 Mixer, Pilot, Citadel 및 Galley의 네 개의 서비스로 분리되어 있었지만, Istio 1.5 버전 이후에는 이러한 기능들을 단일 바이너리인 Istiod로 통합되었습니다. Istiod는 서비스 매쉬 관리를 담당하며, Istio 구성 정보를 유지 관리하고 Envoy 프록시에 대한 구성 정보를 생성합니다. 이러한 기능을 통해, Istiod는 서비스 간의 통신 규칙을 설정하고, 트래픽 라우팅 규칙을 구성할 수 있습니다. 또한, Istiod는 서비스 간의 통신에 대한 보안 기능도 제공합니다. Citadel과 통합되어 서비스 인증 및 상호 TLS(mTLS) 연결 설정을 수행합니다. Istiod는 다양한 보안 기능을 제공하며, 서비스 간의 통신을 보호할 수 있습니다. Istiod는 Kubernetes 클러스터 내에서 동작하며, 다른 Istio 컴포넌트와 통신하여 서비스 매쉬의 관리 및 보안 기능을 제공합니다. pilot : CRD(CustumResourceDefinition)을 SidecarProxy가 이해할 수 있는 형식으로 변환 및 전파 galley : kubernetes yaml 파일을 istio가 이해할 수 있는 형식으로 변환 citadel : 인증 관리(TLS certification 등)","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Istio","slug":"Kubernetes/Istio","permalink":"https://ckck803.github.io/categories/Kubernetes/Istio/"}],"tags":[]},{"title":"Service Mesh","slug":"k8s/istio/service-mesh","date":"2023-05-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.539Z","comments":true,"path":"2023/05/08/k8s/istio/service-mesh/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/istio/service-mesh/","excerpt":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ https://gruuuuu.github.io/cloud/service-mesh-istio/ 서비스 메쉬 서비스 매쉬(Service Mesh)는 분산 시스템에서 서비스 간의 통신을 관리하고 모니터링하는 아키텍처 패턴 마이크로서비스 아키텍처에서는 여러 개의 작은 서비스로 분할되어 동작하며, 각각의 서비스는 서로 다른 언어, 프레임워크, 플랫폼에서 개발될 수 있습니다. 이러한 분산 시스템에서는 서비스 간의 통신을 관리하는 것이 중요합니다. 서비스 매쉬는 네트워크 인프라에서 서비스 간의 통신을 추상화하고, 서비스 간의 통신을 보안하고, 부하 분산을 수행하며, 서비스 간의 장애 처리를 제공합니다. 서비스 매쉬는 서비스 간의 통신을 중앙 집중적으로 관리하는 기존의 아키텍처 패턴과는 달리, 분산 시스템에서는 서비스 매쉬를 사용하여 각각의 서비스가 통신 관리를 담당하게 됩니다. 이로 인해, 각각의 서비스는 독립적으로 확장하고, 업그레이드하며, 유지보수할 수 있습니다.","text":"목차 Istio - Locality Load Balancing (지역 로드 밸런싱) Istio - Sidecar Injection Post not found: k8s/istio/istio-install Istio 란? 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ https://gruuuuu.github.io/cloud/service-mesh-istio/ 서비스 메쉬 서비스 매쉬(Service Mesh)는 분산 시스템에서 서비스 간의 통신을 관리하고 모니터링하는 아키텍처 패턴 마이크로서비스 아키텍처에서는 여러 개의 작은 서비스로 분할되어 동작하며, 각각의 서비스는 서로 다른 언어, 프레임워크, 플랫폼에서 개발될 수 있습니다. 이러한 분산 시스템에서는 서비스 간의 통신을 관리하는 것이 중요합니다. 서비스 매쉬는 네트워크 인프라에서 서비스 간의 통신을 추상화하고, 서비스 간의 통신을 보안하고, 부하 분산을 수행하며, 서비스 간의 장애 처리를 제공합니다. 서비스 매쉬는 서비스 간의 통신을 중앙 집중적으로 관리하는 기존의 아키텍처 패턴과는 달리, 분산 시스템에서는 서비스 매쉬를 사용하여 각각의 서비스가 통신 관리를 담당하게 됩니다. 이로 인해, 각각의 서비스는 독립적으로 확장하고, 업그레이드하며, 유지보수할 수 있습니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Istio","slug":"Kubernetes/Istio","permalink":"https://ckck803.github.io/categories/Kubernetes/Istio/"}],"tags":[]},{"title":"CoreDNS","slug":"k8s/service/CoreDNS","date":"2023-05-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.542Z","comments":true,"path":"2023/05/08/k8s/service/CoreDNS/","link":"","permalink":"https://ckck803.github.io/2023/05/08/k8s/service/CoreDNS/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s 참고 공식 문서 https://kubernetes.io/docs/concepts/services-networking/service/ CoreDNS CoreDNS는 쿠버네티스(Kubernetes) 클러스터 내에서 DNS(Domain Name System) 기능을 제공하는 가벼운 DNS 서버 쿠버네티스 클러스터 내의 파드, 서비스 및 기타 리소스를 DNS 이름으로 매핑하여 네트워크 통신에 사용됩니다. CoreDNS는 클러스터 내부에서 DNS 조회를 처리하기 위해 디폴트로 설치되는 DNS 서버입니다. 이전에는 쿠버네티스에선 kube-dns 라는 DNS 서버가 사용되었지만, 쿠버네티스 버전 1.11부터는 CoreDNS가 디폴트로 사용됩니다. CoreDNS 기능","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s 참고 공식 문서 https://kubernetes.io/docs/concepts/services-networking/service/ CoreDNS CoreDNS는 쿠버네티스(Kubernetes) 클러스터 내에서 DNS(Domain Name System) 기능을 제공하는 가벼운 DNS 서버 쿠버네티스 클러스터 내의 파드, 서비스 및 기타 리소스를 DNS 이름으로 매핑하여 네트워크 통신에 사용됩니다. CoreDNS는 클러스터 내부에서 DNS 조회를 처리하기 위해 디폴트로 설치되는 DNS 서버입니다. 이전에는 쿠버네티스에선 kube-dns 라는 DNS 서버가 사용되었지만, 쿠버네티스 버전 1.11부터는 CoreDNS가 디폴트로 사용됩니다. CoreDNS 기능 DNS 이름 해석 CoreDNS는 쿠버네티스 클러스터 내에서 파드, 서비스, 인그레스 등과 같은 리소스에 대한 DNS 이름을 해석합니다. 이를 통해 클러스터 내부에서 DNS를 사용하여 리소스에 접근할 수 있습니다. Service Discovery CoreDNS는 쿠버네티스의 서비스를 DNS 이름으로 매핑하여 파드 간 통신을 용이하게 합니다. 서비스의 DNS 이름은 클러스터 내의 파드에서 해당 서비스로의 네트워크 통신을 가능하게 합니다. Custom DNS 설정 CoreDNS는 사용자 정의 DNS 설정을 지원합니다. 쿠버네티스 클러스터 관리자는 CoreDNS 설정을 수정하여 클러스터 외부 DNS 서버와의 통합 또는 추가적인 DNS 레코드를 관리할 수 있습니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"서비스","slug":"Kubernetes/서비스","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%84%9C%EB%B9%84%EC%8A%A4/"}],"tags":[]},{"title":"Spring Batch - 23. Job 을 Step 으로 갖는 JobStep","slug":"spring/spring-batch/jobstep/spring-batch-23-JobStep","date":"2023-05-06T23:25:35.000Z","updated":"2024-02-26T15:30:07.940Z","comments":true,"path":"2023/05/07/spring/spring-batch/jobstep/spring-batch-23-JobStep/","link":"","permalink":"https://ckck803.github.io/2023/05/07/spring/spring-batch/jobstep/spring-batch-23-JobStep/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Spring Batch - 23. Job 을 Step 으로 갖는 JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder JobStepJob 에 속하는 Step 중에서 외부의 Job 을 포함하고 있는 Step 입니다. 외부의 Job 이 실패하게 되면 해당 Step 이 실패하므로 결국 해당 Step 을 가진 Job 도 실패하게 됩니다. 모든 메타데이터는 기본 Job 과 외부 Job 별로 각각 저장됩니다. 커다란 시스템을 작은 모듈로 쪼개고 Job 의 흐름을 관리하고자 할때 사용할 수 있습니다. @Beanpublic Job parentJob() &#123; return this.jobBuilderFactory.get(&quot;parentJob&quot;) .start(jobStep(null)) .next(step2()) .build();&#125;@Beanpublic Step jobStep(JobLauncher jobLauncher) &#123; return this.stepBuilderFactory.get(&quot;jobStep&quot;) .job(childJob()) .launcher(jobLauncher) .listener(new StepExecutionListener() &#123; @Override public void beforeStep(StepExecution stepExecution) &#123; stepExecution.getExecutionContext().putString(&quot;name&quot;, &quot;user1&quot;); &#125; @Override public ExitStatus afterStep(StepExecution stepExecution) &#123; return null; &#125; &#125;) .parametersExtractor(jobParametersExtractor()) .build();&#125;@Beanpublic Job childJob() &#123; return this.jobBuilderFactory.get(&quot;childJob&quot;) .start(step1()) .build();&#125;@Beanpublic Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123;// throw new RuntimeException(&quot;step1 was failed&quot;); return RepeatStatus.FINISHED; &#125; &#125;) .build();&#125;@Beanpublic Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; throw new RuntimeException(&quot;step2 was failed&quot;);// return RepeatStatus.FINISHED; &#125;) .build();&#125;@Bean public DefaultJobParametersExtractor jobParametersExtractor() &#123; // ExecutionContext 에 설정된 Key 로 되있는 값을 가져올 수 있다. DefaultJobParametersExtractor extractor = new DefaultJobParametersExtractor(); extractor.setKeys(new String[]&#123;&quot;name&quot;&#125;); return extractor;&#125;","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Spring Batch - 23. Job 을 Step 으로 갖는 JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder JobStepJob 에 속하는 Step 중에서 외부의 Job 을 포함하고 있는 Step 입니다. 외부의 Job 이 실패하게 되면 해당 Step 이 실패하므로 결국 해당 Step 을 가진 Job 도 실패하게 됩니다. 모든 메타데이터는 기본 Job 과 외부 Job 별로 각각 저장됩니다. 커다란 시스템을 작은 모듈로 쪼개고 Job 의 흐름을 관리하고자 할때 사용할 수 있습니다. @Beanpublic Job parentJob() &#123; return this.jobBuilderFactory.get(&quot;parentJob&quot;) .start(jobStep(null)) .next(step2()) .build();&#125;@Beanpublic Step jobStep(JobLauncher jobLauncher) &#123; return this.stepBuilderFactory.get(&quot;jobStep&quot;) .job(childJob()) .launcher(jobLauncher) .listener(new StepExecutionListener() &#123; @Override public void beforeStep(StepExecution stepExecution) &#123; stepExecution.getExecutionContext().putString(&quot;name&quot;, &quot;user1&quot;); &#125; @Override public ExitStatus afterStep(StepExecution stepExecution) &#123; return null; &#125; &#125;) .parametersExtractor(jobParametersExtractor()) .build();&#125;@Beanpublic Job childJob() &#123; return this.jobBuilderFactory.get(&quot;childJob&quot;) .start(step1()) .build();&#125;@Beanpublic Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123;// throw new RuntimeException(&quot;step1 was failed&quot;); return RepeatStatus.FINISHED; &#125; &#125;) .build();&#125;@Beanpublic Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; throw new RuntimeException(&quot;step2 was failed&quot;);// return RepeatStatus.FINISHED; &#125;) .build();&#125;@Bean public DefaultJobParametersExtractor jobParametersExtractor() &#123; // ExecutionContext 에 설정된 Key 로 되있는 값을 가져올 수 있다. DefaultJobParametersExtractor extractor = new DefaultJobParametersExtractor(); extractor.setKeys(new String[]&#123;&quot;name&quot;&#125;); return extractor;&#125; JobParametersExtractor이 인터페이스는 Job 실행 시 필요한 매개변수를 추출하는 역할을 담당합니다. JobParametersExtractor는 Job 실행을 위해 필요한 매개변수를 추출하는 메서드인 extract()를 정의합니다. 이 메서드는 JobParameters 객체를 반환하며, Job 실행에 필요한 매개변수를 포함합니다. Spring Batch에서는 매개변수를 추출하는 여러 가지 방법을 제공합니다. 주요한 방법은 다음과 같습니다. 커맨드 라인 매개변수(Command-line Parameters): 실행 명령어나 스크립트를 통해 Job을 실행할 때, 커맨드 라인에서 전달되는 매개변수를 추출합니다. 예를 들어, “–param1&#x3D;value1 –param2&#x3D;value2”와 같이 전달되는 매개변수를 읽어와 JobParameters 객체로 변환합니다. 환경 변수(Environment Variables): 운영체제의 환경 변수를 통해 매개변수를 전달받을 수 있습니다. 예를 들어, “MY_PARAM&#x3D;value”와 같은 환경 변수를 읽어와 JobParameters 객체로 변환합니다. 속성 파일(Properties Files): Spring 환경 설정 파일에 정의된 속성 값을 읽어와 매개변수로 사용할 수 있습니다. 예를 들어, “my.param&#x3D;value”와 같이 정의된 속성 값을 읽어와 JobParameters 객체로 변환합니다. JobParametersExtractor를 직접 구현하여 매개변수를 추출하는 로직을 사용자 정의할 수도 있습니다. 이를 통해 특정한 매개변수 소스나 추출 방식에 따라 JobParameters를 생성할 수 있습니다. 추출된 JobParameters 객체는 Spring Batch의 Job 실행 시점에 사용되며, Job 내에서 필요한 매개변수 값을 참조할 수 있게 됩니다. 이를 통해 Job의 실행을 동적으로 제어하고, 매개변수 값을 변경하여 다양한 실행 시나리오를 처리할 수 있습니다. public interface JobParametersExtractor &#123; JobParameters getJobParameters(Job job, StepExecution stepExecution);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"}],"tags":[]},{"title":"쿠버네티스 - ConfigMap","slug":"k8s/config/configmap","date":"2023-05-06T21:31:46.000Z","updated":"2024-02-18T16:19:54.536Z","comments":true,"path":"2023/05/07/k8s/config/configmap/","link":"","permalink":"https://ckck803.github.io/2023/05/07/k8s/config/configmap/","excerpt":"목차 쿠버네티스 - Secret 쿠버네티스 - ConfigMap 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s ConfigMap 쿠버네티스(ConfigMap)은 애플리케이션의 설정 데이터를 저장하고 관리하기 위한 리소스 설정 데이터는 키-값 쌍으로 구성되며, 애플리케이션에서 필요한 설정 값을 포함할 수 있습니다. ConfigMap은 클러스터 수준 또는 네임스페이스 수준에서 생성될 수 있으며, 클러스터 수준의 ConfigMap은 모든 네임스페이스에서 사용할 수 있습니다. ConfigMap은 주로 환경 변수, 설정 파일, 명령행 인수 등과 같은 애플리케이션 구성에 사용됩니다. 이러한 구성 데이터는 컨테이너 이미지와 분리되어 애플리케이션을 다양한 환경에서 재사용하거나 구성을 변경할 수 있도록 합니다. 또한 ConfigMap은 애플리케이션을 업데이트하거나 배포하는 동안 구성을 쉽게 관리할 수 있도록 도와줍니다. ConfigMap은 YAML 또는 JSON 형식으로 정의되며, 쿠버네티스 클러스터에 생성 및 적용됩니다. ConfigMap을 생성한 후에는 해당 ConfigMap을 사용하려는 Pod의 컨테이너에 마운트하거나 환경 변수로 설정할 수 있습니다. 이렇게 하면 애플리케이션은 ConfigMap에서 정의된 설정 값을 사용할 수 있습니다. 예를 들어, ConfigMap에서 “db_host”라는 키에 대한 값으로 “database.example.com”을 설정하면, 애플리케이션은 이 값을 읽어와 데이터베이스 호스트로 사용할 수 있습니다. ConfigMap은 클러스터나 네임스페이스 수준에서 변경 및 관리할 수 있으므로, 변경된 설정 값은 애플리케이션을 다시 시작하지 않고도 즉시 적용될 수 있습니다. 파일을 통째로 ConfigMap 으로 만들기","text":"목차 쿠버네티스 - Secret 쿠버네티스 - ConfigMap 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s ConfigMap 쿠버네티스(ConfigMap)은 애플리케이션의 설정 데이터를 저장하고 관리하기 위한 리소스 설정 데이터는 키-값 쌍으로 구성되며, 애플리케이션에서 필요한 설정 값을 포함할 수 있습니다. ConfigMap은 클러스터 수준 또는 네임스페이스 수준에서 생성될 수 있으며, 클러스터 수준의 ConfigMap은 모든 네임스페이스에서 사용할 수 있습니다. ConfigMap은 주로 환경 변수, 설정 파일, 명령행 인수 등과 같은 애플리케이션 구성에 사용됩니다. 이러한 구성 데이터는 컨테이너 이미지와 분리되어 애플리케이션을 다양한 환경에서 재사용하거나 구성을 변경할 수 있도록 합니다. 또한 ConfigMap은 애플리케이션을 업데이트하거나 배포하는 동안 구성을 쉽게 관리할 수 있도록 도와줍니다. ConfigMap은 YAML 또는 JSON 형식으로 정의되며, 쿠버네티스 클러스터에 생성 및 적용됩니다. ConfigMap을 생성한 후에는 해당 ConfigMap을 사용하려는 Pod의 컨테이너에 마운트하거나 환경 변수로 설정할 수 있습니다. 이렇게 하면 애플리케이션은 ConfigMap에서 정의된 설정 값을 사용할 수 있습니다. 예를 들어, ConfigMap에서 “db_host”라는 키에 대한 값으로 “database.example.com”을 설정하면, 애플리케이션은 이 값을 읽어와 데이터베이스 호스트로 사용할 수 있습니다. ConfigMap은 클러스터나 네임스페이스 수준에서 변경 및 관리할 수 있으므로, 변경된 설정 값은 애플리케이션을 다시 시작하지 않고도 즉시 적용될 수 있습니다. 파일을 통째로 ConfigMap 으로 만들기global: scrape_interval: 15sscrape_configs: - job_name: prometheus metrics_path: /prometheus/metrics static_configs: - targets: - localhost:9090 kubectl create cm my-config --from-file=config-file.yaml kubectl get cmNAME DATA AGEmy-config 1 54s kubectl describe cm/my-config Name: my-configNamespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====config-file.yaml:----global: scrape_interval: 15sscrape_configs: - job_name: prometheus metrics_path: /prometheus/metrics static_configs: - targets: - localhost:9090BinaryData====Events: &lt;none&gt; apiVersion: v1kind: Podmetadata: name: alpine-envspec: containers: - name: alpine image: alpine command: [&quot;sleep&quot;] args: [&quot;100000&quot;] env: - name: hello valueFrom: configMapKeyRef: name: my-config key: hello # 접속 후 설정 확인kubectl exec -it alpine -- ls /etc/configkubectl exec -it alpine -- cat /etc/config/config-file.yml env 파일로 만들기hello=worldhaha=hoho kubectl create cm env-config --from-env-file=config-env.yamlconfigmap/env-config created kubectl describe cm/env-config Name: env-configNamespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====haha:----hohohello:----worldBinaryData====Events: &lt;none&gt; YAML 파일로 만들기apiVersion: v1kind: ConfigMapmetadata: name: my-configdata: hello: world kuber: netes multiline: |- first second third kubectl apply -f config-map.yaml kubectl exec -it alpine -- cat /etc/config/multiline firstsecondthird","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Config","slug":"Kubernetes/Config","permalink":"https://ckck803.github.io/categories/Kubernetes/Config/"}],"tags":[]},{"title":"Spring Batch - 22. Tasklet 기반 Step","slug":"spring/spring-batch/tasklet/spring-batch-22-Tasklet","date":"2023-05-06T11:25:35.000Z","updated":"2024-02-26T15:30:32.093Z","comments":true,"path":"2023/05/06/spring/spring-batch/tasklet/spring-batch-22-Tasklet/","link":"","permalink":"https://ckck803.github.io/2023/05/06/spring/spring-batch/tasklet/spring-batch-22-Tasklet/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Tasklet Tasklet 은 Step 에서 실행되는 작업의 단위 중 하나 Tasklet 은 Step 내에서 실행되는 작업의 단위 중 하나며 보통 단일 작업을 수행하는데 사용합니다. TaskletStep 객체에 의해 반복적으로 수행되며 Tasklet 반환값에 따라 계속 수행하거나 종료합니다. RepeatStatus : Taasklet 의 반복여부 상태 값 RepeatStatus.FINISHED : Tasklet 종료, RepeatStatus 를 null 로 반환하면 RepeatStatus.FINISHED 로 해석된다. RepeatStatus.CONTINUABLE : Tasklet 반복 Tasklet 인터페이스","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Tasklet Tasklet 은 Step 에서 실행되는 작업의 단위 중 하나 Tasklet 은 Step 내에서 실행되는 작업의 단위 중 하나며 보통 단일 작업을 수행하는데 사용합니다. TaskletStep 객체에 의해 반복적으로 수행되며 Tasklet 반환값에 따라 계속 수행하거나 종료합니다. RepeatStatus : Taasklet 의 반복여부 상태 값 RepeatStatus.FINISHED : Tasklet 종료, RepeatStatus 를 null 로 반환하면 RepeatStatus.FINISHED 로 해석된다. RepeatStatus.CONTINUABLE : Tasklet 반복 Tasklet 인터페이스public interface Tasklet &#123; @Nullable RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception;&#125; @Componentpublic class CustomTasklet implements Tasklet &#123; @Override public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception &#123; System.out.println(&quot;stepContribution = &quot; + stepContribution + &quot;, chunkContext = &quot; + chunkContext); return RepeatStatus.FINISHED; &#125;&#125; @Beanpublic Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception &#123; System.out.println(&quot;stepContribution = &quot; + stepContribution + &quot;, chunkContext = &quot; + chunkContext); return RepeatStatus.FINISHED; &#125; &#125;) .build();&#125;@Beanpublic Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet(customTasklet) .build();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"}],"tags":[]},{"title":"Spring Batch - 21. TaskletStep","slug":"spring/spring-batch/tasklet/spring-batch-21-TaskletStep","date":"2023-05-04T11:25:35.000Z","updated":"2024-02-26T15:30:27.634Z","comments":true,"path":"2023/05/04/spring/spring-batch/tasklet/spring-batch-21-TaskletStep/","link":"","permalink":"https://ckck803.github.io/2023/05/04/spring/spring-batch/tasklet/spring-batch-21-TaskletStep/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder TaskletStep TaskletStep 은 Step 구현체 중 하나로 Tasklet 을 실행한다. TaskletStep 은 Step 인터페이스를 구현하며, Tasklet 을 실행하기 위한 Step 입니다. Tasklet 은 Step 의 실행 시점에 호출되는 단일한 실행 단위입니다. TaskletStep 을 사용하는 경우, Tasklet 인터페이스를 구현한 클래스를 작성하고, 해당 클래스에서 수행할 로직을 구현합니다. 이후 TaskletStep 을 정의할 때, 이 Tasklet 클래스를 참조하여 Step을 구성합니다. TaskletStep 을 사용하는 가장 일반적인 예는 파일을 읽어들이고, 처리한 후 결과를 파일로 출력하는 작업입니다. 이 경우, Tasklet 클래스에서 파일을 읽어들이고, 처리한 후 결과를 파일로 출력하는 로직을 구현하면 됩니다. 또한, TaskletStep 은 다양한 환경에서 사용될 수 있으며, Spring Batch의 다른 Step과 조합하여 다양한 처리 작업을 수행할 수 있습니다. TaskletStep 아키텍처","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder TaskletStep TaskletStep 은 Step 구현체 중 하나로 Tasklet 을 실행한다. TaskletStep 은 Step 인터페이스를 구현하며, Tasklet 을 실행하기 위한 Step 입니다. Tasklet 은 Step 의 실행 시점에 호출되는 단일한 실행 단위입니다. TaskletStep 을 사용하는 경우, Tasklet 인터페이스를 구현한 클래스를 작성하고, 해당 클래스에서 수행할 로직을 구현합니다. 이후 TaskletStep 을 정의할 때, 이 Tasklet 클래스를 참조하여 Step을 구성합니다. TaskletStep 을 사용하는 가장 일반적인 예는 파일을 읽어들이고, 처리한 후 결과를 파일로 출력하는 작업입니다. 이 경우, Tasklet 클래스에서 파일을 읽어들이고, 처리한 후 결과를 파일로 출력하는 로직을 구현하면 됩니다. 또한, TaskletStep 은 다양한 환경에서 사용될 수 있으며, Spring Batch의 다른 Step과 조합하여 다양한 처리 작업을 수행할 수 있습니다. TaskletStep 아키텍처Step 은 RepeatTemplate 를 사용해서 Tasklet 구문을 트랜잭션 경계 내에서 반복해서 실행한다.Task 기반과 Chunk 기반으로 나누어서 Tasklet 을 실행한다. TaskletStep 과 메타데이터Job 이 TaskletStep 을 실행하게 되면 StepExecution 객체가 생성됩니다. StepExecution 객체는 내부적으로 ExecutionContext 를 생성해 TaskletStep 에 전달하게 됩니다. TaskletStep 이 Step 을 실행하기 전에 StepListener 객체를 호출해 Step 실행전에 실행해야할 로직을 수행합니다. RepeatTemplate 객체가 Tasklet 객체들을 반복적으로 수행합니다. 기본값으로 RepeatStatus.CONTINUABLE 상태로 반복해서 Tasklet 을 수행하고 Tasklet 이 정상적으로 종료된 경우에는 RepeatStatus.FINISHED 상태로 반환합니다. Step 을 실행후에는 다시 StepListener 를 호출해 Step 실행후 실행해야할 로직을 수행합니다. Step 이 완료후 StepExecution 객체에 Step 완료 상태를 업데이트 해줍니다. ExitStatus 와 BatchStatus 두 가지 상태를 업데이트 해줍니다. SimpleStepHandlerSimpleJob 이 Step 을 실행시키게 되면 SimpleStepHandler 에 의해 Step 이 실행됩니다. @Overridepublic StepExecution handleStep(Step step, JobExecution execution) throws JobInterruptedException,JobRestartException, StartLimitExceededException &#123; if (execution.isStopping()) &#123; throw new JobInterruptedException(&quot;JobExecution interrupted.&quot;); &#125; JobInstance jobInstance = execution.getJobInstance(); // StepExecution 가져온다. StepExecution lastStepExecution = jobRepository.getLastStepExecution(jobInstance, step.getName()); if (stepExecutionPartOfExistingJobExecution(execution, lastStepExecution)) &#123; // If the last execution of this step was in the same job, it&#x27;s // probably intentional so we want to run it again... if (logger.isInfoEnabled()) &#123; logger.info(String.format(&quot;Duplicate step [%s] detected in execution of job=[%s]. &quot; + &quot;If either step fails, both will be executed again on restart.&quot;, step.getName(), jobInstance .getJobName())); &#125; lastStepExecution = null; &#125; StepExecution currentStepExecution = lastStepExecution; if (shouldStart(lastStepExecution, execution, step)) &#123; // StepExecution 객체를 생성한다. currentStepExecution = execution.createStepExecution(step.getName()); boolean isRestart = (lastStepExecution != null &amp;&amp; !lastStepExecution.getStatus().equals( BatchStatus.COMPLETED)); if (isRestart) &#123; currentStepExecution.setExecutionContext(lastStepExecution.getExecutionContext()); if(lastStepExecution.getExecutionContext().containsKey(&quot;batch.executed&quot;)) &#123; currentStepExecution.getExecutionContext().remove(&quot;batch.executed&quot;); &#125; &#125; else &#123; // 현재 StepExecution 객체안에 ExecutionContext 객체를 생성해 저장한다. currentStepExecution.setExecutionContext(new ExecutionContext(executionContext)); &#125; // JobRepository 객체를 통해 현재 StepExecution 객체를 저장한다. jobRepository.add(currentStepExecution); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Executing step: [&quot; + step.getName() + &quot;]&quot;); &#125; try &#123; // Step 을 실행한다. step.execute(currentStepExecution); currentStepExecution.getExecutionContext().put(&quot;batch.executed&quot;, true); &#125; catch (JobInterruptedException e) &#123; // Ensure that the job gets the message that it is stopping // and can pass it on to other steps that are executing // concurrently. execution.setStatus(BatchStatus.STOPPING); throw e; &#125; jobRepository.updateExecutionContext(execution); if (currentStepExecution.getStatus() == BatchStatus.STOPPING || currentStepExecution.getStatus() == BatchStatus.STOPPED) &#123; // Ensure that the job gets the message that it is stopping execution.setStatus(BatchStatus.STOPPING); throw new JobInterruptedException(&quot;Job interrupted by step execution&quot;); &#125; &#125; return currentStepExecution;&#125; Task 기반 Chunk 기반 비교스프링 배치에서는 Step 의 실행단위는 크게 2가지로 나누어진다. 하나는 Task 기반이고 다른 하나는 Chunk 기반입니다. Task 기반 Step 은 단일 작업 기반으로 처리하는 것이 효율적인 경우에 사용합니다. 주로 Tasklet 구현체를 만들어서 사용하며 대량 처리를 하는 경우 Chunk 기반에 비해 더 복잡한 구현이 필요하다. Chunk 기반 Step 은 하나의 큰 덩어리를 N 개씩 나눠서 실행한다는 의미로 대량 처리를 하는 경우 더 효율적으로 처리할 수 있습니다. ItemReader, ItemProcessor, ItemWriter 를 사용하며 Chunk 기반 전용 Tasklet 인 ChunkOrientedTasklet 구현체가 제공된다. AbstractTaskletStepBuilderpublic TaskletStep build() &#123; registerStepListenerAsChunkListener(); TaskletStep step = new TaskletStep(getName()); super.enhance(step); step.setChunkListeners(chunkListeners.toArray(new ChunkListener[0])); // Tasklet 실행에 필요한 Transaction 설정 if (transactionAttribute != null) &#123; step.setTransactionAttribute(transactionAttribute); &#125; // 반복 실행을 위한 RepeatTemplate 설정 if (stepOperations == null) &#123; stepOperations = new RepeatTemplate(); if (taskExecutor != null) &#123; TaskExecutorRepeatTemplate repeatTemplate = new TaskExecutorRepeatTemplate(); repeatTemplate.setTaskExecutor(taskExecutor); repeatTemplate.setThrottleLimit(throttleLimit); stepOperations = repeatTemplate; &#125; ((RepeatTemplate) stepOperations).setExceptionHandler(exceptionHandler); &#125; // Step 에 RepeatTemplate 설정 step.setStepOperations(stepOperations); // Tasklet 설정 step.setTasklet(createTasklet()); step.setStreams(streams.toArray(new ItemStream[0])); try &#123; step.afterPropertiesSet(); &#125; catch (Exception e) &#123; throw new StepBuilderException(e); &#125; return step;&#125; AbstractStep@Overridepublic final void execute(StepExecution stepExecution) throws JobInterruptedException,UnexpectedJobExecutionException &#123; Assert.notNull(stepExecution, &quot;stepExecution must not be null&quot;); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Executing: id=&quot; + stepExecution.getId()); &#125; // StepExecution 관련 속성 저장 stepExecution.setStartTime(new Date()); stepExecution.setStatus(BatchStatus.STARTED); Timer.Sample sample = BatchMetrics.createTimerSample(); getJobRepository().update(stepExecution); // Start with a default value that will be trumped by anything ExitStatus exitStatus = ExitStatus.EXECUTING; doExecutionRegistration(stepExecution); try &#123; getCompositeListener().beforeStep(stepExecution); open(stepExecution.getExecutionContext()); try &#123; // Step 실행 doExecute(stepExecution); &#125; catch (RepeatException e) &#123; throw e.getCause(); &#125; exitStatus = ExitStatus.COMPLETED.and(stepExecution.getExitStatus()); // Check if someone is trying to stop us if (stepExecution.isTerminateOnly()) &#123; throw new JobInterruptedException(&quot;JobExecution interrupted.&quot;); &#125; // Need to upgrade here not set, in case the execution was stopped stepExecution.upgradeStatus(BatchStatus.COMPLETED); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Step execution success: id=&quot; + stepExecution.getId()); &#125; &#125; catch (Throwable e) &#123; stepExecution.upgradeStatus(determineBatchStatus(e)); exitStatus = exitStatus.and(getDefaultExitStatusForFailure(e)); stepExecution.addFailureException(e); if (stepExecution.getStatus() == BatchStatus.STOPPED) &#123; logger.info(String.format(&quot;Encountered interruption executing step %s in job %s : %s&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName(), e.getMessage())); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Full exception&quot;, e); &#125; &#125; else &#123; logger.error(String.format(&quot;Encountered an error executing step %s in job %s&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e); &#125; &#125; finally &#123; try &#123; // Update the step execution to the latest known value so the // listeners can act on it exitStatus = exitStatus.and(stepExecution.getExitStatus()); stepExecution.setExitStatus(exitStatus); exitStatus = exitStatus.and(getCompositeListener().afterStep(stepExecution)); &#125; catch (Exception e) &#123; logger.error(String.format(&quot;Exception in afterStep callback in step %s in job %s&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e); &#125; try &#123; getJobRepository().updateExecutionContext(stepExecution); &#125; catch (Exception e) &#123; stepExecution.setStatus(BatchStatus.UNKNOWN); exitStatus = exitStatus.and(ExitStatus.UNKNOWN); stepExecution.addFailureException(e); logger.error(String.format(&quot;Encountered an error saving batch meta data for step %s in job %s. &quot; + &quot;This job is now in an unknown state and should not be restarted.&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e); &#125; sample.stop(BatchMetrics.createTimer(&quot;step&quot;, &quot;Step duration&quot;, Tag.of(&quot;job.name&quot;, stepExecution.getJobExecution().getJobInstance().getJobName()), Tag.of(&quot;name&quot;, stepExecution.getStepName()), Tag.of(&quot;status&quot;, stepExecution.getExitStatus().getExitCode()) )); stepExecution.setEndTime(new Date()); stepExecution.setExitStatus(exitStatus); Duration stepExecutionDuration = BatchMetrics.calculateDuration(stepExecution.getStartTime(), stepExecution.getEndTime()); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Step: [&quot; + stepExecution.getStepName() + &quot;] executed in &quot; + BatchMetrics.formatDuration(stepExecutionDuration)); &#125; try &#123; getJobRepository().update(stepExecution); &#125; catch (Exception e) &#123; stepExecution.setStatus(BatchStatus.UNKNOWN); stepExecution.setExitStatus(exitStatus.and(ExitStatus.UNKNOWN)); stepExecution.addFailureException(e); logger.error(String.format(&quot;Encountered an error saving batch meta data for step %s in job %s. &quot; + &quot;This job is now in an unknown state and should not be restarted.&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e); &#125; try &#123; close(stepExecution.getExecutionContext()); &#125; catch (Exception e) &#123; logger.error(String.format(&quot;Exception while closing step execution resources in step %s in job %s&quot;, name, stepExecution.getJobExecution().getJobInstance().getJobName()), e); stepExecution.addFailureException(e); &#125; doExecutionRelease(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Step execution complete: &quot; + stepExecution.getSummary()); &#125; &#125;&#125; TaskletStep@Overrideprotected void doExecute(StepExecution stepExecution) throws Exception &#123; stepExecution.getExecutionContext().put(TASKLET_TYPE_KEY, tasklet.getClass().getName()); stepExecution.getExecutionContext().put(STEP_TYPE_KEY, this.getClass().getName()); stream.update(stepExecution.getExecutionContext()); getJobRepository().updateExecutionContext(stepExecution); // Shared semaphore per step execution, so other step executions can run // in parallel without needing the lock final Semaphore semaphore = createSemaphore(); stepOperations.iterate(new StepContextRepeatCallback(stepExecution) &#123; @Override public RepeatStatus doInChunkContext(RepeatContext repeatContext, ChunkContext chunkContext) throws Exception &#123; StepExecution stepExecution = chunkContext.getStepContext().getStepExecution(); // Before starting a new transaction, check for // interruption. interruptionPolicy.checkInterrupted(stepExecution); RepeatStatus result; try &#123; // TransactionTemplate 안에서 Transaction 처리 result = new TransactionTemplate(transactionManager, transactionAttribute) .execute(new ChunkTransactionCallback(chunkContext, semaphore)); &#125; catch (UncheckedTransactionException e) &#123; // Allow checked exceptions to be thrown inside callback throw (Exception) e.getCause(); &#125; chunkListener.afterChunk(chunkContext); // Check for interruption after transaction as well, so that // the interrupted exception is correctly propagated up to // caller interruptionPolicy.checkInterrupted(stepExecution); return result == null ? RepeatStatus.FINISHED : result; &#125; &#125;);&#125; startLimitStep 마다 설정할 수 있으며 Step 의 실행 횟수를 조정합니다. 설정된 실행 횟수를 초과해서 Step 이 실행될 경우 StartLimitExceededException 예외가 발생합니다. @Beanpublic Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception &#123; System.out.println(&quot;stepContribution = &quot; + stepContribution + &quot;, chunkContext = &quot; + chunkContext); throw new RuntimeException(&quot;&quot;);// return RepeatStatus.FINISHED; &#125; &#125;) .startLimit(3) .build();&#125; allowStartIfCompleteStep 도 Job 과 마찬가지로 실행이 성공할 경우 재시작하지 않고 실패할 경우에는 재시작합니다. BatchStatus.COMPLETED 상태를 가진 Step 은 Job 이 재시작할때 실행하지 않고 스킵합니다. 재시작이 가능한 Job 에서 Step 의 이전 성공 여부와 상관 없이 항상 Step 을 실행하기 위해서는 allowStartIfComplete 메소드를 통해 해당 Step 이 재시작이 가능하도록 설정해줘야 합니다. @Beanpublic Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception &#123; System.out.println(&quot;stepContribution = &quot; + stepContribution + &quot;, chunkContext = &quot; + chunkContext); return RepeatStatus.FINISHED; &#125; &#125;) .allowStartIfComplete(true) .build();&#125; TaskletStep 상속","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"}],"tags":[]},{"title":"Spring Batch - JobListener","slug":"spring/spring-batch/job/spring-batch-JobListener","date":"2023-05-04T06:25:35.000Z","updated":"2024-02-26T15:29:45.567Z","comments":true,"path":"2023/05/04/spring/spring-batch/job/spring-batch-JobListener/","link":"","permalink":"https://ckck803.github.io/2023/05/04/spring/spring-batch/job/spring-batch-JobListener/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobListener JobListener는 Job 실행 전후에 특정 작업을 수행할 수 있도록 하는 인터페이스 beforeJob 메서드는 Job 실행 전에 호출되며, JobExecutionContext를 인자로 받습니다. 이 메서드에서는 Job 실행 전에 수행해야 하는 작업을 구현할 수 있습니다. afterJob 메서드는 Job 실행 후에 호출되며, JobExecution과 JobExecutionDecider를 인자로 받습니다. 이 메서드에서는 Job 실행 후에 수행해야 하는 작업을 구현할 수 있습니다. public interface JobListener &#123; public void beforeJob() throws Exception; public void afterJob() throws Exception;&#125;","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobListener JobListener는 Job 실행 전후에 특정 작업을 수행할 수 있도록 하는 인터페이스 beforeJob 메서드는 Job 실행 전에 호출되며, JobExecutionContext를 인자로 받습니다. 이 메서드에서는 Job 실행 전에 수행해야 하는 작업을 구현할 수 있습니다. afterJob 메서드는 Job 실행 후에 호출되며, JobExecution과 JobExecutionDecider를 인자로 받습니다. 이 메서드에서는 Job 실행 후에 수행해야 하는 작업을 구현할 수 있습니다. public interface JobListener &#123; public void beforeJob() throws Exception; public void afterJob() throws Exception;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"}],"tags":[]},{"title":"Spring Batch - 20. StepBuilderFactory 와 StepBuilder","slug":"spring/spring-batch/step/spring-batch-20-StepBuilderFactory","date":"2023-05-04T06:25:35.000Z","updated":"2024-02-26T15:30:23.159Z","comments":true,"path":"2023/05/04/spring/spring-batch/step/spring-batch-20-StepBuilderFactory/","link":"","permalink":"https://ckck803.github.io/2023/05/04/spring/spring-batch/step/spring-batch-20-StepBuilderFactory/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder StepBuilderFactory StepBuilder 를 생성하는 팩토리 클래스 public class StepBuilderFactory &#123; private JobRepository jobRepository; private PlatformTransactionManager transactionManager; public StepBuilderFactory(JobRepository jobRepository, PlatformTransactionManager transactionManager) &#123; this.jobRepository = jobRepository; this.transactionManager = transactionManager; &#125; public StepBuilder get(String name) &#123; StepBuilder builder = new StepBuilder(name).repository(jobRepository).transactionManager( transactionManager); return builder; &#125;&#125; StepBuilder Step 구성을 쉽게 하기 위한 빌더 클래스","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - ItemWriter Spring Batch - ItemProcessor Spring Batch - ItemReader Spring Batch - ChunkProvider 와 ChunkProcessor Spring Batch - ChunkOrientedTasklet Spring Batch - Chunk 기반 Step Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder StepBuilderFactory StepBuilder 를 생성하는 팩토리 클래스 public class StepBuilderFactory &#123; private JobRepository jobRepository; private PlatformTransactionManager transactionManager; public StepBuilderFactory(JobRepository jobRepository, PlatformTransactionManager transactionManager) &#123; this.jobRepository = jobRepository; this.transactionManager = transactionManager; &#125; public StepBuilder get(String name) &#123; StepBuilder builder = new StepBuilder(name).repository(jobRepository).transactionManager( transactionManager); return builder; &#125;&#125; StepBuilder Step 구성을 쉽게 하기 위한 빌더 클래스 StepBuilderFactory 객체내 get 메소드를 이용하면 StepBuilder 객체를 생성할 수 있다. StepBuilderFactory 객체를 통해 생성된 StepBuilder 객체는 호출되는 메소드에 따라 하위 Builder 객체 생성한 후 각 Step 생성을 위임한다 메소드별 생성되는 하위 StepBuilder 객체 메소드 반환 객체 설명 tasklet TaskletStepBuilder TaskletStep 를 생성하는 Builder 클래스 chunk SimpleStepBuilder TaskletStep 를 생성하며 내부적으로 Chunk 기반의 작업을 처리하는 ChunkOrientedTasklet 클래스를 생성한다. partitioner PartitionStepBuilder PartitionStep 을 생성하며 Multi Thread 방식으로 Job 을 처리한다. job JobStepBuilder JobStep 을 생성하여 Step 안에서 Job 을 실행한다. flow FlowStepBuilder FlowStep 을 생성하여 Flow 안에서 Job 을 실행한다. StepBuilder.java public class StepBuilder extends StepBuilderHelper&lt;StepBuilder&gt; &#123; public StepBuilder(String name) &#123; super(name); &#125; // TaskletStepBuilder 객체 생성 public TaskletStepBuilder tasklet(Tasklet tasklet) &#123; return new TaskletStepBuilder(this).tasklet(tasklet); &#125; // SimpleStepBuilder 객체 생성 public &lt;I, O&gt; SimpleStepBuilder&lt;I, O&gt; chunk(int chunkSize) &#123; return new SimpleStepBuilder&lt;I, O&gt;(this).chunk(chunkSize); &#125; // SimpleStepBuilder 객체 생성 public &lt;I, O&gt; SimpleStepBuilder&lt;I, O&gt; chunk(CompletionPolicy completionPolicy) &#123; return new SimpleStepBuilder&lt;I, O&gt;(this).chunk(completionPolicy); &#125; // PartitionStepBuilder 객체 생성 public PartitionStepBuilder partitioner(String stepName, Partitioner partitioner) &#123; return new PartitionStepBuilder(this).partitioner(stepName, partitioner); &#125; // PartitionStepBuilder 객체 생성 public PartitionStepBuilder partitioner(Step step) &#123; return new PartitionStepBuilder(this).step(step); &#125; // JobStepBuilder 객체 생성 public JobStepBuilder job(Job job) &#123; return new JobStepBuilder(this).job(job); &#125; // FlowStepBuilder 객체 생성 public FlowStepBuilder flow(Flow flow) &#123; return new FlowStepBuilder(this).flow(flow); &#125;&#125; TaskletStepBuilder@Beanpublic Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; System.out.println(&quot;step1 has executed&quot;); return RepeatStatus.FINISHED; &#125;) .build();&#125; SimpleStepBuilder@Beanpublic Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .&lt;String, String&gt;chunk(3) .reader(() -&gt; null) .writer(list -&gt; &#123;&#125;) .build();&#125; PartitionStepBuilder@Beanpublic Step step3() &#123; return stepBuilderFactory.get(&quot;step3&quot;) .partitioner(step1()) .gridSize(2) .build();&#125; JobStepBuilder@Beanpublic Step step4() &#123; return stepBuilderFactory.get(&quot;step4&quot;) .job(job()) .build();&#125; @Beanpublic Job job() &#123; return this.jobBuilderFactory.get(&quot;job&quot;) .start(step1()) .next(step2())// .next(step3()) .build();&#125; FlowStepBuilder@Beanpublic Step step5() &#123; return stepBuilderFactory.get(&quot;step5&quot;) .flow(flow()) .build();&#125; @Beanpublic Flow flow() &#123; FlowBuilder&lt;Flow&gt; flowBuilder = new FlowBuilder&lt;&gt;(&quot;flow&quot;); flowBuilder.start(step2()).end(); return flowBuilder.build();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"}],"tags":[]},{"title":"Spring Batch - 19. JobParameters 증가 JobParametersIncrementer","slug":"spring/spring-batch/job/spring-batch-19-JobIncrementer","date":"2023-05-03T06:25:35.000Z","updated":"2024-02-26T15:29:41.485Z","comments":true,"path":"2023/05/03/spring/spring-batch/job/spring-batch-19-JobIncrementer/","link":"","permalink":"https://ckck803.github.io/2023/05/03/spring/spring-batch/job/spring-batch-19-JobIncrementer/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobParameters 증가 - JobParametersIncrementer JobParameters 의 변경없이 Job 을 여러번 재시작 하고 싶은 경우 설정 JobParameters 의 필요한 값을 증가시켜 다음에 사용될 JobParameters 객체를 반환합니다. 기존의 JobParameters 의 변경없이 Job 을 여러번 재시작 하고 싶은 경우 설정합니다. RunIdIncrementer 구현체를 지원하며 필요에 따라 JobParametersIncrementer 인터페이스를 직접 구현할 수 있습니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobParameters 증가 - JobParametersIncrementer JobParameters 의 변경없이 Job 을 여러번 재시작 하고 싶은 경우 설정 JobParameters 의 필요한 값을 증가시켜 다음에 사용될 JobParameters 객체를 반환합니다. 기존의 JobParameters 의 변경없이 Job 을 여러번 재시작 하고 싶은 경우 설정합니다. RunIdIncrementer 구현체를 지원하며 필요에 따라 JobParametersIncrementer 인터페이스를 직접 구현할 수 있습니다. JobParametersIncrementer 인터페이스public interface JobParametersIncrementer &#123; JobParameters getNext(@Nullable JobParameters parameters);&#125; public class CustomJobParametersIncrementer implements JobParametersIncrementer &#123; static final SimpleDateFormat format = new SimpleDateFormat(&quot;yyyyMMdd-hhmmss&quot;); public JobParameters getNext(JobParameters parameters) &#123; String id = format.format(new Date()); return new JobParametersBuilder().addString(&quot;run.id&quot;, id).toJobParameters(); &#125;&#125; RunIdIncrementer - JobParametersIncrementer 구현체public class RunIdIncrementer implements JobParametersIncrementer &#123; private static String RUN_ID_KEY = &quot;run.id&quot;; private String key = RUN_ID_KEY; public void setKey(String key) &#123; this.key = key; &#125; @Override public JobParameters getNext(@Nullable JobParameters parameters) &#123; JobParameters params = (parameters == null) ? new JobParameters() : parameters; JobParameter runIdParameter = params.getParameters().get(this.key); long id = 1; if (runIdParameter != null) &#123; try &#123; id = Long.parseLong(runIdParameter.getValue().toString()) + 1; &#125; catch (NumberFormatException exception) &#123; throw new IllegalArgumentException(&quot;Invalid value for parameter &quot; + this.key, exception); &#125; &#125; return new JobParametersBuilder(params).addLong(this.key, id).toJobParameters(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"}],"tags":[]},{"title":"데이터 베이스 - Soft Delete & Hard Delete","slug":"database/soft_hard_delete","date":"2023-04-22T16:21:23.000Z","updated":"2024-02-18T16:19:54.523Z","comments":true,"path":"2023/04/23/database/soft_hard_delete/","link":"","permalink":"https://ckck803.github.io/2023/04/23/database/soft_hard_delete/","excerpt":"Hard DeleteHard Delete 는 데이터베이스에서 특정 레코드를 완전히 삭제하는 것을 의미합니다. 이 경우 해당 레코드는 영구적으로 삭제되어 복구할 수 없습니다. Soft DeleteSoft Delete 는 데이터베이스에서 특정 레코드를 논리적으로 삭제하지만, 물리적으로는 데이터베이스에 그대로 남아있는 것을 의미합니다. 즉, 해당 레코드를 삭제했을 때, 실제로는 데이터베이스에서 해당 레코드를 삭제하지 않고, 삭제되었다는 표시를 하여 삭제된 것처럼 처리합니다. 이렇게 하면 데이터를 복구할 수 있으며, 사용자가 실수로 데이터를 삭제했을 때 복구할 수 있는 장점이 있습니다. 소프트 삭제를 구현하는 방법에는 다양한 방법이 있습니다. 가장 일반적인 방법은 레코드에 삭제 플래그 (delete flag)라는 특별한 필드를 추가하고, 이 필드에 삭제 여부를 표시하는 것입니다. 이렇게 하면 삭제된 레코드를 쉽게 찾을 수 있고, 삭제된 레코드를 복구할 수도 있습니다.","text":"Hard DeleteHard Delete 는 데이터베이스에서 특정 레코드를 완전히 삭제하는 것을 의미합니다. 이 경우 해당 레코드는 영구적으로 삭제되어 복구할 수 없습니다. Soft DeleteSoft Delete 는 데이터베이스에서 특정 레코드를 논리적으로 삭제하지만, 물리적으로는 데이터베이스에 그대로 남아있는 것을 의미합니다. 즉, 해당 레코드를 삭제했을 때, 실제로는 데이터베이스에서 해당 레코드를 삭제하지 않고, 삭제되었다는 표시를 하여 삭제된 것처럼 처리합니다. 이렇게 하면 데이터를 복구할 수 있으며, 사용자가 실수로 데이터를 삭제했을 때 복구할 수 있는 장점이 있습니다. 소프트 삭제를 구현하는 방법에는 다양한 방법이 있습니다. 가장 일반적인 방법은 레코드에 삭제 플래그 (delete flag)라는 특별한 필드를 추가하고, 이 필드에 삭제 여부를 표시하는 것입니다. 이렇게 하면 삭제된 레코드를 쉽게 찾을 수 있고, 삭제된 레코드를 복구할 수도 있습니다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"Scan","slug":"CS/DataBase/Scan","permalink":"https://ckck803.github.io/categories/CS/DataBase/Scan/"}],"tags":[]},{"title":"Spring Batch - 18. Job 의 재시작 방지 preventRestart","slug":"spring/spring-batch/job/spring-batch-18-preventRestart","date":"2023-04-06T06:25:35.000Z","updated":"2024-02-26T15:29:37.866Z","comments":true,"path":"2023/04/06/spring/spring-batch/job/spring-batch-18-preventRestart/","link":"","permalink":"https://ckck803.github.io/2023/04/06/spring/spring-batch/job/spring-batch-18-preventRestart/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing Job 의 재시작 방지 - preventRestart Job 이 실패하더라도 재시작하지 않도록 설정한다. SimpleJob 에는 Job의 재시작을 관리하는 restartable 은 기본값이 True 로 설정돼 있어 Job 이 실패했을시 재시작 하도록 합니다. preventRestart 메소드는 restartable 를 False 로 변경해 Job 이 실패하더라도 재시작하지 않도록 합니다. preventRestart 메소드는 Job 실행에 대한 JobExecution 객체가 있는지 확인하고 기존 객체가 없을 경우 Job 을 수행합니다. 만일 기존 JobExecution 객체가 있을 경우 Job 을 수행하지 않고 JobRestartException 예외를 발생시킨다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing Job 의 재시작 방지 - preventRestart Job 이 실패하더라도 재시작하지 않도록 설정한다. SimpleJob 에는 Job의 재시작을 관리하는 restartable 은 기본값이 True 로 설정돼 있어 Job 이 실패했을시 재시작 하도록 합니다. preventRestart 메소드는 restartable 를 False 로 변경해 Job 이 실패하더라도 재시작하지 않도록 합니다. preventRestart 메소드는 Job 실행에 대한 JobExecution 객체가 있는지 확인하고 기존 객체가 없을 경우 Job 을 수행합니다. 만일 기존 JobExecution 객체가 있을 경우 Job 을 수행하지 않고 JobRestartException 예외를 발생시킨다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"}],"tags":[]},{"title":"Spring Batch - 17. JobParameters 검증 JobParametersValidator","slug":"spring/spring-batch/job/spring-batch-17-JobParametersValidator","date":"2023-04-05T06:25:35.000Z","updated":"2024-02-26T15:29:34.708Z","comments":true,"path":"2023/04/05/spring/spring-batch/job/spring-batch-17-JobParametersValidator/","link":"","permalink":"https://ckck803.github.io/2023/04/05/spring/spring-batch/job/spring-batch-17-JobParametersValidator/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobParameters 검증 - JobParametersValidatorJobParametersValidator 릍 통한 JobParameters 검증은 Job 을 실행하기 전에 SimpleJobLauncher 내부에서 한번 Job 이 실행할때 SimpleJobL 에서 한번 총 두번의 Validation 을 진행한다. public interface JobParametersValidator &#123; void validate(@Nullable JobParameters parameters) throws JobParametersInvalidException;&#125; JobParametersValidator 기본 구현체 - DefaultJobParametersValidator requiredKeys JobParameter 에 필수적으로 포함되어야 할 Key 필수 Key 가 없을 경우 JobParametersInvalidException 예외를 발생시킨다. optionalKeys JobParameter 에 선택적으로 포함되어야 할 Key public DefaultJobParametersValidator(String[] requiredKeys, String[] optionalKeys) &#123; super(); setRequiredKeys(requiredKeys); setOptionalKeys(optionalKeys);&#125;@Overridepublic void validate(@Nullable JobParameters parameters) throws JobParametersInvalidException &#123; if (parameters == null) &#123; throw new JobParametersInvalidException(&quot;The JobParameters can not be null&quot;); &#125; Set&lt;String&gt; keys = parameters.getParameters().keySet(); // optionalKeys 가 있을 경우에만 실행 if (!optionalKeys.isEmpty()) &#123; Collection&lt;String&gt; missingKeys = new HashSet&lt;&gt;(); // JobParameters Key 에 대한 검증을 한다. for (String key : keys) &#123; if (!optionalKeys.contains(key) &amp;&amp; !requiredKeys.contains(key)) &#123; missingKeys.add(key); &#125; &#125; // JobParameters 로 넘어온 Key 가 requiredKeys 에도 optionalKeys 에도 없으면 JobParametersInvalidException 예외를 발생시킨다. if (!missingKeys.isEmpty()) &#123; throw new JobParametersInvalidException( &quot;The JobParameters contains keys that are not explicitly optional or required: &quot; + missingKeys); &#125; &#125; Collection&lt;String&gt; missingKeys = new HashSet&lt;&gt;(); // requiredKeys 가 JobParameters Key 에 모두 포함이 됐는지 검증한다. for (String key : requiredKeys) &#123; if (!keys.contains(key)) &#123; missingKeys.add(key); &#125; &#125; if (!missingKeys.isEmpty()) &#123; throw new JobParametersInvalidException(&quot;The JobParameters do not contain required keys: &quot; + missingKeys); &#125;&#125;","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobParameters 검증 - JobParametersValidatorJobParametersValidator 릍 통한 JobParameters 검증은 Job 을 실행하기 전에 SimpleJobLauncher 내부에서 한번 Job 이 실행할때 SimpleJobL 에서 한번 총 두번의 Validation 을 진행한다. public interface JobParametersValidator &#123; void validate(@Nullable JobParameters parameters) throws JobParametersInvalidException;&#125; JobParametersValidator 기본 구현체 - DefaultJobParametersValidator requiredKeys JobParameter 에 필수적으로 포함되어야 할 Key 필수 Key 가 없을 경우 JobParametersInvalidException 예외를 발생시킨다. optionalKeys JobParameter 에 선택적으로 포함되어야 할 Key public DefaultJobParametersValidator(String[] requiredKeys, String[] optionalKeys) &#123; super(); setRequiredKeys(requiredKeys); setOptionalKeys(optionalKeys);&#125;@Overridepublic void validate(@Nullable JobParameters parameters) throws JobParametersInvalidException &#123; if (parameters == null) &#123; throw new JobParametersInvalidException(&quot;The JobParameters can not be null&quot;); &#125; Set&lt;String&gt; keys = parameters.getParameters().keySet(); // optionalKeys 가 있을 경우에만 실행 if (!optionalKeys.isEmpty()) &#123; Collection&lt;String&gt; missingKeys = new HashSet&lt;&gt;(); // JobParameters Key 에 대한 검증을 한다. for (String key : keys) &#123; if (!optionalKeys.contains(key) &amp;&amp; !requiredKeys.contains(key)) &#123; missingKeys.add(key); &#125; &#125; // JobParameters 로 넘어온 Key 가 requiredKeys 에도 optionalKeys 에도 없으면 JobParametersInvalidException 예외를 발생시킨다. if (!missingKeys.isEmpty()) &#123; throw new JobParametersInvalidException( &quot;The JobParameters contains keys that are not explicitly optional or required: &quot; + missingKeys); &#125; &#125; Collection&lt;String&gt; missingKeys = new HashSet&lt;&gt;(); // requiredKeys 가 JobParameters Key 에 모두 포함이 됐는지 검증한다. for (String key : requiredKeys) &#123; if (!keys.contains(key)) &#123; missingKeys.add(key); &#125; &#125; if (!missingKeys.isEmpty()) &#123; throw new JobParametersInvalidException(&quot;The JobParameters do not contain required keys: &quot; + missingKeys); &#125;&#125; @Beanpublic Job batchJob() &#123; return this.jobBuilderFactory.get(&quot;batchJob&quot;) .start(step1()) .next(step2()) .next(step3()) .validator(new DefaultJobParametersValidator(new String[]&#123;&quot;name&quot;, &quot;date&quot;&#125;,new String[]&#123;&quot;count&quot;&#125;)) .build();&#125; public class CustomJobParametersValidator implements JobParametersValidator &#123; @Override public void validate(JobParameters jobParameters) throws JobParametersInvalidException &#123; if (jobParameters.getString(&quot;name&quot;) == null) &#123; throw new JobParametersInvalidException(&quot;name parameter is not found.&quot;); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"}],"tags":[]},{"title":"Spring Batch - 16. SimpleJob 와 SimpleJobLauncher","slug":"spring/spring-batch/job/spring-batch-16-SimpleJob","date":"2023-04-04T06:25:35.000Z","updated":"2024-02-26T15:29:30.493Z","comments":true,"path":"2023/04/04/spring/spring-batch/job/spring-batch-16-SimpleJob/","link":"","permalink":"https://ckck803.github.io/2023/04/04/spring/spring-batch/job/spring-batch-16-SimpleJob/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing SimpleJob Step 을 실행시킬 수 있는 Job 의 구현체로서 SimpleJobBuilder 에 의해 생성된다. 하나 이상의 Step 으로 구성되며 순차적으로 Step 을 실행시킨다. 모든 Step 의 실행이 성공적으로 완료 돼야 Job 이 최종적으로 성공 상태가 된다. SimpleJob 메소드 start 최초로 한번 설정 한 후 SimpleJobBuilder 가 생성되고 반환된다. next 다음 실행할 step 들을 순차적으로 연결하도록 설정 validator Job 실행에 필요한 Parameter 를 검증 DefaultJobParametersValidator 구현체를 지원하며 JobParametersValidator 인터페이스를 직접 구현할 수 있다. preventRestart Job 의 재실행을 방지 하는 설정 incrementer JobParameter 에서 필요한 값을 증가 시켜 다음에 사용할 JobParameter 오브젝트를 리턴 RunIdIncrementer 구현체를 지원하며 JobParametersIncrementer 인터페이스를 직접 구현할 수 있다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing SimpleJob Step 을 실행시킬 수 있는 Job 의 구현체로서 SimpleJobBuilder 에 의해 생성된다. 하나 이상의 Step 으로 구성되며 순차적으로 Step 을 실행시킨다. 모든 Step 의 실행이 성공적으로 완료 돼야 Job 이 최종적으로 성공 상태가 된다. SimpleJob 메소드 start 최초로 한번 설정 한 후 SimpleJobBuilder 가 생성되고 반환된다. next 다음 실행할 step 들을 순차적으로 연결하도록 설정 validator Job 실행에 필요한 Parameter 를 검증 DefaultJobParametersValidator 구현체를 지원하며 JobParametersValidator 인터페이스를 직접 구현할 수 있다. preventRestart Job 의 재실행을 방지 하는 설정 incrementer JobParameter 에서 필요한 값을 증가 시켜 다음에 사용할 JobParameter 오브젝트를 리턴 RunIdIncrementer 구현체를 지원하며 JobParametersIncrementer 인터페이스를 직접 구현할 수 있다. public class SimpleJob extends AbstractJob &#123; private List&lt;Step&gt; steps = new ArrayList&lt;&gt;(); public SimpleJob() &#123; this(null); &#125; public SimpleJob(String name) &#123; super(name); &#125; public void setSteps(List&lt;Step&gt; steps) &#123; this.steps.clear(); this.steps.addAll(steps); &#125; @Override public Collection&lt;String&gt; getStepNames() &#123; List&lt;String&gt; names = new ArrayList&lt;&gt;(); for (Step step : steps) &#123; names.add(step.getName()); if(step instanceof StepLocator) &#123; names.addAll(((StepLocator)step).getStepNames()); &#125; &#125; return names; &#125; public void addStep(Step step) &#123; this.steps.add(step); &#125; @Override public Step getStep(String stepName) &#123; for (Step step : this.steps) &#123; if (step.getName().equals(stepName)) &#123; return step; &#125; else if(step instanceof StepLocator) &#123; Step result = ((StepLocator)step).getStep(stepName); if(result != null) &#123; return result; &#125; &#125; &#125; return null; &#125; @Override protected void doExecute(JobExecution execution) throws JobInterruptedException, JobRestartException, StartLimitExceededException &#123; StepExecution stepExecution = null; for (Step step : steps) &#123; stepExecution = handleStep(step, execution); if (stepExecution.getStatus() != BatchStatus.COMPLETED) &#123; // // Terminate the job if a step fails // break; &#125; &#125; if (stepExecution != null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Upgrading JobExecution status: &quot; + stepExecution); &#125; execution.upgradeStatus(stepExecution.getStatus()); execution.setExitStatus(stepExecution.getExitStatus()); &#125; &#125;&#125; SimpleJobLauncherSimpleJobLauncher 는 JobLauncher 인터페이스의 구현체로 SimpleJob 을 실행합니다. public class SimpleJobLauncher implements JobLauncher, InitializingBean &#123; protected static final Log logger = LogFactory.getLog(SimpleJobLauncher.class); private JobRepository jobRepository; private TaskExecutor taskExecutor; @Override public JobExecution run(final Job job, final JobParameters jobParameters) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException &#123; Assert.notNull(job, &quot;The Job must not be null.&quot;); Assert.notNull(jobParameters, &quot;The JobParameters must not be null.&quot;); final JobExecution jobExecution; // 마지막으로 실행된 JobExecution 객체가 있는지 확인한다. JobExecution lastExecution = jobRepository.getLastJobExecution(job.getName(), jobParameters); if (lastExecution != null) &#123; // Job Restart 설정을 확인한다. if (!job.isRestartable()) &#123; throw new JobRestartException(&quot;JobInstance already exists and is not restartable&quot;); &#125; for (StepExecution execution : lastExecution.getStepExecutions()) &#123; BatchStatus status = execution.getStatus(); if (status.isRunning() || status == BatchStatus.STOPPING) &#123; throw new JobExecutionAlreadyRunningException(&quot;A job execution for this job is already running: &quot; + lastExecution); &#125; else if (status == BatchStatus.UNKNOWN) &#123; throw new JobRestartException( &quot;Cannot restart step [&quot; + execution.getStepName() + &quot;] from UNKNOWN status. &quot; + &quot;The last execution ended with a failure that could not be rolled back, &quot; + &quot;so it may be dangerous to proceed. Manual intervention is probably necessary.&quot;); &#125; &#125; &#125; // JobParamter 에 대한 검증을 진행한다. job.getJobParametersValidator().validate(jobParameters); jobExecution = jobRepository.createJobExecution(job.getName(), jobParameters); try &#123; taskExecutor.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Job: [&quot; + job + &quot;] launched with the following parameters: [&quot; + jobParameters + &quot;]&quot;); &#125; job.execute(jobExecution); if (logger.isInfoEnabled()) &#123; Duration jobExecutionDuration = BatchMetrics.calculateDuration(jobExecution.getStartTime(), jobExecution.getEndTime()); logger.info(&quot;Job: [&quot; + job + &quot;] completed with the following parameters: [&quot; + jobParameters + &quot;] and the following status: [&quot; + jobExecution.getStatus() + &quot;]&quot; + (jobExecutionDuration == null ? &quot;&quot; : &quot; in &quot; + BatchMetrics.formatDuration(jobExecutionDuration))); &#125; &#125; catch (Throwable t) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Job: [&quot; + job + &quot;] failed unexpectedly and fatally with the following parameters: [&quot; + jobParameters + &quot;]&quot;, t); &#125; rethrow(t); &#125; &#125; private void rethrow(Throwable t) &#123; if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else if (t instanceof Error) &#123; throw (Error) t; &#125; throw new IllegalStateException(t); &#125; &#125;); &#125; catch (TaskRejectedException e) &#123; jobExecution.upgradeStatus(BatchStatus.FAILED); if (jobExecution.getExitStatus().equals(ExitStatus.UNKNOWN)) &#123; jobExecution.setExitStatus(ExitStatus.FAILED.addExitDescription(e)); &#125; jobRepository.update(jobExecution); &#125; return jobExecution; &#125; public void setJobRepository(JobRepository jobRepository) &#123; this.jobRepository = jobRepository; &#125; public void setTaskExecutor(TaskExecutor taskExecutor) &#123; this.taskExecutor = taskExecutor; &#125; @Override public void afterPropertiesSet() throws Exception &#123; Assert.state(jobRepository != null, &quot;A JobRepository has not been set.&quot;); if (taskExecutor == null) &#123; logger.info(&quot;No TaskExecutor has been set, defaulting to synchronous executor.&quot;); taskExecutor = new SyncTaskExecutor(); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"}],"tags":[]},{"title":"Spring Batch - 15. JobBuilderFactory & JobBuilder","slug":"spring/spring-batch/job/spring-batch-15-JobBuilderFactory","date":"2023-04-02T06:25:35.000Z","updated":"2024-02-26T15:29:26.805Z","comments":true,"path":"2023/04/02/spring/spring-batch/job/spring-batch-15-JobBuilderFactory/","link":"","permalink":"https://ckck803.github.io/2023/04/02/spring/spring-batch/job/spring-batch-15-JobBuilderFactory/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobBuilderFactory JobBuilder 객체를 생성하는 팩토리 클래스 jobBuilderFactory.get(“jobName”) “jobName” 은 스프링 배치가 Job 을 실행시킬때 참조하는 Job 이름 “jobNaem” 은 DB 에도 저장된다. JobBuilderFactory.java public class JobBuilderFactory &#123; private JobRepository jobRepository; public JobBuilderFactory(JobRepository jobRepository) &#123; this.jobRepository = jobRepository; &#125; public JobBuilder get(String name) &#123; // JobBuilder 클래스가 생성되는 시점에 JobRepository 객체가 전달된다. JobBuilder builder = new JobBuilder(name).repository(jobRepository); return builder; &#125;&#125; JobBuilder","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobBuilderFactory JobBuilder 객체를 생성하는 팩토리 클래스 jobBuilderFactory.get(“jobName”) “jobName” 은 스프링 배치가 Job 을 실행시킬때 참조하는 Job 이름 “jobNaem” 은 DB 에도 저장된다. JobBuilderFactory.java public class JobBuilderFactory &#123; private JobRepository jobRepository; public JobBuilderFactory(JobRepository jobRepository) &#123; this.jobRepository = jobRepository; &#125; public JobBuilder get(String name) &#123; // JobBuilder 클래스가 생성되는 시점에 JobRepository 객체가 전달된다. JobBuilder builder = new JobBuilder(name).repository(jobRepository); return builder; &#125;&#125; JobBuilder Job 을 구성하는 설정 조건에 따라 두개의 하위 Builder 클래스를 생성하고 실제 Job 생성을 위임 한다. start() 에 Step 객체가 들어가면 SimpleJobBuilder 를 반환한다. start() 에 Flow 객체가 들어가면 FlowJobBuilder 를 반환한다. flow() 에 Step 객체가 들어가면 FlowJobBuilder 를 반환한다. SimpleJobBuilder SimpleJob 을 생성하는 Builder 클래스 FlowJobBuilder FlowJob 을 생성하는 Builder 클래스 JobBuilder.java public class JobBuilder extends JobBuilderHelper&lt;JobBuilder&gt; &#123; public JobBuilder(String name) &#123; super(name); &#125; // Parameter 가 Step 객체일 경우 SimpleJobBuilder 객체를 반환한다. public SimpleJobBuilder start(Step step) &#123; return new SimpleJobBuilder(this).start(step); &#125; // Parameter 가 Flow 객체일 경우 JobFlowBuilder 객체를 반환한다. public JobFlowBuilder start(Flow flow) &#123; return new FlowJobBuilder(this).start(flow); &#125; // Parameter 가 Step 객체일 경우 JobFlowBuilder 객체를 반환한다. public JobFlowBuilder flow(Step step) &#123; return new FlowJobBuilder(this).start(step); &#125;&#125; JobBuilder 클래스는 JobBuilderHelper 클래스를 상속하고 있다. CommonJobProperties 는 Job 생성에 사용되는 공통 속성을 정의하는 클래스 CommonJobProperties 는 JobBuilderFactory에서 사용됩니다. JobBuilderHelper 는 CommonJobProperties 를 참조하고 있다. JobBuilder 클래스는 SimpleJobRepository 클래스를 참조하고 있다. JobRepository 는 Job 이 생성되는 시점, JobBuilder 가 구동되는 시점부터 전달돼 메타 데이터들을 저장하기 위한 초기화 작업을 한다. JobBuilderHelperpublic abstract class JobBuilderHelper&lt;B extends JobBuilderHelper&lt;B&gt;&gt; &#123; protected final Log logger = LogFactory.getLog(getClass()); private final CommonJobProperties properties; public JobBuilderHelper(String name) &#123; this.properties = new CommonJobProperties(); properties.name = name; &#125; protected JobBuilderHelper(JobBuilderHelper&lt;?&gt; parent) &#123; this.properties = new CommonJobProperties(parent.properties); &#125; public B validator(JobParametersValidator jobParametersValidator) &#123; properties.jobParametersValidator = jobParametersValidator; @SuppressWarnings(&quot;unchecked&quot;) B result = (B) this; return result; &#125; public B incrementer(JobParametersIncrementer jobParametersIncrementer) &#123; properties.jobParametersIncrementer = jobParametersIncrementer; @SuppressWarnings(&quot;unchecked&quot;) B result = (B) this; return result; &#125; public B repository(JobRepository jobRepository) &#123; properties.jobRepository = jobRepository; @SuppressWarnings(&quot;unchecked&quot;) B result = (B) this; return result; &#125; public B listener(Object listener) &#123; Set&lt;Method&gt; jobExecutionListenerMethods = new HashSet&lt;&gt;(); jobExecutionListenerMethods.addAll(ReflectionUtils.findMethod(listener.getClass(), BeforeJob.class)); jobExecutionListenerMethods.addAll(ReflectionUtils.findMethod(listener.getClass(), AfterJob.class)); if(jobExecutionListenerMethods.size() &gt; 0) &#123; JobListenerFactoryBean factory = new JobListenerFactoryBean(); factory.setDelegate(listener); properties.addJobExecutionListener((JobExecutionListener) factory.getObject()); &#125; @SuppressWarnings(&quot;unchecked&quot;) B result = (B) this; return result; &#125; public B listener(JobExecutionListener listener) &#123; properties.addJobExecutionListener(listener); @SuppressWarnings(&quot;unchecked&quot;) B result = (B) this; return result; &#125; public B preventRestart() &#123; properties.restartable = false; @SuppressWarnings(&quot;unchecked&quot;) B result = (B) this; return result; &#125; protected String getName() &#123; return properties.name; &#125; protected JobRepository getJobRepository() &#123; return properties.jobRepository; &#125; protected boolean isRestartable() &#123; return properties.restartable; &#125; protected void enhance(Job target) &#123; if (target instanceof AbstractJob) &#123; AbstractJob job = (AbstractJob) target; job.setJobRepository(properties.getJobRepository()); // JobParametersIncrementer 설정 JobParametersIncrementer jobParametersIncrementer = properties.getJobParametersIncrementer(); if (jobParametersIncrementer != null) &#123; job.setJobParametersIncrementer(jobParametersIncrementer); &#125; // JobParametersIncrementer 설정 JobParametersValidator jobParametersValidator = properties.getJobParametersValidator(); if (jobParametersValidator != null) &#123; job.setJobParametersValidator(jobParametersValidator); &#125; Boolean restartable = properties.getRestartable(); if (restartable != null) &#123; job.setRestartable(restartable); &#125; List&lt;JobExecutionListener&gt; listeners = properties.getJobExecutionListeners(); if (!listeners.isEmpty()) &#123; job.setJobExecutionListeners(listeners.toArray(new JobExecutionListener[0])); &#125; &#125; &#125; public static class CommonJobProperties &#123; private Set&lt;JobExecutionListener&gt; jobExecutionListeners = new LinkedHashSet&lt;&gt;(); private boolean restartable = true; private JobRepository jobRepository; private JobParametersIncrementer jobParametersIncrementer; private JobParametersValidator jobParametersValidator; public CommonJobProperties() &#123; &#125; public CommonJobProperties(CommonJobProperties properties) &#123; this.name = properties.name; this.restartable = properties.restartable; this.jobRepository = properties.jobRepository; this.jobExecutionListeners = new LinkedHashSet&lt;&gt;(properties.jobExecutionListeners); this.jobParametersIncrementer = properties.jobParametersIncrementer; this.jobParametersValidator = properties.jobParametersValidator; &#125; public JobParametersIncrementer getJobParametersIncrementer() &#123; return jobParametersIncrementer; &#125; public void setJobParametersIncrementer(JobParametersIncrementer jobParametersIncrementer) &#123; this.jobParametersIncrementer = jobParametersIncrementer; &#125; public JobParametersValidator getJobParametersValidator() &#123; return jobParametersValidator; &#125; public void setJobParametersValidator(JobParametersValidator jobParametersValidator) &#123; this.jobParametersValidator = jobParametersValidator; &#125; public JobRepository getJobRepository() &#123; return jobRepository; &#125; public void setJobRepository(JobRepository jobRepository) &#123; this.jobRepository = jobRepository; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;JobExecutionListener&gt; getJobExecutionListeners() &#123; return new ArrayList&lt;&gt;(jobExecutionListeners); &#125; public void addStepExecutionListeners(List&lt;JobExecutionListener&gt; jobExecutionListeners) &#123; this.jobExecutionListeners.addAll(jobExecutionListeners); &#125; public void addJobExecutionListener(JobExecutionListener jobExecutionListener) &#123; this.jobExecutionListeners.add(jobExecutionListener); &#125; public boolean getRestartable() &#123; return restartable; &#125; public void setRestartable(boolean restartable) &#123; this.restartable = restartable; &#125; private String name; &#125;&#125; @Beanpublic Job batchJob1() &#123; return this.jobBuilderFactory.get(&quot;batchJob1&quot;) .incrementer(new RunIdIncrementer()) .start(step1()) .next(step2()) .build();&#125;@Beanpublic Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; System.out.println(&quot;&gt;&gt; step1 has executed&quot;); return RepeatStatus.FINISHED; &#125;) .build();&#125;@Beanpublic Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; System.out.println(&quot;&gt;&gt; step2 has executed&quot;); return RepeatStatus.FINISHED; &#125;) .build();&#125; @Beanpublic Job batchJob2() &#123; return this.jobBuilderFactory.get(&quot;batchJob1&quot;) .incrementer(new RunIdIncrementer()) .start(flow()) .next(step2()) .end() .build();&#125; @Beanpublic Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; System.out.println(&quot;&gt;&gt; step2 has executed&quot;); return RepeatStatus.FINISHED; &#125;) .build();&#125;@Beanpublic Flow flow() &#123; FlowBuilder&lt;Flow&gt; flowBuilder = new FlowBuilder&lt;&gt;(&quot;flow&quot;); flowBuilder.start(step3()) .next(step4()) .end(); return flowBuilder.build();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Spring Batch - JobRegistry","slug":"spring/spring-batch/job/spring-batch-JobRegistry","date":"2023-04-02T06:25:35.000Z","updated":"2024-02-26T15:29:49.864Z","comments":true,"path":"2023/04/02/spring/spring-batch/job/spring-batch-JobRegistry/","link":"","permalink":"https://ckck803.github.io/2023/04/02/spring/spring-batch/job/spring-batch-JobRegistry/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobRegistry JobRegistry 는 JobLauncher가 실행할 수 있는 Job을 등록하고 관리하는 인터페이스, JobRegistry는 일반적으로 JobLauncher를 생성하는 데 사용됩니다. JobRegistry를 사용하면 JobLauncher가 실행할 수 있는 Job을 등록하고, 실행 시간에 등록된 Job을 선택할 수 있습니다. JobRegistry는 다양한 방법으로 구현될 수 있으며, XML 파일, 데이터베이스, 자바 구성 등에서 Job을 등록할 수 있습니다. JobRegistry는 Spring Batch에서 Job을 실행하는 방법 중 하나입니다. 다른 방법으로는 JobRepository를 사용하여 Job을 저장하고, JobOperator를 사용하여 Job을 실행하는 방법이 있습니다. JobRegistry는 JobLauncher를 생성하는 데 사용되며, JobLauncher는 Job을 실행합니다. JobRegistry는 Spring Batch에서 Job의 관리 및 실행을 간편하게 할 수 있는 기능을 제공합니다. JobRegistry를 사용하면 Job을 등록하여 여러 Job을 실행할 수 있고, Job을 실행할 때마다 새로운 Job을 만들 필요가 없습니다. 또한 JobRegistry를 사용하면 JobLauncher를 생성하는 과정을 단순화할 수 있습니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 24. FlowJob Post not found: spring/spring-batch/tasklet/spring-batch-23-JobStep Spring Batch - 22. Tasklet 기반 Step Spring Batch - 21. TaskletStep Spring Batch - 20. StepBuilderFactory 와 StepBuilder Spring Batch - 19. JobParameters 증가 JobParametersIncrementer Spring Batch - 18. Job 의 재시작 방지 preventRestart Spring Batch - 17. JobParameters 검증 JobParametersValidator Spring Batch - 16. SimpleJob 와 SimpleJobLauncher Spring Batch - 15. JobBuilderFactory &amp; JobBuilder Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobRegistry JobRegistry 는 JobLauncher가 실행할 수 있는 Job을 등록하고 관리하는 인터페이스, JobRegistry는 일반적으로 JobLauncher를 생성하는 데 사용됩니다. JobRegistry를 사용하면 JobLauncher가 실행할 수 있는 Job을 등록하고, 실행 시간에 등록된 Job을 선택할 수 있습니다. JobRegistry는 다양한 방법으로 구현될 수 있으며, XML 파일, 데이터베이스, 자바 구성 등에서 Job을 등록할 수 있습니다. JobRegistry는 Spring Batch에서 Job을 실행하는 방법 중 하나입니다. 다른 방법으로는 JobRepository를 사용하여 Job을 저장하고, JobOperator를 사용하여 Job을 실행하는 방법이 있습니다. JobRegistry는 JobLauncher를 생성하는 데 사용되며, JobLauncher는 Job을 실행합니다. JobRegistry는 Spring Batch에서 Job의 관리 및 실행을 간편하게 할 수 있는 기능을 제공합니다. JobRegistry를 사용하면 Job을 등록하여 여러 Job을 실행할 수 있고, Job을 실행할 때마다 새로운 Job을 만들 필요가 없습니다. 또한 JobRegistry를 사용하면 JobLauncher를 생성하는 과정을 단순화할 수 있습니다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Spring Batch - 14. 배치 초기화 설정 (application.properties)","slug":"spring/spring-batch/spring-batch-14-batch-initialize","date":"2023-04-01T06:25:35.000Z","updated":"2024-02-26T15:30:48.451Z","comments":true,"path":"2023/04/01/spring/spring-batch/spring-batch-14-batch-initialize/","link":"","permalink":"https://ckck803.github.io/2023/04/01/spring/spring-batch/spring-batch-14-batch-initialize/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing BatchAutoConfiguration BatchAutoConfiguration 에서는 ApplicationRunner 의 일종인 JobLauncherApplicationRunner 를 생성한다. BatchAutoConfiguration은 @EnableBatchProcessing 어노테이션을 사용하여 활성화됩니다. BatchAutoConfiguration.java public class BatchAutoConfiguration &#123; @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = &quot;spring.batch.job&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true) public JobLauncherApplicationRunner jobLauncherApplicationRunner(JobLauncher jobLauncher, JobExplorer jobExplorer, JobRepository jobRepository, BatchProperties properties) &#123; // JobLauncher 객체와 JobExplorer 객체와 JobRepository 객체를 이용해 JobLauncherApplicationRunner 객체를 생성한다. JobLauncherApplicationRunner runner = new JobLauncherApplicationRunner(jobLauncher, jobExplorer, jobRepository); // Application Properties 에 등록된 Job 이름들을 가져온다. String jobNames = properties.getJob().getNames(); if (StringUtils.hasText(jobNames)) &#123; runner.setJobNames(jobNames); &#125; return runner; &#125; ... 이하 생략 ...&#125; JobLauncherApplicationRunner","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing BatchAutoConfiguration BatchAutoConfiguration 에서는 ApplicationRunner 의 일종인 JobLauncherApplicationRunner 를 생성한다. BatchAutoConfiguration은 @EnableBatchProcessing 어노테이션을 사용하여 활성화됩니다. BatchAutoConfiguration.java public class BatchAutoConfiguration &#123; @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = &quot;spring.batch.job&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true) public JobLauncherApplicationRunner jobLauncherApplicationRunner(JobLauncher jobLauncher, JobExplorer jobExplorer, JobRepository jobRepository, BatchProperties properties) &#123; // JobLauncher 객체와 JobExplorer 객체와 JobRepository 객체를 이용해 JobLauncherApplicationRunner 객체를 생성한다. JobLauncherApplicationRunner runner = new JobLauncherApplicationRunner(jobLauncher, jobExplorer, jobRepository); // Application Properties 에 등록된 Job 이름들을 가져온다. String jobNames = properties.getJob().getNames(); if (StringUtils.hasText(jobNames)) &#123; runner.setJobNames(jobNames); &#125; return runner; &#125; ... 이하 생략 ...&#125; JobLauncherApplicationRunner Spring boot 에서 제공하는 ApplicationRunner 의 구현체 로 어플리케이션이 구동되자마자 실행되며 Bean 으로 등록된 모든 Job 을 실행시킨다. JobLauncherApplicationRunner 는 JobLauncher 클래스를 이용해 JobRegistry 에 등록된 모든 Job을 실행시킵니다. 이러한 실행은 ApplicationContext 가 완전히 로드되고 실행된 후에 시작됩니다. 실행 시점에서 등록된 모든 Job을 가져와 실행하므로 Job 이름이 고유해야 합니다. JobLauncherApplicationRunner 를 사용하려면 애플리케이션에서 @EnableBatchProcessing 을 사용하여 Spring Batch를 활성화하고, JobLauncherApplicationRunner 를 Bean 으로 등록해야 합니다. 그러면 Spring Boot 애플리케이션이 시작될 때 JobLauncherApplicationRunner가 실행되어 등록된 모든 Job을 자동으로 실행시키게 됩니다. JobLauncherApplicationRunner는 Spring Batch Job 을 자동으로 실행하는 간단한 방법을 제공합니다. 그러나 Job 을 실행할 때 매개변수를 지정해야 하는 경우나, 실행 조건이나 Job 실행 전&#x2F;후 처리를 추가해야 하는 경우에는 보다 유연한 방법으로 JobLauncher 를 직접 사용해야 합니다. JobLauncherApplicationRunner 객체는 execute 라는 메소드를 이용해 내부에 가지고 있는 JobLauncher 객체를 이용해 Job 을 수행한다. JobLauncherApplicationRunner.java public class JobLauncherApplicationRunner implements ApplicationRunner, Ordered, ApplicationEventPublisherAware &#123; ... 생략 ... private final JobLauncher jobLauncher; // Spring Boot 가 Job 을 Scan 한 후에 JobLauncherApplicationRunner 에 전달해준다. // JobLauncherApplicationRunner 는 여러개의 Job 을 가지고 있을 수 있게 된다. @Autowired(required = false) public void setJobs(Collection&lt;Job&gt; jobs) &#123; this.jobs = jobs; &#125; protected void execute(Job job, JobParameters jobParameters) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException, JobParametersNotFoundException &#123; JobParameters parameters = getNextJobParameters(job, jobParameters); // JobLauncher 를 이용해 Job 을 수행하는 역할을 한다. JobExecution execution = this.jobLauncher.run(job, parameters); if (this.publisher != null) &#123; this.publisher.publishEvent(new JobExecutionEvent(execution)); &#125; &#125; // @Override public void run(ApplicationArguments args) throws Exception &#123; String[] jobArguments = args.getNonOptionArgs().toArray(new String[0]); run(jobArguments); &#125; public void run(String... args) throws JobExecutionException &#123; logger.info(&quot;Running default command line with: &quot; + Arrays.asList(args)); launchJobFromProperties(StringUtils.splitArrayElementsIntoProperties(args, &quot;=&quot;)); &#125; protected void launchJobFromProperties(Properties properties) throws JobExecutionException &#123; // Argument 들을 JobParameters 객체로 변환해 저장한다. JobParameters jobParameters = this.converter.getJobParameters(properties); executeLocalJobs(jobParameters); executeRegisteredJobs(jobParameters); &#125; // Batch Properties 로 등록된 Job 들이 있을 경우 실행한다. private void executeLocalJobs(JobParameters jobParameters) throws JobExecutionException &#123; for (Job job : this.jobs) &#123; // spring.batch.job.names 에 등록된 Job 이 있는지 확인한다. // 특정한 Job 만을 실행하고 싶을 경우 사용한다. if (StringUtils.hasText(this.jobNames)) &#123; String[] jobsToRun = this.jobNames.split(&quot;,&quot;); if (!PatternMatchUtils.simpleMatch(jobsToRun, job.getName())) &#123; logger.debug(LogMessage.format(&quot;Skipped job: %s&quot;, job.getName())); continue; &#125; &#125; // Job 을 실행한다. execute(job, jobParameters); &#125; &#125; // JobRegistry 에 등록된 모든 Job을 실행합니다 private void executeRegisteredJobs(JobParameters jobParameters) throws JobExecutionException &#123; if (this.jobRegistry != null &amp;&amp; StringUtils.hasText(this.jobNames)) &#123; String[] jobsToRun = this.jobNames.split(&quot;,&quot;); for (String jobName : jobsToRun) &#123; try &#123; Job job = this.jobRegistry.getJob(jobName); if (this.jobs.contains(job)) &#123; continue; &#125; execute(job, jobParameters); &#125; catch (NoSuchJobException ex) &#123; logger.debug(LogMessage.format(&quot;No job found in registry for job name: %s&quot;, jobName)); &#125; &#125; &#125; &#125; ... 생략 ...&#125; BatchProperties BatchProperties는 Spring Batch 의 설정을 담당하는 클래스 Job 이름, 스키마 초기화 설정, 테이블 Prefix 등의 값을 설정할 수 있다. application.properties 또는 application.yml 파일에 설정한다. BatchProperties.java // application.properties or application.yml 에서 spring.batch 가 Spring Batch 의 Prefix 다. @ConfigurationProperties(prefix = &quot;spring.batch&quot;)public class BatchProperties &#123; ... 생략 ...&#125; application.properties배치 잡의 실행 여부를 설정# Spring Boot 가 자동으로 실행시키는 Batch Job 을 실행시키도록 한다.spring.batch.job.enabled: true # default# Spring Boot 가 자동으로 실행시키는 Batch Job 을 실행하지 않도록 한다.spring.batch.job.enabled: false 배치 잡의 재시작 여부를 설정# 기본이 true, 재시작을 허용한다.spring.batch.job.restartable: true# 재시작을 허용g하지 않는다spring.batch.job.restartable: false 실행할 배치 잡의 이름을 지정 지정한 Job 만 실행하도록 설정한다. spring.batch.job.names: ${job.name.NONE} # Hard Coding 방식spring.batch.job.names: springJob1# Binding 을 사용한 방식# Default 는 NONE 으로 아무 Job 도 실행시키지 않는다.spring.batch.job.names: $&#123;job.name:NONE&#125; 어플리케이션 실행시 Program arguments 로 job 이름 입력한다. --job.name=helloJob --job.name=helloJob.simpleJob 하나 이상의 job 을 실행할 경우 쉼표로 구분해서 입력 한다. 어플리케이션 실행시점에 Argument 로 넘겨서 Binding 되도록 한다. 배치 잡에서 허용하는 실패 횟수를 설정# 배치 잡에서 허용하는 실패 횟수를 설정한다. default: 3spring.batch.job.failures-allowed: 3 배치 잡에서 생성되는 메타 데이터 테이블 스키마 생성여부를 설정spring.batch.jdbc.initialize-schema: alwaysspring.batch.jdbc.initialize-schema: embeddedspring.batch.jdbc.initialize-schema: never 배치 잡에서 생성되는 메타 데이터 테이블 Prefix 를 설정한다.spring.batch.jdbc.table-prefix: Job 실행 옵션","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"쿠버네티스 - ReadinessProbe & LivenessProbe","slug":"k8s/pod/ReadinessProbe_LivenessProbe","date":"2023-03-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.541Z","comments":true,"path":"2023/03/08/k8s/pod/ReadinessProbe_LivenessProbe/","link":"","permalink":"https://ckck803.github.io/2023/03/08/k8s/pod/ReadinessProbe_LivenessProbe/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s Pod Pod 는 쿠버네티스에서 관리하는 가장 작은 배포 단위 쿠버네티스는 Pod 을 이용해 Container 를 관리 한다. Pod 는 단일 Node 에서 실행되며 각각의 Pod 는 고유한 IP 와 Host 이름을 가지고 있다. 쿠버네티스는 Pod 을 배포 하고 Pod 안에 한개 이상의 컨테이너가 존재한다. Pod 내 Container는 모두 동일한 Host 에서 실행되며 Network 와 저장소를 공유한다. apiVersion: v1kind: Podmetadata: name: echo labels: app: echospec: containers: - name: app image: ghcr.io/subicura/echo:v1 다중 컨테이너","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s Pod Pod 는 쿠버네티스에서 관리하는 가장 작은 배포 단위 쿠버네티스는 Pod 을 이용해 Container 를 관리 한다. Pod 는 단일 Node 에서 실행되며 각각의 Pod 는 고유한 IP 와 Host 이름을 가지고 있다. 쿠버네티스는 Pod 을 배포 하고 Pod 안에 한개 이상의 컨테이너가 존재한다. Pod 내 Container는 모두 동일한 Host 에서 실행되며 Network 와 저장소를 공유한다. apiVersion: v1kind: Podmetadata: name: echo labels: app: echospec: containers: - name: app image: ghcr.io/subicura/echo:v1 다중 컨테이너","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"워크로드","slug":"Kubernetes/워크로드","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C/"}],"tags":[]},{"title":"EKS - Cluster Autoscaler","slug":"aws/eks/eks-autoscaler","date":"2023-03-05T21:31:07.000Z","updated":"2024-02-18T16:19:54.516Z","comments":true,"path":"2023/03/06/aws/eks/eks-autoscaler/","link":"","permalink":"https://ckck803.github.io/2023/03/06/aws/eks/eks-autoscaler/","excerpt":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://github.com/kubernetes/autoscaler https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/what-is-amazon-ec2-auto-scaling.html &#123; &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ &#123; &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;autoscaling:DescribeAutoScalingGroups&quot;, &quot;autoscaling:DescribeAutoScalingInstances&quot;, &quot;autoscaling:DescribeLaunchConfigurations&quot;, &quot;autoscaling:DescribeScalingActivities&quot;, &quot;autoscaling:DescribeTags&quot;, &quot;ec2:DescribeInstanceTypes&quot;, &quot;ec2:DescribeLaunchTemplateVersions&quot; ], &quot;Resource&quot;: [&quot;*&quot;] &#125;, &#123; &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;autoscaling:SetDesiredCapacity&quot;, &quot;autoscaling:TerminateInstanceInAutoScalingGroup&quot;, &quot;ec2:DescribeImages&quot;, &quot;ec2:GetInstanceTypesFromInstanceRequirements&quot;, &quot;eks:DescribeNodegroup&quot; ], &quot;Resource&quot;: [&quot;*&quot;] &#125; ]&#125; helm repo add autoscaler https://kubernetes.github.io/autoscaler helm show values autoscaler/cluster-autoscaler 적용 대상 node에는 아래의 tag가 달려야 한다. k8s.io/cluster-autoscaler/skcc-dev-floot-eks: ownedk8s.io/cluster-autoscaler/enabled: true","text":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://github.com/kubernetes/autoscaler https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/what-is-amazon-ec2-auto-scaling.html &#123; &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ &#123; &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;autoscaling:DescribeAutoScalingGroups&quot;, &quot;autoscaling:DescribeAutoScalingInstances&quot;, &quot;autoscaling:DescribeLaunchConfigurations&quot;, &quot;autoscaling:DescribeScalingActivities&quot;, &quot;autoscaling:DescribeTags&quot;, &quot;ec2:DescribeInstanceTypes&quot;, &quot;ec2:DescribeLaunchTemplateVersions&quot; ], &quot;Resource&quot;: [&quot;*&quot;] &#125;, &#123; &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;autoscaling:SetDesiredCapacity&quot;, &quot;autoscaling:TerminateInstanceInAutoScalingGroup&quot;, &quot;ec2:DescribeImages&quot;, &quot;ec2:GetInstanceTypesFromInstanceRequirements&quot;, &quot;eks:DescribeNodegroup&quot; ], &quot;Resource&quot;: [&quot;*&quot;] &#125; ]&#125; helm repo add autoscaler https://kubernetes.github.io/autoscaler helm show values autoscaler/cluster-autoscaler 적용 대상 node에는 아래의 tag가 달려야 한다. k8s.io/cluster-autoscaler/skcc-dev-floot-eks: ownedk8s.io/cluster-autoscaler/enabled: true","categories":[{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"}],"tags":[]},{"title":"EKS - EFS CSI Driver 설치","slug":"aws/eks/eks-efs","date":"2023-03-04T22:31:07.000Z","updated":"2024-02-18T16:19:54.516Z","comments":true,"path":"2023/03/05/aws/eks/eks-efs/","link":"","permalink":"https://ckck803.github.io/2023/03/05/aws/eks/eks-efs/","excerpt":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://aws.amazon.com/ko/blogs/tech/persistent-storage-for-kubernetes/ EFS CSI Driver 설치를 위한 EKS 내 Service Account 생성curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-efs-csi-driver/master/docs/iam-policy-example.json aws iam create-policy \\ --policy-name AmazonEKS_EFS_CSI_Driver_Policy \\ --policy-document file://iam-policy-example.json eksctl create iamserviceaccount \\ --cluster my-cluster \\ --namespace kube-system \\ --name efs-csi-controller-sa \\ --attach-policy-arn arn:aws:iam::&lt;111122223333&gt;:policy/AmazonEKS_EFS_CSI_Driver_Policy \\ --approve \\ --region &lt;region-code&gt; EBS CSI Driver 설치","text":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://aws.amazon.com/ko/blogs/tech/persistent-storage-for-kubernetes/ EFS CSI Driver 설치를 위한 EKS 내 Service Account 생성curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-efs-csi-driver/master/docs/iam-policy-example.json aws iam create-policy \\ --policy-name AmazonEKS_EFS_CSI_Driver_Policy \\ --policy-document file://iam-policy-example.json eksctl create iamserviceaccount \\ --cluster my-cluster \\ --namespace kube-system \\ --name efs-csi-controller-sa \\ --attach-policy-arn arn:aws:iam::&lt;111122223333&gt;:policy/AmazonEKS_EFS_CSI_Driver_Policy \\ --approve \\ --region &lt;region-code&gt; EBS CSI Driver 설치helm repo add aws-efs-csi-driver https://kubernetes-sigs.github.io/aws-efs-csi-driver/ helm repo update helm upgrade -i aws-efs-csi-driver aws-efs-csi-driver/aws-efs-csi-driver \\ --namespace kube-system \\ --set image.repository=602401143452.dkr.ecr.region-code.amazonaws.com/eks/aws-efs-csi-driver \\ --set controller.serviceAccount.create=false \\ --set controller.serviceAccount.name=efs-csi-controller-sa EBS StorageClass 생성kind: StorageClassapiVersion: storage.k8s.io/v1metadata: name: efs-scprovisioner: efs.csi.aws.comparameters: provisioningMode: efs-ap fileSystemId: &quot;&lt;EFS Filesystem ID&gt;&quot; directoryPerms: &quot;700&quot; gidRangeStart: &quot;1000&quot; # optional gidRangeEnd: &quot;2000&quot; # optional","categories":[{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"}],"tags":[]},{"title":"쿠버네티스 - k9s","slug":"k8s/k9s","date":"2023-03-04T21:31:46.000Z","updated":"2024-02-18T16:19:54.540Z","comments":true,"path":"2023/03/05/k8s/k9s/","link":"","permalink":"https://ckck803.github.io/2023/03/05/k8s/k9s/","excerpt":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod","text":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"}],"tags":[]},{"title":"쿠버네티스 - Resource 제한","slug":"k8s/autoscaler/resource","date":"2023-03-04T21:31:46.000Z","updated":"2024-02-18T16:19:54.536Z","comments":true,"path":"2023/03/05/k8s/autoscaler/resource/","link":"","permalink":"https://ckck803.github.io/2023/03/05/k8s/autoscaler/resource/","excerpt":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod ResourcePod의 spec에서 resources 필드를 통해 리소스를 제한할 수 있습니다. resources 필드는 limits 와 requests 로 구성됩니다. limits는 Pod가 사용할 수 있는 최대 리소스 양을 설정하고, requests는 Pod가 최소한으로 필요로 하는 리소스 양을 설정합니다. apiVersion: v1kind: Podmetadata: name: my-podspec: containers: - name: my-container image: nginx resources: limits: cpu: &quot;1&quot; memory: &quot;512Mi&quot; requests: cpu: &quot;500m&quot; memory: &quot;256Mi&quot;","text":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod ResourcePod의 spec에서 resources 필드를 통해 리소스를 제한할 수 있습니다. resources 필드는 limits 와 requests 로 구성됩니다. limits는 Pod가 사용할 수 있는 최대 리소스 양을 설정하고, requests는 Pod가 최소한으로 필요로 하는 리소스 양을 설정합니다. apiVersion: v1kind: Podmetadata: name: my-podspec: containers: - name: my-container image: nginx resources: limits: cpu: &quot;1&quot; memory: &quot;512Mi&quot; requests: cpu: &quot;500m&quot; memory: &quot;256Mi&quot;","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"}],"tags":[]},{"title":"EKS - EBS CSI Driver 설치","slug":"aws/eks/eks-ebs","date":"2023-03-04T21:31:07.000Z","updated":"2024-02-18T16:19:54.516Z","comments":true,"path":"2023/03/05/aws/eks/eks-ebs/","link":"","permalink":"https://ckck803.github.io/2023/03/05/aws/eks/eks-ebs/","excerpt":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://aws.amazon.com/ko/blogs/tech/persistent-storage-for-kubernetes/ EBS CSI Driver 설치를 위한 EKS 내 Service Account 생성eksctl create iamserviceaccount \\ --name ebs-csi-controller-sa \\ --namespace kube-system \\ --cluster &lt;Cluste 이름&gt; \\ --attach-policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy \\ --approve \\ --role-only \\ --role-name AmazonEKS_EBS_CSI_DriverRole EBS CSI Driver 설치aws eks describe-addon-versions --addon-name aws-ebs-csi-driver eksctl create addon \\ --name aws-ebs-csi-driver \\ --cluster &lt;Cluste 이름&gt; \\ --service-account-role-arn arn:aws:iam::&lt;AWS 계정 ID&gt;:role/AmazonEKS_EBS_CSI_DriverRole \\ --force","text":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://aws.amazon.com/ko/blogs/tech/persistent-storage-for-kubernetes/ EBS CSI Driver 설치를 위한 EKS 내 Service Account 생성eksctl create iamserviceaccount \\ --name ebs-csi-controller-sa \\ --namespace kube-system \\ --cluster &lt;Cluste 이름&gt; \\ --attach-policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy \\ --approve \\ --role-only \\ --role-name AmazonEKS_EBS_CSI_DriverRole EBS CSI Driver 설치aws eks describe-addon-versions --addon-name aws-ebs-csi-driver eksctl create addon \\ --name aws-ebs-csi-driver \\ --cluster &lt;Cluste 이름&gt; \\ --service-account-role-arn arn:aws:iam::&lt;AWS 계정 ID&gt;:role/AmazonEKS_EBS_CSI_DriverRole \\ --force EBS StorageClass 생성apiVersion: storage.k8s.io/v1kind: StorageClass metadata: name: jenkins-ebs namespace: cicdvolumeBindingMode: Immediate# volumeBindingMode: WaitForFirstConsumer provisioner: ebs.csi.aws.comparameters: type: gp3 tagSpecification_1: &lt;tag name1&gt;=&lt;value1&gt; tagSpecification_2: &lt;tag name2&gt;=&lt;value2&gt;reclaimPolicy: RetainallowVolumeExpansion: true apiVersion: v1kind: PersistentVolumeClaimmetadata: name: nexus-claim-efs namespace: cicdspec: accessModes: - ReadWriteOnce storageClassName: nexus-ebs resources: requests: storage: 20Gi namespace: cicd kind: StorageClassapiVersion: storage.k8s.io/v1metadata: name: efs-scprovisioner: efs.csi.aws.comparameters: provisioningMode: efs-ap fileSystemId: &quot;&lt;EFS Filesystem ID&gt;&quot; directoryPerms: &quot;700&quot; gidRangeStart: &quot;1000&quot; # optional gidRangeEnd: &quot;2000&quot; # optional","categories":[{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"}],"tags":[]},{"title":"EKS - ALB Controller 를 활용한 NLB 생성","slug":"aws/eks/eks-nlb","date":"2023-03-03T21:31:07.000Z","updated":"2024-02-18T16:19:54.516Z","comments":true,"path":"2023/03/04/aws/eks/eks-nlb/","link":"","permalink":"https://ckck803.github.io/2023/03/04/aws/eks/eks-nlb/","excerpt":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/network-load-balancing.html apiVersion: v1kind: Servicemetadata: name: nlb-sample-service namespace: nlb-sample-app annotations: service.beta.kubernetes.io/aws-load-balancer-type: external service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: ip service.beta.kubernetes.io/aws-load-balancer-scheme: internet-facing service.beta.kubernetes.io/aws-load-balancer-name: skcc-prd-vitality-dx-nlb-ftp service.beta.kubernetes.io/subnets: &lt;Public Subnet1 ID&gt;, &lt;Public Subnet2 ID&gt;spec: ports: - port: 80 targetPort: 80 protocol: TCP type: LoadBalancer selector: app: nginx apiVersion: apps/v1kind: Deploymentmetadata: name: nlb-sample-app namespace: nlb-sample-appspec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: public.ecr.aws/nginx/nginx:1.21 ports: - name: tcp containerPort: 80","text":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/network-load-balancing.html apiVersion: v1kind: Servicemetadata: name: nlb-sample-service namespace: nlb-sample-app annotations: service.beta.kubernetes.io/aws-load-balancer-type: external service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: ip service.beta.kubernetes.io/aws-load-balancer-scheme: internet-facing service.beta.kubernetes.io/aws-load-balancer-name: skcc-prd-vitality-dx-nlb-ftp service.beta.kubernetes.io/subnets: &lt;Public Subnet1 ID&gt;, &lt;Public Subnet2 ID&gt;spec: ports: - port: 80 targetPort: 80 protocol: TCP type: LoadBalancer selector: app: nginx apiVersion: apps/v1kind: Deploymentmetadata: name: nlb-sample-app namespace: nlb-sample-appspec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: public.ecr.aws/nginx/nginx:1.21 ports: - name: tcp containerPort: 80","categories":[{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"}],"tags":[]},{"title":"EKS - ALB Controller 설치","slug":"aws/eks/eks-alb","date":"2023-03-02T21:31:07.000Z","updated":"2024-02-18T16:19:54.516Z","comments":true,"path":"2023/03/03/aws/eks/eks-alb/","link":"","permalink":"https://ckck803.github.io/2023/03/03/aws/eks/eks-alb/","excerpt":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/aws-load-balancer-controller.html IAM policy &amp; role 생성curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.4.7/docs/install/iam_policy.json aws iam create-policy \\ --policy-name AWSLoadBalancerControllerIAMPolicy \\ --policy-document file://iam_policy.json ServiceAccount 생성eksctl create iamserviceaccount \\ --cluster=my-cluster \\ --namespace=kube-system \\ --name=aws-load-balancer-controller \\ # 원하는 Service Account 이름으로 변경해도 된다 --role-name AmazonEKSLoadBalancerControllerRole \\ --attach-policy-arn=arn:aws:iam::111122223333:policy/AWSLoadBalancerControllerIAMPolicy \\ --approve","text":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/aws-load-balancer-controller.html IAM policy &amp; role 생성curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.4.7/docs/install/iam_policy.json aws iam create-policy \\ --policy-name AWSLoadBalancerControllerIAMPolicy \\ --policy-document file://iam_policy.json ServiceAccount 생성eksctl create iamserviceaccount \\ --cluster=my-cluster \\ --namespace=kube-system \\ --name=aws-load-balancer-controller \\ # 원하는 Service Account 이름으로 변경해도 된다 --role-name AmazonEKSLoadBalancerControllerRole \\ --attach-policy-arn=arn:aws:iam::111122223333:policy/AWSLoadBalancerControllerIAMPolicy \\ --approve Helm 을 이용한 ALB Controller 생성helm repo add eks https://aws.github.io/eks-charts helm repo update helm install aws-load-balancer-controller eks/aws-load-balancer-controller \\ -n kube-system \\ --set clusterName=&lt;EKS Cluster 이름&gt; \\ --set serviceAccount.create=false \\ --set serviceAccount.name=&lt;ServiceAccount 이름&gt; 결과 NAME: aws-load-balancer-controllerLAST DEPLOYED: Fri Feb 17 09:50:16 2023NAMESPACE: kube-systemSTATUS: deployedREVISION: 1TEST SUITE: NoneNOTES:AWS Load Balancer controller installed! ALB Ingress 생성 ALB Ingress Annotation 참고 https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.2/guide/ingress/annotations/ apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: &lt;Ingress 이름&gt; namespace: &lt;Namespace&gt; annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/group.name: froot # Ingress Group 이름 alb.ingress.kubernetes.io/listen-ports: &#x27;[&#123;&quot;HTTPS&quot;: 443, &quot;HTTP&quot;: 80&#125;]&#x27; # ALB 가 수신한 PORT 를 설정합니다. alb.ingress.kubernetes.io/load-balancer-name: &lt;ALB 이름&gt; alb.ingress.kubernetes.io/scheme: internal alb.ingress.kubernetes.io/security-groups: &lt;Security Group 정보&gt; alb.ingress.kubernetes.io/ssl-policy: ELBSecurityPolicy-FS-1-2-Res-2020-10 alb.ingress.kubernetes.io/subnets: &lt;Subnet1 ID&gt;, &lt;Subnet2 ID&gt; alb.ingress.kubernetes.io/success-codes: 403,404,200,302 alb.ingress.kubernetes.io/tags: &lt;tag1=value1&gt;, &lt;tag2=value2&gt; alb.ingress.kubernetes.io/target-type: ipspec: rules: - host: &lt;도메인 이름&gt; http: paths: - path: /* backend: service: name: &lt;Service 이름&gt; port: number: &lt;Service 포트&gt;","categories":[{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"}],"tags":[]},{"title":"EKS - Cluster Access 문제","slug":"aws/eks/cluster-access","date":"2023-03-01T21:31:46.000Z","updated":"2024-02-18T16:19:54.515Z","comments":true,"path":"2023/03/02/aws/eks/cluster-access/","link":"","permalink":"https://ckck803.github.io/2023/03/02/aws/eks/cluster-access/","excerpt":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) Error 현재 사용자 또는 역할이 이 EKS Cluster 에 있는 Kubenetes 객체에 엑세스 할 수 없습니다.EKS Dashboard 에서 다음과 같이 문구가 뜨면서 Kubernetes 객체에 정상적으로 Access 하지 못하는 문제가 있다. 다음과 같이 에러가 발생하는 이유는 생성한 클러스터 내부 ConfigMap의 aws-auth에 현재 사용자 또는 역할이 없어 AWS Console에서 확인이 안되는 것이다. 1. ARN 확인 2. ConfigMap 수정다음 명령어를 통해 aws-auth ConfigMap 에 접근해 mapUsers 를 추가 해주도록 하자.","text":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) Error 현재 사용자 또는 역할이 이 EKS Cluster 에 있는 Kubenetes 객체에 엑세스 할 수 없습니다.EKS Dashboard 에서 다음과 같이 문구가 뜨면서 Kubernetes 객체에 정상적으로 Access 하지 못하는 문제가 있다. 다음과 같이 에러가 발생하는 이유는 생성한 클러스터 내부 ConfigMap의 aws-auth에 현재 사용자 또는 역할이 없어 AWS Console에서 확인이 안되는 것이다. 1. ARN 확인 2. ConfigMap 수정다음 명령어를 통해 aws-auth ConfigMap 에 접근해 mapUsers 를 추가 해주도록 하자. kubectl edit cm/aws-auth -n kube-system ConfigMap 에 아래 정보를 추가userarn : iam 에서 확인 할 수 있는 ARN 정보username : 사용자 계정 이름groups에 system:masters 를 추가해야 AWS콘솔에서 EKS를 올바르게 확인할 수 있습니다. mapUsers: | - userarn: &lt;arn 정보&gt; username: &lt;계정 이름&gt; groups: - system:masters","categories":[{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"}],"tags":[]},{"title":"EKS - NodeGroup 생성","slug":"aws/eks/eks-nodegroup","date":"2023-03-01T21:31:46.000Z","updated":"2024-02-18T16:19:54.517Z","comments":true,"path":"2023/03/02/aws/eks/eks-nodegroup/","link":"","permalink":"https://ckck803.github.io/2023/03/02/aws/eks/eks-nodegroup/","excerpt":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 UserData 생성 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/launch-templates.html#launch-template-custom-ami https://eksctl.io/usage/managing-nodegroups/ https://kim-dragon.tistory.com/54 1. LauchTemplate 생성1. UserData 생성을 위한 EKS Cluster 정보 확인aws eks describe-cluster 명령어를 이용해 필요한 EKS 클러스터의 정보를 가져오도록 한다. 클러스터 Certificate Authority 확인 aws eks describe-cluster \\ --query &quot;cluster.certificateAuthority.data&quot; \\ --output text \\ --name [클러스터 이름] \\ --region [지역] \\ --profile [aws-profile]","text":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 UserData 생성 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/launch-templates.html#launch-template-custom-ami https://eksctl.io/usage/managing-nodegroups/ https://kim-dragon.tistory.com/54 1. LauchTemplate 생성1. UserData 생성을 위한 EKS Cluster 정보 확인aws eks describe-cluster 명령어를 이용해 필요한 EKS 클러스터의 정보를 가져오도록 한다. 클러스터 Certificate Authority 확인 aws eks describe-cluster \\ --query &quot;cluster.certificateAuthority.data&quot; \\ --output text \\ --name [클러스터 이름] \\ --region [지역] \\ --profile [aws-profile] 결과 LS0tLS1CRUd....RS0tLS0tCg== 클러스터 EndPoint 확인 aws eks describe-cluster \\ --query &quot;cluster.endpoint&quot; \\ --output text \\ --name my-cluster \\ --region region-code https://3224AD3EC8CEA69EDAE9C57D9792EBB2.yl4.ap-northeast-2.eks.amazonaws.com 서비스 IP 주소 범위 확인 aws eks describe-cluster \\ --query &quot;cluster.kubernetesNetworkConfig.serviceIpv4Cidr&quot; \\ --output text \\ --name my-cluster \\ --region region-code 172.20.0.0/16 2. UserData 생성MIME-Version: 1.0Content-Type: multipart/mixed; boundary=&quot;==MYBOUNDARY==&quot;--==MYBOUNDARY==Content-Type: text/x-shellscript; charset=&quot;us-ascii&quot;#!/bin/bashset -ex/etc/eks/bootstrap.sh my-cluster \\ --b64-cluster-ca [클러스터의 certificate-authority] \\ --apiserver-endpoint [클러스터의 api-server-endpoint] \\ --dns-cluster-ip [클러스터의 service-cidr] \\ --container-runtime containerd \\ --kubelet-extra-args &#x27;--max-pods=my-[최대 Pod 개수]&#x27; \\ --use-max-pods false--==MYBOUNDARY==-- 3. UserData 를 Base64 로 인코딩 Base 64로 인코딩 해주는 사이트 https://www.convertstring.com/ko/EncodeDecode/Base64Encode TUlNRS1WZXJzaW...VJZPT0tLQ== 4. 완성된 Launch Template 정보&#123; &quot;BlockDeviceMappings&quot;: [ &#123; &quot;DeviceName&quot;: &quot;/dev/xvda&quot;, &quot;Ebs&quot;: &#123; &quot;Encrypted&quot;: true, &quot;DeleteOnTermination&quot;: true, &quot;SnapshotId&quot;: &quot;snap-0f505c7c316673bd3&quot;, &quot;VolumeSize&quot;: 30, &quot;VolumeType&quot;: &quot;gp3&quot; &#125; &#125; ], &quot;ImageId&quot;: &quot;ami-07d1f1e1f9eaaf855&quot;, // Amazon Machine Image &quot;InstanceType&quot;: &quot;t3.medium&quot;, // Instance Type &quot;KeyName&quot;: &quot;Key-Pair-Name&quot;, // EC2 Key Pair 이름 &quot;UserData&quot;: &quot;TUlNRS1WZXJzaW...VJZPT0tLQ==&quot;, // [base64로 encoding된 UserData] &quot;SecurityGroupIds&quot;: [&quot;sg-0b59ab7daf120b3aa&quot;]&#125; 5. AWS Cli 를 이용해 Launch Template 생성aws ec2 create-launch-template \\ --launch-template-name skcc-dev-floot-template-eks-cicd \\ --version-description version1 \\ --launch-template-data file:///Users/dongwoo-yang/vitality/devops/devops/eks-cicd/launch-template-data-cicd.json 6. 결과 Launch Template 이 정상적으로 생성된 경우 &#123; &quot;LaunchTemplate&quot;: &#123; &quot;LaunchTemplateId&quot;: &quot;lt-0a34f65e6a5f56f26&quot;, &quot;LaunchTemplateName&quot;: &quot;skcc-dev-floot-template-eks-cicd&quot;, &quot;CreateTime&quot;: &quot;2023-03-05T04:35:54+00:00&quot;, &quot;DefaultVersionNumber&quot;: 1, &quot;LatestVersionNumber&quot;: 1 &#125;&#125; Launch Template 생성시 문제가 있는 경우 &#123; &quot;LaunchTemplate&quot;: &#123; &quot;LaunchTemplateId&quot;: &quot;lt-0f71298159e2cb0b9&quot;, &quot;LaunchTemplateName&quot;: &quot;skcc-dev-floot-template-eks-cicd&quot;, &quot;CreateTime&quot;: &quot;2023-03-05T04:24:31+00:00&quot;, &quot;DefaultVersionNumber&quot;: 1, &quot;LatestVersionNumber&quot;: 1 &#125;, &quot;Warning&quot;: &#123; &quot;Errors&quot;: [ &#123; &quot;Code&quot;: &quot;InvalidSecurityGroupID.NotFound&quot;, &quot;Message&quot;: &quot;The security group &#x27;sg-044a9f8e5e9ad6aea&#x27; does not exist&quot; &#125; ] &#125;&#125; 7. 잘 못 만들었을 경우 삭제aws ec2 delete-launch-template --launch-template-id lt-0f71298159e2cb0b9 삭제 반환 값 &#123; &quot;LaunchTemplate&quot;: &#123; &quot;LaunchTemplateId&quot;: &quot;lt-032f99015c21e4006&quot;, &quot;LaunchTemplateName&quot;: &quot;skcc-dev-floot-template-eks-cicd&quot;, &quot;CreateTime&quot;: &quot;2023-03-05T04:30:59+00:00&quot;, &quot;DefaultVersionNumber&quot;: 1, &quot;LatestVersionNumber&quot;: 1 &#125;&#125; 2. Nodegroup 생성1. Nodegroup 생성을 위한 Config 파일 작성apiVersion: eksctl.io/v1alpha5kind: ClusterConfigmetadata: name: skcc-dev-floot-eks region: ap-northeast-2vpc: id: &quot;vpc-0b743e88067ce8f6f&quot; subnets: private: ap-northeast-2a: id: &quot;subnet-0f80a51bc0046c935&quot; ap-northeast-2c: id: &quot;subnet-0acaea413f9bd4192&quot; securityGroup: &quot;sg-0b59ab7daf120b3aa&quot; # this is the ControlPlaneSecurityGroupmanagedNodeGroups: - name: skcc-dev-floot-nodegroup-cicd launchTemplate: id: lt-0a34f65e6a5f56f26 version: &quot;1&quot; labels: &#123; nodegroup-role: cicd &#125; availabilityZones: [&quot;ap-northeast-2a&quot;, &quot;ap-northeast-2c&quot;] desiredCapacity: 1 # instanceType: t3.medium iam: instanceRoleARN: &lt;Arn 정보&gt; privateNetworking: true tags: &quot;cz-stage&quot;: &quot;dev&quot; &quot;cz-owner&quot;: &quot;양동우&quot; &quot;cz-appl&quot;: &quot;cicd&quot; &quot;cz-project&quot;: &quot;floot&quot; &quot;cz-org&quot;: &quot;Vitality사업팀&quot; 2. Eksctl 를 이용한 NodeGroup 생성eksctl create nodegroup -f ./eks-nodegroup-cicd.yaml Node Group 생성 로그 2023-03-05 13:38:34 [ℹ] will use version 1.24 for new nodegroup(s) based on control plane version2023-03-05 13:38:34 [!] no eksctl-managed CloudFormation stacks found for &quot;skcc-dev-floot-eks&quot;, will attempt to create nodegroup(s) on non eksctl-managed cluster2023-03-05 13:38:35 [ℹ] nodegroup &quot;skcc-dev-floot-nodegroup-cicd&quot; will use &quot;&quot; [AmazonLinux2/1.24]2023-03-05 13:38:35 [ℹ] 4 existing nodegroup(s) (skcc-dev-floot-nodegroup-logging,skcc-dev-floot-nodegroup-monitoring,skcc-dev-floot-nodegroup-monitoring2,skcc-uat-floot-nodegroup-monitoring) will be excluded2023-03-05 13:38:35 [ℹ] 1 nodegroup (skcc-dev-floot-nodegroup-cicd) was included (based on the include/exclude rules)2023-03-05 13:38:35 [ℹ] will create a CloudFormation stack for each of 1 managed nodegroups in cluster &quot;skcc-dev-floot-eks&quot;2023-03-05 13:38:35 [ℹ] 1 task: &#123; 1 task: &#123; 1 task: &#123; create managed nodegroup &quot;skcc-dev-floot-nodegroup-cicd&quot; &#125; &#125; &#125;2023-03-05 13:38:35 [ℹ] building managed nodegroup stack &quot;eksctl-skcc-dev-floot-eks-nodegroup-skcc-dev-floot-nodegroup-cicd&quot;2023-03-05 13:38:35 [ℹ] deploying stack &quot;eksctl-skcc-dev-floot-eks-nodegroup-skcc-dev-floot-nodegroup-cicd&quot;2023-03-05 13:38:36 [ℹ] waiting for CloudFormation stack &quot;eksctl-skcc-dev-floot-eks-nodegroup-skcc-dev-floot-nodegroup-cicd&quot;2023-03-05 13:39:06 [ℹ] waiting for CloudFormation stack &quot;eksctl-skcc-dev-floot-eks-nodegroup-skcc-dev-floot-nodegroup-cicd&quot;2023-03-05 13:39:44 [ℹ] waiting for CloudFormation stack &quot;eksctl-skcc-dev-floot-eks-nodegroup-skcc-dev-floot-nodegroup-cicd&quot;2023-03-05 13:41:32 [ℹ] waiting for CloudFormation stack &quot;eksctl-skcc-dev-floot-eks-nodegroup-skcc-dev-floot-nodegroup-cicd&quot;2023-03-05 13:41:32 [ℹ] no tasks2023-03-05 13:41:32 [✔] created 0 nodegroup(s) in cluster &quot;skcc-dev-floot-eks&quot;2023-03-05 13:41:32 [ℹ] nodegroup &quot;skcc-dev-floot-nodegroup-cicd&quot; has 1 node(s)2023-03-05 13:41:32 [ℹ] node &quot;ip-10-180-19-19.ap-northeast-2.compute.internal&quot; is ready2023-03-05 13:41:32 [ℹ] waiting for at least 1 node(s) to become ready in &quot;skcc-dev-floot-nodegroup-cicd&quot;2023-03-05 13:41:32 [ℹ] nodegroup &quot;skcc-dev-floot-nodegroup-cicd&quot; has 1 node(s)2023-03-05 13:41:32 [ℹ] node &quot;ip-10-180-19-19.ap-northeast-2.compute.internal&quot; is ready2023-03-05 13:41:32 [✔] created 1 managed nodegroup(s) in cluster &quot;skcc-dev-floot-eks&quot;2023-03-05 13:41:33 [ℹ] checking security group configuration for all nodegroups2023-03-05 13:41:33 [ℹ] all nodegroups have up-to-date cloudformation templates 3. 필요한 경우 Nodegroup 삭제eksctl delete nodegroup --cluster=skcc-dev-floot-eks --name=skcc-dev-floot-nodegroup-cicd Node Group 삭제 로그 2023-03-03 23:10:16 [ℹ] 1 nodegroup (skcc-dev-floot-nodegroup-cicd) was included (based on the include/exclude rules)2023-03-03 23:10:16 [ℹ] will drain 1 nodegroup(s) in cluster &quot;skcc-dev-floot-eks&quot;2023-03-03 23:10:16 [ℹ] starting parallel draining, max in-flight of 12023-03-03 23:10:17 [ℹ] cordon node &quot;ip-10-180-18-62.ap-northeast-2.compute.internal&quot;2023-03-03 23:10:17 [✔] drained all nodes: [ip-10-180-18-62.ap-northeast-2.compute.internal]2023-03-03 23:10:17 [ℹ] will delete 1 nodegroups from cluster &quot;skcc-dev-floot-eks&quot;2023-03-03 23:10:17 [ℹ] 1 task: &#123; 1 task: &#123; delete nodegroup &quot;skcc-dev-floot-nodegroup-cicd&quot; [async] &#125; &#125;2023-03-03 23:10:17 [ℹ] will delete stack &quot;eksctl-skcc-dev-floot-eks-nodegroup-skcc-dev-floot-nodegroup-cicd&quot;2023-03-03 23:10:17 [ℹ] will delete 0 nodegroups from auth ConfigMap in cluster &quot;skcc-dev-floot-eks&quot;2023-03-03 23:10:17 [✔] deleted 1 nodegroup(s) from cluster &quot;skcc-dev-floot-eks&quot; EKS 에서 사용하는 instance 타입 확인하기aws eks describe-nodegroup \\--cluster-name &lt;cluster name&gt; \\--nodegroup-name skcc-uat-chat-nodegroup-monitoring \\--query &#x27;nodegroup.launchTemplate.instanceType&#x27;","categories":[{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"}],"tags":[]},{"title":"쿠버네티스 - 토폴로지 인지 힌트 (Topology Aware Hint)","slug":"k8s/topology-aware-hints","date":"2023-02-18T21:31:46.000Z","updated":"2024-02-18T16:19:54.542Z","comments":true,"path":"2023/02/19/k8s/topology-aware-hints/","link":"","permalink":"https://ckck803.github.io/2023/02/19/k8s/topology-aware-hints/","excerpt":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod 참고 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/kubernetes-versions.html https://kubernetes.io/ko/docs/concepts/services-networking/topology-aware-hints/ https://tetrate.io/blog/minimizing-cross-zone-traffic-charges-with-istio/ 토폴로지 인지 힌트 (Topology Aware Hint)쿠버네티스 클러스터가 멀티-존(multi-zone) 환경에 배포되는 일이 점점 많아지고 있다. 토폴로지 인지 힌트 는 트래픽이 발생한 존 내에서 트래픽을 유지하도록 처리하는 메커니즘을 제공한다. 이러한 개념은 보통 “토폴로지 인지 라우팅”이라고 부른다. 서비스의 엔드포인트를 계산할 때, 엔드포인트슬라이스 컨트롤러는 각 엔드포인트의 토폴로지(지역(region) 및 존)를 고려하여, 엔드포인트가 특정 존에 할당되도록 힌트 필드를 채운다. 그러면 kube-proxy와 같은 클러스터 구성 요소는 해당 힌트를 인식하고, (토폴로지 상 가까운 엔드포인트를 사용하도록) 트래픽 라우팅 구성에 활용한다. 토폴로지 인지 힌트(Topology Aware Hints) 는 클라이언트가 엔드포인트를 어떻게 사용해야 하는지에 대한 제안을 포함시킴으로써 토폴로지 인지 라우팅을 가능하게 한다. 이러한 접근은 엔드포인트슬라이스(EndpointSlice) 및 엔드포인트(Endpoint) 오브젝트의 소비자(consumer)가 이용할 수 있는 메타데이터를 추가하며, 이를 통해 해당 네트워크 엔드포인트로의 트래픽이 근원지에 더 가깝게 라우트될 수 있다. 비용을 줄이거나 네트워크 성능을 높이기 위해, 인접성을 고려하여 트래픽을 라우트할 수 있다.","text":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod 참고 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/kubernetes-versions.html https://kubernetes.io/ko/docs/concepts/services-networking/topology-aware-hints/ https://tetrate.io/blog/minimizing-cross-zone-traffic-charges-with-istio/ 토폴로지 인지 힌트 (Topology Aware Hint)쿠버네티스 클러스터가 멀티-존(multi-zone) 환경에 배포되는 일이 점점 많아지고 있다. 토폴로지 인지 힌트 는 트래픽이 발생한 존 내에서 트래픽을 유지하도록 처리하는 메커니즘을 제공한다. 이러한 개념은 보통 “토폴로지 인지 라우팅”이라고 부른다. 서비스의 엔드포인트를 계산할 때, 엔드포인트슬라이스 컨트롤러는 각 엔드포인트의 토폴로지(지역(region) 및 존)를 고려하여, 엔드포인트가 특정 존에 할당되도록 힌트 필드를 채운다. 그러면 kube-proxy와 같은 클러스터 구성 요소는 해당 힌트를 인식하고, (토폴로지 상 가까운 엔드포인트를 사용하도록) 트래픽 라우팅 구성에 활용한다. 토폴로지 인지 힌트(Topology Aware Hints) 는 클라이언트가 엔드포인트를 어떻게 사용해야 하는지에 대한 제안을 포함시킴으로써 토폴로지 인지 라우팅을 가능하게 한다. 이러한 접근은 엔드포인트슬라이스(EndpointSlice) 및 엔드포인트(Endpoint) 오브젝트의 소비자(consumer)가 이용할 수 있는 메타데이터를 추가하며, 이를 통해 해당 네트워크 엔드포인트로의 트래픽이 근원지에 더 가깝게 라우트될 수 있다. 비용을 줄이거나 네트워크 성능을 높이기 위해, 인접성을 고려하여 트래픽을 라우트할 수 있다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"}],"tags":[]},{"title":"Istio - 토폴로지 인지 힌트","slug":"k8s/istio/istio-topology-aware-hints","date":"2023-02-18T21:31:46.000Z","updated":"2024-02-18T16:19:54.539Z","comments":true,"path":"2023/02/19/k8s/istio/istio-topology-aware-hints/","link":"","permalink":"https://ckck803.github.io/2023/02/19/k8s/istio/istio-topology-aware-hints/","excerpt":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod 참고 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/kubernetes-versions.html https://kubernetes.io/ko/docs/concepts/services-networking/topology-aware-hints/ https://tetrate.io/blog/minimizing-cross-zone-traffic-charges-with-istio/ 쿠버네티스 Node Zone 확인kubectl get nodes -L topology.kubernetes.io/zone Istio 에 토폴로지 인지 힌트 추가apiVersion: v1kind: Servicemetadata: annotations: # topology-aware-hints 추가 service.kubernetes.io/topology-aware-hints: auto name: istiod namespace: istio-system","text":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod 참고 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/kubernetes-versions.html https://kubernetes.io/ko/docs/concepts/services-networking/topology-aware-hints/ https://tetrate.io/blog/minimizing-cross-zone-traffic-charges-with-istio/ 쿠버네티스 Node Zone 확인kubectl get nodes -L topology.kubernetes.io/zone Istio 에 토폴로지 인지 힌트 추가apiVersion: v1kind: Servicemetadata: annotations: # topology-aware-hints 추가 service.kubernetes.io/topology-aware-hints: auto name: istiod namespace: istio-system","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"}],"tags":[]},{"title":"쿠버네티스 - Namespace","slug":"k8s/namespace/namespace","date":"2023-02-18T21:31:46.000Z","updated":"2024-02-18T16:19:54.540Z","comments":true,"path":"2023/02/19/k8s/namespace/namespace/","link":"","permalink":"https://ckck803.github.io/2023/02/19/k8s/namespace/namespace/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s Namespace 란? 쿠번네티스 Cluster 들을 논리적으로 나누기 위한 수단. Namespace 를 이용하면 Pod, Service, Volumn 과 같은 다양한 리소스를 분리하고 격리할 수 있다. Namespace 생성kubectl create namespace your-namespace-name apiVersion: v1kind: Namespacemetadata: name: [Namespace 이름] kubectl apply -f namespace.yaml","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s Namespace 란? 쿠번네티스 Cluster 들을 논리적으로 나누기 위한 수단. Namespace 를 이용하면 Pod, Service, Volumn 과 같은 다양한 리소스를 분리하고 격리할 수 있다. Namespace 생성kubectl create namespace your-namespace-name apiVersion: v1kind: Namespacemetadata: name: [Namespace 이름] kubectl apply -f namespace.yaml 활성화 네임스페이스 변경kubectl config set-context --current --namespace=&lt;insert-namespace-name-here&gt; Kubectxaliaskubectx &lt;alias&gt;=&lt;cluster 이름&gt; Kubens","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"}],"tags":[]},{"title":"쿠버네티스 - Ingress","slug":"k8s/ingress/ingress","date":"2023-02-11T21:31:46.000Z","updated":"2024-02-18T16:19:54.537Z","comments":true,"path":"2023/02/12/k8s/ingress/ingress/","link":"","permalink":"https://ckck803.github.io/2023/02/12/k8s/ingress/ingress/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s Ingress","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s Ingress","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"}],"tags":[]},{"title":"쿠버네티스 - Service","slug":"k8s/service/service","date":"2023-02-10T21:31:46.000Z","updated":"2024-02-18T16:19:54.542Z","comments":true,"path":"2023/02/11/k8s/service/service/","link":"","permalink":"https://ckck803.github.io/2023/02/11/k8s/service/service/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s 참고 공식 문서 https://kubernetes.io/docs/concepts/services-networking/service/ Service Service 는 클러스터 내부에서 작동하는 Pod 들을 하나의 서비스로 단일화 해 네트워크에 노출 시키는 Resource Service 는 쿠버네티스내 여러개의 Pod 들이 작동하지만, 하나의 그룹으로 단일화 해 네트워크로 노출하기 때문에 마치 하나의 어플리케이션이 작동하는 것 처럼 추상화할 수 있습니다. 덕분에 서비스를 사용하면 파드를 직접 지정하지 않고 네트워크를 통해 파드에 접근할 수 있습니다. 또한, Service 는 동일한 애플리케이션의 여러 Pod 에 대한 로드 밸런싱 도 제공합니다. 기존에 서로 다른 어플리케이션 Pod 들끼리 통신하는 방식에서 Service 라는 단위를 통해 통신하는 형태로 변경이 됐습니다. 덕분에 동적으로 변하는 Pod 의 IP 주소 문제를 해결할 수 있었으며, 여러개의 Pod 를 바라보기 때문에 Pod 에 대한 로드밸런서 기능을 제공합니다. 또한, DNS 를 사용해 Service 이름을 등록함으로써 Service 이름으로 통신할 수 있게 지원합니다.","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s 참고 공식 문서 https://kubernetes.io/docs/concepts/services-networking/service/ Service Service 는 클러스터 내부에서 작동하는 Pod 들을 하나의 서비스로 단일화 해 네트워크에 노출 시키는 Resource Service 는 쿠버네티스내 여러개의 Pod 들이 작동하지만, 하나의 그룹으로 단일화 해 네트워크로 노출하기 때문에 마치 하나의 어플리케이션이 작동하는 것 처럼 추상화할 수 있습니다. 덕분에 서비스를 사용하면 파드를 직접 지정하지 않고 네트워크를 통해 파드에 접근할 수 있습니다. 또한, Service 는 동일한 애플리케이션의 여러 Pod 에 대한 로드 밸런싱 도 제공합니다. 기존에 서로 다른 어플리케이션 Pod 들끼리 통신하는 방식에서 Service 라는 단위를 통해 통신하는 형태로 변경이 됐습니다. 덕분에 동적으로 변하는 Pod 의 IP 주소 문제를 해결할 수 있었으며, 여러개의 Pod 를 바라보기 때문에 Pod 에 대한 로드밸런서 기능을 제공합니다. 또한, DNS 를 사용해 Service 이름을 등록함으로써 Service 이름으로 통신할 수 있게 지원합니다. apiVersion: apps/v1kind: Deploymentmetadata: name: redisspec: selector: matchLabels: app: counter tier: db template: metadata: labels: app: counter tier: db spec: containers: - name: redis image: redis ports: - containerPort: 6379 protocol: TCP---apiVersion: v1kind: Servicemetadata: name: redisspec: ports: - port: 6379 protocol: TCP selector: app: counter tier: db kubectl apply -f counter-redis-svc.yml Service 생성 흐름 API Server 를 이용해 Service 를 생성합니다. EndPoint Controller 는 Service 와 Pod 를 감시하면서 조건에 맞는 Pod 의 IP 를 수집합니다. EndPoint Controller 가 수집한 IP를 가지고 EndPoint 생성 Kube-Proxy 는 EndPoint 변화를 감시하고 노드의 iptables 을 설정합니다. CoreDNS 는 Service 를 감시하고 Service 이름과 IP 를 CoreDNS 에 추가 Service - ClusterIP ClusterIP 는 클러스터 내부에서만 접근이 가능하며, 클러스터 내부 통신 을 위해 사용합니다. ClusterIP 는 별도의 설정 없이 Service 를 생성하면 만들어지는 Serivce 유형의 기본값이며 Service 에 할당되는 IP 주소 입니다. 클러스터 외부에서는 접근이 불가능 하며 클러스터 내부 통신을 위해서만 사용됩니다. 클러스터 내의 다른 파드나 서비스에서 해당 서비스의 ClusterIP 를 사용하여 통신할 수 있습니다. NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 32sservice/redis ClusterIP 10.109.247.112 &lt;none&gt; 6379/TCP 5s 쿠버네티스에서 Cluster IP 로 정의된 서비스에 접근하고 싶을 경우 port-forward 를 이용하면 접근할 수 있습니다. kubectl port-forward svc/redis 6379 Service - NodePortCluterIP는 클러스터 내부에서만 접근할 수 있습니다. 클러스터에서 접근하기 위한 방법으로 NodePort 를 제공하는데, 클러스터의 모든 노드에 지정된 Port 를 spec.type: NodePort 옵션을 통해 Service 를 NodePort 타입으로 생성할 수 있습니다. spec.ports.nodePort 옵션을 통해 노드에 오픈할 Port 를 설정할 수 있습니다. apiVersion: v1kind: Servicemetadata: name: counter-npspec: type: NodePort ports: - port: 3000 protocol: TCP nodePort: 31000 selector: app: counter tier: app NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEcounter-np NodePort 10.109.112.196 &lt;none&gt; 3000:31000/TCP 5skubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 6h9mredis ClusterIP 10.109.247.112 &lt;none&gt; 6379/TCP 6h9m minikube service counter-np Service - LoadBalancerNodePort 의 단점은 노드가 사라졌을 때 자동으로 다른 노드를 통해 접근이 불가능하다는 점입니다. 예를 들어, 3개의 노드가 있다면 3개 중에 아무 노드로 접근해도 NodePort로 연결할 수 있지만 어떤 노드가 살아 있는지는 알 수가 없습니다. apiVersion: v1kind: Servicemetadata: name: counter-lbspec: type: LoadBalancer ports: - port: 30000 targetPort: 3000 protocol: TCP selector: app: counter tier: app NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEcounter-lb LoadBalancer 10.97.105.155 192.168.49.2 30000:30810/TCP 7h51mcounter-np NodePort 10.109.112.196 &lt;none&gt; 3000:31000/TCP 8hkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 15hredis ClusterIP 10.109.247.112 &lt;none&gt; 6379/TCP 15h Minikube에 가상 LoadBalancer 만들기 minikube addons enable metallb minikube addons configure metallb -- Enter Load Balancer Start IP: 192.168.49.2-- Enter Load Balancer End IP: 192.168.49.2 ▪ Using image quay.io/metallb/controller:v0.9.6 ▪ Using image quay.io/metallb/speaker:v0.9.6✅ metallb 이 성공적으로 설정되었습니다","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"서비스","slug":"Kubernetes/서비스","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%84%9C%EB%B9%84%EC%8A%A4/"}],"tags":[]},{"title":"쿠버네티스 - Deployment","slug":"k8s/pod/deployment","date":"2023-02-10T06:31:46.000Z","updated":"2024-02-18T16:19:54.541Z","comments":true,"path":"2023/02/10/k8s/pod/deployment/","link":"","permalink":"https://ckck803.github.io/2023/02/10/k8s/pod/deployment/","excerpt":"목차 Post not found: k8s/namespace Post not found: k8s/ingress 쿠버네티스 - Deployment Post not found: k8s/pod/replicaset 쿠버네티스 - Pod Deployment 어플리케이션을 클러스터 내의 여러 노드에 자동으로 배포 및 롤백 할 수 있는 리소스 클러스터에 인스턴스를 생성하고 배포하는 작업을 수항한다. Pod 를 개체를 관리한다. Deployment 를 이용해 Pod 를 생성하고 클러스터의 노드에 배포할 수 있다. Deployment 를 통해 Application 의 새로운 버전을 배포하거나 이전 버전으로 롤백할 수 있다. Deployment 를 생성하면 Deployment 에 해당하는 ReplicaSet 도 함께 생성된다. Deployment 리소스를 사용하면 애플리케이션의 상태, 레플리카 수, 롤링 업데이트, 롤백 등을 관리할 수 있습니다. 여러 개의 Pod 인스턴스를 생성하여 애플리케이션을 실행하는 것이 Deployment의 주요 목적입니다. Pod는 컨테이너를 실행하는 단위이며, Deployment는 이러한 Pod 인스턴스들을 생성하고 관리합니다. Deployment는 Pod의 상태를 모니터링하고 필요에 따라 새로운 Pod를 생성하거나 종료하여 애플리케이션을 원하는 상태로 유지합니다. Deployment는 롤링 업데이트를 통해 애플리케이션을 업데이트할 수 있는 기능도 제공합니다. 새로운 버전의 애플리케이션을 배포하면 Deployment는 점진적으로 Pod를 업데이트하고 이전 버전과 새 버전을 동시에 실행하면서 서비스의 가용성을 유지합니다. 롤링 업데이트 중에 문제가 발생하면 롤백하여 이전 버전으로 되돌릴 수도 있습니다. Deployment 리소스는 YAML 또는 JSON 형식으로 정의되며, 쿠버네티스 클러스터에 배포되어 관리됩니다. Deployment를 생성하면 해당 애플리케이션의 레플리카셋(ReplicaSet)과 함께 생성됩니다. ReplicaSet은 Pod 인스턴스의 수를 지정하고 관리하는 역할을 수행하며, Deployment는 ReplicaSet을 업데이트하거나 롤백하는 등의 작업을 수행합니다.","text":"목차 Post not found: k8s/namespace Post not found: k8s/ingress 쿠버네티스 - Deployment Post not found: k8s/pod/replicaset 쿠버네티스 - Pod Deployment 어플리케이션을 클러스터 내의 여러 노드에 자동으로 배포 및 롤백 할 수 있는 리소스 클러스터에 인스턴스를 생성하고 배포하는 작업을 수항한다. Pod 를 개체를 관리한다. Deployment 를 이용해 Pod 를 생성하고 클러스터의 노드에 배포할 수 있다. Deployment 를 통해 Application 의 새로운 버전을 배포하거나 이전 버전으로 롤백할 수 있다. Deployment 를 생성하면 Deployment 에 해당하는 ReplicaSet 도 함께 생성된다. Deployment 리소스를 사용하면 애플리케이션의 상태, 레플리카 수, 롤링 업데이트, 롤백 등을 관리할 수 있습니다. 여러 개의 Pod 인스턴스를 생성하여 애플리케이션을 실행하는 것이 Deployment의 주요 목적입니다. Pod는 컨테이너를 실행하는 단위이며, Deployment는 이러한 Pod 인스턴스들을 생성하고 관리합니다. Deployment는 Pod의 상태를 모니터링하고 필요에 따라 새로운 Pod를 생성하거나 종료하여 애플리케이션을 원하는 상태로 유지합니다. Deployment는 롤링 업데이트를 통해 애플리케이션을 업데이트할 수 있는 기능도 제공합니다. 새로운 버전의 애플리케이션을 배포하면 Deployment는 점진적으로 Pod를 업데이트하고 이전 버전과 새 버전을 동시에 실행하면서 서비스의 가용성을 유지합니다. 롤링 업데이트 중에 문제가 발생하면 롤백하여 이전 버전으로 되돌릴 수도 있습니다. Deployment 리소스는 YAML 또는 JSON 형식으로 정의되며, 쿠버네티스 클러스터에 배포되어 관리됩니다. Deployment를 생성하면 해당 애플리케이션의 레플리카셋(ReplicaSet)과 함께 생성됩니다. ReplicaSet은 Pod 인스턴스의 수를 지정하고 관리하는 역할을 수행하며, Deployment는 ReplicaSet을 업데이트하거나 롤백하는 등의 작업을 수행합니다. 쿠버네티스 Deployment는 애플리케이션의 배포와 관리를 효율적이고 안정적으로 수행할 수 있도록 지원하는 중요한 리소스입니다. Deployment 만들기 kind Deployment apiVersion: apps/v1kind: Deploymentmetadata: name: echo-deployspec: replicas: 4 selector: matchLabels: app: echo tier: app template: metadata: labels: app: echo tier: app spec: containers: - name: echo image: ghcr.io/subicura/echo:v1 Deployment 적용이미지를 변경한다. spec: containers: - name: echo image: ghcr.io/subicura/echo:v2 kubectl apply -f [deployment 파일명] Deployment Update Revision - 롤백 Revision 버전 확인 kubectl rollout history deployment [Deployment 이름] Rollback kubectl rollout undo deployment [Deployment 이름] --to-revision=[롤백할 Revision 버전]","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"워크로드","slug":"Kubernetes/워크로드","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C/"}],"tags":[]},{"title":"쿠버네티스 - StatefulSet","slug":"k8s/pod/StatefulSet","date":"2023-02-10T02:31:46.000Z","updated":"2024-02-18T16:19:54.541Z","comments":true,"path":"2023/02/10/k8s/pod/StatefulSet/","link":"","permalink":"https://ckck803.github.io/2023/02/10/k8s/pod/StatefulSet/","excerpt":"목차 쿠버네티스 - HPA (Horizontal Pod Autoscaler) 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s StatefulSet쿠버네티스(StatefulSet)는 쿠버네티스 클러스터 내에서 실행되는 애플리케이션의 상태를 유지하는 데 사용되는 컨트롤러입니다. 일반적으로 상태가 있는 애플리케이션인 데이터베이스, 메시지 큐 또는 파일 시스템과 같은 애플리케이션에 유용합니다. 쿠버네티스에서 일반적인 배포 유형인 Deployment는 상태를 가지지 않는 애플리케이션에 적합하지만, StatefulSet은 상태를 유지해야하는 애플리케이션을 관리하는 데 사용됩니다. 각 StatefulSet 팟은 고유한 네트워크 식별자와 지속적인 데이터 저장을 위한 별도의 볼륨을 갖습니다. 이러한 고유성은 팟이 쿠버네티스 클러스터에서 생성, 업데이트 및 삭제될 때 유지됩니다. StatefulSet은 일련의 인스턴스를 정의하고 관리하는 데 사용됩니다. 각 인스턴스는 순차적인 인덱스로 식별되며, 정의된 인스턴스 수에 따라 자동으로 생성 및 관리됩니다. 또한 StatefulSet은 인스턴스 간에 순차적으로 시작되고 종료되는 순서 보증을 제공합니다. StatefulSet을 사용하여 애플리케이션을 배포하면 각 인스턴스에 고유한 호스트 이름이 부여되고, 이를 통해 클러스터 내에서 인스턴스를 참조할 수 있습니다. 이러한 특성은 데이터베이스 클러스터의 마스터-슬레이브 설정과 같은 애플리케이션에서 중요합니다. StatefulSet은 쿠버네티스 클러스터의 안정성과 신뢰성을 향상시키는 데 도움이 됩니다. 예를 들어, StatefulSet은 팟이 실패한 경우 자동으로 새로운 인스턴스를 시작하여 애플리케이션의 가용성을 유지합니다. 또한 업그레이드 및 롤백과 같은 애플리케이션 버전 관리를 쉽게 할 수 있습니다. 요약하면, 쿠버네티스 StatefulSet은 상태가 있는 애플리케이션을 배포하고 관리하는 데 사용되며, 각 인스턴스에는 고유한 식별자와 별도의 볼륨이 제공됩니다. 이를 통해 순차적","text":"목차 쿠버네티스 - HPA (Horizontal Pod Autoscaler) 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s StatefulSet쿠버네티스(StatefulSet)는 쿠버네티스 클러스터 내에서 실행되는 애플리케이션의 상태를 유지하는 데 사용되는 컨트롤러입니다. 일반적으로 상태가 있는 애플리케이션인 데이터베이스, 메시지 큐 또는 파일 시스템과 같은 애플리케이션에 유용합니다. 쿠버네티스에서 일반적인 배포 유형인 Deployment는 상태를 가지지 않는 애플리케이션에 적합하지만, StatefulSet은 상태를 유지해야하는 애플리케이션을 관리하는 데 사용됩니다. 각 StatefulSet 팟은 고유한 네트워크 식별자와 지속적인 데이터 저장을 위한 별도의 볼륨을 갖습니다. 이러한 고유성은 팟이 쿠버네티스 클러스터에서 생성, 업데이트 및 삭제될 때 유지됩니다. StatefulSet은 일련의 인스턴스를 정의하고 관리하는 데 사용됩니다. 각 인스턴스는 순차적인 인덱스로 식별되며, 정의된 인스턴스 수에 따라 자동으로 생성 및 관리됩니다. 또한 StatefulSet은 인스턴스 간에 순차적으로 시작되고 종료되는 순서 보증을 제공합니다. StatefulSet을 사용하여 애플리케이션을 배포하면 각 인스턴스에 고유한 호스트 이름이 부여되고, 이를 통해 클러스터 내에서 인스턴스를 참조할 수 있습니다. 이러한 특성은 데이터베이스 클러스터의 마스터-슬레이브 설정과 같은 애플리케이션에서 중요합니다. StatefulSet은 쿠버네티스 클러스터의 안정성과 신뢰성을 향상시키는 데 도움이 됩니다. 예를 들어, StatefulSet은 팟이 실패한 경우 자동으로 새로운 인스턴스를 시작하여 애플리케이션의 가용성을 유지합니다. 또한 업그레이드 및 롤백과 같은 애플리케이션 버전 관리를 쉽게 할 수 있습니다. 요약하면, 쿠버네티스 StatefulSet은 상태가 있는 애플리케이션을 배포하고 관리하는 데 사용되며, 각 인스턴스에는 고유한 식별자와 별도의 볼륨이 제공됩니다. 이를 통해 순차적 StatefulSet vs deploymentStatefulSet과 Deployment는 Kubernetes에서 애플리케이션을 배포하고 관리하기 위한 리소스 유형입니다. 이들 간에는 몇 가지 중요한 차이점이 있습니다: 파드 식별과 순서: Deployment: Deployment는 파드를 수평적으로 확장하고, 파드의 수명 주기를 관리합니다. 파드에는 고유한 식별자가 없으며, 일반적으로 무작위로 생성되고 교체될 수 있습니다. StatefulSet: StatefulSet은 고유한 식별자를 가진 순차적으로 인스턴스화되는 파드를 관리합니다. 각 파드는 지속적으로 유지되며, 일관된 이름을 가지고 있어 네트워크 식별성을 유지합니다. 네트워킹과 서비스 디스커버리: Deployment: Deployment의 파드는 무작위로 생성되며, 각 파드는 임의의 네트워크 주소를 가집니다. 이는 서비스 디스커버리에 유리합니다. StatefulSet: StatefulSet의 파드는 고유한 순서를 가지고 생성되며, 각 파드는 일관된 이름과 네트워크 식별자를 가지고 있습니다. 이는 파드 간의 통신, 데이터베이스 복제 등과 같은 상태 관리에 유리합니다. 볼륨 관리: Deployment: Deployment는 파드의 볼륨을 동적으로 생성하고 관리하는 데 유용한 기능을 제공합니다. 하지만 볼륨의 수명 주기는 파드와 연결되지 않으며, 파드 재생성 시 볼륨이 사라질 수 있습니다. StatefulSet: StatefulSet은 파드 간에 지속적인 데이터 공유를 위한 볼륨을 관리하는 데 유용합니다. 각 파드는 별도의 지속적인 볼륨을 가지며, 파드 재생성 시에도 데이터는 보존됩니다. 업데이트 전략: Deployment: Deployment는 롤링 업데이트를 기본 전략으로 사용하여 새로운 버전의 애플리케이션을 배포하고 이전 버전의 파드를 점진적으로 교체합니다. StatefulSet: StatefulSet은 보다 신중한 업데이트 전략이 필요한 애플리케이션에 적합합니다. 파드를 순서대로 업데이트하여 데이터의 일관성을 유지합니다. 요약하면, Deployment는 상태를 가지지 않는 애플리케이션의 배포에 적합하며, StatefulSet은 상태를 가지는 애플리케이션(예: 데이터베이스)의 배포에 적합합니다. Deployment는 파드의 수평적인 확장에 중점을 두고 있으며, StatefulSet은 파드의 식별과 순차적인 배포, 네트워킹 및 볼륨 관리에 중점을 둡니다. StatefulSet vs ReplicaSetStatefulSet과 ReplicaSet은 Kubernetes에서 사용되는 컨트롤러 유형입니다. 두 개의 차이점을 살펴보겠습니다. 식별 가능한 상태 유지: ReplicaSet은 상태를 가지지 않는 파드 그룹을 관리합니다. 파드는 동일한 사양을 가지며, 클러스터에서의 실행을 보장하는 데 사용됩니다. ReplicaSet은 파드에 순서가 없으며, 파드가 재시작되면 다른 호스트에 배치될 수 있습니다.StatefulSet은 ReplicaSet과 유사하지만, 각 파드에 고유한 식별자를 부여하여 식별 가능한 상태를 유지합니다. 각 파드는 일련 번호를 가지고 있으며, 클러스터 내에서 고유한 DNS 이름을 통해 액세스할 수 있습니다. 이를 통해 StatefulSet은 파드의 순서를 보존하고, 데이터베이스나 메시지 큐와 같이 식별 가능한 상태를 요구하는 애플리케이션을 관리하는 데 유용합니다.파드의 관리 방식: ReplicaSet은 파드의 개수를 유지하는 데 초점을 맞춥니다. ReplicaSet은 지정된 개수의 파드를 유지하려고 시도하며, 파드가 삭제되면 새로운 파드를 생성하여 대체합니다. 그러나 파드의 호스트 이름이나 네트워크 식별자는 변경되지 않습니다.StatefulSet은 ReplicaSet의 기능을 포함하면서도 파드에 고유한 식별자를 제공합니다. StatefulSet은 파드를 일련 번호에 따라 생성하고, 삭제되는 경우 순차적으로 재생성합니다. 이러한 관리 방식은 파드가 고유한 네트워크 식별자와 영속적인 볼륨을 가질 수 있게 해주므로, 데이터베이스나 분산 시스템과 같은 상태를 유지해야 하는 애플리케이션을 실행하는 데 적합합니다.요약하자면, ReplicaSet은 파드 그룹의 크기를 유지하는 데 초점을 맞추고, 순서나 상태를 고려하지 않습니다. StatefulSet은 ReplicaSet의 기능을 포함하며, 각 파드에 고유한 식별자와 상태를 부여하여 식별 가능한 상태 유지를 지원합니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"워크로드","slug":"Kubernetes/워크로드","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C/"}],"tags":[]},{"title":"쿠버네티스 - DaemonSet","slug":"k8s/pod/DaemonSet","date":"2023-02-09T22:31:46.000Z","updated":"2024-02-18T16:19:54.541Z","comments":true,"path":"2023/02/10/k8s/pod/DaemonSet/","link":"","permalink":"https://ckck803.github.io/2023/02/10/k8s/pod/DaemonSet/","excerpt":"목차 Post not found: k8s/namespace Post not found: k8s/ingress 쿠버네티스 - Deployment Post not found: k8s/pod/replicaset 쿠버네티스 - Pod DaemonSet쿠버네티스( Kubernetes)에서 DaemonSet은 클러스터 내의 모든 노드에 특정 파드(Pod) 인스턴스를 배포하는 컨트롤러입니다. DaemonSet은 각 노드에서 반드시 실행되어야 하는 백그라운드 작업이나 로그 수집기와 같은 애플리케이션에 이상적입니다. 일반적인 ReplicaSet이나 Deployment와는 달리 DaemonSet은 모든 노드에서 파드를 실행하며, 새로운 노드가 클러스터에 추가되면 자동으로 해당 노드에 파드 인스턴스를 스케줄링합니다. 또한, 노드가 제거되면 DaemonSet은 해당 노드에서 실행 중인 파드를 자동으로 종료하고 대체 노드에서 실행될 새로운 파드 인스턴스를 생성합니다. DaemonSet은 주로 다음과 같은 사용 사례에 적합합니다: 로그 수집기: 모든 노드에서 로그를 수집하기 위해 DaemonSet을 사용할 수 있습니다. 예를 들어, Fluentd, Filebeat 등의 로그 수집기를 DaemonSet으로 배포하여 모든 노드의 로그를 중앙 집중화된 위치로 전송할 수 있습니다. 네트워크 에이전트: 네트워크 에이전트는 모든 노드에서 실행되어 네트워크 정책을 구현하고 트래픽을 관리합니다. DaemonSet을 사용하여 네트워크 에이전트를 클러스터의 모든 노드에 배포할 수 있습니다. 모니터링 및 메트릭 수집기: 클러스터의 모든 노드에서 메트릭 및 모니터링 정보를 수집하기 위해 DaemonSet을 사용할 수 있습니다. Prometheus, Telegraf 등의 도구를 DaemonSet으로 배포하여 모든 노드의 메트릭을 수집하고 모니터링할 수 있습니다. DaemonSet을 사용하면 쿠버네티스 클러스터의 모든 노드에서 실행되어야 하는 작업을 쉽게 배포하고 관리할 수 있습니다.","text":"목차 Post not found: k8s/namespace Post not found: k8s/ingress 쿠버네티스 - Deployment Post not found: k8s/pod/replicaset 쿠버네티스 - Pod DaemonSet쿠버네티스( Kubernetes)에서 DaemonSet은 클러스터 내의 모든 노드에 특정 파드(Pod) 인스턴스를 배포하는 컨트롤러입니다. DaemonSet은 각 노드에서 반드시 실행되어야 하는 백그라운드 작업이나 로그 수집기와 같은 애플리케이션에 이상적입니다. 일반적인 ReplicaSet이나 Deployment와는 달리 DaemonSet은 모든 노드에서 파드를 실행하며, 새로운 노드가 클러스터에 추가되면 자동으로 해당 노드에 파드 인스턴스를 스케줄링합니다. 또한, 노드가 제거되면 DaemonSet은 해당 노드에서 실행 중인 파드를 자동으로 종료하고 대체 노드에서 실행될 새로운 파드 인스턴스를 생성합니다. DaemonSet은 주로 다음과 같은 사용 사례에 적합합니다: 로그 수집기: 모든 노드에서 로그를 수집하기 위해 DaemonSet을 사용할 수 있습니다. 예를 들어, Fluentd, Filebeat 등의 로그 수집기를 DaemonSet으로 배포하여 모든 노드의 로그를 중앙 집중화된 위치로 전송할 수 있습니다. 네트워크 에이전트: 네트워크 에이전트는 모든 노드에서 실행되어 네트워크 정책을 구현하고 트래픽을 관리합니다. DaemonSet을 사용하여 네트워크 에이전트를 클러스터의 모든 노드에 배포할 수 있습니다. 모니터링 및 메트릭 수집기: 클러스터의 모든 노드에서 메트릭 및 모니터링 정보를 수집하기 위해 DaemonSet을 사용할 수 있습니다. Prometheus, Telegraf 등의 도구를 DaemonSet으로 배포하여 모든 노드의 메트릭을 수집하고 모니터링할 수 있습니다. DaemonSet을 사용하면 쿠버네티스 클러스터의 모든 노드에서 실행되어야 하는 작업을 쉽게 배포하고 관리할 수 있습니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"워크로드","slug":"Kubernetes/워크로드","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C/"}],"tags":[]},{"title":"쿠버네티스 - ReplicaSet","slug":"k8s/pod/ReplicaSets","date":"2023-02-09T21:31:46.000Z","updated":"2024-02-18T16:19:54.541Z","comments":true,"path":"2023/02/10/k8s/pod/ReplicaSets/","link":"","permalink":"https://ckck803.github.io/2023/02/10/k8s/pod/ReplicaSets/","excerpt":"목차 Post not found: k8s/namespace Post not found: k8s/ingress 쿠버네티스 - Deployment Post not found: k8s/pod/replicaset 쿠버네티스 - Pod 참고 https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors ReplicaSet 쿠버네티스에서 실행되는 Pod 의 Replica(복제본) 를 생성하고 지정된 Pod 수를 유지하는 오브젝트 ReplicaSet 은 파드의 개수를 모니터링하고, 파드의 개수가 지정된 개수보다 적으면 새로운 파드를 생성하고, 파드의 개수가 지정된 개수보다 많으면 기존의 파드를 삭제합니다. ReplicaSet은 특정 파드의 복제본 수를 지정하는 것을 목표로 합니다. 파드를 정의하는 템플릿과 함께 ReplicaSet을 생성하면 ReplicaSet은 해당 템플릿을 기반으로 복제본 파드를 생성합니다. 만약 파드의 복제본 수가 ReplicaSet의 목표값보다 적다면, ReplicaSet은 추가 파드를 생성하여 원하는 복제본 수를 유지하려고 시도합니다. 반대로, 파드의 복제본 수가 ReplicaSet의 목표값보다 많다면, ReplicaSet은 파드를 제거하여 원하는 복제본 수를 줄이려고 시도합니다. ReplicaSet은 파드의 복제본 수를 모니터링하며, 다양한 상황에서 자동으로 조치를 취합니다. 예를 들어, ReplicaSet이 파드의 수를 감지하고 즉시 새로운 복제본을 생성하여 장애가 발생한 파드를 대체할 수 있습니다. ReplicaSet은 롤링 업데이트(rolling update)를 통해 애플리케이션 버전 업그레이드도 관리할 수 있습니다. 이는 예전 버전의 파드를 점진적으로 제거하고 새 버전의 파드를 생성하여 서비스 중단을 최소화합니다.","text":"목차 Post not found: k8s/namespace Post not found: k8s/ingress 쿠버네티스 - Deployment Post not found: k8s/pod/replicaset 쿠버네티스 - Pod 참고 https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors ReplicaSet 쿠버네티스에서 실행되는 Pod 의 Replica(복제본) 를 생성하고 지정된 Pod 수를 유지하는 오브젝트 ReplicaSet 은 파드의 개수를 모니터링하고, 파드의 개수가 지정된 개수보다 적으면 새로운 파드를 생성하고, 파드의 개수가 지정된 개수보다 많으면 기존의 파드를 삭제합니다. ReplicaSet은 특정 파드의 복제본 수를 지정하는 것을 목표로 합니다. 파드를 정의하는 템플릿과 함께 ReplicaSet을 생성하면 ReplicaSet은 해당 템플릿을 기반으로 복제본 파드를 생성합니다. 만약 파드의 복제본 수가 ReplicaSet의 목표값보다 적다면, ReplicaSet은 추가 파드를 생성하여 원하는 복제본 수를 유지하려고 시도합니다. 반대로, 파드의 복제본 수가 ReplicaSet의 목표값보다 많다면, ReplicaSet은 파드를 제거하여 원하는 복제본 수를 줄이려고 시도합니다. ReplicaSet은 파드의 복제본 수를 모니터링하며, 다양한 상황에서 자동으로 조치를 취합니다. 예를 들어, ReplicaSet이 파드의 수를 감지하고 즉시 새로운 복제본을 생성하여 장애가 발생한 파드를 대체할 수 있습니다. ReplicaSet은 롤링 업데이트(rolling update)를 통해 애플리케이션 버전 업그레이드도 관리할 수 있습니다. 이는 예전 버전의 파드를 점진적으로 제거하고 새 버전의 파드를 생성하여 서비스 중단을 최소화합니다. 일반적으로 ReplicaSet은 디플로이먼트(Deployment)와 함께 사용됩니다. 디플로이먼트는 ReplicaSet을 쉽게 정의하고 관리할 수 있는 리소스입니다. ReplicaSet은 주로 파드의 복제본 수를 관리하는 데 사용되지만, 디플로이먼트는 업데이트 전략, 롤백, 롤링 업데이트 등을 지원하여 애플리케이션 배포 및 관리를 더욱 편리하게 할 수 있습니다. 요약하자면, ReplicaSet은 쿠버네티스에서 파드의 복제본 수를 관리하고 유지하는 기능을 제공하는 오브젝트로, 파드의 가용성과 확장성을 보장합니다. ReplicaSet 생성ReplicaSet은 label 을 체크해서 원하는 수의 Pod 이 없으면 새로운 Pod 을 생성합니다. 이를 설정으로 표현하면 다음과 같습니다. 정의 설명 spec.replicas 원하는 Pod의 개수 spec.selector label 체크 조건 spec.template 생성할 Pod의 명세 apiVersion: apps/v1kind: ReplicaSetmetadata: name: echo-rsspec: replicas: 1 selector: matchLabels: app: echo tier: app template: metadata: labels: app: echo tier: app spec: containers: - name: echo image: ghcr.io/subicura/echo:v1 ReplicatSet 적용 및 확인kubectl apply -f ReplicaSet.yaml ReplicatSet 검색# default Namespace 내의 ReplicatSet 검색kubectl get replicasets# 모든 Namespace 내의 ReplicatSet 검색kubectl get replicasets --all-namespaces# 단축어를 사용한 검색kubectl get rs# 상세한 검색kubectl get replicasets -o wide Scale Out","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"워크로드","slug":"Kubernetes/워크로드","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C/"}],"tags":[]},{"title":"Docker","slug":"docker/docker","date":"2023-02-07T21:31:46.000Z","updated":"2024-03-03T01:43:01.898Z","comments":true,"path":"2023/02/08/docker/docker/","link":"","permalink":"https://ckck803.github.io/2023/02/08/docker/docker/","excerpt":"Container 란?컨테이너는 어플리케이션을 실행하기 위해 필요한 모든 요소가 포함된 소프트웨어 패키지를 의미합니다.Container 화된 어플리케이션은 실행시 별 독립된(격리된) 실행환경에서 실행됩니다. Docker 란? Docker 는 컨테이너 기반 가상화 플랫폼으로, 어플리케이션을 패키징하고 배포하는데 사용됩니다. 도커(Docker)는 컨테이너 기반 가상화 플랫폼으로, 어플리케이션을 패키징하고 배포하는 데 사용됩니다. 도커는 소프트웨어를 컨테이너로 묶어서 실행할 수 있게 해주며, 이 컨테이너는 호스트 시스템과 격리되어 있어 응용 프로그램의 이식성과 확장성을 높이는 데 도움이 됩니다.","text":"Container 란?컨테이너는 어플리케이션을 실행하기 위해 필요한 모든 요소가 포함된 소프트웨어 패키지를 의미합니다.Container 화된 어플리케이션은 실행시 별 독립된(격리된) 실행환경에서 실행됩니다. Docker 란? Docker 는 컨테이너 기반 가상화 플랫폼으로, 어플리케이션을 패키징하고 배포하는데 사용됩니다. 도커(Docker)는 컨테이너 기반 가상화 플랫폼으로, 어플리케이션을 패키징하고 배포하는 데 사용됩니다. 도커는 소프트웨어를 컨테이너로 묶어서 실행할 수 있게 해주며, 이 컨테이너는 호스트 시스템과 격리되어 있어 응용 프로그램의 이식성과 확장성을 높이는 데 도움이 됩니다.","categories":[{"name":"Docker","slug":"Docker","permalink":"https://ckck803.github.io/categories/Docker/"}],"tags":[]},{"title":"쿠버네티스 - Code 로 Config 수정하기","slug":"k8s/edit-code","date":"2023-02-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.537Z","comments":true,"path":"2023/02/08/k8s/edit-code/","link":"","permalink":"https://ckck803.github.io/2023/02/08/k8s/edit-code/","excerpt":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod 참고 https://gist.github.com/mordr/3c2df494c690672247c720f66f0fb613 환경 변수 추가export KUBE_EDITOR=&#x27;code --wait&#x27;","text":"목차 Post not found: k8s/namespace Post not found: k8s/ingress Post not found: k8s/deployment Post not found: k8s/replicaset Post not found: k8s/node Post not found: k8s/pod 참고 https://gist.github.com/mordr/3c2df494c690672247c720f66f0fb613 환경 변수 추가export KUBE_EDITOR=&#x27;code --wait&#x27;","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"}],"tags":[]},{"title":"쿠버네티스 - kubectl","slug":"k8s/kubectl","date":"2023-02-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.540Z","comments":true,"path":"2023/02/08/k8s/kubectl/","link":"","permalink":"https://ckck803.github.io/2023/02/08/k8s/kubectl/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s 참고 https://kubebyexample.com/learning-paths/application-development-kubernetes/lesson-1-running-containerized-applications Kubectl 명령어조회kubectl get pod kubectl get pod -w kubectl get pod -o wide","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane Post not found: k8s/k8s 참고 https://kubebyexample.com/learning-paths/application-development-kubernetes/lesson-1-running-containerized-applications Kubectl 명령어조회kubectl get pod kubectl get pod -w kubectl get pod -o wide AZ 확인kubectl get nodes -L topology.kubernetes.io/zone Pod 내 Container 로그 확인Config 변경kubectl config use-context minikube kubectl config get-contexts 적용된 리소스를 yaml 형식으로 보고 싶윽 경우kubectl get pods [pods name] -o yaml 로그 확인 명령어kubectl logs [Pod 이름] -n [Namespace 이름] 쿠버네티스 Namespace 내 Scaling 중단 for i in $(kubectl get deploy -n &lt;namespace&gt; | grep -v NAME | awk &#x27;&#123;print $1&#125;&#x27;) ; do kubectl scale deploy/$i -n &lt;namespace&gt;$i replicas=0; done 실행 for i in $(kubectl get deploy -n &lt;namespace&gt; | grep -v NAME | awk &#x27;&#123;print $1&#125;&#x27;) ; do kubectl scale deploy/$i -n &lt;namespace&gt;$i replicas=1; done","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"}],"tags":[]},{"title":"쿠버네티스 - kube-proxy","slug":"k8s/k8s/kube-proxy","date":"2023-02-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.540Z","comments":true,"path":"2023/02/08/k8s/k8s/kube-proxy/","link":"","permalink":"https://ckck803.github.io/2023/02/08/k8s/k8s/kube-proxy/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 kube-proxy","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 kube-proxy","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"구성요소","slug":"Kubernetes/구성요소","permalink":"https://ckck803.github.io/categories/Kubernetes/%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"}],"tags":[]},{"title":"쿠버네티스 - Node","slug":"k8s/node/node","date":"2023-02-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.540Z","comments":true,"path":"2023/02/08/k8s/node/node/","link":"","permalink":"https://ckck803.github.io/2023/02/08/k8s/node/node/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s Master NodeNode 란 Node 는 쿠버네티스에서 Worker 머신 을 말하며 클러스터에 따라 가상 또는 물리 머신일 수 있다. Container 화 된 어플리케이션을 실행하고 관리하는 역할 Node 는 호스트 운영체제와 함께 실행되며 CPU, Memory, Disk, Network 와 같은 하드웨어 리소스를 제공한다. Node 확인kubectl get nodes Node 내의 Pod 확인","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod Post not found: k8s/k8s Master NodeNode 란 Node 는 쿠버네티스에서 Worker 머신 을 말하며 클러스터에 따라 가상 또는 물리 머신일 수 있다. Container 화 된 어플리케이션을 실행하고 관리하는 역할 Node 는 호스트 운영체제와 함께 실행되며 CPU, Memory, Disk, Network 와 같은 하드웨어 리소스를 제공한다. Node 확인kubectl get nodes Node 내의 Pod 확인 node-name : 위에서 확인한 Node 이름 kubectl get pods --field-selector=spec.nodeName=&lt;node-name&gt;","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"}],"tags":[]},{"title":"쿠버네티스 - Pod","slug":"k8s/pod/pod","date":"2023-02-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.541Z","comments":true,"path":"2023/02/08/k8s/pod/pod/","link":"","permalink":"https://ckck803.github.io/2023/02/08/k8s/pod/pod/","excerpt":"목차 Post not found: k8s/namespace Post not found: k8s/ingress 쿠버네티스 - Deployment Post not found: k8s/pod/replicaset 쿠버네티스 - Pod 참고 https://blog.2dal.com/2018/03/28/kubernetes-01-pod/ https://blog.heptio.com/core-kubernetes-jazz-improv-over-orchestration-a7903ea92ca 출처해당 포스트는 subicura 강사님의 초보를 위한 쿠버네티스 안내서 강의를 바탕으로 작성 됐습니다. Pod Pod 는 쿠버네티스에서 관리하는 기본단위 이며 가장 작은 배포 단위 쿠버네티스는 Pod 을 이용해 Container 를 관리 하며 Pod 내의 Container 는 모두 동일한 Host 에서 실행되며 네트워크와 저장소를 공유합니다. 이로 인해 컨테이너는 같은 Pod 내에서 다른 Container 와 효율적으로 통신하고 데이터를 공유할 수 있습니다.","text":"목차 Post not found: k8s/namespace Post not found: k8s/ingress 쿠버네티스 - Deployment Post not found: k8s/pod/replicaset 쿠버네티스 - Pod 참고 https://blog.2dal.com/2018/03/28/kubernetes-01-pod/ https://blog.heptio.com/core-kubernetes-jazz-improv-over-orchestration-a7903ea92ca 출처해당 포스트는 subicura 강사님의 초보를 위한 쿠버네티스 안내서 강의를 바탕으로 작성 됐습니다. Pod Pod 는 쿠버네티스에서 관리하는 기본단위 이며 가장 작은 배포 단위 쿠버네티스는 Pod 을 이용해 Container 를 관리 하며 Pod 내의 Container 는 모두 동일한 Host 에서 실행되며 네트워크와 저장소를 공유합니다. 이로 인해 컨테이너는 같은 Pod 내에서 다른 Container 와 효율적으로 통신하고 데이터를 공유할 수 있습니다. Pod 의 특징 단일 노드에서 실행 Pod는 하나의 노드(호스트) 에서 실행됩니다. IP 주소와 호스트 이름 공유 각 Pod는 고유한 IP 주소를 가지며, Pod 내 컨테이너들은 고유한 IP 주소를 공유합니다. 또한 Pod 내의 컨테이너는 동일한 호스트 이름을 사용하여 서로 통신할 수 있습니다. Pod 내 컨테이너가 두개 이상 있을 경우 두 컨테이너는 같은 IP 주소를 갖는다. 하나의 Pod 안에 있는 모든 컨테이너들은 localhost 로 서로 통신할 수 있다. 볼륨 마운트 Pod 는 볼륨을 사용하여 데이터를 저장하고 컨테이너 간에 공유할 수 있습니다. 이를 통해 데이터 지속성과 컨테이너 간의 데이터 공유가 가능해집니다. Container 라이프사이클 관리 Pod 는 컨테이너의 라이프사이클을 관리합니다. 컨테이너가 실행되거나 종료될 때 Pod 는 자동으로 컨테이너를 다시 시작하거나 다른 컨테이너를 생성합니다. Pod 생성하기kubectl run echo --image ghcr.io/subicura/echo:v1 yaml 파일을 이용한 Pod 생성보다 많은 정보를 이용해 Pod 를 생성할 수 있도록 쿠버네티스에서는 yaml 파일을 이용해 Pod 를 생성할 수 있도록 지원합니다. 쿠버네티스는 리소스를 관리할 때 name 과 label 을 이용합니다. yaml 파일에 대한 정보로 &#96; apiVersion: v1kind: Podmetadata: name: echo labels: app: echospec: containers: - name: app image: ghcr.io/subicura/echo:v1 kubectl apply 명령어를 이용해 pod 를 생성해주도록 한다. kubectl apply -f echo-pod.yml 실행 결과READY 에서 1/1 은 해당 Pod의 준비 상태를 나타내며, 첫 번째 숫자는 현재 준비된 컨테이너 수를, 두 번째 숫자는 총 컨테이너 수를 나타냅니다. Pod 생성과정 API Server 를 이용해 Pod 를 생성합니다. API Server 는 ectd 에 생성된 Pod 를 기록합니다. Scheduler 는 Node 를 할당받지 못한 Pod 를 체크한 후 Pod 를 실행할 Node 를 할당해줍니다. Scheduler 는 Pod 를 실행할 Node 정보를 API Server에 알려줍니다. kubelet 은 해당 노드에 바인딩된 파드들을 watch 하다가 할당된 Pod 내 컨테이너를 실행합니다. kubelet 은 컨테이너 런타임을 통해 Pod 상태를 모니터링 하다가 상태가 변경되면 API Server 에 반영합니다. API Server 은 kubelet 을 통해 전달받은 Pod 의 상태를 etcd 에 반영합니다. Pod 제거kubectl delete 명령어를 이용해 해당 Pod 를 제거할 수 있습니다. kubectl delete pod [삭제할 Pod 이름] Probe컨테이너에서 Kubelet 에 의해 주기적으로 수행되는 진단 livenessProbe컨테이너가 정상적으로 동작하는지 체크하고 정상적으로 동작하지 않는다면 컨테이너를 재시작 하여 문제를 해결합니다. 매니페스트 내 spec.containers.livenessProbe 를 정의함으로써 Container 의 livenessProbe 를 설정할 수 있습니다. apiVersion: v1kind: Podmetadata: name: echo-lp labels: app: echospec: containers: - name: app image: ghcr.io/subicura/echo:v1 livenessProbe: httpGet: path: /not/exist port: 8080 initialDelaySeconds: 5 timeoutSeconds: 2 # Default 1 periodSeconds: 5 # Defaults 10 failureThreshold: 1 # Defaults 3 readinessProbe컨테이너가 준비되었는지 체크하고 정상적으로 준비되지 않았다면 Pod으로 들어오는 요청을 제외합니다 livenessProbe와 차이점은 문제가 있어도 Pod을 재시작하지 않고 요청만 제외한다는 점입니다. 매니페스트 내 spec.containers.readinessProbe 를 정의함으로써 Container 내 readinessProbe 를 설정할 수 있습니다. apiVersion: v1kind: Podmetadata: name: echo-rp labels: app: echospec: containers: - name: app image: ghcr.io/subicura/echo:v1 readinessProbe: httpGet: path: /not/exist port: 8080 initialDelaySeconds: 5 timeoutSeconds: 2 # Default 1 periodSeconds: 5 # Defaults 10 failureThreshold: 1 # Defaults 3 다중 컨테이너Pod 에는 한개 이상의 컨테이너를 실행시킬 수 있습니다. apiVersion: v1kind: Podmetadata: name: counter labels: app: counterspec: containers: - name: app image: ghcr.io/subicura/counter:latest env: - name: REDIS_HOST value: &quot;localhost&quot; - name: db image: redis Pod 내 총 컨테이너 수가 2로 늘어난 것을 확인할 수 있습니다. Pod 내 Container 목록을 확인해보면 app Conatainer 와 db Container 가 실행돼 있는 것을 확인할 수 있습니다. kubectl get pods &lt;pod-name&gt; -o jsonpath=&#x27;&#123;.spec.containers[*].name&#125;&#x27;","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"워크로드","slug":"Kubernetes/워크로드","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C/"}],"tags":[]},{"title":"EKS - eksctl 로 클러스터 생성 및 삭제","slug":"aws/eks/eks-eksctl","date":"2023-01-31T20:31:07.000Z","updated":"2024-02-18T16:19:54.516Z","comments":true,"path":"2023/02/01/aws/eks/eks-eksctl/","link":"","permalink":"https://ckck803.github.io/2023/02/01/aws/eks/eks-eksctl/","excerpt":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 eksctl Documnet https://eksctl.io/ eksctl로 클러스터 생성하기 https://catalog.us-east-1.prod.workshops.aws/workshops/9c0aa9ab-90a9-44a6-abe1-8dff360ae428/ko-KR/50-eks-cluster/100-launch-cluster Amazon EKS의 애플리케이션 로드 밸런싱 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/alb-ingress.html 나만의 k8s 클러스터 구축하기 https://coffeewhale.com/kubernetes/cluster/eks/2020/09/03/k8s-eks/ EKSCTL 를 이용한 EKS 구성 https://kingofbackend.tistory.com/235 eksctl 설치 MAC OS # mac osbrew tap weaveworks/tapbrew install weaveworks/tap/eksctl Linux # eksctl 명령어 설치curl --silent --location &quot;https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz&quot; | tar xz -C /tmp# 전역적으로 사용할 수 있게 bin 파일로 이동sudo mv /tmp/eksctl /usr/local/bin","text":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) 참고 eksctl Documnet https://eksctl.io/ eksctl로 클러스터 생성하기 https://catalog.us-east-1.prod.workshops.aws/workshops/9c0aa9ab-90a9-44a6-abe1-8dff360ae428/ko-KR/50-eks-cluster/100-launch-cluster Amazon EKS의 애플리케이션 로드 밸런싱 https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/alb-ingress.html 나만의 k8s 클러스터 구축하기 https://coffeewhale.com/kubernetes/cluster/eks/2020/09/03/k8s-eks/ EKSCTL 를 이용한 EKS 구성 https://kingofbackend.tistory.com/235 eksctl 설치 MAC OS # mac osbrew tap weaveworks/tapbrew install weaveworks/tap/eksctl Linux # eksctl 명령어 설치curl --silent --location &quot;https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz&quot; | tar xz -C /tmp# 전역적으로 사용할 수 있게 bin 파일로 이동sudo mv /tmp/eksctl /usr/local/bin 명령어를 통한 Cluster 설치eksctl 명령어를 이용해 aws 에 생성하고자 하는 Kubernetes 클러스터를 생성해줄 수 있습니다. EKS 클러스터 생성시 NodeGroup 과 Node 들이 한번에 설치된 모습을 확인할 수 있다. cluster-name: 새로운 EKS 클러스터의 이름을 지정합니다. aws-region: 클러스터가 생성될 AWS 리전을 지정합니다. ap-northeast-2 (서울) nodegroup-name: 노드 그룹의 이름을 지정합니다. instance-type: 노드 인스턴스 유형을 지정합니다. t3.xlarge, m5.large number-of-nodes: 생성할 노드의 수를 지정합니다. eksctl create cluster \\ --name &lt;cluster-name&gt; \\ --version &lt;Kubernetes 버전&gt; --region &lt;aws-region&gt; \\ --nodegroup-name &lt;nodegroup-name&gt; \\ --node-type &lt;instance-type&gt; \\ --nodes &lt;number-of-nodes&gt; Cluster 만 우선 생성Kubernetes 클러스터를 우선 생성하고 이후에 NodeGroup 을 추가하고 싶을 때 create 명령어 실행시 --without-nodegroup 옵션을 주면 EKS Cluster 만 생성된 모습을 볼 수 있다. eksctl create cluster \\ --name &lt;cluster-name&gt; \\ --version &lt;Kubernetes 버전&gt; --region &lt;aws-region&gt; \\ --without-nodegroup ClusterConfig 파일을 이용한 설치ClusterConfig 를 yaml 파일로 생성해줍니다. ---apiVersion: eksctl.io/v1alpha5kind: ClusterConfigmetadata: name: eks-demo # 생성할 EKS 클러스터명 region: $&#123;AWS_REGION&#125; # 클러스터를 생성할 리전 version: &quot;1.23&quot;vpc: cidr: &quot;10.0.0.0/16&quot; # 클러스터에서 사용할 VPC의 CIDR nat: gateway: HighlyAvailablemanagedNodeGroups: - name: node-group # 클러스터의 노드 그룹명 instanceType: m5.large # 클러스터 워커 노드의 인스턴스 타입 desiredCapacity: 3 # 클러스터 워커 노드의 갯수 volumeSize: 20 # 클러스터 워커 노드의 EBS 용량 (단위: GiB) privateNetworking: true ssh: enableSsm: true iam: withAddonPolicies: imageBuilder: true # Amazon ECR에 대한 권한 추가 albIngress: true # albIngress에 대한 권한 추가 cloudWatch: true # cloudWatch에 대한 권한 추가 autoScaler: true # auto scaling에 대한 권한 추가 ebs: true # EBS CSI Driver에 대한 권한 추가cloudWatch: clusterLogging: enableTypes: [&quot;*&quot;]iam: withOIDC: true 생성된 ClusterConfig 파일을 eksctl 명령어를 이용해 cluster 를 생성해주도록 한다. eksctl create cluster -f eks-demo-cluster.yaml 3개의 Node 를 갖고 있는 클러스터 아키텍처 Kube Config 에 새로운 클러스터 추가aws eks update-kubeconfig \\ --region [aws-region]\\ --name [eks 클러스터 이름] \\ --role-arn [AWS Role] \\ --profile [AWS Profile] Eksctl Cluster 삭제eksctl 명령어를 이용해 삭제하고 싶은 cluster 를 삭제할 수 있습니다. eksctl delete cluster --name &lt;cluster name&gt; 삭제 로그 3개 노드로eksctl create cluster \\ --name user10-eks3 --version 1.25 \\ --node-type t3.medium --nodes 3 \\ --nodes-min 1 \\ --node-volume-type gp3 \\ --nodes-max 3 \\ --asg-access \\ --full-ecr-access --spot \\ --with-oidc --managed \\ kubectl get nodesNAME STATUS ROLES AGE VERSIONip-192-168-16-29.ap-northeast-1.compute.internal Ready &lt;none&gt; 79m v1.22.17-eks-0a21954ip-192-168-46-125.ap-northeast-1.compute.internal Ready &lt;none&gt; 79m v1.22.17-eks-0a21954ip-192-168-77-21.ap-northeast-1.compute.internal Ready &lt;none&gt; 79m v1.22.17-eks-0a21954","categories":[{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"}],"tags":[]},{"title":"React - React Router Dom 사용하기","slug":"react/react-router.dom","date":"2023-01-23T21:31:46.000Z","updated":"2024-11-23T16:46:03.700Z","comments":true,"path":"2023/01/24/react/react-router.dom/","link":"","permalink":"https://ckck803.github.io/2023/01/24/react/react-router.dom/","excerpt":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 React Router Dom 추가하기# npm 사용npm install react-router-dom# yarn 사용yarn add react-router-dom","text":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 React Router Dom 추가하기# npm 사용npm install react-router-dom# yarn 사용yarn add react-router-dom","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Redux","slug":"Frontend/Redux","permalink":"https://ckck803.github.io/categories/Frontend/Redux/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"쿠버네티스 - etcd","slug":"k8s/k8s/etcd","date":"2023-01-10T21:31:46.000Z","updated":"2024-02-18T16:19:54.540Z","comments":true,"path":"2023/01/11/k8s/k8s/etcd/","link":"","permalink":"https://ckck803.github.io/2023/01/11/k8s/k8s/etcd/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 참고 공식문서 https://kubernetes.io/ko/docs/concepts/overview/components/ https://malwareanalysis.tistory.com/512 etcd쿠버네티스(etcd)는 쿠버네티스 클러스터의 상태와 구성 정보를 저장하고 관리하는 데 사용되는 분산 키-값 저장소입니다. etcd는 신뢰성과 일관성을 제공하여 쿠버네티스 클러스터의 안정적인 동작을 보장합니다. etcd는 분산 환경에서 동작하는 일관성 있는 데이터베이스로서, 분산 시스템에서 발생하는 다양한 문제에 대응하기 위해 설계되었습니다. 이를 위해 Raft라는 합의 알고리즘을 사용하여 일관성 있는 복제를 제공합니다. Raft 알고리즘은 분산 시스템에서 노드 간에 일관된 상태를 유지하고 리더 노드의 선택과 로그 복제를 통해 안정성을 보장하는 데 사용됩니다. 쿠버네티스 클러스터 내의 모든 구성 요소는 etcd에 상태 정보를 저장합니다. 이 정보에는 클러스터의 노드, 팟, 서비스, 볼륨, 설정 등의 데이터가 포함됩니다. etcd는 이러한 정보를 실시간으로 유지하고 변경 사항을 관리하여 쿠버네티스 클러스터의 모든 구성 요소가 항상 일관된 상태로 동작할 수 있도록 합니다. 또한, etcd는 분산 환경에서 안정적인 데이터 저장소로서 동작하므로, 장애가 발생하거나 노드가 추가되거나 제거될 때에도 클러스터의 안정성을 유지할 수 있습니다. etcd는 데이터를 여러 노드에 복제하여 가용성과 내결함성을 보장하며, 필요에 따라 데이터를 자동으로 복구하여 시스템의 일관성을 유지합니다.","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 참고 공식문서 https://kubernetes.io/ko/docs/concepts/overview/components/ https://malwareanalysis.tistory.com/512 etcd쿠버네티스(etcd)는 쿠버네티스 클러스터의 상태와 구성 정보를 저장하고 관리하는 데 사용되는 분산 키-값 저장소입니다. etcd는 신뢰성과 일관성을 제공하여 쿠버네티스 클러스터의 안정적인 동작을 보장합니다. etcd는 분산 환경에서 동작하는 일관성 있는 데이터베이스로서, 분산 시스템에서 발생하는 다양한 문제에 대응하기 위해 설계되었습니다. 이를 위해 Raft라는 합의 알고리즘을 사용하여 일관성 있는 복제를 제공합니다. Raft 알고리즘은 분산 시스템에서 노드 간에 일관된 상태를 유지하고 리더 노드의 선택과 로그 복제를 통해 안정성을 보장하는 데 사용됩니다. 쿠버네티스 클러스터 내의 모든 구성 요소는 etcd에 상태 정보를 저장합니다. 이 정보에는 클러스터의 노드, 팟, 서비스, 볼륨, 설정 등의 데이터가 포함됩니다. etcd는 이러한 정보를 실시간으로 유지하고 변경 사항을 관리하여 쿠버네티스 클러스터의 모든 구성 요소가 항상 일관된 상태로 동작할 수 있도록 합니다. 또한, etcd는 분산 환경에서 안정적인 데이터 저장소로서 동작하므로, 장애가 발생하거나 노드가 추가되거나 제거될 때에도 클러스터의 안정성을 유지할 수 있습니다. etcd는 데이터를 여러 노드에 복제하여 가용성과 내결함성을 보장하며, 필요에 따라 데이터를 자동으로 복구하여 시스템의 일관성을 유지합니다. 요약하자면, 쿠버네티스의 etcd는 분산 키-값 저장소로서 쿠버네티스 클러스터의 상태와 구성 정보를 저장하고 관리합니다. 이를 통해 쿠버네티스 클러스터의 안정적인 운영과 확장성을 제공합니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"구성요소","slug":"Kubernetes/구성요소","permalink":"https://ckck803.github.io/categories/Kubernetes/%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"}],"tags":[]},{"title":"쿠버네티스 - Data Plane","slug":"k8s/k8s/data_plane","date":"2023-01-09T21:31:46.000Z","updated":"2024-02-18T16:19:54.539Z","comments":true,"path":"2023/01/10/k8s/k8s/data_plane/","link":"","permalink":"https://ckck803.github.io/2023/01/10/k8s/k8s/data_plane/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ Data Plane 이란데이터 플레인은 클러스터 내에서 컨테이너화된 애플리케이션들의 통신과 네트워크 기능을 담당합니다. Data Plane은 Kubernetes Worker Node에 위치한 컨테이너 런타임 환경과 관련된 구성 요소들로 이루어져 있습니다. 예를 들어, 각 Worker Node에는 쿠버네티스 컨트롤 플레인에서 제어되는 파드(Pod)가 배치됩니다. 이러한 파드는 각각 하나 이상의 컨테이너를 실행하며, 이 컨테이너는 애플리케이션 또는 서비스를 제공합니다. Data Plane의 핵심 구성 요소 중 하나는 kube-proxy입니다. kube-proxy는 서비스(Services)를 처리하며, 클러스터 내부의 파드와 서비스 간의 네트워크 연결을 관리합니다. 이를 위해 kube-proxy는 파드와 서비스에 대한 가상 IP 주소를 할당하고, 이를 통해 라우팅하며, 로드 밸런싱과 같은 작업을 수행합니다. 또 다른 중요한 구성 요소는 컨테이너 네트워크 인터페이스(CNI) 플러그인입니다. CNI 플러그인은 클러스터의 노드와 파드에 할당된 IP 주소를 관리하고, 네트워크 보안을 제공하며, 네트워크 트래픽을 제어합니다.","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ Data Plane 이란데이터 플레인은 클러스터 내에서 컨테이너화된 애플리케이션들의 통신과 네트워크 기능을 담당합니다. Data Plane은 Kubernetes Worker Node에 위치한 컨테이너 런타임 환경과 관련된 구성 요소들로 이루어져 있습니다. 예를 들어, 각 Worker Node에는 쿠버네티스 컨트롤 플레인에서 제어되는 파드(Pod)가 배치됩니다. 이러한 파드는 각각 하나 이상의 컨테이너를 실행하며, 이 컨테이너는 애플리케이션 또는 서비스를 제공합니다. Data Plane의 핵심 구성 요소 중 하나는 kube-proxy입니다. kube-proxy는 서비스(Services)를 처리하며, 클러스터 내부의 파드와 서비스 간의 네트워크 연결을 관리합니다. 이를 위해 kube-proxy는 파드와 서비스에 대한 가상 IP 주소를 할당하고, 이를 통해 라우팅하며, 로드 밸런싱과 같은 작업을 수행합니다. 또 다른 중요한 구성 요소는 컨테이너 네트워크 인터페이스(CNI) 플러그인입니다. CNI 플러그인은 클러스터의 노드와 파드에 할당된 IP 주소를 관리하고, 네트워크 보안을 제공하며, 네트워크 트래픽을 제어합니다. 이러한 구성 요소들은 Kubernetes의 Data Plane에서 상호작용하여, 애플리케이션 인스턴스의 실행과 관리, 트래픽 라우팅, 네트워크 보안 등 다양한 작업을 수행합니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"구성요소","slug":"Kubernetes/구성요소","permalink":"https://ckck803.github.io/categories/Kubernetes/%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"}],"tags":[]},{"title":"쿠버네티스 - Control Plane","slug":"k8s/k8s/control_plane","date":"2023-01-08T21:31:46.000Z","updated":"2024-02-18T16:19:54.539Z","comments":true,"path":"2023/01/09/k8s/k8s/control_plane/","link":"","permalink":"https://ckck803.github.io/2023/01/09/k8s/k8s/control_plane/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ Control Plane 이란Control Plane은 Kubernetes 클러스터 내에서 모든 매니지먼트 기능을 제공하는 중앙 집중화된 구성 요소입니다. 이것은 Kubernetes 클러스터를 구성하는 모든 노드에 설치되어 있으며, 클러스터 내의 다른 구성 요소와 상호 작용하여 Kubernetes 애플리케이션을 배포, 확장, 업데이트 및 관리하는 데 사용됩니다. Control Plane은 크게 세 가지 주요 컴포넌트로 구성됩니다. API Server 클러스터 내의 모든 리소스를 관리하고 Kubernetes API를 노출하는 중앙 집중화된 컴포넌트입니다. API 서버는 사용자가 Kubernetes 클러스터와 상호 작용하기 위한 인터페이스를 제공하며, 클러스터 리소스를 조작하는 모든 작업을 처리합니다. Controller Manager API 서버에서 리소스 변경 사항을 감지하고 해당 리소스 상태를 원하는 상태로 유지하기 위해 실행되는 컴포넌트입니다. 예를 들어, 노드가 다운되면 컨트롤러 매니저는 해당 노드에서 실행 중인 파드를 다른 노드로 이동시키기 위해 동작합니다. etcd 클러스터 상태를 저장하는 분산형 Key-Value 저장소입니다. Kubernetes 컨트롤 플레인의 모든 컴포넌트는 etcd를 통해 클러스터의 상태를 읽고 쓰게 됩니다. etcd 는 분산형 저장소이기 때문에 데이터 일관성과 가용성을 보장합니다. 이러한 컴포넌트는 모두 Kubernetes 클러스터 내에서 상호작용하며, 애플리케이션을 배포, 확장, 업데이트 및 관리하기 위한 모든 매니지먼트 작업을 수행합니다. Control Plane은 Kubernetes 클러스터의 중심적인 역할을 수행하며, 클러스터의 안정성과 가용성을 보장하기 위해 중요한 역할을 합니다.","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 공식 홈페이지 https://istio.io/latest/docs/setup/getting-started/ Control Plane 이란Control Plane은 Kubernetes 클러스터 내에서 모든 매니지먼트 기능을 제공하는 중앙 집중화된 구성 요소입니다. 이것은 Kubernetes 클러스터를 구성하는 모든 노드에 설치되어 있으며, 클러스터 내의 다른 구성 요소와 상호 작용하여 Kubernetes 애플리케이션을 배포, 확장, 업데이트 및 관리하는 데 사용됩니다. Control Plane은 크게 세 가지 주요 컴포넌트로 구성됩니다. API Server 클러스터 내의 모든 리소스를 관리하고 Kubernetes API를 노출하는 중앙 집중화된 컴포넌트입니다. API 서버는 사용자가 Kubernetes 클러스터와 상호 작용하기 위한 인터페이스를 제공하며, 클러스터 리소스를 조작하는 모든 작업을 처리합니다. Controller Manager API 서버에서 리소스 변경 사항을 감지하고 해당 리소스 상태를 원하는 상태로 유지하기 위해 실행되는 컴포넌트입니다. 예를 들어, 노드가 다운되면 컨트롤러 매니저는 해당 노드에서 실행 중인 파드를 다른 노드로 이동시키기 위해 동작합니다. etcd 클러스터 상태를 저장하는 분산형 Key-Value 저장소입니다. Kubernetes 컨트롤 플레인의 모든 컴포넌트는 etcd를 통해 클러스터의 상태를 읽고 쓰게 됩니다. etcd 는 분산형 저장소이기 때문에 데이터 일관성과 가용성을 보장합니다. 이러한 컴포넌트는 모두 Kubernetes 클러스터 내에서 상호작용하며, 애플리케이션을 배포, 확장, 업데이트 및 관리하기 위한 모든 매니지먼트 작업을 수행합니다. Control Plane은 Kubernetes 클러스터의 중심적인 역할을 수행하며, 클러스터의 안정성과 가용성을 보장하기 위해 중요한 역할을 합니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"구성요소","slug":"Kubernetes/구성요소","permalink":"https://ckck803.github.io/categories/Kubernetes/%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"}],"tags":[]},{"title":"쿠버네티스","slug":"k8s/k8s/k8s","date":"2023-01-07T21:31:46.000Z","updated":"2024-02-18T16:19:54.540Z","comments":true,"path":"2023/01/08/k8s/k8s/k8s/","link":"","permalink":"https://ckck803.github.io/2023/01/08/k8s/k8s/k8s/","excerpt":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 참고 공식문서 https://kubernetes.io/ko/docs/concepts/overview/components/ https://malwareanalysis.tistory.com/512 쿠버네티스가 등장하게 된 배경MSA (Micro Service Architecture) 의 등장과 Container 화된 어플리케이션이 등장하고 많아지면서 여러 호스트로 구성되고 배포되는 서비스들을 중앙에서 통합, 관리해 줄 수 있는 플랫폼이 필요하게 됐다. 기존 컨테이너 가상화 기술인 도커는 단일 호스트에 컨테이너 서비스를 배포하는데 적합하나 여러 호스트로 구성된 컨테이너 서비스를 관리하는데에 있어서는 한계가 있었다. 여러 호스트로 구성된 컨테이너 환경을 중앙에서 통합 관리 하기 위해 컨테이너 오케스트레이션 플랫포인 쿠버네티스가 등장하게 됐다. 쿠버네티스란?","text":"목차 쿠버네티스 - Namespace 쿠버네티스 - Ingress Post not found: k8s/deployment/deployment Post not found: k8s/replicaset/replicaset 쿠버네티스 - Node 쿠버네티스 - Pod 쿠버네티스 - Data Plane 쿠버네티스 - Control Plane 쿠버네티스 참고 공식문서 https://kubernetes.io/ko/docs/concepts/overview/components/ https://malwareanalysis.tistory.com/512 쿠버네티스가 등장하게 된 배경MSA (Micro Service Architecture) 의 등장과 Container 화된 어플리케이션이 등장하고 많아지면서 여러 호스트로 구성되고 배포되는 서비스들을 중앙에서 통합, 관리해 줄 수 있는 플랫폼이 필요하게 됐다. 기존 컨테이너 가상화 기술인 도커는 단일 호스트에 컨테이너 서비스를 배포하는데 적합하나 여러 호스트로 구성된 컨테이너 서비스를 관리하는데에 있어서는 한계가 있었다. 여러 호스트로 구성된 컨테이너 환경을 중앙에서 통합 관리 하기 위해 컨테이너 오케스트레이션 플랫포인 쿠버네티스가 등장하게 됐다. 쿠버네티스란? 쿠버네티스란 컨테이너화된 어플리케이션 을 배포, 확장하고 관리하는 것을 자동화해주는 컨테이너 오케스트레이션 플랫폼 이다. 구글에서 사용하는 Borg 를 기반으로 2014년에 공개되고 2015년에 리눅스 재단 산하의 CNCF (Cloud Native Computing Foundation) 에 코드를 기부함으로써 오픈 소스 프로젝트가 됐다. 단순한 컨테이너 플랫폼이 아닌 마이크로서비스, 클라우드 플랫폼을 지향하고 컨테이너로 이루어진 것들을 손쉽게 담고 관리할 수 있는 그릇 역할을 한다. 서버리스, CI&#x2F;CD, 머신러닝 등 다양한 기능이 쿠버네티스 플랫폼 위에서 동작한다. 쿠버네티스의 기능 스케줄링 컨테이너화된 애플리케이션을 배포 할때 어떤 노드에 배포할지 결정한다. affinity : Pod 를 특정 노드에 배포하도록 하는 정책 Hard affinity : Pod 가 조건이 딱 맞는 Node 에만 배포되도록 하는 정책 Soft affinity : Pod 가 조건에 되도록 맞는 Node 에 되도록이면 배포하도록 하는 정책 Taint : Pod 가 배포하지 못하도록 하는 정책 서비스 디스커버리와 로드 밸런싱 스토리지 오케스트레이션 컨테이너화된 애플리케이션이 사용하는 스토리지를 관리하는 기능을 제공한다. 자동화된 롤아웃과 롤백 자동화된 빈 패킹 시크릿과 구성 관리 컨테이너화된 애플리케이션의 구성을 관리하고 업데이트 하는 기능을 제공한다. 자가 치유 노드나 컨테이너의 장애를 감지하고, 자동으로 치유하는 기능을 제공한다. 배치 실행 오토 스케일링 같은 컨테이너 이미지를 기반으로 여러 컨테이너를 배포하면서 부하를 분산하고 부하에 따라 컨테이너 레플리카 수를 자동으로 늘리거나 줄일 수 있다. 쿠버네티스 클러스터 클러스터(Cluster)란, 여러 대의 컴퓨터 노드(Node) 로 구성된 분산 시스템을 의미합니다. 이러한 노드들은 쿠버네티스 마스터(Master) 에 의해 제어되며, 클러스터는 애플리케이션을 실행하고 관리하는 데 사용됩니다. 클러스터 구성요소 - 마스터 노드(Master Node)마스터 노드는 클러스터의 제어 플레인(Control Plane)을 관리합니다. 제어 플레인은 클러스터의 상태를 추적하고 노드 간의 작업을 조정하는 역할을 수행합니다. 마스터 노드는 API 서버, 스케줄러(Scheduler), 컨트롤러 매니저(Controller Manager) 등의 컴포넌트로 구성됩니다. 클러스터 구성요소 - 워커 노드(Worker Node)워커 노드는 애플리케이션 컨테이너를 실행하는 데 사용되는 실제 컴퓨터 노드입니다. 워커 노드는 클러스터 내에서 작업을 수행하고, 애플리케이션을 실행하고 관리하는 역할을 담당합니다. 각 워커 노드는 쿠버네티스 에이전트(Agent)인 kubelet과 컨테이너 런타임(Docker, containerd, 등)으로 구성됩니다. 클러스터 구성요소 - 저장소클러스터는 애플리케이션 데이터를 저장하기 위한 저장소를 사용할 수 있습니다. 이 저장소는 퍼시스턴트 볼륨(Persistent Volume)이나 외부 클라우드 서비스 등으로 구성될 수 있습니다.","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"구성요소","slug":"Kubernetes/구성요소","permalink":"https://ckck803.github.io/categories/Kubernetes/%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"}],"tags":[]},{"title":"EKS (Elastic Kubernetes Service)","slug":"aws/eks/eks","date":"2023-01-04T20:31:07.000Z","updated":"2024-02-18T16:19:54.517Z","comments":true,"path":"2023/01/05/aws/eks/eks/","link":"","permalink":"https://ckck803.github.io/2023/01/05/aws/eks/eks/","excerpt":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) EKS (Elastic Kubernetes Service) 란? Elastic Kubernetes Service 의 약자로 AWS 에서 제공하는 Kubernetes 관리 서비스 EKS를 사용하면 Kubernetes 마스터를 관리하고 보안, 스케일링, 업그레이드 및 가용성과 같은 관리적인 부담을 덜 수 있습니다. EKS는 Kubernetes API를 완전히 호환하며, AWS에서 제공하는 다양한 서비스와 통합할 수 있습니다. 이러한 서비스는 Amazon Elastic Load Balancer, Amazon Simple Storage Service, Amazon DynamoDB 등이 있습니다. EKS는 Kubernetes 마스터를 관리하므로 클러스터를 시작하기 위해 마스터 노드를 프로비저닝하고 구성할 필요가 없습니다. 대신, 단일 명령으로 새로운 Kubernetes 클러스터를 시작하고 노드를 추가하거나 제거할 수 있습니다. EKS는 또한 클러스터 보안을 제공하며, Kubernetes 마스터와 작업 노드가 모두 Amazon VPC(Virtual Private Cloud) 내에서 실행됩니다. 또한 EKS는 Kubernetes 마스터와 작업 노드 간의 통신을 위해 네트워크 라우팅 및 보안 구성을 자동으로 처리합니다. 마지막으로, EKS는 Amazon EC2와 같은 AWS 서비스와의 긴밀한 통합을 제공하며, 클러스터 노드의 Amazon Machine Image(AMI)를 사용하여 노드를 구성할 수 있습니다. 이는 사용자가 EKS와 다른 AWS 서비스를 쉽게 통합하고 관리할 수 있도록 도와줍니다. Kubernetes 클러스터를 쉽게 생성하고 관리할 수 있도록 지원한다.","text":"목차 EKS - Cluster Autoscaler EKS - EFS CSI Driver 설치 EKS - EBS CSI Driver 설치 EKS - ALB Controller 를 활용한 NLB 생성 EKS - ALB Controller 설치 EKS - Cluster Access 문제 EKS - NodeGroup 생성 EKS - eksctl 로 클러스터 생성 및 삭제 EKS (Elastic Kubernetes Service) EKS (Elastic Kubernetes Service) 란? Elastic Kubernetes Service 의 약자로 AWS 에서 제공하는 Kubernetes 관리 서비스 EKS를 사용하면 Kubernetes 마스터를 관리하고 보안, 스케일링, 업그레이드 및 가용성과 같은 관리적인 부담을 덜 수 있습니다. EKS는 Kubernetes API를 완전히 호환하며, AWS에서 제공하는 다양한 서비스와 통합할 수 있습니다. 이러한 서비스는 Amazon Elastic Load Balancer, Amazon Simple Storage Service, Amazon DynamoDB 등이 있습니다. EKS는 Kubernetes 마스터를 관리하므로 클러스터를 시작하기 위해 마스터 노드를 프로비저닝하고 구성할 필요가 없습니다. 대신, 단일 명령으로 새로운 Kubernetes 클러스터를 시작하고 노드를 추가하거나 제거할 수 있습니다. EKS는 또한 클러스터 보안을 제공하며, Kubernetes 마스터와 작업 노드가 모두 Amazon VPC(Virtual Private Cloud) 내에서 실행됩니다. 또한 EKS는 Kubernetes 마스터와 작업 노드 간의 통신을 위해 네트워크 라우팅 및 보안 구성을 자동으로 처리합니다. 마지막으로, EKS는 Amazon EC2와 같은 AWS 서비스와의 긴밀한 통합을 제공하며, 클러스터 노드의 Amazon Machine Image(AMI)를 사용하여 노드를 구성할 수 있습니다. 이는 사용자가 EKS와 다른 AWS 서비스를 쉽게 통합하고 관리할 수 있도록 도와줍니다. Kubernetes 클러스터를 쉽게 생성하고 관리할 수 있도록 지원한다.","categories":[{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"}],"tags":[]},{"title":"Spring Batch","slug":"spring/spring-batch/basic/batch-basic-01","date":"2022-05-13T14:25:35.000Z","updated":"2024-02-26T15:27:43.134Z","comments":true,"path":"2022/05/13/spring/spring-batch/basic/batch-basic-01/","link":"","permalink":"https://ckck803.github.io/2022/05/13/spring/spring-batch/basic/batch-basic-01/","excerpt":"Real Time 작업 - 실시간 작업바로 응답을 받아서 보는 것을 실시간 작업이라 한다. 배치 작업은작업들을 한번에 모아서 처리하는 작업 배송이나 정산은 모아서 특정 주기마다 처리하는 작업고객눈에는 보이지 않지만 서비스 뒷펀에서 대량의 작업을 처리한다.","text":"Real Time 작업 - 실시간 작업바로 응답을 받아서 보는 것을 실시간 작업이라 한다. 배치 작업은작업들을 한번에 모아서 처리하는 작업 배송이나 정산은 모아서 특정 주기마다 처리하는 작업고객눈에는 보이지 않지만 서비스 뒷펀에서 대량의 작업을 처리한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Django Rest - 장고를 이용한 rest api 만들기","slug":"django/rest/rest-01","date":"2022-05-11T11:47:30.000Z","updated":"2024-02-18T16:47:07.442Z","comments":true,"path":"2022/05/11/django/rest/rest-01/","link":"","permalink":"https://ckck803.github.io/2022/05/11/django/rest/rest-01/","excerpt":"장고를 이용한 rest api 만들기settings myapi&#x2F;settings.py STATIC_ROOT = os.path.join(BASE_DIR, &#x27;staticfiles&#x27;) 정적 파일 root 추가 INSTALLED_APPS = [ ... &#x27;rest_framework&#x27;,] INSTALLED_APPS에 quiz와 rest_framework를 추가해준다. 모델 생성하기 quiz&#x2F;models.py","text":"장고를 이용한 rest api 만들기settings myapi&#x2F;settings.py STATIC_ROOT = os.path.join(BASE_DIR, &#x27;staticfiles&#x27;) 정적 파일 root 추가 INSTALLED_APPS = [ ... &#x27;rest_framework&#x27;,] INSTALLED_APPS에 quiz와 rest_framework를 추가해준다. 모델 생성하기 quiz&#x2F;models.py from django.db import models# Create your models here.class Quiz(models.Model): title = models.CharField(max_length=200) body = models.TextField() answer = models.IntegerField() 시리얼라이저 생성하기 quiz&#x2F;serializers.py from rest_framework import serializersfrom .models import Quizclass QuizSerializer(serializers.ModelSerializer): class Meta: model = Quiz fields = (&#x27;title&#x27;, &#x27;body&#x27;, &#x27;answer&#x27;) 시리얼라이저는 장고의 model데이터를 JSON형태로 만들어주는 코드이다. api통신이 가능하게 해준다. 반환 값 설정하기 quize&#x2F;views.py from rest_framework.response import Responsefrom rest_framework.decorators import api_viewfrom .models import Quizfrom .serializers import QuizSerializer# Create your views here.@api_view([&#x27;GET&#x27;])def HelloAPI(request): return Response(&quot;Hello World!&quot;); url 설정하기 quiz&#x2F;urls.py from django.urls import path, includefrom .views import HelloAPIurlpatterns = [ path(&quot;hello/&quot;, HelloAPI),] myapi&#x2F;urls.py from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;quiz/&#x27;, include(&#x27;quiz.urls&#x27;)),] 새로운 API 추가하기 quiz&#x2F;views.py from rest_framework.response import Responsefrom rest_framework.decorators import api_viewfrom .models import Quizfrom .serializers import QuizSerializerimport random# Create your views here.@api_view([&#x27;GET&#x27;])def HelloAPI(request): return Response(&quot;Hello World!&quot;);@api_view([&#x27;GET&#x27;])def randomQuiz(request, id): totalQuizs = Quiz.objects.all() randomQuizs = random.sample(list(totalQuizs), id) # many=True은 다량의 데이터에 대해서도 직렬화를 진행한다. serializer = QuizSerializer(randomQuizs, many=True) return Response(serializer.data) url에 추가하기 quiz&#x2F;urls.py from django.urls import path, includefrom .views import HelloAPI, randomQuizurlpatterns = [ path(&quot;hello/&quot;, HelloAPI), path(&quot;&lt;int:id&gt;/&quot;, randomQuiz),] admin 페이지에 Quiz모델 추가하기 quiz&#x2F;admin.py from django.contrib import adminfrom .models import Quiz# Register your models here.admin.site.register(Quiz)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Comment (댓글) view 구현하기","slug":"django/mysite/django-26","date":"2022-05-10T01:47:30.000Z","updated":"2024-02-18T16:47:07.440Z","comments":true,"path":"2022/05/10/django/mysite/django-26/","link":"","permalink":"https://ckck803.github.io/2022/05/10/django/mysite/django-26/","excerpt":"Comment (댓글) view 구현하기테스트 코드 작성 blog&#x2F;tests.py # Comment를 생성한다.comment_000 = create_post(post_000, text=&#x27;a test comment&#x27;, author=self.author_obama) # Comment comments_div = main_div.find(&#x27;div&#x27;, id=&#x27;comment-list&#x27;) self.assertIn(comment_000.author.username, comments_div.text) self.assertIn(comment_000.text, comments_div.text) post_detail 수정하기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;!-- Comment --&gt;&lt;div id=&quot;comment-list&quot;&gt;&#123;% for comment in object.comment_set.all %&#125; &lt;div class=&quot;media mb-4&quot;&gt; &lt;img class=&quot;d-flex mr-3 rounded-circle&quot; src=&quot;http://placehold.it/50x50&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h5 class=&quot;mt-0&quot;&gt;&#123;&#123; comment.author &#125;&#125;&lt;/h5&gt; &#123;&#123; comment.get_markdwon_content | safe &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endfor %&#125;&lt;/div&gt; admin 사이트에서 comment확인할 수 있게 반영하기 blog&#x2F;admin.py","text":"Comment (댓글) view 구현하기테스트 코드 작성 blog&#x2F;tests.py # Comment를 생성한다.comment_000 = create_post(post_000, text=&#x27;a test comment&#x27;, author=self.author_obama) # Comment comments_div = main_div.find(&#x27;div&#x27;, id=&#x27;comment-list&#x27;) self.assertIn(comment_000.author.username, comments_div.text) self.assertIn(comment_000.text, comments_div.text) post_detail 수정하기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;!-- Comment --&gt;&lt;div id=&quot;comment-list&quot;&gt;&#123;% for comment in object.comment_set.all %&#125; &lt;div class=&quot;media mb-4&quot;&gt; &lt;img class=&quot;d-flex mr-3 rounded-circle&quot; src=&quot;http://placehold.it/50x50&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h5 class=&quot;mt-0&quot;&gt;&#123;&#123; comment.author &#125;&#125;&lt;/h5&gt; &#123;&#123; comment.get_markdwon_content | safe &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endfor %&#125;&lt;/div&gt; admin 사이트에서 comment확인할 수 있게 반영하기 blog&#x2F;admin.py from django.contrib import adminfrom .models import Post, Category, Comment# Register your models here.class CategoryAdmin(admin.ModelAdmin): # 미리 만들어지는 field # slug를 자동으로 만들어준다. prepopulated_fields = &#123;&#x27;slug&#x27;: (&#x27;name&#x27;, )&#125;admin.site.register(Post)admin.site.register(Comment)admin.site.register(Category, CategoryAdmin) markdown 적용해주기 blog&#x2F;models.py class Comment(models.Model): post = models.ForeignKey(Post, on_delete=models.CASCADE) text = MarkdownxField() author = models.ForeignKey(User, on_delete=models.CASCADE) # markdown을 html로 바꿔준다. def get_markdwon_content(self): return markdown(self.text)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Comment (댓글) 작성창 구현하기","slug":"django/mysite/django-27","date":"2022-05-10T01:47:30.000Z","updated":"2024-02-18T16:47:07.440Z","comments":true,"path":"2022/05/10/django/mysite/django-27/","link":"","permalink":"https://ckck803.github.io/2022/05/10/django/mysite/django-27/","excerpt":"Comment (댓글) 작성창 구현하기forms.py 파일 생성하기 blog&#x2F; 해당 돌더에 forms.py 파일을 생성한다. from .models import Commentfrom django import formsclass CommentForm(forms.ModelForm): class Meta: model = Comment fields = &#123;&#x27;text&#x27;,&#125; 테스트 코드 작성하기 blog&#x2F;tests.py # 로그인하기login_success = self.client.login(username=&#x27;smith&#x27;, password=&#x27;nopassword&#x27;)self.assertTrue(login_success)# post를 이용하여 서버에 데이터를 보낸다.response = self.client.post( post_000.get_absolute_url() + &#x27;new_comment/&#x27;, &#123;&#x27;text&#x27;:&#x27;A test comment for the first comment&#x27;&#125;, follow=True # redirect하는 것까지 확인을 해봐라)self.assertEqual(response.status_code, 200) views.py에 반영하기","text":"Comment (댓글) 작성창 구현하기forms.py 파일 생성하기 blog&#x2F; 해당 돌더에 forms.py 파일을 생성한다. from .models import Commentfrom django import formsclass CommentForm(forms.ModelForm): class Meta: model = Comment fields = &#123;&#x27;text&#x27;,&#125; 테스트 코드 작성하기 blog&#x2F;tests.py # 로그인하기login_success = self.client.login(username=&#x27;smith&#x27;, password=&#x27;nopassword&#x27;)self.assertTrue(login_success)# post를 이용하여 서버에 데이터를 보낸다.response = self.client.post( post_000.get_absolute_url() + &#x27;new_comment/&#x27;, &#123;&#x27;text&#x27;:&#x27;A test comment for the first comment&#x27;&#125;, follow=True # redirect하는 것까지 확인을 해봐라)self.assertEqual(response.status_code, 200) views.py에 반영하기 blog&#x2F;views.py class PostDetail(DetailView): model = Post def get_context_data(self, *, object_list=None, **kwargs): context = super(PostDetail, self).get_context_data(**kwargs) context[&#x27;category_list&#x27;] = Category.objects.all() # Post들 중에서 category가 None인 것의 갯수를 가져온다. context[&#x27;posts_without_category&#x27;] = Post.objects.filter(category=None).count() context[&#x27;comment_form&#x27;] = CommentForm() return context 템플릿에 반영하기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;!-- Comments Form --&gt;&lt;div class=&quot;card my-4&quot;&gt; &lt;h5 class=&quot;card-header&quot;&gt;Leave a Comment:&lt;/h5&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;&#123; comment_form &#125;&#125; &lt;textarea class=&quot;form-control&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt; crispy-forms 설치히가 pip install django-crispy-forms 설정에 crispy-forms추가하기 mysite&#x2F;settings.py INSTALLED_APPS = [ &#x27;blog&#x27;, &#x27;markdownx&#x27;, &#x27;crispy_forms&#x27;, &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;,]CRISPY_TEMPLATE_PACK = &#x27;bootstrap4&#x27; crispy filter추가하기 blog&#x2F;template&#x2F;post_detail.html &#123;% load crispy_forms_tags %&#125; crispy filter반영하기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;!-- Comments Form --&gt;&lt;div class=&quot;card my-4&quot;&gt; &lt;h5 class=&quot;card-header&quot;&gt;Leave a Comment:&lt;/h5&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;&#123;&#123; object.get_absolute_url &#125;&#125;new_comment/&quot;&gt;&#123;% csrf_token %&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;&#123; comment_form | crispy &#125;&#125; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt; 댓글로 focus 맞춰주기 blog&#x2F;models.py class Comment(models.Model): post = models.ForeignKey(Post, on_delete=models.CASCADE) text = MarkdownxField() author = models.ForeignKey(User, on_delete=models.CASCADE) # markdown을 html로 바꿔준다. def get_markdwon_content(self): return markdown(self.text) def get_absolute_url(self): return self.post.get_absolute_url() + &#x27;#comment-id-&#123;&#125;&#x27;.format(self.pk) blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;!-- Comment --&gt;&lt;div id=&quot;comment-list&quot;&gt;&#123;% for comment in object.comment_set.all %&#125; &lt;div class=&quot;media mb-4&quot; id=&quot;comment-id-&#123;&#123; comment.pk &#125;&#125;&quot;&gt; &lt;img class=&quot;d-flex mr-3 rounded-circle&quot; src=&quot;http://placehold.it/50x50&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h5 class=&quot;mt-0&quot;&gt;&#123;&#123; comment.author &#125;&#125;&lt;/h5&gt; &#123;&#123; comment.get_markdwon_content | safe &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endfor %&#125;&lt;/div&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 블로그 post list와 post detail 페이지에 카테고리 추가하기","slug":"django/mysite/django-28","date":"2022-05-10T01:47:30.000Z","updated":"2024-02-18T16:47:07.440Z","comments":true,"path":"2022/05/10/django/mysite/django-28/","link":"","permalink":"https://ckck803.github.io/2022/05/10/django/mysite/django-28/","excerpt":"블로그 post list와 post detail 페이지에 카테고리 추가하기테스트 코드 작성하기 blog&#x2F;tests.py post_001 = create_post( title=&quot;The second post&quot;, content=&quot;Second Second Second&quot;, author=self.author_000, category=create_category(name=&#x27;정치/사회&#x27;))# category card에서 category_card = body.find(&#x27;div&#x27;, id=&#x27;category-card&#x27;) self.assertIn(&#x27;미분류(1)&#x27;, category_card.text) #### 미분류 (1)이 있어야 한다. self.assertIn(&#x27;정치/사회(1)&#x27;, category_card.text) #### 정치/사회(1)이 있어야 한다. main_div = body.find(&#x27;div&#x27;, id=&#x27;main_div&#x27;) self.assertIn(&#x27;정치/사회&#x27;, main_div.text) ###&#x27;정치/사회&#x27; 있어야 함 self.assertIn((&#x27;미분류&#x27;, main_div.text)) ### &#x27;미분류&#x27; 있어야 함 id 추가하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html &lt;div class=&quot;card my-4&quot; id = &quot;category-card&quot;&gt; 카테고리 카드 수정해주기 blog&#x2F;views.py","text":"블로그 post list와 post detail 페이지에 카테고리 추가하기테스트 코드 작성하기 blog&#x2F;tests.py post_001 = create_post( title=&quot;The second post&quot;, content=&quot;Second Second Second&quot;, author=self.author_000, category=create_category(name=&#x27;정치/사회&#x27;))# category card에서 category_card = body.find(&#x27;div&#x27;, id=&#x27;category-card&#x27;) self.assertIn(&#x27;미분류(1)&#x27;, category_card.text) #### 미분류 (1)이 있어야 한다. self.assertIn(&#x27;정치/사회(1)&#x27;, category_card.text) #### 정치/사회(1)이 있어야 한다. main_div = body.find(&#x27;div&#x27;, id=&#x27;main_div&#x27;) self.assertIn(&#x27;정치/사회&#x27;, main_div.text) ###&#x27;정치/사회&#x27; 있어야 함 self.assertIn((&#x27;미분류&#x27;, main_div.text)) ### &#x27;미분류&#x27; 있어야 함 id 추가하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html &lt;div class=&quot;card my-4&quot; id = &quot;category-card&quot;&gt; 카테고리 카드 수정해주기 blog&#x2F;views.py # templates로 추가적인 정보를 넘겨주고 싶을 경우def get_context_data(self, *, object_list=None, **kwargs): context = super(PostList, self).get_context_data(**kwargs) context[&#x27;categories_list&#x27;] = Category.objects.all() # Post들 중에서 category가 None인 것의 갯수를 가져온다. context[&#x27;posts_without_category&#x27;] = Post.objects.filter(category=None).count() return context base.html 수정하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html &lt;li&gt; &lt;a href=&quot;#&quot;&gt;미분류(&#123;&#123; posts_without_category &#125;&#125;)&lt;/a&gt;&lt;/li&gt;&#123;% for category in category_list %&#125;&lt;li&gt; &lt;a href=&quot;#&quot;&gt;&#123;&#123; category.name &#125;&#125;(&#123;&#123; category.post_set.count &#125;&#125;)&lt;/a&gt;&lt;/li&gt;&#123;% endfor %&#125; Category코드 수정하기 blog&#x2F;models.py # Create your models here.# 카테고리를 추가한다.class Category(models.Model): # Category의 이름이 유일할 수 있게 unique옵션을 준다. name = models.CharField(max_length=25, unique=True) description = models.TextField(blank=True) # 카테고리 이름을 출력해준다. def __str__(self): return self.name 카테고리가 없을 경우 미분류로 출력되게 html을 변경해준다. blog&#x2F;templates&#x2F;blog&#x2F;post_list.html &lt;!-- badge를 붙인다. --&gt;&lt;!-- 카테고리가 있는 경우에는 카테고리를 보여주고, 없는 경우에는 미분류를 보여준다. --&gt;&#123;% if p.category %&#125;&lt;!-- badge가 오른쪽에 붙을 수 있게 float-right옵션을 이용한다. --&gt;&lt;span class=&quot;badge badge-primary float-right&quot;&gt;&#123;&#123; p.category &#125;&#125;&lt;/span&gt;&#123;% else %&#125;&lt;span class=&quot;badge badge-primary float-right&quot;&gt;미분류&lt;/span&gt;&#123;% endif %&#125; admin에 category를 등록하기","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Comment (댓글) 모델 구현하기","slug":"django/mysite/django-25","date":"2022-05-09T14:47:30.000Z","updated":"2024-02-18T16:47:07.439Z","comments":true,"path":"2022/05/09/django/mysite/django-25/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-25/","excerpt":"Comment (댓글) 모델 구현하기테스트 코드 작성하기 blog&#x2F;tests.py # commnet를 생성하는 함수def create_comment(post, text=&#x27;a comment&#x27;, author=None): if author is None: author, is_created = User.objects.get_or_create( username=&#x27;guset&#x27;, password=&#x27;guestpassword&#x27; ) comment = Comment.objects.create( post = post, text = text, author = author ) return comment # class test_Model에 추가 # 댓글 기능에 관한 test def test_comment(self): post_000 = create_post( title=&quot;The first post&quot;, content=&quot;Hello World. We are the world.&quot;, author=self.author_000, ) self.assertEqual(Comment.objects.count(), 0) comment_000 = create_comment( post=post_000 ) comment_001 = create_comment( post=post_000, text=&#x27;second comment&#x27; ) self.assertEqual(Comment.objects.count(), 2) self.assertEqual(post_000.comment_set.count(), 2) comment 모델 추가하기 blog&#x2F;models.py class Comment(models.Model): post = models.ForeignKey(Post, on_delete=models.CASCADE) text = MarkdownxField() author = models.ForeignKey(User, on_delete=models.CASCADE)","text":"Comment (댓글) 모델 구현하기테스트 코드 작성하기 blog&#x2F;tests.py # commnet를 생성하는 함수def create_comment(post, text=&#x27;a comment&#x27;, author=None): if author is None: author, is_created = User.objects.get_or_create( username=&#x27;guset&#x27;, password=&#x27;guestpassword&#x27; ) comment = Comment.objects.create( post = post, text = text, author = author ) return comment # class test_Model에 추가 # 댓글 기능에 관한 test def test_comment(self): post_000 = create_post( title=&quot;The first post&quot;, content=&quot;Hello World. We are the world.&quot;, author=self.author_000, ) self.assertEqual(Comment.objects.count(), 0) comment_000 = create_comment( post=post_000 ) comment_001 = create_comment( post=post_000, text=&#x27;second comment&#x27; ) self.assertEqual(Comment.objects.count(), 2) self.assertEqual(post_000.comment_set.count(), 2) comment 모델 추가하기 blog&#x2F;models.py class Comment(models.Model): post = models.ForeignKey(Post, on_delete=models.CASCADE) text = MarkdownxField() author = models.ForeignKey(User, on_delete=models.CASCADE)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 로그인 사용자만 접속 가능하게 하기","slug":"django/mysite/django-24","date":"2022-05-09T13:47:30.000Z","updated":"2024-02-18T16:47:07.439Z","comments":true,"path":"2022/05/09/django/mysite/django-24/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-24/","excerpt":"로그인 사용자만 접속 가능하게 하기테스트 코드 작성 blog&#x2F;tests.py # post_create를 확인하기 위한 테스트 코드def test_post_create(self): response = self.client.get(&#x27;/blog/create/&#x27;) # 로그인 하지 않은 상태에서는 create로 접속시에 200이 뜨면 안된다. self.assertNotEqual(response.status_code, 200) # 로그인을 했을 때만 create로 접속시 200이 뜨게 해야 한다. self.client.login(username=&#x27;smith&#x27;, password=&#x27;nopassword&#x27;) response = self.client.get(&#x27;/blog/create/&#x27;) self.assertEqual(response.status_code, 200) # 정상적으로 이루어진 경우 BeautifulSoup을 이용해 html.parser로 파싱한 객체를 생성한다. soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;) main_div = soup.find(&#x27;div&#x27;, id=&#x27;main-div&#x27;) # self.assertIn(&#x27;New Post&#x27;, main_div.text) 뷰 수정하기 blog&#x2F;views.py from django.contrib.auth.mixins import LoginRequiredMixinclass PostCreate(LoginRequiredMixin, CreateView): model = Post fields = [ &#x27;title&#x27;, &#x27;content&#x27;, &#x27;head_image&#x27;, &#x27;category&#x27;, # &#x27;tags&#x27; ] def form_valid(self, form): # 작성자를 가지고 온다. current_user = self.request.user # 로그인을 한 상태인지 확인을 한다. if current_user.is_authenticated: # form의 author를 현재 작성중인 사람으로 채워 넣어 form.instance.author = current_user return super(type(self), self).form_valid(form) else : return redirect(&#x27;/blog/&#x27;) PostCreate에서 LoginRequiredMixin을 추가적으로 상속한다.","text":"로그인 사용자만 접속 가능하게 하기테스트 코드 작성 blog&#x2F;tests.py # post_create를 확인하기 위한 테스트 코드def test_post_create(self): response = self.client.get(&#x27;/blog/create/&#x27;) # 로그인 하지 않은 상태에서는 create로 접속시에 200이 뜨면 안된다. self.assertNotEqual(response.status_code, 200) # 로그인을 했을 때만 create로 접속시 200이 뜨게 해야 한다. self.client.login(username=&#x27;smith&#x27;, password=&#x27;nopassword&#x27;) response = self.client.get(&#x27;/blog/create/&#x27;) self.assertEqual(response.status_code, 200) # 정상적으로 이루어진 경우 BeautifulSoup을 이용해 html.parser로 파싱한 객체를 생성한다. soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;) main_div = soup.find(&#x27;div&#x27;, id=&#x27;main-div&#x27;) # self.assertIn(&#x27;New Post&#x27;, main_div.text) 뷰 수정하기 blog&#x2F;views.py from django.contrib.auth.mixins import LoginRequiredMixinclass PostCreate(LoginRequiredMixin, CreateView): model = Post fields = [ &#x27;title&#x27;, &#x27;content&#x27;, &#x27;head_image&#x27;, &#x27;category&#x27;, # &#x27;tags&#x27; ] def form_valid(self, form): # 작성자를 가지고 온다. current_user = self.request.user # 로그인을 한 상태인지 확인을 한다. if current_user.is_authenticated: # form의 author를 현재 작성중인 사람으로 채워 넣어 form.instance.author = current_user return super(type(self), self).form_valid(form) else : return redirect(&#x27;/blog/&#x27;) PostCreate에서 LoginRequiredMixin을 추가적으로 상속한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Post 작성 화면 / 기능 구현하기","slug":"django/mysite/django-23","date":"2022-05-09T12:47:30.000Z","updated":"2024-02-18T16:47:07.439Z","comments":true,"path":"2022/05/09/django/mysite/django-23/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-23/","excerpt":"Post 작성 화면 &#x2F; 기능 구현하기new 버튼 만들기 blog&#x2F;templates&#x2F;post_list.html &lt;!--로그인 한 사용자에게만 보이게 하기--&gt;&#123;% if user.is_authenticated %&#125; &lt;!-- new post button 만들기 --&gt; &lt;button class=&quot;btn btn-primary btn-sm float-right&quot; onclick=&quot;location.href=&#x27;/blog/create/&#x27;&quot;&gt;new post&lt;/button&gt;&#123;% endif %&#125; post_create 만들기테스트 코드 작성 blog&#x2F;tests.py # post_create를 확인하기 위한 테스트 코드def test_post_create(self): response = self.client.get(&#x27;/blog/create/&#x27;) self.assertEqual(response.status_code, 200) # 정상적으로 이루어진 경우 BeautifulSoup을 이용해 html.parser로 파싱한 객체를 생성한다. soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;) main_div = soup.find(&#x27;div&#x27;, id=&#x27;main-div&#x27;) # self.assertIn(&#x27;New Post&#x27;, main_div.text) url 추가하기","text":"Post 작성 화면 &#x2F; 기능 구현하기new 버튼 만들기 blog&#x2F;templates&#x2F;post_list.html &lt;!--로그인 한 사용자에게만 보이게 하기--&gt;&#123;% if user.is_authenticated %&#125; &lt;!-- new post button 만들기 --&gt; &lt;button class=&quot;btn btn-primary btn-sm float-right&quot; onclick=&quot;location.href=&#x27;/blog/create/&#x27;&quot;&gt;new post&lt;/button&gt;&#123;% endif %&#125; post_create 만들기테스트 코드 작성 blog&#x2F;tests.py # post_create를 확인하기 위한 테스트 코드def test_post_create(self): response = self.client.get(&#x27;/blog/create/&#x27;) self.assertEqual(response.status_code, 200) # 정상적으로 이루어진 경우 BeautifulSoup을 이용해 html.parser로 파싱한 객체를 생성한다. soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;) main_div = soup.find(&#x27;div&#x27;, id=&#x27;main-div&#x27;) # self.assertIn(&#x27;New Post&#x27;, main_div.text) url 추가하기 blog&#x2F;urls.py # 새로운 post를 생성하는 페이지로 넘어가기 위한 urlpath(&#x27;create/&#x27;, views.PostCreate.as_view()), view에 반영하기 blog&#x2F;views.py from django.views.generic import CreateViewclass PostCreate(CreateView): model = Post fields = [ &#x27;title&#x27;, &#x27;content&#x27;, &#x27;head_image&#x27;, &#x27;category&#x27;, # &#x27;tags&#x27; ] 자동으로 채워주는 기능 활성화 하기 blog&#x2F;models.py # 작성 일자 created = models.DateTimeField(auto_now_add=True) 작성중인 user가져오기 blog&#x2F;views.py def form_valid(self, form): current_user = self.request.user form.instance.author = current_user return super(type(self), self).form_valid(form) 로그인 한 상태인지 안한 상태인지 확인한 후 redirect하기 blog&#x2F;views.py class PostCreate(CreateView): model = Post fields = [ &#x27;title&#x27;, &#x27;content&#x27;, &#x27;head_image&#x27;, &#x27;category&#x27;, # &#x27;tags&#x27; ] def form_valid(self, form): # 작성자를 가지고 온다. current_user = self.request.user # 로그인을 한 상태인지 확인을 한다. if current_user.is_authenticated: # form의 author를 현재 작성중인 사람으로 채워 넣어 form.instance.author = current_user return super(type(self), self).form_valid(form) else : return redirect(&#x27;/blog/&#x27;)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Post 수정 화면 / 기능 구현하기","slug":"django/mysite/django-22","date":"2022-05-09T11:47:30.000Z","updated":"2024-02-18T16:47:07.438Z","comments":true,"path":"2022/05/09/django/mysite/django-22/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-22/","excerpt":"Post 수정 화면 &#x2F; 기능 구현하기update된 url을 반환하는 함수 만들어 주기 blog&#x2F;models.py # update된 url을 반환하기 위한 함수def get_update_url(self): return self.get_absolute_url() + &#x27;update/&#x27; update된 url로 접속하기 blog&#x2F;views.py from django.views.generic import UpdateViewclass PostUpdate(UpdateView): model = Post # post의 모든 field를 가져와라 field = &#x27;__all__&#x27; blog&#x2F;urls.py from django.urls import path, includefrom .import viewsurlpatterns = [ # path(&#x27;&#x27;, views.index), # path(&#x27;&lt;int:pk&gt;/&#x27;, views.post_detail), path(&#x27;category/&lt;str:slug&gt;/&#x27;, views.PostListByCategory.as_view()), path(&#x27;&lt;int:pk&gt;/update/&#x27;, views.PostUpdate.as_view()), path(&#x27;&lt;int:pk&gt;/&#x27;, views.PostDetail.as_view()), path(&#x27;&#x27;, views.PostList.as_view()),]","text":"Post 수정 화면 &#x2F; 기능 구현하기update된 url을 반환하는 함수 만들어 주기 blog&#x2F;models.py # update된 url을 반환하기 위한 함수def get_update_url(self): return self.get_absolute_url() + &#x27;update/&#x27; update된 url로 접속하기 blog&#x2F;views.py from django.views.generic import UpdateViewclass PostUpdate(UpdateView): model = Post # post의 모든 field를 가져와라 field = &#x27;__all__&#x27; blog&#x2F;urls.py from django.urls import path, includefrom .import viewsurlpatterns = [ # path(&#x27;&#x27;, views.index), # path(&#x27;&lt;int:pk&gt;/&#x27;, views.post_detail), path(&#x27;category/&lt;str:slug&gt;/&#x27;, views.PostListByCategory.as_view()), path(&#x27;&lt;int:pk&gt;/update/&#x27;, views.PostUpdate.as_view()), path(&#x27;&lt;int:pk&gt;/&#x27;, views.PostDetail.as_view()), path(&#x27;&#x27;, views.PostList.as_view()),] post_form 추가하기 blog&#x2F;templates&#x2F;blog&#x2F;post_form.html &#123;% extends &#x27;blog/base.html&#x27; %&#125;&lt;!-- 포스트의 title을 반영한다. --&gt;&#123;% block title %&#125;&#123;&#123; object.title &#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &#123;&#123; form &#125;&#125;&#123;% endblock %&#125; update 페이지에 원하는 field만 가져오기 blog&#x2F;views.py class PostUpdate(UpdateView): model = Post # post의 모든 field를 가져와라 # fields = &#x27;__all__&#x27; fields = [ &#x27;title&#x27;, &#x27;content&#x27;, &#x27;head_image&#x27;, &#x27;category&#x27;, # &#x27;tags&#x27; ] update 페이지 다듬어 주기 blog&#x2F;templates&#x2F;blog&#x2F;post_form.html &#123;% extends &#x27;blog/base.html&#x27; %&#125;&lt;!-- 포스트의 title을 반영한다. --&gt;&#123;% block title %&#125;&#123;&#123; object.title &#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;table&gt; &#123;&#123; form.as_table &#125;&#125; &lt;/table&gt;&#123;% endblock %&#125; 실시간으로 변경사항 볼 수 있게하기 blog&#x2F;templates&#x2F;blog&#x2F;post_form.html &#123;% extends &#x27;blog/base.html&#x27; %&#125;&lt;!-- 포스트의 title을 반영한다. --&gt;&#123;% block title %&#125;&#123;&#123; object.title &#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form method=&quot;POST&quot; action=&quot;&quot;&gt;&#123;% csrf_token %&#125; &lt;table&gt; &#123;&#123; form.as_table &#125;&#125; &lt;/table&gt; &lt;!-- submit 버튼--&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary float-right&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; &#123;&#123; form.media &#125;&#125;&#123;% endblock %&#125; Edit 버튼 활성화 하기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-secondary float-right&quot; onclick=&quot;location.href=&#x27;&#123;&#123; object.get_update_url &#125;&#125;&#x27;&quot;&gt;EDIT&lt;/button&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 마크다운적용하기, tag field에 공란 허용하기","slug":"django/mysite/django-21","date":"2022-05-09T09:47:30.000Z","updated":"2024-02-18T16:47:07.438Z","comments":true,"path":"2022/05/09/django/mysite/django-21/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-21/","excerpt":"마크다운적용하기, tag field에 공란 허용하기 post에 그림이 나타나게 해주기 줄바꿈이 적용될 수 있게 바꿔주기 -&gt; 마크다운 이용하기 post에 그림이 나타나게 해주기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;img class=&quot;img-fluid rounded&quot; src=&quot;&#123;&#123;object.head_image.url&#125;&#125;&quot; alt=&quot;&quot;&gt; 줄바꿈이 적용될 수 있게 바꿔주기 -&gt; 마크다운 이용하기https://neutronx.github.io/django-markdownx/ pip install django-markdownx 앱 추가하기","text":"마크다운적용하기, tag field에 공란 허용하기 post에 그림이 나타나게 해주기 줄바꿈이 적용될 수 있게 바꿔주기 -&gt; 마크다운 이용하기 post에 그림이 나타나게 해주기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;img class=&quot;img-fluid rounded&quot; src=&quot;&#123;&#123;object.head_image.url&#125;&#125;&quot; alt=&quot;&quot;&gt; 줄바꿈이 적용될 수 있게 바꿔주기 -&gt; 마크다운 이용하기https://neutronx.github.io/django-markdownx/ pip install django-markdownx 앱 추가하기 mysite&#x2F;settings.py INSTALLED_APPS = [ &#x27;blog&#x27;, &#x27;markdownx&#x27;, &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;,] urlpatterns에 추가하기 mysite&#x2F;urls.py urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;blog/&#x27;, include(&#x27;blog.urls&#x27;)), path(&#x27;markdownx/&#x27;, include(&#x27;markdownx.urls&#x27;)),] models.py에 사용하기from markdownx.models import MarkdownxFieldclass MyModel(models.Model): myfield = MarkdownxField() blog&#x2F;models.py from django.db import modelsfrom django.contrib.auth.models import Userfrom markdownx.models import MarkdownxField# Create your models here.# 카테고리를 추가한다.class Category(models.Model): # Category의 이름이 유일할 수 있게 unique옵션을 준다. name = models.CharField(max_length=25, unique=True) description = models.TextField(blank=True) # unicode를 허용한다. # slug를 이용하여 url에 카테고리가 뜰 수 있게 해준다. slug = models.SlugField(unique=True, allow_unicode=True) def get_absolute_url(self): return &#x27;/blog/category/&#123;&#125;/&#x27;.format(self.slug) # 카테고리 이름을 출력해준다. def __str__(self): return self.name class Meta: verbose_name_plural = &#x27;categories&#x27;class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 # content = models.TextField() # 마크다운을 사용할 수 있게 MarkdownField로 바꿔준다. content = MarkdownxField() # 이미지 파일 저장을 위한 객체 # upload된 이미지 파일은 blog에 저장이 된다. blank = True는 공란이여도 된다는 의미이다. head_image = models.ImageField(upload_to=&#x27;blog/%Y/%m/%d/&#x27;, blank=True) # 작성 일자 created = models.DateTimeField() # 저자 author = models.ForeignKey(User, on_delete=models.CASCADE) # 카테고리 객체 추가 category = models.ForeignKey(Category, blank=True, null=True, on_delete=models.SET_NULL) # 해당 객체를 문자열로 바꿧을 때 어떤 식으로 보여줄 것인지를 결정한다. def __str__(self): # 작성된 페이지의 제목과 저자를 보여준다. return &#x27;&#123;&#125; :: &#123;&#125;&#x27;.format(self.title, self.author) # 포스트의 절대 경로를 얻기 위한 함 def get_absolute_url(self): return &#x27;/blog/&#123;&#125;/&#x27;.format(self.pk) 마크다운안의 이미지가 제대로 나올 수 있게 하기 blog&#x2F;models.py from markdownx.utils import markdown# markdown을 html로 바꿔준다. def get_markdwon_content(self): return markdown(self.content) blog&#x2F;templates&#x2F;post_detail.html &#123;#&#123;&#123; object.content &#125;&#125;#&#125;&lt;!--safe 옵션을 줘야 바뀐 html 코드를 바로 적용할 수 있다 --&gt;&#123;&#123; object.get_markdwon_content | safe &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Post Detail 개선사항 도출하고 Test 코드 만들기","slug":"django/mysite/django-20","date":"2022-05-09T08:47:30.000Z","updated":"2024-02-18T16:47:07.437Z","comments":true,"path":"2022/05/09/django/mysite/django-20/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-20/","excerpt":"Post Detail 개선사항 도출하고 Test 코드 만들기 post에 카테고리 표시하기 edit 버튼 만들기 post에 그림이 나타나게 해주기 줄바꿈이 적용될 수 있게 바꿔주기 -&gt; 마크다운 이용하기 post에 카테고리 표시하기테스트 코드 만들어주기 blog&#x2F;tests.py self.assertIn(category_politics.name, main_div.text) # category가 main_div에 있다.self.assertNotIn(&#x27;EDIT&#x27;, main_div.text) # EDIT 버튼이 로그인 하지 않은 경우 보이지 않는다.login_success = self.client.login(username=&#x27;smith&#x27;, password=&#x27;nopassword&#x27;) # login을 한 경우에는self.assertTrue(login_success)response = self.client.get(post_000_url)self.assertEqual(response.status_code, 200)soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;)main_div = soup.find(&#x27;div&#x27;, id=&#x27;main-div&#x27;)self.assertEqual(post_000.author, self.author_000) # post.author와 login한 사람이 같으면self.assertIn(&#x27;EDIT&#x27;, main_div.text) # EDIT button이 있다. blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &#123;% if p.category %&#125;&lt;!-- badge가 오른쪽에 붙을 수 있게 float-right옵션을 이용한다. --&gt;&lt;span class=&quot;badge badge-primary float-right&quot;&gt;&#123;&#123; p.category &#125;&#125;&lt;/span&gt;&#123;% else %&#125;&lt;span class=&quot;badge badge-primary float-right&quot;&gt;미분류&lt;/span&gt;&#123;% endif %&#125; post_list.html로부터 category부분의 내용을 post_detail.html에 붙여준다.","text":"Post Detail 개선사항 도출하고 Test 코드 만들기 post에 카테고리 표시하기 edit 버튼 만들기 post에 그림이 나타나게 해주기 줄바꿈이 적용될 수 있게 바꿔주기 -&gt; 마크다운 이용하기 post에 카테고리 표시하기테스트 코드 만들어주기 blog&#x2F;tests.py self.assertIn(category_politics.name, main_div.text) # category가 main_div에 있다.self.assertNotIn(&#x27;EDIT&#x27;, main_div.text) # EDIT 버튼이 로그인 하지 않은 경우 보이지 않는다.login_success = self.client.login(username=&#x27;smith&#x27;, password=&#x27;nopassword&#x27;) # login을 한 경우에는self.assertTrue(login_success)response = self.client.get(post_000_url)self.assertEqual(response.status_code, 200)soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;)main_div = soup.find(&#x27;div&#x27;, id=&#x27;main-div&#x27;)self.assertEqual(post_000.author, self.author_000) # post.author와 login한 사람이 같으면self.assertIn(&#x27;EDIT&#x27;, main_div.text) # EDIT button이 있다. blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &#123;% if p.category %&#125;&lt;!-- badge가 오른쪽에 붙을 수 있게 float-right옵션을 이용한다. --&gt;&lt;span class=&quot;badge badge-primary float-right&quot;&gt;&#123;&#123; p.category &#125;&#125;&lt;/span&gt;&#123;% else %&#125;&lt;span class=&quot;badge badge-primary float-right&quot;&gt;미분류&lt;/span&gt;&#123;% endif %&#125; post_list.html로부터 category부분의 내용을 post_detail.html에 붙여준다. Edit 버튼 만들기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;!-- 로그인 한 사용자가 author와 같으면 EDIT 버튼을 보여준다.--&gt;&#123;% if request.user == object.author %&#125; &lt;span class=&quot;badge badge-info float-right&quot;&gt;EDIT&lt;/span&gt;&#123;% endif %&#125; 버튼 형식으로 만들기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;!-- 로그인 한 사용자가 author와 같으면 EDIT 버튼을 보여준다.--&gt;&#123;% if request.user == object.author %&#125; &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-secondary float-right&quot;&gt;EDIT&lt;/button&gt;&#123;% endif %&#125; 다른 사람으로 로그인 되는 경우에 대해서 테스트 코드 작성 blog&#x2F;tests.py login_success = self.client.login(username=&#x27;obama&#x27;, password=&#x27;nopassword&#x27;) # login을 한 경우에는self.assertTrue(login_success)response = self.client.get(post_000_url)self.assertEqual(response.status_code, 200)soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;)main_div = soup.find(&#x27;div&#x27;, id=&#x27;main-div&#x27;)self.assertEqual(post_000.author, self.author_000) # post.author와 login한 사람이 같으면self.assertNotIn(&#x27;EDIT&#x27;, main_div.text) # EDIT button이 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Category 페이지 만들기 (slugField)","slug":"django/mysite/django-19","date":"2022-05-09T07:47:30.000Z","updated":"2024-02-18T16:47:07.437Z","comments":true,"path":"2022/05/09/django/mysite/django-19/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-19/","excerpt":"Category 페이지 만들기 (slugField)Category에 get_absolute_url추가하기 blog&#x2F;models.py # Create your models here.# 카테고리를 추가한다.class Category(models.Model): # Category의 이름이 유일할 수 있게 unique옵션을 준다. name = models.CharField(max_length=25, unique=True) description = models.TextField(blank=True) # unicode를 허용한다. # slug를 이용하여 url에 카테고리가 뜰 수 있게 해준다. slug = models.SlugField(unique=True, allow_unicode=True) def get_absoulte_url(self): return &#x27;/blog/category/&#123;&#125;/&#x27;.format(self.slug) # 카테고리 이름을 출력해준다. def __str__(self): return self.name class Meta: verbose_name_plural = &#x27;categories&#x27; admin에 slug가 자동으로 생성 될 수 있게하기 blog&#x2F;admin.py from django.contrib import adminfrom .models import Post, Category# Register your models here.class CategoryAdmin(admin.ModelAdmin): # 미리 만들어지는 field # slug를 자동으로 만들어준다. prepopulated_fields = &#123;&#x27;slug&#x27;: (&#x27;name&#x27;, )&#125;admin.site.register(Post)admin.site.register(Category, CategoryAdmin) url 만들어주기 blog&#x2F;urls.py","text":"Category 페이지 만들기 (slugField)Category에 get_absolute_url추가하기 blog&#x2F;models.py # Create your models here.# 카테고리를 추가한다.class Category(models.Model): # Category의 이름이 유일할 수 있게 unique옵션을 준다. name = models.CharField(max_length=25, unique=True) description = models.TextField(blank=True) # unicode를 허용한다. # slug를 이용하여 url에 카테고리가 뜰 수 있게 해준다. slug = models.SlugField(unique=True, allow_unicode=True) def get_absoulte_url(self): return &#x27;/blog/category/&#123;&#125;/&#x27;.format(self.slug) # 카테고리 이름을 출력해준다. def __str__(self): return self.name class Meta: verbose_name_plural = &#x27;categories&#x27; admin에 slug가 자동으로 생성 될 수 있게하기 blog&#x2F;admin.py from django.contrib import adminfrom .models import Post, Category# Register your models here.class CategoryAdmin(admin.ModelAdmin): # 미리 만들어지는 field # slug를 자동으로 만들어준다. prepopulated_fields = &#123;&#x27;slug&#x27;: (&#x27;name&#x27;, )&#125;admin.site.register(Post)admin.site.register(Category, CategoryAdmin) url 만들어주기 blog&#x2F;urls.py from django.urls import path, includefrom .import viewsurlpatterns = [ # path(&#x27;&#x27;, views.index), # path(&#x27;&lt;int:pk&gt;/&#x27;, views.post_detail), path(&#x27;category/&lt;str:slug&gt;/&#x27;, views.PostListByCategory.as_view()), path(&#x27;&lt;int:pk&gt;/&#x27;, views.PostDetail.as_view()), path(&#x27;&#x27;, views.PostList.as_view()),] blog&#x2F;models.py class PostListByCategory(PostList): def get_queryset(self): slug = self.kwargs[&#x27;slug&#x27;] category = Category.objects.get(slug=slug) return Post.objects.filter(category=category). blog&#x2F;templates&#x2F;blog&#x2F;base.html &lt;!-- title이 있는 경우에 --&gt;&#123;% if title %&#125; &#123;% block title %&#125;&#123;&#123; title &#125;&#125;&#123;% endblock %&#125;&#123;% endif %&#125;&#123;% block content %&#125; 내용 추가하기 view 수정하기 blog&#x2F;view.py class PostListByCategory(ListView): def get_queryset(self): slug = self.kwargs[&#x27;slug&#x27;] category = Category.objects.get(slug=slug) return Post.objects.filter(category=category).order_by(&#x27;-created&#x27;) def get_context_data(self, *, object_list=None, **kwargs): context = super(type(self), self).get_context_data(**kwargs) context[&#x27;category_list&#x27;] = Category.objects.all() # Post들 중에서 category가 None인 것의 갯수를 가져온다. context[&#x27;posts_without_category&#x27;] = Post.objects.filter(category=None).count() slug = self.kwargs[&#x27;slug&#x27;] category = Category.objects.get(slug=slug) context[&#x27;title&#x27;] = &#x27;Blog - &#123;&#125;&#x27;.format(category.name) return context 카테고리 버튼 활성화 하기&lt;a href=&quot;&#123;&#123; category.get_absolute_url &#125;&#125;&quot;&gt;&#123;&#123; category.name &#125;&#125;(&#123;&#123; category.post_set.count &#125;&#125;)&lt;/a&gt; 제목에 카테고리 표현해 주기 blog&#x2F;templates&#x2F;blog&#x2F;post_list.html &lt;h1&gt;Blog &#123;% if category %&#125; &lt;small&gt;&#123;&#123; category &#125;&#125;&lt;/small&gt;&#123;% endif %&#125;&lt;/h1&gt; blog&#x2F;views.py slug = self.kwargs[&#x27;slug&#x27;] category = Category.objects.get(slug=slug) context[&#x27;category&#x27;] = category 제목 카테고리 하얗게 하기&lt;h1&gt;Blog &#123;% if category %&#125; &lt;small class=&quot;text-muted&quot;&gt;: &#123;&#123; category &#125;&#125;&lt;/small&gt;&#123;% endif %&#125;&lt;/h1&gt; 미분류 활성화 하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html &lt;a href=&quot;/blog/category/_none/&quot;&gt;미분류(&#123;&#123; posts_without_category &#125;&#125;)&lt;/a&gt; 테스트 코드 작성하기 blog&#x2F;tests.py # 미분류 카테고리에 관한 test함수def test_post_list_no_category(self): category_politics = create_category(name=&#x27;정치/사회&#x27;) post_000 = create_post( title=&quot;The first post&quot;, content=&quot;Hello World. We are the world.&quot;, author=self.author_000, ) post_001 = create_post( title=&quot;The second post&quot;, content=&quot;Second Second Second&quot;, author=self.author_000, category=category_politics, ) # url이 /blog/category/_none/이다. response = self.client.get(&#x27;/blog/category/_none/&#x27;) self.assertEqual(response.status_code, 200) # 정상적으로 이루어진 경우 BeautifulSoup을 이용해 html.parser로 파싱한 객체를 생성한다. soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;) title = soup.title # self.assertEqual(&#x27;Blog - &#123;&#125;&#x27;.format(category_politics.name), soup.title.text) main_div = soup.find(&#x27;div&#x27;, id=&#x27;main-div&#x27;) self.assertIn(&#x27;미분류&#x27;, main_div.text) self.assertNotIn(category_politics.name, main_div.text) views.py 수정하기 blog&#x2F;views.py class PostListByCategory(ListView): def get_queryset(self): slug = self.kwargs[&#x27;slug&#x27;] # slug가 none인경우 if slug == &#x27;_none&#x27;: category = None else: category = Category.objects.get(slug=slug) return Post.objects.filter(category=category).order_by(&#x27;-created&#x27;) def get_context_data(self, *, object_list=None, **kwargs): context = super(type(self), self).get_context_data(**kwargs) context[&#x27;category_list&#x27;] = Category.objects.all() # Post들 중에서 category가 None인 것의 갯수를 가져온다. context[&#x27;posts_without_category&#x27;] = Post.objects.filter(category=None).count() slug = self.kwargs[&#x27;slug&#x27;] # slug가 none인경우 if slug == &#x27;_none&#x27;: context[&#x27;category&#x27;] = &#x27;미분&#x27; else: category = Category.objects.get(slug=slug) context[&#x27;category&#x27;] = category # context[&#x27;title&#x27;] = &#x27;Blog - &#123;&#125;&#x27;.format(category.name) return context","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 사소한 문제들 해결(불필요한 내용 삭제하기; category 복수형 수정하기 (categorys -> categories))","slug":"django/mysite/django-18","date":"2022-05-09T06:47:30.000Z","updated":"2024-02-18T16:47:07.437Z","comments":true,"path":"2022/05/09/django/mysite/django-18/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-18/","excerpt":"사소한 문제들 해결: 불필요한 내용 삭제하기; category 복수형 수정하기 (categorys -&gt; categories)post_detail에 카테고리 반영하기 blog&#x2F;models.py def get_context_data(self, *, object_list=None, **kwargs): context = super(PostList, self).get_context_data(**kwargs) context[&#x27;category_list&#x27;] = Category.objects.all() # Post들 중에서 category가 None인 것의 갯수를 가져온다. context[&#x27;posts_without_category&#x27;] = Post.objects.filter(category=None).count() return context blog&#x2F;tests.py def check_right_side(self, soup): category_card = soup.find(&#x27;div&#x27;, id=&#x27;category-card&#x27;) self.assertIn(&#x27;미분류(1)&#x27;, category_card.text) #### 미분류 (1)이 있어야 한다. self.assertIn(&#x27;정치/사회(1)&#x27;, category_card.text) #### 정치/사회(1)이 있어야 한다.# category가 잘 작동하는지 확인하기self.check_right_side(soup)","text":"사소한 문제들 해결: 불필요한 내용 삭제하기; category 복수형 수정하기 (categorys -&gt; categories)post_detail에 카테고리 반영하기 blog&#x2F;models.py def get_context_data(self, *, object_list=None, **kwargs): context = super(PostList, self).get_context_data(**kwargs) context[&#x27;category_list&#x27;] = Category.objects.all() # Post들 중에서 category가 None인 것의 갯수를 가져온다. context[&#x27;posts_without_category&#x27;] = Post.objects.filter(category=None).count() return context blog&#x2F;tests.py def check_right_side(self, soup): category_card = soup.find(&#x27;div&#x27;, id=&#x27;category-card&#x27;) self.assertIn(&#x27;미분류(1)&#x27;, category_card.text) #### 미분류 (1)이 있어야 한다. self.assertIn(&#x27;정치/사회(1)&#x27;, category_card.text) #### 정치/사회(1)이 있어야 한다.# category가 잘 작동하는지 확인하기self.check_right_side(soup)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 블로그 post에 카테고리 추가하기","slug":"django/mysite/django-17","date":"2022-05-09T05:47:30.000Z","updated":"2024-02-18T16:47:07.436Z","comments":true,"path":"2022/05/09/django/mysite/django-17/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-17/","excerpt":"블로그 post list와 post detail 페이지에 카테고리 추가하기테스트 코드 작성하기 blog&#x2F;tests.py post_001 = create_post( title=&quot;The second post&quot;, content=&quot;Second Second Second&quot;, author=self.author_000, category=create_category(name=&#x27;정치/사회&#x27;))# category card에서 category_card = body.find(&#x27;div&#x27;, id=&#x27;category-card&#x27;) self.assertIn(&#x27;미분류(1)&#x27;, category_card.text) #### 미분류 (1)이 있어야 한다. self.assertIn(&#x27;정치/사회(1)&#x27;, category_card.text) #### 정치/사회(1)이 있어야 한다. main_div = body.find(&#x27;div&#x27;, id=&#x27;main_div&#x27;) self.assertIn(&#x27;정치/사회&#x27;, main_div.text) ###&#x27;정치/사회&#x27; 있어야 함 self.assertIn((&#x27;미분류&#x27;, main_div.text)) ### &#x27;미분류&#x27; 있어야 함 id 추가하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html &lt;div class=&quot;card my-4&quot; id = &quot;category-card&quot;&gt; 카테고리 카드 수정해주기 blog&#x2F;views.py","text":"블로그 post list와 post detail 페이지에 카테고리 추가하기테스트 코드 작성하기 blog&#x2F;tests.py post_001 = create_post( title=&quot;The second post&quot;, content=&quot;Second Second Second&quot;, author=self.author_000, category=create_category(name=&#x27;정치/사회&#x27;))# category card에서 category_card = body.find(&#x27;div&#x27;, id=&#x27;category-card&#x27;) self.assertIn(&#x27;미분류(1)&#x27;, category_card.text) #### 미분류 (1)이 있어야 한다. self.assertIn(&#x27;정치/사회(1)&#x27;, category_card.text) #### 정치/사회(1)이 있어야 한다. main_div = body.find(&#x27;div&#x27;, id=&#x27;main_div&#x27;) self.assertIn(&#x27;정치/사회&#x27;, main_div.text) ###&#x27;정치/사회&#x27; 있어야 함 self.assertIn((&#x27;미분류&#x27;, main_div.text)) ### &#x27;미분류&#x27; 있어야 함 id 추가하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html &lt;div class=&quot;card my-4&quot; id = &quot;category-card&quot;&gt; 카테고리 카드 수정해주기 blog&#x2F;views.py # templates로 추가적인 정보를 넘겨주고 싶을 경우def get_context_data(self, *, object_list=None, **kwargs): context = super(PostList, self).get_context_data(**kwargs) context[&#x27;categories_list&#x27;] = Category.objects.all() # Post들 중에서 category가 None인 것의 갯수를 가져온다. context[&#x27;posts_without_category&#x27;] = Post.objects.filter(category=None).count() return context base.html 수정하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html &lt;li&gt; &lt;a href=&quot;#&quot;&gt;미분류(&#123;&#123; posts_without_category &#125;&#125;)&lt;/a&gt;&lt;/li&gt;&#123;% for category in category_list %&#125;&lt;li&gt; &lt;a href=&quot;#&quot;&gt;&#123;&#123; category.name &#125;&#125;(&#123;&#123; category.post_set.count &#125;&#125;)&lt;/a&gt;&lt;/li&gt;&#123;% endfor %&#125; Category코드 수정하기 blog&#x2F;models.py # Create your models here.# 카테고리를 추가한다.class Category(models.Model): # Category의 이름이 유일할 수 있게 unique옵션을 준다. name = models.CharField(max_length=25, unique=True) description = models.TextField(blank=True) # 카테고리 이름을 출력해준다. def __str__(self): return self.name 카테고리가 없을 경우 미분류로 출력되게 html을 변경해준다. blog&#x2F;templates&#x2F;blog&#x2F;post_list.html &lt;!-- badge를 붙인다. --&gt;&lt;!-- 카테고리가 있는 경우에는 카테고리를 보여주고, 없는 경우에는 미분류를 보여준다. --&gt;&#123;% if p.category %&#125;&lt;!-- badge가 오른쪽에 붙을 수 있게 float-right옵션을 이용한다. --&gt;&lt;span class=&quot;badge badge-primary float-right&quot;&gt;&#123;&#123; p.category &#125;&#125;&lt;/span&gt;&#123;% else %&#125;&lt;span class=&quot;badge badge-primary float-right&quot;&gt;미분류&lt;/span&gt;&#123;% endif %&#125; admin에 category를 등록하기","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 블로그 post에 카테고리 추가하기","slug":"django/mysite/django-16","date":"2022-05-09T04:47:30.000Z","updated":"2024-02-18T16:47:07.436Z","comments":true,"path":"2022/05/09/django/mysite/django-16/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-16/","excerpt":"블로그 post에 카테고리 추가하기테스트 코드 작성하기 blog&#x2F;tests.py # 카테고리 생성을 위한 코드def create_category(name=&#x27;life&#x27;, description=&quot;&quot;): category, is_created = Category.objects.get_or_create( name=name, description=description ) return category# 카테고리를 테스트 하기 위한class TestModel(TestCase): def setUp(self): # 브라우저 역할을 해준다. self.client = Client() self.author_000 = User.objects.create( username=&#x27;smith&#x27;, password=&#x27;nopassword&#x27;) def test_category(self): category = create_category() def test_post(self): category = create_category( ) post_000 = create_post( title=&quot;The first post&quot;, content=&quot;Hello World. We are the world.&quot;, author=self.author_000, category=category ) # 카테고리에서 포스트를 불러오는 코드 self.assertEqual(category.post_set.count(), 1) 카테고리 만들어 주기 blog&#x2F;models.py # 카테고리를 추가한다.class Category(models.Model): name = models.CharField(max_length=25) description = models.TextField(black=True) 전체 소스 코드from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.# 카테고리를 추가한다.class Category(models.Model): # Category의 이름이 유일할 수 있게 unique옵션을 준다. name = models.CharField(max_length=25, unique=True) description = models.TextField(blank=True)class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 content = models.TextField() # 이미지 파일 저장을 위한 객체 # upload된 이미지 파일은 blog에 저장이 된다. blank = True는 공란이여도 된다는 의미이다. head_image = models.ImageField(upload_to=&#x27;blog/%Y/%m/%d/&#x27;, blank=True) # 작성 일자 created = models.DateTimeField() # 저자 author = models.ForeignKey(User, on_delete=models.CASCADE) # 카테고리 객체 추가 category = models.ForeignKey(Category, blank=True, null=True, on_delete=models.SET_NULL) # 해당 객체를 문자열로 바꿧을 때 어떤 식으로 보여줄 것인지를 결정한다. def __str__(self): # 작성된 페이지의 제목과 저자를 보여준다. return &#x27;&#123;&#125; :: &#123;&#125;&#x27;.format(self.title, self.author) # 포스트의 절대 경로를 얻기 위한 함 def get_absolute_url(self): return &#x27;/blog/&#123;&#125;/&#x27;.format(self.pk)","text":"블로그 post에 카테고리 추가하기테스트 코드 작성하기 blog&#x2F;tests.py # 카테고리 생성을 위한 코드def create_category(name=&#x27;life&#x27;, description=&quot;&quot;): category, is_created = Category.objects.get_or_create( name=name, description=description ) return category# 카테고리를 테스트 하기 위한class TestModel(TestCase): def setUp(self): # 브라우저 역할을 해준다. self.client = Client() self.author_000 = User.objects.create( username=&#x27;smith&#x27;, password=&#x27;nopassword&#x27;) def test_category(self): category = create_category() def test_post(self): category = create_category( ) post_000 = create_post( title=&quot;The first post&quot;, content=&quot;Hello World. We are the world.&quot;, author=self.author_000, category=category ) # 카테고리에서 포스트를 불러오는 코드 self.assertEqual(category.post_set.count(), 1) 카테고리 만들어 주기 blog&#x2F;models.py # 카테고리를 추가한다.class Category(models.Model): name = models.CharField(max_length=25) description = models.TextField(black=True) 전체 소스 코드from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.# 카테고리를 추가한다.class Category(models.Model): # Category의 이름이 유일할 수 있게 unique옵션을 준다. name = models.CharField(max_length=25, unique=True) description = models.TextField(blank=True)class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 content = models.TextField() # 이미지 파일 저장을 위한 객체 # upload된 이미지 파일은 blog에 저장이 된다. blank = True는 공란이여도 된다는 의미이다. head_image = models.ImageField(upload_to=&#x27;blog/%Y/%m/%d/&#x27;, blank=True) # 작성 일자 created = models.DateTimeField() # 저자 author = models.ForeignKey(User, on_delete=models.CASCADE) # 카테고리 객체 추가 category = models.ForeignKey(Category, blank=True, null=True, on_delete=models.SET_NULL) # 해당 객체를 문자열로 바꿧을 때 어떤 식으로 보여줄 것인지를 결정한다. def __str__(self): # 작성된 페이지의 제목과 저자를 보여준다. return &#x27;&#123;&#125; :: &#123;&#125;&#x27;.format(self.title, self.author) # 포스트의 절대 경로를 얻기 위한 함 def get_absolute_url(self): return &#x27;/blog/&#123;&#125;/&#x27;.format(self.pk)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - read more 버튼 동작하게 하기, post_detail 페이지 개선하기","slug":"django/mysite/django-15","date":"2022-05-09T03:47:30.000Z","updated":"2024-02-18T16:47:07.435Z","comments":true,"path":"2022/05/09/django/mysite/django-15/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-15/","excerpt":"read more 버튼 동작하게 하기, post_detail 페이지 개선하기버튼 활성화 하기id 추가해주기 blog&#x2F;templates&#x2F;blog&#x2F;post_list.html &lt;!-- 버튼이 눌렸을 때 이동할 url과 button을 쉽게 찾기 위한 id를 추가한다. --&gt;&lt;a href=&quot;&#123;&#123; p.get_absolute_url &#125;&#125;&quot; class=&quot;btn btn-primary&quot; id=&quot;read-more-post-&#123;&#123; p.pk &#125;&#125;&quot;&gt;Read More&amp;rarr;&lt;/a&gt; 테스트 코드부터 작성하기 blog&#x2F;tests.py # button 확인을 위한 코드post_000_read_more_button = body.find(&#x27;a&#x27;, id=&quot;read-more-post-&#123;&#125;&quot;.format(post_000.pk))self.assertEqual(post_000_read_more_button[&#x27;href&#x27;], post_000.get_absolute_url()) post_detail 디자인 변경하기","text":"read more 버튼 동작하게 하기, post_detail 페이지 개선하기버튼 활성화 하기id 추가해주기 blog&#x2F;templates&#x2F;blog&#x2F;post_list.html &lt;!-- 버튼이 눌렸을 때 이동할 url과 button을 쉽게 찾기 위한 id를 추가한다. --&gt;&lt;a href=&quot;&#123;&#123; p.get_absolute_url &#125;&#125;&quot; class=&quot;btn btn-primary&quot; id=&quot;read-more-post-&#123;&#123; p.pk &#125;&#125;&quot;&gt;Read More&amp;rarr;&lt;/a&gt; 테스트 코드부터 작성하기 blog&#x2F;tests.py # button 확인을 위한 코드post_000_read_more_button = body.find(&#x27;a&#x27;, id=&quot;read-more-post-&#123;&#125;&quot;.format(post_000.pk))self.assertEqual(post_000_read_more_button[&#x27;href&#x27;], post_000.get_absolute_url()) post_detail 디자인 변경하기https://startbootstrap.com/previews/blog-post/ 테스트 코드 작성하기 blog&#x2F;tests.py # post datail의 내용들이 잘 들어갔는지 확인하기 위한 코드 body = soup.body main_div = body.find(&#x27;div&#x27;, id=&#x27;main_div&#x27;) self.assertIn(post_000.title, main_div.text) self.assertIn(post_000.author.username, main_div.text) 부트 스트랩으로 부터 가져오기 blog&#x2F;templates&#x2F;post_detail.html &#123;% extends &#x27;blog/base.html&#x27; %&#125;&lt;!-- 포스트의 title을 반영한다. --&gt;&#123;% block title %&#125;&#123;&#123; object.title &#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;!-- Title --&gt;&lt;h1 class=&quot;mt-4&quot;&gt;Post Title&lt;/h1&gt;&lt;!-- Author --&gt;&lt;p class=&quot;lead&quot;&gt; by &lt;a href=&quot;#&quot;&gt;Start Bootstrap&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;!-- Date/Time --&gt;&lt;p&gt;Posted on January 1, 2019 at 12:00 PM&lt;/p&gt;&lt;hr&gt;&lt;!-- Preview Image --&gt;&lt;img class=&quot;img-fluid rounded&quot; src=&quot;http://placehold.it/900x300&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;!-- Post Content --&gt;&lt;p class=&quot;lead&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ducimus, vero, obcaecati, aut, error quam sapiente nemo saepe quibusdam sit excepturi nam quia corporis eligendi eos magni recusandae laborum minus inventore?&lt;/p&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ut, tenetur natus doloremque laborum quos iste ipsum rerum obcaecati impedit odit illo dolorum ab tempora nihil dicta earum fugiat. Temporibus, voluptatibus.&lt;/p&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eos, doloribus, dolorem iusto blanditiis unde eius illum consequuntur neque dicta incidunt ullam ea hic porro optio ratione repellat perspiciatis. Enim, iure!&lt;/p&gt;&lt;blockquote class=&quot;blockquote&quot;&gt; &lt;p class=&quot;mb-0&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt; &lt;footer class=&quot;blockquote-footer&quot;&gt;Someone famous in &lt;cite title=&quot;Source Title&quot;&gt;Source Title&lt;/cite&gt; &lt;/footer&gt;&lt;/blockquote&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Error, nostrum, aliquid, animi, ut quas placeat totam sunt tempora commodi nihil ullam alias modi dicta saepe minima ab quo voluptatem obcaecati?&lt;/p&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Harum, dolor quis. Sunt, ut, explicabo, aliquam tenetur ratione tempore quidem voluptates cupiditate voluptas illo saepe quaerat numquam recusandae? Qui, necessitatibus, est!&lt;/p&gt;&lt;hr&gt;&lt;!-- Comments Form --&gt;&lt;div class=&quot;card my-4&quot;&gt; &lt;h5 class=&quot;card-header&quot;&gt;Leave a Comment:&lt;/h5&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;textarea class=&quot;form-control&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- Single Comment --&gt;&lt;div class=&quot;media mb-4&quot;&gt; &lt;img class=&quot;d-flex mr-3 rounded-circle&quot; src=&quot;http://placehold.it/50x50&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h5 class=&quot;mt-0&quot;&gt;Commenter Name&lt;/h5&gt; Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. &lt;/div&gt;&lt;/div&gt;&lt;!-- Comment with nested comments --&gt;&lt;div class=&quot;media mb-4&quot;&gt; &lt;img class=&quot;d-flex mr-3 rounded-circle&quot; src=&quot;http://placehold.it/50x50&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h5 class=&quot;mt-0&quot;&gt;Commenter Name&lt;/h5&gt; Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. &lt;div class=&quot;media mt-4&quot;&gt; &lt;img class=&quot;d-flex mr-3 rounded-circle&quot; src=&quot;http://placehold.it/50x50&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h5 class=&quot;mt-0&quot;&gt;Commenter Name&lt;/h5&gt; Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;media mt-4&quot;&gt; &lt;img class=&quot;d-flex mr-3 rounded-circle&quot; src=&quot;http://placehold.it/50x50&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h5 class=&quot;mt-0&quot;&gt;Commenter Name&lt;/h5&gt; Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; post_detail 수정하기 blog&#x2F;templates&#x2F;post_detail.html &#123;% extends &#x27;blog/base.html&#x27; %&#125;&lt;!-- 포스트의 title을 반영한다. --&gt;&#123;% block title %&#125;&#123;&#123; object.title &#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;!-- Title --&gt;&lt;h1&gt;&#123;&#123; object.title &#125;&#125;&lt;/h1&gt;&lt;!-- Author --&gt;&lt;p class=&quot;lead&quot;&gt; by &lt;a href=&quot;#&quot;&gt;&#123;&#123; object.author.username &#125;&#125;&lt;/a&gt;&lt;/p&gt; 테스트 코드 추가 blog&#x2F;tests.py # post datail의 내용들이 잘 들어갔는지 확인하기 위한 코드 body = soup.body main_div = body.find(&#x27;div&#x27;, id=&#x27;main_div&#x27;) self.assertIn(post_000.title, main_div.text) self.assertIn(post_000.author.username, main_div.text) self.assertIn(post_000.content, main_div.text)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - HTML 분리해서 관리하기","slug":"django/mysite/django-14","date":"2022-05-09T02:47:30.000Z","updated":"2024-02-18T16:47:07.435Z","comments":true,"path":"2022/05/09/django/mysite/django-14/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-14/","excerpt":"HTML 분리해서 관리하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html 추가 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- Blog Entries Column --&gt; &lt;div class=&quot;col-md-8&quot;&gt; &#123;% block content %&#125; &#123;% endblock %&#125; &lt;/div&gt; blog&#x2F;templates&#x2F;blog&#x2F;post_list 수정 &#123;% extends &#x27;blog/base.html&#x27; %&#125;&#123;% block content %&#125;&lt;!-- Blog Post --&gt;&#123;%if object_list.exists %&#125;&lt;!-- 포스트의 모든 게시물들을 하나씩 가져온다. --&gt;&#123;% for p in object_list %&#125;&lt;div class=&quot;card mb-4&quot;&gt; &lt;!-- &lt;img class=&quot;card-img-top&quot; src=&quot;http://placehold.it/750x300&quot; alt=&quot;Card image cap&quot; /&gt; --&gt; &#123;% if p.head_image %&#125; &lt;img class=&quot;card-img-top&quot; src=&quot;&#123;&#123;p.head_image.url&#125;&#125;&quot; alt=&quot;Card image cap&quot; /&gt; &#123;% else %&#125; &lt;img class=&quot;card-img-top&quot; src=&quot;https://picsum.photos/seed/picsum/750/300&quot; alt=&quot;Card image cap&quot; /&gt; &#123;% endif %&#125; &lt;div class=&quot;card-body&quot;&gt; &lt;!-- 제목 --&gt; &lt;h2 class=&quot;card-title&quot;&gt;&#123;&#123;p.title&#125;&#125;&lt;/h2&gt; &lt;!-- 내용 --&gt; &lt;p class=&quot;card-text&quot;&gt; &#123;&#123;p.content | truncatewords:50&#125;&#125; &lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Read More &amp;rarr;&lt;/a&gt; &lt;/div&gt; &lt;!-- 작성일과 작성자 --&gt; &lt;div class=&quot;card-footer text-muted&quot;&gt; Posted on &#123;&#123;p.created&#125;&#125; by &lt;a href=&quot;#&quot;&gt;&#123;&#123;p.author&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&#123;%endfor%&#125;&#123;%else%&#125;&lt;h3&gt;아직 게시물이 없습니다.&lt;/h3&gt;&#123;%endif%&#125;&#123;% endblock %&#125; extends와 block을 이용하여 중복되는 템플릿을 삭제한 후 간단하게 만들어 주었다. blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &#123;% extends &#x27;blog/base.html&#x27; %&#125;&#123;% block content %&#125;&lt;h1&gt;&#123;&#123;object.title&#125;&#125;&lt;/h1&gt;&lt;div&gt; &#123;&#123;object.content&#125;&#125;&lt;/div&gt;&#123;% endblock %&#125; 결과","text":"HTML 분리해서 관리하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html 추가 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- Blog Entries Column --&gt; &lt;div class=&quot;col-md-8&quot;&gt; &#123;% block content %&#125; &#123;% endblock %&#125; &lt;/div&gt; blog&#x2F;templates&#x2F;blog&#x2F;post_list 수정 &#123;% extends &#x27;blog/base.html&#x27; %&#125;&#123;% block content %&#125;&lt;!-- Blog Post --&gt;&#123;%if object_list.exists %&#125;&lt;!-- 포스트의 모든 게시물들을 하나씩 가져온다. --&gt;&#123;% for p in object_list %&#125;&lt;div class=&quot;card mb-4&quot;&gt; &lt;!-- &lt;img class=&quot;card-img-top&quot; src=&quot;http://placehold.it/750x300&quot; alt=&quot;Card image cap&quot; /&gt; --&gt; &#123;% if p.head_image %&#125; &lt;img class=&quot;card-img-top&quot; src=&quot;&#123;&#123;p.head_image.url&#125;&#125;&quot; alt=&quot;Card image cap&quot; /&gt; &#123;% else %&#125; &lt;img class=&quot;card-img-top&quot; src=&quot;https://picsum.photos/seed/picsum/750/300&quot; alt=&quot;Card image cap&quot; /&gt; &#123;% endif %&#125; &lt;div class=&quot;card-body&quot;&gt; &lt;!-- 제목 --&gt; &lt;h2 class=&quot;card-title&quot;&gt;&#123;&#123;p.title&#125;&#125;&lt;/h2&gt; &lt;!-- 내용 --&gt; &lt;p class=&quot;card-text&quot;&gt; &#123;&#123;p.content | truncatewords:50&#125;&#125; &lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Read More &amp;rarr;&lt;/a&gt; &lt;/div&gt; &lt;!-- 작성일과 작성자 --&gt; &lt;div class=&quot;card-footer text-muted&quot;&gt; Posted on &#123;&#123;p.created&#125;&#125; by &lt;a href=&quot;#&quot;&gt;&#123;&#123;p.author&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&#123;%endfor%&#125;&#123;%else%&#125;&lt;h3&gt;아직 게시물이 없습니다.&lt;/h3&gt;&#123;%endif%&#125;&#123;% endblock %&#125; extends와 block을 이용하여 중복되는 템플릿을 삭제한 후 간단하게 만들어 주었다. blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &#123;% extends &#x27;blog/base.html&#x27; %&#125;&#123;% block content %&#125;&lt;h1&gt;&#123;&#123;object.title&#125;&#125;&lt;/h1&gt;&lt;div&gt; &#123;&#123;object.content&#125;&#125;&lt;/div&gt;&#123;% endblock %&#125; 결과AssertionError: &#x27; &#x27; != &#x27;Blog&#x27;- + Blog----------------------------------------------------------------------Ran 2 tests in 0.031sFAILED (failures=2)Destroying test database for alias &#x27;default&#x27;... 테스트시 오류가 뜬다. 타이틀이 제대로 반영이 안됐기 때문이다. title도 제대로 반영이 될 수 있도록 수정하기 blog&#x2F;templates&#x2F;blog&#x2F;base.html &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;!-- title이 없는 경우는 Blog를 내보내고 있는 경우는 그것으로 대체한다. --&gt; &lt;title&gt;&#123;% block title %&#125;Blog&#123;% endblock %&#125;&lt;/title&gt; blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &#123;% extends &#x27;blog/base.html&#x27; %&#125;&lt;!-- 포스트의 title을 반영한다. --&gt;&#123;% block title %&#125;&#123;&#123; object.title &#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;h1&gt;&#123;&#123;object.title&#125;&#125;&lt;/h1&gt;&lt;div&gt; &#123;&#123;object.content&#125;&#125;&lt;/div&gt;&#123;% endblock %&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Post Detail 페이지 테스트 코드 작성하기","slug":"django/mysite/django-13","date":"2022-05-09T01:47:30.000Z","updated":"2024-02-18T16:47:07.434Z","comments":true,"path":"2022/05/09/django/mysite/django-13/","link":"","permalink":"https://ckck803.github.io/2022/05/09/django/mysite/django-13/","excerpt":"Post Detail 페이지 테스트 코드 작성하기절대 경로를 얻기 위함 함수 만들기 blog&#x2F;models.py def get_absolute_url(self): return &#x27;/blog/&#123;&#125;/&#x27;.format(self.pk) admin 페이지내의 post에 view on site버튼이 활성화 된다. blog&#x2F;tests.py def create_post(title, content, author): blog_post = Post.objects.create( title=title, content=content, created=timezone.now(), author=author, ) detail을 확인하기 위한 함수를 생성 blog&#x2F;tests.py","text":"Post Detail 페이지 테스트 코드 작성하기절대 경로를 얻기 위함 함수 만들기 blog&#x2F;models.py def get_absolute_url(self): return &#x27;/blog/&#123;&#125;/&#x27;.format(self.pk) admin 페이지내의 post에 view on site버튼이 활성화 된다. blog&#x2F;tests.py def create_post(title, content, author): blog_post = Post.objects.create( title=title, content=content, created=timezone.now(), author=author, ) detail을 확인하기 위한 함수를 생성 blog&#x2F;tests.py # post detail을 확인하기 위한 함수def test_post_detail(self): post_000 = create_post( title=&quot;The first post&quot;, content=&quot;Hello World. We are the world.&quot;, author=self.author_000, ) self.assertGreater(Post.objects.count(), 0) post_000_url = post_000.get_absolute_url() self.assertEqual(post_000_url, &#x27;/blog/&#123;&#125;/&#x27;.format(post_000.pk)) response = self.client.get(post_000_url) self.assertEqual(response.status_code, 200) soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;) title = soup.title self.assertEqual(title.text, &#x27;&#123;&#125;&#x27;.format(post_000.title)) self.check_navbar(soup) 전체 소스 코드from django.test import TestCase, Clientfrom bs4 import BeautifulSoupfrom .models import Postfrom django.utils import timezonefrom django.contrib.auth.models import User# Create your tests here.def create_post(title, content, author): blog_post = Post.objects.create( title=title, content=content, created=timezone.now(), author=author, ) return blog_postclass TestView(TestCase): def setUp(self): # 브라우저 역할을 해준다. self.client = Client() self.author_000 = User.objects.create(username=&#x27;smith&#x27;, password=&#x27;nopassword&#x27;) def check_navbar(self, soup): # Beautifulsoup 객체로부터 div 태그를 갖고 id는 navbar를 가진 내용을 가져온다. navbar = soup.find(&#x27;div&#x27;, id=&#x27;navbar&#x27;) # 내용중에서 Blog가 들어가 있는지 확인한다. self.assertIn(&#x27;Blog&#x27;, navbar.text) # 내용준에서 About me가 들어가 있는지 확인한다. self.assertIn(&#x27;About me&#x27;, navbar.text) def test_post_list(self): # blog로 get요청을 한 후 response = self.client.get(&#x27;/blog/&#x27;) # 응답 값이 200이랑 같은지 확인해라 self.assertEqual(response.status_code, 200) # 정상적으로 이루어진 경우 BeautifulSoup을 이용해 html.parser로 파싱한 객체를 생성한다. soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;) title = soup.title self.assertEqual(title.text, &#x27;Blog&#x27;) self.check_navbar(soup) # # Beautifulsoup 객체로부터 div 태그를 갖고 id는 navbar를 가진 내용을 가져온다. # navbar = soup.find(&#x27;div&#x27;, id = &#x27;navbar&#x27;) # # 내용중에서 Blog가 들어가 있는지 확인한다. # self.assertIn(&#x27;Blog&#x27;, navbar.text) # # 내용준에서 About me가 들어가 있는지 확인한다. # self.assertIn(&#x27;About me&#x27;, navbar.text) # Blog 포스트가 없는 경우에는 아직 없습니다를 띄어준다. self.assertEqual(Post.objects.count(), 0) self.assertIn(&#x27;아직 게시물이 없습니다.&#x27;, soup.body.text) # test에는 database에 실재 데이터가 담겨 있는지는 고려하지 앟는다. # 새로 db를 만들고 그 안에서 test를 진행한다. post_000 = create_post( title=&quot;The first post&quot;, content=&quot;Hello World. We are the world.&quot;, author=self.author_000, ) # Blog 포스터가 존재하는 경우 self.assertGreater(Post.objects.count(), 0) response = self.client.get(&#x27;/blog/&#x27;) self.assertEqual(response.status_code, 200) soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;) body = soup.body # post_000이 들어가 있는 상태라 아직 게시물이 없습니다가 나오면 안된다. self.assertNotIn(&#x27;아직 게시물이 없습니다.&#x27;, body.text) # post_000이 제대로 들어가 있는지 확인한다. self.assertIn(post_000.title, body.text) # post detail을 확인하기 위한 함수 def test_post_detail(self): post_000 = create_post( title=&quot;The first post&quot;, content=&quot;Hello World. We are the world.&quot;, author=self.author_000, ) self.assertGreater(Post.objects.count(), 0) post_000_url = post_000.get_absolute_url() self.assertEqual(post_000_url, &#x27;/blog/&#123;&#125;/&#x27;.format(post_000.pk)) response = self.client.get(post_000_url) self.assertEqual(response.status_code, 200) soup = BeautifulSoup(response.content, &#x27;html.parser&#x27;) title = soup.title self.assertEqual(title.text, &#x27;&#123;&#125;&#x27;.format(post_000.title)) self.check_navbar(soup)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Post List 페이지 테스트 코드 작성하기 part A","slug":"django/mysite/django-12","date":"2022-05-08T09:47:30.000Z","updated":"2024-02-18T16:47:07.434Z","comments":true,"path":"2022/05/08/django/mysite/django-12/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-12/","excerpt":"Post Detail 페이지 만들기상세 페이지를 보여주기 위한 url을 추가한다. blog&#x2F;urls.py from django.urls import path, includefrom .import viewsurlpatterns = [ # path(&#x27;&#x27;, views.index), path(&#x27;&lt;int:pk&gt;/&#x27;, views.post_detail()) path(&#x27;&#x27;, views.PostList.as_view()),] 상세 페이지를 보여주기 위한 view를 위한 코드를 작성 blog&#x2F;views.py from django.shortcuts import renderfrom .models import Postfrom django.views.generic import ListView# Create your views here.# List로 보여줄 때는 django.views.generic의# ListView를 상속하여 보여주면 간단하게 보여줄 수 있다.class PostList(ListView): model = Post def get_queryset(self): # 역순으로 보여주기 위해 -로 붙인다. return Post.objects.order_by(&#x27;-created&#x27;)# 상세 페이지를 보여주기 위한 함수를 추가한다.def post_detail(request, pk): blog_post = Post.objects.get(pk=pk) return render( request, &#x27;blog/post_detail.html&#x27;, &#123; &#x27;blog_post&#x27;: blog_post, &#125; ) 상세 페이지를 위한 html 코드 만들기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html","text":"Post Detail 페이지 만들기상세 페이지를 보여주기 위한 url을 추가한다. blog&#x2F;urls.py from django.urls import path, includefrom .import viewsurlpatterns = [ # path(&#x27;&#x27;, views.index), path(&#x27;&lt;int:pk&gt;/&#x27;, views.post_detail()) path(&#x27;&#x27;, views.PostList.as_view()),] 상세 페이지를 보여주기 위한 view를 위한 코드를 작성 blog&#x2F;views.py from django.shortcuts import renderfrom .models import Postfrom django.views.generic import ListView# Create your views here.# List로 보여줄 때는 django.views.generic의# ListView를 상속하여 보여주면 간단하게 보여줄 수 있다.class PostList(ListView): model = Post def get_queryset(self): # 역순으로 보여주기 위해 -로 붙인다. return Post.objects.order_by(&#x27;-created&#x27;)# 상세 페이지를 보여주기 위한 함수를 추가한다.def post_detail(request, pk): blog_post = Post.objects.get(pk=pk) return render( request, &#x27;blog/post_detail.html&#x27;, &#123; &#x27;blog_post&#x27;: blog_post, &#125; ) 상세 페이지를 위한 html 코드 만들기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;&#123;&#123;blog_post.title&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;blog_post.title&#125;&#125;&lt;/h1&gt; &lt;div&gt; &#123;&#123;blog_post.content&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; detail 함수를 클래스로 바꿔주기 blog&#x2F;views.py # def post_detail(request, pk):# blog_post = Post.objects.get(pk=pk)# return render(# request,# &#x27;blog/post_detail.html&#x27;,# &#123;# &#x27;blog_post&#x27;: blog_post,# &#125;# )class PostDetail(DetailView): model = Post 클래스로 변경 후 url 수정하기 blog&#x2F;urls.py urlpatterns = [ # path(&#x27;&#x27;, views.index), # path(&#x27;&lt;int:pk&gt;/&#x27;, views.post_detail), path(&#x27;&lt;int:pk&gt;/&#x27;, views.PostDetail.as_view()), path(&#x27;&#x27;, views.PostList.as_view()),] 클래스로 변경 후 html 수정하기&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;&#123;&#123;object.title&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;object.title&#125;&#125;&lt;/h1&gt; &lt;div&gt; &#123;&#123;object.content&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Post Detail 페이지 만들기","slug":"django/mysite/django-11","date":"2022-05-08T08:47:30.000Z","updated":"2024-02-18T16:47:07.433Z","comments":true,"path":"2022/05/08/django/mysite/django-11/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-11/","excerpt":"Post Detail 페이지 만들기상세 페이지를 보여주기 위한 url을 추가한다. blog&#x2F;urls.py from django.urls import path, includefrom .import viewsurlpatterns = [ # path(&#x27;&#x27;, views.index), path(&#x27;&lt;int:pk&gt;/&#x27;, views.post_detail()) path(&#x27;&#x27;, views.PostList.as_view()),] 상세 페이지를 보여주기 위한 view를 위한 코드를 작성 blog&#x2F;views.py from django.shortcuts import renderfrom .models import Postfrom django.views.generic import ListView# Create your views here.# List로 보여줄 때는 django.views.generic의# ListView를 상속하여 보여주면 간단하게 보여줄 수 있다.class PostList(ListView): model = Post def get_queryset(self): # 역순으로 보여주기 위해 -로 붙인다. return Post.objects.order_by(&#x27;-created&#x27;)# 상세 페이지를 보여주기 위한 함수를 추가한다.def post_detail(request, pk): blog_post = Post.objects.get(pk=pk) return render( request, &#x27;blog/post_detail.html&#x27;, &#123; &#x27;blog_post&#x27;: blog_post, &#125; ) 상세 페이지를 위한 html 코드 만들기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html","text":"Post Detail 페이지 만들기상세 페이지를 보여주기 위한 url을 추가한다. blog&#x2F;urls.py from django.urls import path, includefrom .import viewsurlpatterns = [ # path(&#x27;&#x27;, views.index), path(&#x27;&lt;int:pk&gt;/&#x27;, views.post_detail()) path(&#x27;&#x27;, views.PostList.as_view()),] 상세 페이지를 보여주기 위한 view를 위한 코드를 작성 blog&#x2F;views.py from django.shortcuts import renderfrom .models import Postfrom django.views.generic import ListView# Create your views here.# List로 보여줄 때는 django.views.generic의# ListView를 상속하여 보여주면 간단하게 보여줄 수 있다.class PostList(ListView): model = Post def get_queryset(self): # 역순으로 보여주기 위해 -로 붙인다. return Post.objects.order_by(&#x27;-created&#x27;)# 상세 페이지를 보여주기 위한 함수를 추가한다.def post_detail(request, pk): blog_post = Post.objects.get(pk=pk) return render( request, &#x27;blog/post_detail.html&#x27;, &#123; &#x27;blog_post&#x27;: blog_post, &#125; ) 상세 페이지를 위한 html 코드 만들기 blog&#x2F;templates&#x2F;blog&#x2F;post_detail.html &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;&#123;&#123;blog_post.title&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;blog_post.title&#125;&#125;&lt;/h1&gt; &lt;div&gt; &#123;&#123;blog_post.content&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; detail 함수를 클래스로 바꿔주기 blog&#x2F;views.py # def post_detail(request, pk):# blog_post = Post.objects.get(pk=pk)# return render(# request,# &#x27;blog/post_detail.html&#x27;,# &#123;# &#x27;blog_post&#x27;: blog_post,# &#125;# )class PostDetail(DetailView): model = Post 클래스로 변경 후 url 수정하기 blog&#x2F;urls.py urlpatterns = [ # path(&#x27;&#x27;, views.index), # path(&#x27;&lt;int:pk&gt;/&#x27;, views.post_detail), path(&#x27;&lt;int:pk&gt;/&#x27;, views.PostDetail.as_view()), path(&#x27;&#x27;, views.PostList.as_view()),] 클래스로 변경 후 html 수정하기&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;&#123;&#123;object.title&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;object.title&#125;&#125;&lt;/h1&gt; &lt;div&gt; &#123;&#123;object.content&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - template(html)에서 if문 사용하기","slug":"django/mysite/django-10","date":"2022-05-08T07:47:30.000Z","updated":"2024-02-18T16:47:07.433Z","comments":true,"path":"2022/05/08/django/mysite/django-10/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-10/","excerpt":"template(html)에서 if문 사용하기이미지가 있을 때만 나타내기&#123;% if p.head_image %&#125;&lt;img class=&quot;card-img-top&quot; src=&quot;&#123;&#123;p.head_image.url&#125;&#125;&quot; alt=&quot;Card image cap&quot;/&gt;&#123;% endif %&#125; &#123;% if %&#125;문을 이용하여 처리를 한다. Lorem Picsum 이용하기&#123;% if p.head_image %&#125;&lt;img class=&quot;card-img-top&quot; src=&quot;&#123;&#123;p.head_image.url&#125;&#125;&quot; alt=&quot;Card image cap&quot;/&gt;&#123;% else %&#125;&lt;img class=&quot;card-img-top&quot; src=&quot;https://picsum.photos/seed/picsum/750/300&quot; alt=&quot;Card image cap&quot;/&gt;&#123;% endif %&#125; 이미지가 없을 경우 Lorem Picsum으로부터 이미지를 가져온다. 템플릿에서 truncate로 앞 내용만 보여주기&#123;&#123;p.content | truncatewords:50&#125;&#125;","text":"template(html)에서 if문 사용하기이미지가 있을 때만 나타내기&#123;% if p.head_image %&#125;&lt;img class=&quot;card-img-top&quot; src=&quot;&#123;&#123;p.head_image.url&#125;&#125;&quot; alt=&quot;Card image cap&quot;/&gt;&#123;% endif %&#125; &#123;% if %&#125;문을 이용하여 처리를 한다. Lorem Picsum 이용하기&#123;% if p.head_image %&#125;&lt;img class=&quot;card-img-top&quot; src=&quot;&#123;&#123;p.head_image.url&#125;&#125;&quot; alt=&quot;Card image cap&quot;/&gt;&#123;% else %&#125;&lt;img class=&quot;card-img-top&quot; src=&quot;https://picsum.photos/seed/picsum/750/300&quot; alt=&quot;Card image cap&quot;/&gt;&#123;% endif %&#125; 이미지가 없을 경우 Lorem Picsum으로부터 이미지를 가져온다. 템플릿에서 truncate로 앞 내용만 보여주기&#123;&#123;p.content | truncatewords:50&#125;&#125; truncatewords를 이용해 50단어만 출력하도록 설정한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 사진 업로드를 위한 ImageField와 업로드된 파일 관리 방법","slug":"django/mysite/django-09","date":"2022-05-08T06:47:30.000Z","updated":"2024-02-18T16:47:07.432Z","comments":true,"path":"2022/05/08/django/mysite/django-09/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-09/","excerpt":"blog&#x2F;models.py from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 content = models.TextField() # 이미지 파일 저장을 위한 객체 # upload된 이미지 파일은 blog에 저장이 된다. blank = True는 공란이여도 된다는 의미이다. head_image = models.ImageField(upload_to=&#x27;blog/&#x27;, blank=True) # 작성 일자 created = models.DateTimeField() # 저자 author = models.ForeignKey(User, on_delete=models.CASCADE) # 해당 객체를 문자열로 바꿧을 때 어떤 식으로 보여줄 것인지를 결정한다. def __str__(self): # 작성된 페이지의 제목과 저자를 보여준다. return &#x27;&#123;&#125; :: &#123;&#125;&#x27;.format(self.title, self.author) head_image = models.ImageField(upload_to=&#39;blog/&#39;, blank=True)를 추가했으므로 이제 이미지 파일을 올릴 수 있게 되었다.이렇게 할 경우 일반적으로 blog폴더에 계속 이미지 파일이 생기게 됨으로 settings.py에 가서 이미지가 저장될 수 있는 폴더를 설정해주어야 한다. 미디어가 저장될 기본 폴더 설정하기 mysite&#x2F;settings.py MEDIA_ROOT = os.path.join(BASE_DIR, &#x27;_media&#x27;) 이미지 파일이 _media폴더에 저장되게 된다. 날짜별로 사진 파일 저장하기 blog&#x2F;models.py","text":"blog&#x2F;models.py from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 content = models.TextField() # 이미지 파일 저장을 위한 객체 # upload된 이미지 파일은 blog에 저장이 된다. blank = True는 공란이여도 된다는 의미이다. head_image = models.ImageField(upload_to=&#x27;blog/&#x27;, blank=True) # 작성 일자 created = models.DateTimeField() # 저자 author = models.ForeignKey(User, on_delete=models.CASCADE) # 해당 객체를 문자열로 바꿧을 때 어떤 식으로 보여줄 것인지를 결정한다. def __str__(self): # 작성된 페이지의 제목과 저자를 보여준다. return &#x27;&#123;&#125; :: &#123;&#125;&#x27;.format(self.title, self.author) head_image = models.ImageField(upload_to=&#39;blog/&#39;, blank=True)를 추가했으므로 이제 이미지 파일을 올릴 수 있게 되었다.이렇게 할 경우 일반적으로 blog폴더에 계속 이미지 파일이 생기게 됨으로 settings.py에 가서 이미지가 저장될 수 있는 폴더를 설정해주어야 한다. 미디어가 저장될 기본 폴더 설정하기 mysite&#x2F;settings.py MEDIA_ROOT = os.path.join(BASE_DIR, &#x27;_media&#x27;) 이미지 파일이 _media폴더에 저장되게 된다. 날짜별로 사진 파일 저장하기 blog&#x2F;models.py # 이미지 파일 저장을 위한 객체# upload된 이미지 파일은 blog에 저장이 된다. blank = True는 공란이여도 된다는 의미이다.head_image = models.ImageField(upload_to=&#x27;blog/%Y/%m/%d/&#x27;, blank=True) upload_to=&#39;blog/%Y/%m/%d/&#39;로 저장하게 되면 날짜별로 사진 파일이 저장되게 된다. 사진 반영하기 변경전blog&#x2F;templates&#x2F;blog&#x2F;post_list.html &lt;img class=&quot;card-img-top&quot; src=&quot;http://placehold.it/750x300&quot; alt=&quot;Card image cap&quot;/&gt; &lt;img class=&quot;card-img-top&quot; src=&quot;&#123;&#123;p.head_image.url&#125;&#125;&quot; alt=&quot;Card image cap&quot; /&gt; 결과 블로그 포스트에 사진이 없는 것들이 있기 때문에 이 오류가 뜨게 된다. mysite&#x2F;settings.py MEDIA_URL = &#x27;/_media/&#x27; mysite&#x2F;urls.py from django.contrib import adminfrom django.urls import path, include# static을 추가한다.from django.conf.urls.static import static# settings를 추가한다.from django.conf import settingsurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;blog/&#x27;, include(&#x27;blog.urls&#x27;)),]# static 파일의 media파일을 MEDIA_URL과 연결한다.urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - Bootstrap Grid","slug":"django/mysite/django-08","date":"2022-05-08T05:47:30.000Z","updated":"2024-02-18T16:47:07.432Z","comments":true,"path":"2022/05/08/django/mysite/django-08/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-08/","excerpt":"Bootstrap Gridcontainer blog&#x2F;templates&#x2F;blog&#x2F;post_list.html &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;!-- 포스트의 모든 게시물들을 하나씩 가져온다. --&gt; &#123;% for p in object_list %&#125; &lt;!-- 제목 --&gt; &lt;h3&gt;&#123;&#123;p.title&#125;&#125;&lt;/h3&gt; &lt;!-- 작성일과 작성자 --&gt; &lt;h4&gt;&#123;&#123;p.created&#125;&#125; by &#123;&#123;p.author&#125;&#125;&lt;/h4&gt; &lt;!-- 내용 --&gt; &lt;p&gt;&#123;&#123;p.content&#125;&#125;&lt;/p&gt; &#123;%endfor%&#125;&lt;/div&gt; 메인 페이지 디자인 변경하기 https://startbootstrap.com/templates/blog/ &lt;!-- Page Content --&gt;&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt;&lt;!-- /.row --&gt; bootstrap으로부터 페이지 container 변경을 위해 코드를 가져온다. 가져온 페이지 디자인에 콘텐츠 넣어주기","text":"Bootstrap Gridcontainer blog&#x2F;templates&#x2F;blog&#x2F;post_list.html &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;!-- 포스트의 모든 게시물들을 하나씩 가져온다. --&gt; &#123;% for p in object_list %&#125; &lt;!-- 제목 --&gt; &lt;h3&gt;&#123;&#123;p.title&#125;&#125;&lt;/h3&gt; &lt;!-- 작성일과 작성자 --&gt; &lt;h4&gt;&#123;&#123;p.created&#125;&#125; by &#123;&#123;p.author&#125;&#125;&lt;/h4&gt; &lt;!-- 내용 --&gt; &lt;p&gt;&#123;&#123;p.content&#125;&#125;&lt;/p&gt; &#123;%endfor%&#125;&lt;/div&gt; 메인 페이지 디자인 변경하기 https://startbootstrap.com/templates/blog/ &lt;!-- Page Content --&gt;&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt;&lt;!-- /.row --&gt; bootstrap으로부터 페이지 container 변경을 위해 코드를 가져온다. 가져온 페이지 디자인에 콘텐츠 넣어주기&lt;!-- Blog Entries Column --&gt;&lt;div class=&quot;col-md-8&quot;&gt; &lt;h1 class=&quot;my-4&quot;&gt; Blog &lt;/h1&gt; &lt;!-- Blog Post --&gt; &lt;!-- 포스트의 모든 게시물들을 하나씩 가져온다. --&gt; &#123;% for p in object_list %&#125; &lt;div class=&quot;card mb-4&quot;&gt; &lt;img class=&quot;card-img-top&quot; src=&quot;http://placehold.it/750x300&quot; alt=&quot;Card image cap&quot; /&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;!-- 제목 --&gt; &lt;h2 class=&quot;card-title&quot;&gt;&#123;&#123;p.title&#125;&#125;&lt;/h2&gt; &lt;!-- 내용 --&gt; &lt;p class=&quot;card-text&quot;&gt; &#123;&#123;p.content&#125;&#125; &lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Read More &amp;rarr;&lt;/a&gt; &lt;/div&gt; &lt;!-- 작성일과 작성자 --&gt; &lt;div class=&quot;card-footer text-muted&quot;&gt; Posted on &#123;&#123;p.created&#125;&#125; by &lt;a href=&quot;#&quot;&gt;&#123;&#123;p.author&#125;&#125;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &#123;%endfor%&#125;&lt;/div&gt; CSS 수정하기padding값을 조절하기 수정 전 body &#123; padding-top: 120px;&#125; 수정 후 body &#123; padding-top: 80px;&#125; 만약 수정사항이 바뀌지 않는 경우 방문기록 -&gt; 인터넷 기록 모두 삭제하면 된다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - navigation bar 만들기","slug":"django/mysite/django-07","date":"2022-05-08T04:47:30.000Z","updated":"2024-02-18T16:47:07.432Z","comments":true,"path":"2022/05/08/django/mysite/django-07/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-07/","excerpt":"navigation bar 만들기view-source:https://bootswatch.com/simplex/ &lt;body&gt; &lt;!-- navigation bar 코드가 시작되는 부분 --&gt; &lt;div class=&quot;navbar navbar-expand-lg fixed-top navbar-light bg-light&quot;&gt; .... &lt;/div&gt;&lt;/body&gt; 내용의 코드를 긁어서 blog&#x2F;template&#x2F;blog&#x2F;post_list.html에 붙여준다.","text":"navigation bar 만들기view-source:https://bootswatch.com/simplex/ &lt;body&gt; &lt;!-- navigation bar 코드가 시작되는 부분 --&gt; &lt;div class=&quot;navbar navbar-expand-lg fixed-top navbar-light bg-light&quot;&gt; .... &lt;/div&gt;&lt;/body&gt; 내용의 코드를 긁어서 blog&#x2F;template&#x2F;blog&#x2F;post_list.html에 붙여준다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - static File 관리하기 bootstrap 적용을 위해","slug":"django/mysite/django-06","date":"2022-05-08T03:47:30.000Z","updated":"2024-02-18T16:47:07.431Z","comments":true,"path":"2022/05/08/django/mysite/django-06/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-06/","excerpt":"static File 관리하기 : bootstrap 적용을 위해https://bootswatch.com/simplex/ bootstrap을 적용해보기 blog&#x2F;templates&#x2F;blog&#x2F;post_index.html css 파일&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../4/simplex/bootstrap.css&quot; media=&quot;screen&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../_assets/css/custom.min.css&quot; /&gt; javascript 파일 blog&#x2F;templates&#x2F;blog&#x2F;post_index.html &lt;script src=&quot;../_vendor/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../_vendor/popper.js/dist/umd/popper.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../_vendor/bootstrap/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../_assets/js/custom.js&quot;&gt;&lt;/script&gt;","text":"static File 관리하기 : bootstrap 적용을 위해https://bootswatch.com/simplex/ bootstrap을 적용해보기 blog&#x2F;templates&#x2F;blog&#x2F;post_index.html css 파일&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../4/simplex/bootstrap.css&quot; media=&quot;screen&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;../_assets/css/custom.min.css&quot; /&gt; javascript 파일 blog&#x2F;templates&#x2F;blog&#x2F;post_index.html &lt;script src=&quot;../_vendor/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../_vendor/popper.js/dist/umd/popper.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../_vendor/bootstrap/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../_assets/js/custom.js&quot;&gt;&lt;/script&gt; bootstrap의 javascript를 사용하기 위해서 위 내용을 추가한다. bootstrap의 style과 javascript를 사용하기 위해서 적용을 해준다.저렇게 하면 css파일과 javascript파일이 경로가 이상하여 제대로 작동하지 않으므로 수정할 필요가 있다. static에 추가된 css파일 적용하기 static&#x2F;blog&#x2F; static 폴더를 만든 후 blog의 적용할 스타일들을 모아두기 위해 blog폴더를 하나 더 만들어 준다. blog&#x2F;static&#x2F;blog&#x2F;bootstrap&#x2F;bootstrap.cssblog&#x2F;static&#x2F;blog&#x2F;bootstrap&#x2F;_assets&#x2F;css&#x2F;custom.min.css 두 파일을 생성해준다. static 파일들 불러오기 blog&#x2F;templates&#x2F;blog&#x2F;post_index.html &lt;!DOCTYPE html&gt; &#123;% load static %&#125; html 파일이 static 파일들을 가져올 수 있도록 load 명령어를 통해 가져온다. bootstrap.css 적용하기 blog&#x2F;templates&#x2F;blog&#x2F;bootstrap&#x2F;post_index.html &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;../4/simplex/bootstrap.css&quot; media=&quot;screen&quot; /&gt; --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;%static &#x27;blog/bootstrap/bootstrap.css&#x27; %&#125;&quot; media=&quot;screen&quot;/&gt; custom.min.css 적용하기&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;../_assets/css/custom.min.css&quot; /&gt; --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;%static &#x27;blog/_assets/css/custom.min.css&#x27; %&#125;&quot; /&gt; 자바스크립트 경로 수정하기 blog&#x2F;static&#x2F;blog&#x2F;bootstrap&#x2F;jqeury.min.jsblog&#x2F;static&#x2F;blog&#x2F;bootstrap&#x2F;popper.min.jsblog&#x2F;static&#x2F;blog&#x2F;bootstrap&#x2F;bootstrap.min.jsblog&#x2F;static&#x2F;blog&#x2F;_assets&#x2F;js&#x2F;custom.js4개의 파일 &lt;!-- &lt;script src=&quot;../_vendor/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- &lt;script src=&quot;../_vendor/popper.js/dist/umd/popper.min.js&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- &lt;script src=&quot;../_vendor/bootstrap/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- &lt;script src=&quot;../_assets/js/custom.js&quot;&gt;&lt;/script&gt; --&gt;&lt;script src=&quot;&#123;% static &#x27;blog/_assets/js/jquery.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;blog/_assets/js/popper.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;blog/bootstrap/bootstrap.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;% static &#x27;blog/_assets/js/custom.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - FBV -> MBV 블로그 포스트 리스트","slug":"django/mysite/django-05","date":"2022-05-08T03:47:30.000Z","updated":"2024-02-18T16:47:07.431Z","comments":true,"path":"2022/05/08/django/mysite/django-05/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-05/","excerpt":"blog&#x2F;view.py변경전 from django.shortcuts import renderfrom .models import Postdef index(request): # Post의 내용들을 전부 다 가져온다. posts = Post.objects.all() return render( request, # 템블릿이 되는 html 코드를 작성할 필요가 있다. &#x27;blog/index.html&#x27;, # index.html에서 사용하도록 객체를 넘겨주고 있다. # template에 전해주고 싶은 것들을 적어주면 된다. &#123; &#x27;posts&#x27;: posts, &#125; ) 변경후 from django.shortcuts import renderfrom .models import Postfrom django.views.generic import ListView# Create your views here.class PostList(ListView): model = Post blog&#x2F;urls.py urlpatterns = [ path(&#x27;&#x27;, views.index),] urlpatterns = [ path(&#x27;&#x27;, views.PostList.as_view()),] blog&#x2F;templates&#x2F;blog&#x2F;post_list.html 생성 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;!-- 포스트의 모든 게시물들을 하나씩 가져온다. --&gt; &#123;% for p in object_list %&#125; &lt;!-- 제목 --&gt; &lt;h3&gt;&#123;&#123;p.title&#125;&#125;&lt;/h3&gt; &lt;!-- 작성일과 작성자 --&gt; &lt;h4&gt;&#123;&#123;p.created&#125;&#125; by &#123;&#123;p.author&#125;&#125;&lt;/h4&gt; &lt;!-- 내용 --&gt; &lt;p&gt;&#123;&#123;p.content&#125;&#125;&lt;/p&gt; &#123;%endfor%&#125; &lt;/body&gt;&lt;/html&gt;","text":"blog&#x2F;view.py변경전 from django.shortcuts import renderfrom .models import Postdef index(request): # Post의 내용들을 전부 다 가져온다. posts = Post.objects.all() return render( request, # 템블릿이 되는 html 코드를 작성할 필요가 있다. &#x27;blog/index.html&#x27;, # index.html에서 사용하도록 객체를 넘겨주고 있다. # template에 전해주고 싶은 것들을 적어주면 된다. &#123; &#x27;posts&#x27;: posts, &#125; ) 변경후 from django.shortcuts import renderfrom .models import Postfrom django.views.generic import ListView# Create your views here.class PostList(ListView): model = Post blog&#x2F;urls.py urlpatterns = [ path(&#x27;&#x27;, views.index),] urlpatterns = [ path(&#x27;&#x27;, views.PostList.as_view()),] blog&#x2F;templates&#x2F;blog&#x2F;post_list.html 생성 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;!-- 포스트의 모든 게시물들을 하나씩 가져온다. --&gt; &#123;% for p in object_list %&#125; &lt;!-- 제목 --&gt; &lt;h3&gt;&#123;&#123;p.title&#125;&#125;&lt;/h3&gt; &lt;!-- 작성일과 작성자 --&gt; &lt;h4&gt;&#123;&#123;p.created&#125;&#125; by &#123;&#123;p.author&#125;&#125;&lt;/h4&gt; &lt;!-- 내용 --&gt; &lt;p&gt;&#123;&#123;p.content&#125;&#125;&lt;/p&gt; &#123;%endfor%&#125; &lt;/body&gt;&lt;/html&gt; 역순으로 보이게 하기from django.shortcuts import renderfrom .models import Postfrom django.views.generic import ListView# Create your views here.# List로 보여줄 때는 django.views.generic의# ListView를 상속하여 보여주면 간단하게 보여줄 수 있다.class PostList(ListView): model = Post def get_queryset(self): # 역순으로 보여주기 위해 -로 붙인다. return Post.objects.order_by(&#x27;-created&#x27;)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - MTV 구조 맛보기 model, views, templates 사용하기","slug":"django/mysite/django-04","date":"2022-05-08T02:47:30.000Z","updated":"2024-02-18T16:47:07.430Z","comments":true,"path":"2022/05/08/django/mysite/django-04/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-04/","excerpt":"mysite&#x2F;urls.py from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;blog/&#x27;, include(&#x27;blog.urls&#x27;)),] blog&#x2F;url.py 추가 from django.urls import path, includefrom .import viewsurlpatterns = [ path(&#x27;&#x27;, views.index),] blog&#x2F;views.py from django.shortcuts import render# Create your views here.def index(request): return render( request, # 템블릿이 되는 html 코드를 작성할 필요가 있다. &#x27;blog/index.html&#x27; ) blog&#x2F;templates&#x2F;blog&#x2F;index.html &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; blog&#x2F;views.py","text":"mysite&#x2F;urls.py from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;blog/&#x27;, include(&#x27;blog.urls&#x27;)),] blog&#x2F;url.py 추가 from django.urls import path, includefrom .import viewsurlpatterns = [ path(&#x27;&#x27;, views.index),] blog&#x2F;views.py from django.shortcuts import render# Create your views here.def index(request): return render( request, # 템블릿이 되는 html 코드를 작성할 필요가 있다. &#x27;blog/index.html&#x27; ) blog&#x2F;templates&#x2F;blog&#x2F;index.html &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; blog&#x2F;views.py from django.shortcuts import renderfrom .models import Post# Create your views here.def index(request): # Post의 내용들을 전부 다 가져온다. posts = Post.objects.all() return render( request, # 템블릿이 되는 html 코드를 작성할 필요가 있다. &#x27;blog/index.html&#x27;, &#123; &#x27;posts&#x27;: posts, &#125; ) blog&#x2F;templates&#x2F;blog &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Blog&lt;/h1&gt; &lt;!-- 포스트의 모든 게시물들을 하나씩 가져온다. --&gt; &#123;% for p in posts %&#125; &lt;!-- 제목 --&gt; &lt;h3&gt;&#123;&#123;p.title&#125;&#125;&lt;/h3&gt; &lt;!-- 작성일과 작성자 --&gt; &lt;h4&gt;&#123;&#123;p.created&#125;&#125; by &#123;&#123;p.author&#125;&#125;&lt;/h4&gt; &lt;!-- 내용 --&gt; &lt;p&gt;&#123;&#123;p.content&#125;&#125;&lt;/p&gt; &#123;%endfor%&#125; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 지역(시간) 세팅 수정하기, Post 개선하기 str","slug":"django/mysite/django-03","date":"2022-05-08T01:47:30.000Z","updated":"2024-02-18T16:47:07.429Z","comments":true,"path":"2022/05/08/django/mysite/django-03/","link":"","permalink":"https://ckck803.github.io/2022/05/08/django/mysite/django-03/","excerpt":"django 지역(시간) 세팅 수정하기, Post 개선하기 str시간 세팅 수정하기 mysite&#x2F;setting.py TIME_ZONE = &#x27;UTC&#x27; TIME_ZONE = &#x27;Asia/Seoul&#x27; str 추가하기 blog&#x2F;model.py from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 content = models.TextField() # 작성 일자 create = models.DateTimeField() # 저자 author = models.ForeignKey(User, on_delete=models.CASCADE) # 해당 객체를 문자열로 바꿧을 때 어떤 식으로 보여줄 것인지를 결정한다. def __str__(self): # 작성된 페이지의 제목과 저자를 보여준다. return &#x27;&#123;&#125; :: &#123;&#125;&#x27;.format(self.title, self.author)","text":"django 지역(시간) 세팅 수정하기, Post 개선하기 str시간 세팅 수정하기 mysite&#x2F;setting.py TIME_ZONE = &#x27;UTC&#x27; TIME_ZONE = &#x27;Asia/Seoul&#x27; str 추가하기 blog&#x2F;model.py from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 content = models.TextField() # 작성 일자 create = models.DateTimeField() # 저자 author = models.ForeignKey(User, on_delete=models.CASCADE) # 해당 객체를 문자열로 바꿧을 때 어떤 식으로 보여줄 것인지를 결정한다. def __str__(self): # 작성된 페이지의 제목과 저자를 보여준다. return &#x27;&#123;&#125; :: &#123;&#125;&#x27;.format(self.title, self.author)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - admin 추가하기","slug":"django/mysite/django-admin","date":"2022-05-07T12:47:30.000Z","updated":"2024-02-18T16:47:07.441Z","comments":true,"path":"2022/05/07/django/mysite/django-admin/","link":"","permalink":"https://ckck803.github.io/2022/05/07/django/mysite/django-admin/","excerpt":"admin 계정 만들기python manage.py createsuperuser admin 페이지에 blog의 Post를 반영하기 blog&#x2F;admin.py from django.contrib import adminfrom .models import Post# Register your models here.admin.site.register(Post)","text":"admin 계정 만들기python manage.py createsuperuser admin 페이지에 blog의 Post를 반영하기 blog&#x2F;admin.py from django.contrib import adminfrom .models import Post# Register your models here.admin.site.register(Post)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - blog 앱 만들기 & Post 모델 만들기","slug":"django/mysite/django-startapp","date":"2022-05-07T12:47:30.000Z","updated":"2024-02-18T16:47:07.441Z","comments":true,"path":"2022/05/07/django/mysite/django-startapp/","link":"","permalink":"https://ckck803.github.io/2022/05/07/django/mysite/django-startapp/","excerpt":"blog 앱 만들기 &amp; Post 모델 만들기 &amp; admin에 추가하기블로그 앱 만들기프로젝트 밑에 startapp 명령어를 통해 blog 앱을 만들어 줍니다. python manage.py startapp blog Post 모델 만들기 blog&#x2F;model.py from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 content = models.TextField() # 작성 일자 create = models.DateTimeField() # 저자 author = models.ForeignKey(User) blog 앱 추가하기 mysite&#x2F;setting.py","text":"blog 앱 만들기 &amp; Post 모델 만들기 &amp; admin에 추가하기블로그 앱 만들기프로젝트 밑에 startapp 명령어를 통해 blog 앱을 만들어 줍니다. python manage.py startapp blog Post 모델 만들기 blog&#x2F;model.py from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 content = models.TextField() # 작성 일자 create = models.DateTimeField() # 저자 author = models.ForeignKey(User) blog 앱 추가하기 mysite&#x2F;setting.py INSTALLED_APPS = [ &#x27;blog&#x27;, &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;,] 마이그레이션 하기python manage.py makemigrations 오류가 뜸…TypeError: __init__() missing 1 required positional argument: &#x27;on_delete&#x27; CASCADE 옵션을 주기from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.class Post(models.Model): # 제목 title = models.CharField(max_length=30) # 내용 content = models.TextField() # 작성 일자 create = models.DateTimeField() # 저자 author = models.ForeignKey(User, on_delete=models.CASCADE) ForeignKey에 대한 on_delete 옵션 옵션 설명 models.CASCADE ForeignKeyField가 바라보는 값이 삭제될 때 관련된 모든 row를 삭제한다. models.PROTECT ForeignKeyField가 바라보는 값이 삭제될 때 삭제가 되지 않도록 ProtectedError를 발생시킨다. models.SET_NULL ForeignKeyField가 바라보는 값이 삭제될 때 ForeignKeyField값을 NULL로 한다. models.SET_DEFAULT ForeignKeyField가 바라보는 값이 삭제될 때 ForeignKeyField를 default로 바꾼다. models.set() ForeignKeyField가 바라보는 값이 삭제될 때 ForeignKeyField값을 SET에 의해 설정된 값으로 설정한다. models.DO_NOTHING ForeignKeyField가 바라보는 값이 삭제될 때 아무런 행동을 취하지 않는다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"Django - 장고 시작하기","slug":"django/mysite/django-01","date":"2022-05-07T11:47:30.000Z","updated":"2024-02-18T16:47:07.428Z","comments":true,"path":"2022/05/07/django/mysite/django-01/","link":"","permalink":"https://ckck803.github.io/2022/05/07/django/mysite/django-01/","excerpt":"목차 Django - 블로그 post list와 post detail 페이지에 카테고리 추가하기 Django - Comment (댓글) 작성창 구현하기 Django - Comment (댓글) view 구현하기 Django - Comment (댓글) 모델 구현하기 Django - 로그인 사용자만 접속 가능하게 하기 Django - Post 작성 화면 &#x2F; 기능 구현하기 Django - Post 수정 화면 &#x2F; 기능 구현하기 Django - 마크다운적용하기, tag field에 공란 허용하기 Django - Post Detail 개선사항 도출하고 Test 코드 만들기 Django - Category 페이지 만들기 (slugField) Django - 사소한 문제들 해결(불필요한 내용 삭제하기; category 복수형 수정하기 (categorys -&gt; categories)) Django - 블로그 post에 카테고리 추가하기 Django - 블로그 post에 카테고리 추가하기 Django - 블로그 post에 카테고리 추가하기 Django - read more 버튼 동작하게 하기, post_detail 페이지 개선하기 Django - HTML 분리해서 관리하기 Django - Post Detail 페이지 테스트 코드 작성하기 Django - Post List 페이지 테스트 코드 작성하기 part A Django - Post Detail 페이지 만들기 Django - template(html)에서 if문 사용하기 Django - 사진 업로드를 위한 ImageField와 업로드된 파일 관리 방법 Django - Bootstrap Grid Django - navigation bar 만들기 Django - static File 관리하기 bootstrap 적용을 위해 Django - FBV -&gt; MBV 블로그 포스트 리스트 Django - MTV 구조 맛보기 model, views, templates 사용하기 Django - 지역(시간) 세팅 수정하기, Post 개선하기 str Django - blog 앱 만들기 &amp; Post 모델 만들기 Django - 장고 시작하기 장고 설치하기pip install django 장고 프로젝트 시작하기django 를 설치하면 django-admin 명령어를 사용할 수 있습니다. 설치된 django-admin 에 startproject 명령어를 사용하면 새롭게 장고 프로젝트를 시작할 수 있습니다. django-admin startproject mysite 새로운 장고 프로젝트에 들어가면 manage.py 파일이 있습니다. runserver 명령어를 사용하면 장고 서버를 실행할 수 있습니다. python manage.py runserver","text":"목차 Django - 블로그 post list와 post detail 페이지에 카테고리 추가하기 Django - Comment (댓글) 작성창 구현하기 Django - Comment (댓글) view 구현하기 Django - Comment (댓글) 모델 구현하기 Django - 로그인 사용자만 접속 가능하게 하기 Django - Post 작성 화면 &#x2F; 기능 구현하기 Django - Post 수정 화면 &#x2F; 기능 구현하기 Django - 마크다운적용하기, tag field에 공란 허용하기 Django - Post Detail 개선사항 도출하고 Test 코드 만들기 Django - Category 페이지 만들기 (slugField) Django - 사소한 문제들 해결(불필요한 내용 삭제하기; category 복수형 수정하기 (categorys -&gt; categories)) Django - 블로그 post에 카테고리 추가하기 Django - 블로그 post에 카테고리 추가하기 Django - 블로그 post에 카테고리 추가하기 Django - read more 버튼 동작하게 하기, post_detail 페이지 개선하기 Django - HTML 분리해서 관리하기 Django - Post Detail 페이지 테스트 코드 작성하기 Django - Post List 페이지 테스트 코드 작성하기 part A Django - Post Detail 페이지 만들기 Django - template(html)에서 if문 사용하기 Django - 사진 업로드를 위한 ImageField와 업로드된 파일 관리 방법 Django - Bootstrap Grid Django - navigation bar 만들기 Django - static File 관리하기 bootstrap 적용을 위해 Django - FBV -&gt; MBV 블로그 포스트 리스트 Django - MTV 구조 맛보기 model, views, templates 사용하기 Django - 지역(시간) 세팅 수정하기, Post 개선하기 str Django - blog 앱 만들기 &amp; Post 모델 만들기 Django - 장고 시작하기 장고 설치하기pip install django 장고 프로젝트 시작하기django 를 설치하면 django-admin 명령어를 사용할 수 있습니다. 설치된 django-admin 에 startproject 명령어를 사용하면 새롭게 장고 프로젝트를 시작할 수 있습니다. django-admin startproject mysite 새로운 장고 프로젝트에 들어가면 manage.py 파일이 있습니다. runserver 명령어를 사용하면 장고 서버를 실행할 수 있습니다. python manage.py runserver 마이그레이션 파일 생성python manage.py makemigrations 마이그레이션 적용python manage.py migrate","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"}],"tags":[]},{"title":"React - TypeScript 사용하기","slug":"react/react-typescript/react-ts-01","date":"2022-05-05T21:31:46.000Z","updated":"2024-11-23T16:48:33.834Z","comments":true,"path":"2022/05/06/react/react-typescript/react-ts-01/","link":"","permalink":"https://ckck803.github.io/2022/05/06/react/react-typescript/react-ts-01/","excerpt":"참고 https://create-react-app.dev/docs/adding-typescript/ React TypeScript 사용하기create react app 명령어에 --template typescript 파라미터만 추가해주면 초기 구성이 타입스크립트로 설정되는 것을 확인할 수 있다. # npm 사용npx create-react-app my-app --template typescript# yarn 사용yarn create react-app my-app --template typescript","text":"참고 https://create-react-app.dev/docs/adding-typescript/ React TypeScript 사용하기create react app 명령어에 --template typescript 파라미터만 추가해주면 초기 구성이 타입스크립트로 설정되는 것을 확인할 수 있다. # npm 사용npx create-react-app my-app --template typescript# yarn 사용yarn create react-app my-app --template typescript","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"React","slug":"Frontend/React","permalink":"https://ckck803.github.io/categories/Frontend/React/"},{"name":"TypeScript","slug":"Frontend/React/TypeScript","permalink":"https://ckck803.github.io/categories/Frontend/React/TypeScript/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"Spring Web Socket - STOMP (Simple Text Oriented Message Protocol)","slug":"spring/spring-websocket/stomp","date":"2022-05-05T13:25:35.000Z","updated":"2024-02-26T16:11:54.495Z","comments":true,"path":"2022/05/05/spring/spring-websocket/stomp/","link":"","permalink":"https://ckck803.github.io/2022/05/05/spring/spring-websocket/stomp/","excerpt":"목차 Spring Web Socket - Chat 프로그램 만들기 1 Spring Web Socket - STOMP (Simple Text Oriented Message Protocol) 네트워크 - Web Socket 참고 https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html https://www.baeldung.com/websockets-spring STOMP (Simple&#x2F;Stream Text Oriented Message Protocol) WebSocket 기반 프로토콜이며 Client 와 Server 가 negotiate 하기 위한 sub-protocol 이 정의 돼 있다. STOMP 은 메세징 전송을 효율적으로 하기 위해 탄생한 Text 지향 프로토콜 이며 Message Payload에는 Text or Binary 데이터를 포함 해 전송할 수 있다. 또한 sub-protocol 이 정의 돼 있어 Client 에서 서버로 전송할 메시지 유형, 형식, 내용등이 정의 돼 있다. pub&#x2F;sub 구조로 되어있어 메세지를 전송하고 메세지를 받아 처리하는 부분이 확실히 정해져 있기 때문에 개발자 입장에서 명확하게 인지하고 개발할 수 있는 이점이 있다. 또한 STOMP를 이용하면 메세지의 헤더에 값을 줄 수 있어 헤더 값을 기반으로 통신 시 인증 처리(ChannelInterceptor) 를 구현하는 것도 가능하며 STOMP 스펙에 정의한 규칙만 잘 지키면 여러 언어 및 플랫폼 간 메세지를 상호 운영할 수 있다. 만약 Spring에서 지원하는 STOMP를 사용하면 Spring WebSocket 어플리케이션은 STOMP Broker로 동작하게 된다. STOMP (Simple Text Oriented Message Protocol) 구성 SimpAnnotationMethod Client 로 부터 전달 받은 Message 를 처리한다. clientInboundChannel WebSocket client 로부터 전달 받은 메시지를 전송해준다. clientOutboundChannel Server 메시지를 WebSocket Client 에 전송해준다. brokerChannel Server 내부에서 사용하는 Channel, Message Broker 에 메시지를 전송해준다.","text":"목차 Spring Web Socket - Chat 프로그램 만들기 1 Spring Web Socket - STOMP (Simple Text Oriented Message Protocol) 네트워크 - Web Socket 참고 https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html https://www.baeldung.com/websockets-spring STOMP (Simple&#x2F;Stream Text Oriented Message Protocol) WebSocket 기반 프로토콜이며 Client 와 Server 가 negotiate 하기 위한 sub-protocol 이 정의 돼 있다. STOMP 은 메세징 전송을 효율적으로 하기 위해 탄생한 Text 지향 프로토콜 이며 Message Payload에는 Text or Binary 데이터를 포함 해 전송할 수 있다. 또한 sub-protocol 이 정의 돼 있어 Client 에서 서버로 전송할 메시지 유형, 형식, 내용등이 정의 돼 있다. pub&#x2F;sub 구조로 되어있어 메세지를 전송하고 메세지를 받아 처리하는 부분이 확실히 정해져 있기 때문에 개발자 입장에서 명확하게 인지하고 개발할 수 있는 이점이 있다. 또한 STOMP를 이용하면 메세지의 헤더에 값을 줄 수 있어 헤더 값을 기반으로 통신 시 인증 처리(ChannelInterceptor) 를 구현하는 것도 가능하며 STOMP 스펙에 정의한 규칙만 잘 지키면 여러 언어 및 플랫폼 간 메세지를 상호 운영할 수 있다. 만약 Spring에서 지원하는 STOMP를 사용하면 Spring WebSocket 어플리케이션은 STOMP Broker로 동작하게 된다. STOMP (Simple Text Oriented Message Protocol) 구성 SimpAnnotationMethod Client 로 부터 전달 받은 Message 를 처리한다. clientInboundChannel WebSocket client 로부터 전달 받은 메시지를 전송해준다. clientOutboundChannel Server 메시지를 WebSocket Client 에 전송해준다. brokerChannel Server 내부에서 사용하는 Channel, Message Broker 에 메시지를 전송해준다. Simple Broker 를 이용한 구성 Simple Broker 는 In Memory 형태로 메시지를 저장하고 Client 로 Message 를 전달하는 Message Broker 외부 Broker 를 이용한 구성 외부 Message Broker 를 사용하는 경우 Broker Relay 를 이용해 외부 Broker 와 Client 에 메시지를 전달 한다. 의존성 설정하기implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27;implementation &#x27;org.springframework.boot:spring-boot-starter-websocket&#x27;implementation &#x27;org.springframework.boot:spring-boot-devtools&#x27; STOMP 사용을 위한 Config STOMP 를 사용하기 위해 @EnableWebSocketMessageBroker 를 선언하고 WebSocketMessageBrokerConfigurer 를 구현한다. StompEndpointRegistry WebSocket 연결을 위한 End Point 를 설정한다. 설정된 End Point 를 이용해 Web Socket 통신(Connection) 을 위한 Hand Shaking 이 이뤄진다. MessageBrokerRegistry setApplicationDestinationPrefixes 메서드를 이용해 메시지 요청 에 대한 Prefix 를 설정한다. /pub Prefix 로 시작한 요청은 @Controller 클래스 내 @MessageMapping 메서드로 라우팅 된다. enableSimpleBroker 는 Simple Message Broker 를 활성화 하고 메시지 구독 을 위한 Prefix 를 설정한다. /sub Prefix 로 시작한 메시지를 Broker 로 라우팅 한다. 외부 Broker 를 사용할 경우 enableStompBrokerRelay 메서드를 이용해 STOMP broker relay 를 활성화 시켜준다. package com.websocket.chat.config;import ... 생략@Configuration@EnableWebSocketMessageBrokerpublic class WebSockConfig implements WebSocketMessageBrokerConfigurer &#123; @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint(&quot;/ws-stomp&quot;) .setAllowedOrigins(&quot;*&quot;) .withSockJS(); &#125; @Override public void configureMessageBroker(MessageBrokerRegistry config) &#123; config.enableSimpleBroker(&quot;/sub&quot;); // config.enableStompBrokerRelay(&quot;/sub&quot;); // 외부 Broker 를 사용하는 경우 config.setApplicationDestinationPrefixes(&quot;/pub&quot;); &#125;&#125; 메시지 처리를 위한 Message Handler - MessageMapping @MessageMapping 을 이용한 메시지 처리는 기본적으로 경로 기반 메시지 라우팅 방식에서 메시지 처리를 위해 서용한다. @MessageMapping 를 이용해 Message 를 처리 한 후 값을 반환하게 되면 MessageConverter 에 의해 직렬화 되고 brokerChannel 로 전송 된 후에 Channel 을 구독하는 Client 들에게 전송(Broad Cast) 된다. 이 때, Out Bound 대상은 In Bound 로 들어온 메시지 처음 접두사만 바뀐고 나머지 경로는 동일하다. 기본적으로 Ant 스타일 의 경로 패턴을 지원한다. &#x2F;foo&#x2F;{id} 와 같이 Path Variable 을 사용하면 @DestinationVariable 를 이용해 값을 가져올 수 있다. /pub/chat/message 경로로 들어오는 요청에 대해 Message 를 발행하고 /sub/chat/message/ 경로로 구독하고 있는 subscriber 들에게 응답값을 전달한다. @SendTo, @SendToUser 를 이용해 메시지를 전달하는 경로를 직접 설정할 수 있다 @MessageMapping 메서드를 이용해 값을 반환하는 대신 SimpMessagingTemplate 를 이용해 brokerChannel 로 메시지를 보낼 수 있다. @RequiredArgsConstructor@Controllerpublic class ChatController &#123; private final SimpMessageSendingOperations messagingTemplate; @MessageMapping(&quot;/chat/message&quot;) public void message(ChatMessage message) &#123; if (ChatMessage.MessageType.ENTER.equals(message.getType())) &#123; message.setMessage(message.getSender() + &quot;님이 입장하셨습니다.&quot;); &#125; messagingTemplate.convertAndSend(&quot;/sub/chat/room/&quot; + message.getRoomId(), message); &#125;&#125; CORS 문제When allowCredentials is true, allowedOrigins cannot contain the special value &quot;*&quot; since that cannot be set on the &quot;Access-Control-Allow-Origin&quot; response header. To allow credentials to a set of origins, list them explicitly or consider using &quot;allowedOriginPatterns&quot; instead. 해결 : https://kim6394.tistory.com/273 setAllowedOrigins 를 setAllowedOriginPatterns 로 변경 @Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123; @Override public void configureMessageBroker(MessageBrokerRegistry config) &#123; config.enableSimpleBroker(&quot;/sub&quot;); config.setApplicationDestinationPrefixes(&quot;/pub&quot;); &#125; @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint(&quot;/ws-stomp&quot;) .setAllowedOriginPatterns(&quot;*&quot;) .withSockJS(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring WebSocket","slug":"Spring/Spring-WebSocket","permalink":"https://ckck803.github.io/categories/Spring/Spring-WebSocket/"}],"tags":[]},{"title":"Spring boot - StreamingResponseBody","slug":"spring/spring-resource/springboot-StreamingResponseBody","date":"2022-05-04T20:31:46.000Z","updated":"2024-02-26T15:40:03.468Z","comments":true,"path":"2022/05/05/spring/spring-resource/springboot-StreamingResponseBody/","link":"","permalink":"https://ckck803.github.io/2022/05/05/spring/spring-resource/springboot-StreamingResponseBody/","excerpt":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 참고 https://www.baeldung.com/spring-mvc-sse-streams StreamingResponseBody Spring 에서 제공하는 비동기 요청 처리를 위한 객체, 응답값을 Byte 로 변환해 Streaming 형태로 줄 때 사용하는 객체 @GetMapping(&quot;/video3&quot;)public ResponseEntity&lt;StreamingResponseBody&gt; handleRbe() throws FileNotFoundException &#123; File file = new File(&quot;/Users/dongwoo-yang/spring-file/mysong.mp4&quot;); InputStream inputStream = new FileInputStream(file); StreamingResponseBody stream = out -&gt; &#123; byte[] data = new byte[1024]; int length = 0; while((length = inputStream.read(data)) &gt;= 0)&#123; out.write(data, 0, length); &#125; inputStream.close(); out.flush(); &#125;; HttpHeaders headers = new HttpHeaders(); headers.add(&quot;Content-Type&quot;, &quot;video/mp4&quot;); headers.add(&quot;Content-Length&quot;, Long.toString(file.length())); return ResponseEntity.ok().headers(headers).body(stream);&#125;","text":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 참고 https://www.baeldung.com/spring-mvc-sse-streams StreamingResponseBody Spring 에서 제공하는 비동기 요청 처리를 위한 객체, 응답값을 Byte 로 변환해 Streaming 형태로 줄 때 사용하는 객체 @GetMapping(&quot;/video3&quot;)public ResponseEntity&lt;StreamingResponseBody&gt; handleRbe() throws FileNotFoundException &#123; File file = new File(&quot;/Users/dongwoo-yang/spring-file/mysong.mp4&quot;); InputStream inputStream = new FileInputStream(file); StreamingResponseBody stream = out -&gt; &#123; byte[] data = new byte[1024]; int length = 0; while((length = inputStream.read(data)) &gt;= 0)&#123; out.write(data, 0, length); &#125; inputStream.close(); out.flush(); &#125;; HttpHeaders headers = new HttpHeaders(); headers.add(&quot;Content-Type&quot;, &quot;video/mp4&quot;); headers.add(&quot;Content-Length&quot;, Long.toString(file.length())); return ResponseEntity.ok().headers(headers).body(stream);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"}],"tags":[]},{"title":"Spring boot - Actuator + Prometheus + Grafana","slug":"spring/spring-framework/springboot-actuator","date":"2022-05-04T19:31:46.000Z","updated":"2024-02-26T16:07:27.474Z","comments":true,"path":"2022/05/05/spring/spring-framework/springboot-actuator/","link":"","permalink":"https://ckck803.github.io/2022/05/05/spring/spring-framework/springboot-actuator/","excerpt":"목차 Spring boot - Actuator + Prometheus + Grafana Spring boot - 메시지 국제화 MessageSource Spring Boot - WebMvcConfigurer Spring Boot - 자동 설정 이해 참고 https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator https://www.baeldung.com/spring-boot-actuators https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/production-ready.html https://covenant.tistory.com/244 https://devbksheen.tistory.com/182 Spring boot - Actuator Actuator 는 별도의 구현 없이 Metric 정보, 트래픽 정보, 데이터 베이스 등 운영환경에서 Application 상태 정보에 접근 할 수 있는 기능을 제공하고, HTTP 와 JMX 를 이용해 접근할 수 있다. https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator.endpoints 공식 문서에서 Actuator 가 지원하는 End Point 를 확인할 수 있다. Actuator 의존성 추가implementation &#x27;org.springframework.boot:spring-boot-starter-actuator&#x27; 의존성을 추가한 뒤 Spring Application 을 실행 시킨 후 http://localhost:8080/actuator 로 접속하면 현재 Application 에서 End Point 들을 확인할 수 있다.","text":"목차 Spring boot - Actuator + Prometheus + Grafana Spring boot - 메시지 국제화 MessageSource Spring Boot - WebMvcConfigurer Spring Boot - 자동 설정 이해 참고 https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator https://www.baeldung.com/spring-boot-actuators https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/production-ready.html https://covenant.tistory.com/244 https://devbksheen.tistory.com/182 Spring boot - Actuator Actuator 는 별도의 구현 없이 Metric 정보, 트래픽 정보, 데이터 베이스 등 운영환경에서 Application 상태 정보에 접근 할 수 있는 기능을 제공하고, HTTP 와 JMX 를 이용해 접근할 수 있다. https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator.endpoints 공식 문서에서 Actuator 가 지원하는 End Point 를 확인할 수 있다. Actuator 의존성 추가implementation &#x27;org.springframework.boot:spring-boot-starter-actuator&#x27; 의존성을 추가한 뒤 Spring Application 을 실행 시킨 후 http://localhost:8080/actuator 로 접속하면 현재 Application 에서 End Point 들을 확인할 수 있다. Prometheusimplementation &#x27;io.micrometer:micrometer-core&#x27;implementation &#x27;io.micrometer:micrometer-registry-prometheus&#x27; Spring boot 설정Prometheus 가 Spring Application 에 접근해 정보를 읽어갈 수 있도록 설정을 추가해 줘야 한다. management: endpoint: metrics: enabled: true prometheus: enabled: true endpoints: web: exposure: include: health, info, metrics, prometheus Prometheus 와 Metric 정보를 위한 End Point 들이 개방된 것을 확인할 수 있다. Prometheus 설정Prometheus 에서 Spring Applciation 이 제공하는 정보를 읽어가기 위해서 prometheus.yml 파일을 생성 및 필요한 정보를 기입한다. global.scrape_interval Metric 정보를 수집하는 간격 global.evaluation_interval 규칙을 평가하는 간격 scrape_configs.metrics_path Metrc 정보를 수집할 Path 설정 scrape_configs.static_configs.targets Target 정보 global: scrape_interval: 10s evaluation_interval: 1m external_labels: # 외부 시스템에 표시할 이 서버의 레이블 monitor: &quot;devbeekei-monitor&quot;rule_files: # 규칙을 로딩하고 evaluation_interval 설정에 따라 정기적으로 평가한다.# - &quot;first.rules&quot;# - &quot;second.rules&quot;scrape_configs: - job_name: &quot;monitoring-app&quot; metrics_path: &quot;/actuator/prometheus&quot; static_configs: - targets: [&quot;host.docker.internal:8080&quot;] docker 를 이용해 Prometheus 이미지 를 띄어주도록 한다. 이미지를 실행 시킬 때 Local 에 설정한 prometheus.yml 파일과 이미지 내부 파일을 연결해 docker 내부에서 설정을 사용할 수 있도록 한다. docker run -d -p 9090:9090 -v &#123;prometheus.yml 파일 경로&#125;:/etc/prometheus/prometheus.yml --name prometheus prom/prometheus http://localhost:9090/ 에 접속 하면 Target 에 Spring Application 이 잡혀있는 것을 확인할 수 있다. GrafanaGrafana 도 docker 이미지를 사용해 Prometheus 가 읽어온 데이터를 시각화 하도록 설정한다. docker run --name grafana -d -p 3000:3000 grafana/grafana http://localhost:3000/ 에 접속하면 현재 실행중인 Grafana 에 접속 할 수 있다. 초기 ID&#x2F;PW 는 admin&#x2F;admin 이다. 데이터 소스 추가를 위해 Grafana 시작 화면에서 DATA SOURCE 를 클릭해 Prometheus 를 로부터 데이터를 읽어오도록 설정한다. URL 에는 현재 실행중인 Prometheus URL 정보를 기입해준다. Grafana 에서는 연결된 정보를 보여주기 위해 Dash board 를 생성하거나 유명한 Dash board 를 가져올 수 있다. Import 를 클랙해 JVM dashboard 를 가져오도록 한다.(https://grafana.com/grafana/dashboards/4701) Prometheus 로 부터 Metric 정보를 읽어와 그래프 형태로 데이터를 보여주는 것을 확인할 수 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring/Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/Spring-Framework/"}],"tags":[]},{"title":"Spring boot - ResourceRegion","slug":"spring/spring-resource/springboot-range-request","date":"2022-05-04T19:31:46.000Z","updated":"2024-02-26T15:39:57.515Z","comments":true,"path":"2022/05/05/spring/spring-resource/springboot-range-request/","link":"","permalink":"https://ckck803.github.io/2022/05/05/spring/spring-resource/springboot-range-request/","excerpt":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 Http Range Request 서버에서 클라이언트로 HTTP 메시지 중 일부만 전송할 수 있도록 허용하는 기술 대용량의 미디어 파일, 파일 전송 중 일시 정지 및 다시 시작이 가능하다 Client 가 Range Header 를 통해 특정 리소스의 일부를 요청하면 서버가 그 부분만 전송하는 방식으로 동작한다. Server 가 Range Request 를 지원하면 Response Http Header 에 Content-Range 가 존재한다. HTTP Range 요청에 대한 정상 응답 코드로는 PARTIAL_CONTENT(206) 을 반환한다. Range 요청에 대한 응답 값이 Body 에 담겨져 있다. Spring boot - ResourceRegion HttpRange 는 Range Header 정보를 담든 객체다. Request Header 로부터 정보를 얻어올 수 있다. ResourceRegion 는 전달 받은 Resource 객체 로부터 Range 범위 만큼 나눠 가져오는 객체다. @RestController@Slf4jpublic class VideoController &#123; @GetMapping(value = &quot;/video&quot;) public ResponseEntity&lt;ResourceRegion&gt; streamVideo(@RequestHeader HttpHeaders headers) throws IOException &#123; UrlResource video = new UrlResource(&quot;file:/Users/dongwoo-yang/spring-file/mysong.mp4&quot;); ResourceRegion resourceRegion; final long size = 1000000L; long contentLength = video.contentLength(); Optional&lt;HttpRange&gt; optional = headers.getRange().stream().findFirst(); HttpRange httpRange; if (optional.isPresent()) &#123; httpRange = optional.get(); long start = httpRange.getRangeStart(contentLength); long end = httpRange.getRangeEnd(contentLength); long rangeLength = Long.min(size, end - start + 1); resourceRegion = new ResourceRegion(video, start, rangeLength); &#125; else &#123; long rangeLength = Long.min(size, contentLength); resourceRegion = new ResourceRegion(video, 0, rangeLength); &#125; return ResponseEntity.status(HttpStatus.PARTIAL_CONTENT) .contentType(MediaTypeFactory.getMediaType(video).orElse(MediaType.APPLICATION_OCTET_STREAM)) .body(resourceRegion); &#125;&#125; 서버에서 전송해주는 Resource Size 가 1 MB(1000000) 로 잡혀 있어 1 MB 씩 부분적으로 응답받는 것을 확인할 수 있다.","text":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 Http Range Request 서버에서 클라이언트로 HTTP 메시지 중 일부만 전송할 수 있도록 허용하는 기술 대용량의 미디어 파일, 파일 전송 중 일시 정지 및 다시 시작이 가능하다 Client 가 Range Header 를 통해 특정 리소스의 일부를 요청하면 서버가 그 부분만 전송하는 방식으로 동작한다. Server 가 Range Request 를 지원하면 Response Http Header 에 Content-Range 가 존재한다. HTTP Range 요청에 대한 정상 응답 코드로는 PARTIAL_CONTENT(206) 을 반환한다. Range 요청에 대한 응답 값이 Body 에 담겨져 있다. Spring boot - ResourceRegion HttpRange 는 Range Header 정보를 담든 객체다. Request Header 로부터 정보를 얻어올 수 있다. ResourceRegion 는 전달 받은 Resource 객체 로부터 Range 범위 만큼 나눠 가져오는 객체다. @RestController@Slf4jpublic class VideoController &#123; @GetMapping(value = &quot;/video&quot;) public ResponseEntity&lt;ResourceRegion&gt; streamVideo(@RequestHeader HttpHeaders headers) throws IOException &#123; UrlResource video = new UrlResource(&quot;file:/Users/dongwoo-yang/spring-file/mysong.mp4&quot;); ResourceRegion resourceRegion; final long size = 1000000L; long contentLength = video.contentLength(); Optional&lt;HttpRange&gt; optional = headers.getRange().stream().findFirst(); HttpRange httpRange; if (optional.isPresent()) &#123; httpRange = optional.get(); long start = httpRange.getRangeStart(contentLength); long end = httpRange.getRangeEnd(contentLength); long rangeLength = Long.min(size, end - start + 1); resourceRegion = new ResourceRegion(video, start, rangeLength); &#125; else &#123; long rangeLength = Long.min(size, contentLength); resourceRegion = new ResourceRegion(video, 0, rangeLength); &#125; return ResponseEntity.status(HttpStatus.PARTIAL_CONTENT) .contentType(MediaTypeFactory.getMediaType(video).orElse(MediaType.APPLICATION_OCTET_STREAM)) .body(resourceRegion); &#125;&#125; 서버에서 전송해주는 Resource Size 가 1 MB(1000000) 로 잡혀 있어 1 MB 씩 부분적으로 응답받는 것을 확인할 수 있다. Range Request Header Request Header 를 살펴보면 Range Header 가 존재하는 것을 확인할 수 있고 Range Header 값에는 Range 의 시작 값을 Server 로 보낸다. Range Response Header Response Header 를 살펴 보면 Content-Range Header 가 존재하는 것을 확인할 수 있다. Content-Range Header 에는 전체 Resource 크기에서 응답한 Range 정보가 담겨 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"}],"tags":[]},{"title":"Redis","slug":"database/join","date":"2022-05-04T16:21:23.000Z","updated":"2024-02-18T16:19:54.522Z","comments":true,"path":"2022/05/05/database/join/","link":"","permalink":"https://ckck803.github.io/2022/05/05/database/join/","excerpt":"RedisRedis 특징 Key-Value Store Collection 지원 Pub&#x2F;Sub 지원 디스크 저장 Replication (복제) Redis 는 싱글 스레드다.","text":"RedisRedis 특징 Key-Value Store Collection 지원 Pub&#x2F;Sub 지원 디스크 저장 Replication (복제) Redis 는 싱글 스레드다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Redis","slug":"Programming/Redis","permalink":"https://ckck803.github.io/categories/Programming/Redis/"}],"tags":[]},{"title":"데이터 베이스 - Index","slug":"database/index","date":"2022-05-04T16:21:23.000Z","updated":"2024-02-18T16:19:54.522Z","comments":true,"path":"2022/05/05/database/index/","link":"","permalink":"https://ckck803.github.io/2022/05/05/database/index/","excerpt":"Index 란?인덱스는 데이터베이스에서 테이블의 검색 속도를 높이기 위한 자료 구조 입니다. 인덱스는 테이블의 컬럼을 기반으로 만들어지며, 이를 사용하여 특정 데이터를 빠르게 찾을 수 있습니다. 일반적으로 인덱스는 B-트리나 해시 테이블과 같은 자료 구조를 사용하여 구현됩니다. B-트리 인덱스는 매우 일반적인 인덱스 유형으로, 테이블의 키 값이 정렬된 트리 구조를 사용하여 저장됩니다. 이 구조는 검색, 삽입 및 삭제 작업에 대해 매우 효율적입니다. 해시 인덱스는 테이블의 키 값을 해시 함수를 사용하여 저장하며, 빠른 검색 속도를 제공하지만 범위 검색이나 정렬 기능이 없습니다. 인덱스를 사용하면 특정 행을 검색하는 데 걸리는 시간이 줄어듭니다. 특히 대량의 데이터가 있는 경우 검색 성능을 향상시키는 데 매우 유용합니다. 그러나 인덱스는 테이블의 크기와 관련하여 저장 공간을 차지하므로 인덱스를 너무 많이 사용하면 데이터베이스 성능이 떨어질 수 있습니다. 또한 인덱스를 사용하면 데이터를 삽입, 수정 또는 삭제할 때 추가 작업이 필요하므로 데이터베이스 성능에 영향을 미칠 수 있습니다. 따라서 인덱스는 데이터베이스의 검색 성능을 향상시키는 데 매우 유용하지만, 사용에 주의해야 합니다. 적절한 인덱스를 사용하면 데이터베이스의 성능을 최적화할 수 있습니다. Index Scan 종류 Table Full Scan : 테이블 전체 탐색 Index Unique Scan : 인덱스 수직 탐색 Index Full Sacn : 인덱스 전체 탐색 Index Range Scan : 인덱스 범위 탐색 Index Skip Scan : 인덱스 스킵 탐색 Table Full Scan - 테이블 전체 스캔 전체 테이블의 모든 레코드를 검색하는 방식","text":"Index 란?인덱스는 데이터베이스에서 테이블의 검색 속도를 높이기 위한 자료 구조 입니다. 인덱스는 테이블의 컬럼을 기반으로 만들어지며, 이를 사용하여 특정 데이터를 빠르게 찾을 수 있습니다. 일반적으로 인덱스는 B-트리나 해시 테이블과 같은 자료 구조를 사용하여 구현됩니다. B-트리 인덱스는 매우 일반적인 인덱스 유형으로, 테이블의 키 값이 정렬된 트리 구조를 사용하여 저장됩니다. 이 구조는 검색, 삽입 및 삭제 작업에 대해 매우 효율적입니다. 해시 인덱스는 테이블의 키 값을 해시 함수를 사용하여 저장하며, 빠른 검색 속도를 제공하지만 범위 검색이나 정렬 기능이 없습니다. 인덱스를 사용하면 특정 행을 검색하는 데 걸리는 시간이 줄어듭니다. 특히 대량의 데이터가 있는 경우 검색 성능을 향상시키는 데 매우 유용합니다. 그러나 인덱스는 테이블의 크기와 관련하여 저장 공간을 차지하므로 인덱스를 너무 많이 사용하면 데이터베이스 성능이 떨어질 수 있습니다. 또한 인덱스를 사용하면 데이터를 삽입, 수정 또는 삭제할 때 추가 작업이 필요하므로 데이터베이스 성능에 영향을 미칠 수 있습니다. 따라서 인덱스는 데이터베이스의 검색 성능을 향상시키는 데 매우 유용하지만, 사용에 주의해야 합니다. 적절한 인덱스를 사용하면 데이터베이스의 성능을 최적화할 수 있습니다. Index Scan 종류 Table Full Scan : 테이블 전체 탐색 Index Unique Scan : 인덱스 수직 탐색 Index Full Sacn : 인덱스 전체 탐색 Index Range Scan : 인덱스 범위 탐색 Index Skip Scan : 인덱스 스킵 탐색 Table Full Scan - 테이블 전체 스캔 전체 테이블의 모든 레코드를 검색하는 방식 Index Unique Scan 단 한건의 데이터를 찾을 때 사용하는 Scan 방식 루트 블록에서 시작해 브랜치 블록을 거처 리프블록까지 내려가 최종 데이터가 저장된 테이블 블록을 읽어 단 한건을 찾는다. unique Index 를 통해 = 조건으로 탐색하는 경우 Index Range Scan 인덱스를 루트에서 수직 탐색하다가 리프 블록에 도달해 시작점을 찾고 필요한 범위 만큼 Scan 하는 방식 Index Full Scan 인덱스 루트에서 시작해 수평적으로 리프 블럭까지 스캔하는 방식 Index Skip Scan","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"}],"tags":[]},{"title":"Spring Data JPA - 벌크성 수정 쿼리","slug":"spring/spring-data-jpa/12-spring-data-jpa-bulk","date":"2022-04-25T10:39:59.000Z","updated":"2024-02-26T15:37:38.020Z","comments":true,"path":"2022/04/25/spring/spring-data-jpa/12-spring-data-jpa-bulk/","link":"","permalink":"https://ckck803.github.io/2022/04/25/spring/spring-data-jpa/12-spring-data-jpa-bulk/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 벌크성 수정 쿼리public int bulkAgePlus(int age) &#123; int resultCount = em.createQuery(&quot;update Member m set m.age = m.age + 1 where m.age &gt;= :age&quot;) .setParameter(&quot;age&quot;, age) .executeUpdate(); return resultCount;&#125; @Testpublic void bulkUpdate()&#123; memberJpaRepository.save(new Member(&quot;member1&quot;, 10)); memberJpaRepository.save(new Member(&quot;member2&quot;, 19)); memberJpaRepository.save(new Member(&quot;member3&quot;, 20)); memberJpaRepository.save(new Member(&quot;member4&quot;, 21)); memberJpaRepository.save(new Member(&quot;member5&quot;, 40)); int resultCount = memberJpaRepository.bulkAgePlus(20); assertThat(resultCount).isEqualTo(3);&#125; Spring JPA 사용하기@Modifying@Query(&quot;update Member m set m.age = :age+1 where m.age &gt;= :age&quot;)int bulkAgePlus(@Param(&quot;age&quot;) int age); 벌크성 쿼리는 영속성 Context를 무시하고 바로 DB에 업데이트를 진행 시키기 때문에 벌크성 쿼리를 수행한 후에는 영속성 Context를 초기화 해줄 필요가 있다. 안그러면 기존에 남아있는데이터가 꼬여서 문제가 발생할 수 있다. @Testpublic void bulkUpdate()&#123; memberRepository.save(new Member(&quot;member1&quot;, 10)); memberRepository.save(new Member(&quot;member2&quot;, 19)); memberRepository.save(new Member(&quot;member3&quot;, 20)); memberRepository.save(new Member(&quot;member4&quot;, 21)); memberRepository.save(new Member(&quot;member5&quot;, 40)); int resultCount = memberRepository.bulkAgePlus(20); // 벌크성 쿼리를 실행한 후 영속성 컨텍스트를 날려준다. entityManager.flush(); entityManager.clear(); assertThat(resultCount).isEqualTo(3);&#125;","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 벌크성 수정 쿼리public int bulkAgePlus(int age) &#123; int resultCount = em.createQuery(&quot;update Member m set m.age = m.age + 1 where m.age &gt;= :age&quot;) .setParameter(&quot;age&quot;, age) .executeUpdate(); return resultCount;&#125; @Testpublic void bulkUpdate()&#123; memberJpaRepository.save(new Member(&quot;member1&quot;, 10)); memberJpaRepository.save(new Member(&quot;member2&quot;, 19)); memberJpaRepository.save(new Member(&quot;member3&quot;, 20)); memberJpaRepository.save(new Member(&quot;member4&quot;, 21)); memberJpaRepository.save(new Member(&quot;member5&quot;, 40)); int resultCount = memberJpaRepository.bulkAgePlus(20); assertThat(resultCount).isEqualTo(3);&#125; Spring JPA 사용하기@Modifying@Query(&quot;update Member m set m.age = :age+1 where m.age &gt;= :age&quot;)int bulkAgePlus(@Param(&quot;age&quot;) int age); 벌크성 쿼리는 영속성 Context를 무시하고 바로 DB에 업데이트를 진행 시키기 때문에 벌크성 쿼리를 수행한 후에는 영속성 Context를 초기화 해줄 필요가 있다. 안그러면 기존에 남아있는데이터가 꼬여서 문제가 발생할 수 있다. @Testpublic void bulkUpdate()&#123; memberRepository.save(new Member(&quot;member1&quot;, 10)); memberRepository.save(new Member(&quot;member2&quot;, 19)); memberRepository.save(new Member(&quot;member3&quot;, 20)); memberRepository.save(new Member(&quot;member4&quot;, 21)); memberRepository.save(new Member(&quot;member5&quot;, 40)); int resultCount = memberRepository.bulkAgePlus(20); // 벌크성 쿼리를 실행한 후 영속성 컨텍스트를 날려준다. entityManager.flush(); entityManager.clear(); assertThat(resultCount).isEqualTo(3);&#125; @Modifying(clearAutomatically = true)@Query(&quot;update Member m set m.age = :age+1 where m.age &gt;= :age&quot;)int bulkAgePlus(@Param(&quot;age&quot;) int age);","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"QueryDSL - QueryDsl 페이징 사용하기","slug":"jpa/querydsl/querydsl-15-paging","date":"2022-04-25T08:31:46.000Z","updated":"2024-02-18T16:19:54.535Z","comments":true,"path":"2022/04/25/jpa/querydsl/querydsl-15-paging/","link":"","permalink":"https://ckck803.github.io/2022/04/25/jpa/querydsl/querydsl-15-paging/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 Querydsl 페이징public interface MemberRepositoryCustom &#123; List&lt;MemberTeamDto&gt; search(MemberSearchCondition condition); Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable); Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable);&#125; QueryDSL 에서 제공하는 fetchResults 를 사용하게 되면 데이터를 가져오는 쿼리 와 가져온 데이터 수를 확인하는 Count 쿼리 총 2개의 쿼리가 발생하게 된다. @Overridepublic Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable) &#123; QueryResults&lt;MemberTeamDto&gt; results = queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where( usernameEq(condition.getUsername()), teamNameEq(condition.getTeamName()), ageGoe(condition.getAgeGoe()), ageLoe(condition.getAgeLoe()) ) .offset(pageable.getOffset()) .limit(pageable.getPageSize()) .fetchResults(); // fetchResults 를 사용하게 되면 count 쿼리가 같이 나가게 된다. List&lt;MemberTeamDto&gt; content = results.getResults(); long total = results.getTotal(); return new PageImpl&lt;&gt;(content, pageable, total);&#125; Querydsl 페이징 쿼리와 Count 쿼리 분리@Overridepublic Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable) &#123; // 전체 내용을 가져오는 쿼리 List&lt;MemberTeamDto&gt; content = queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where( usernameEq(condition.getUsername()), teamNameEq(condition.getTeamName()), ageGoe(condition.getAgeGoe()), ageLoe(condition.getAgeLoe()) ) .offset(pageable.getOffset()) .limit(pageable.getPageSize()) .fetch(); // 전체 Count 를 가져오는 쿼리 long total = queryFactory .select(ExpressionUtils.count(member)) .from(member) .leftJoin(member.team, team) .where( usernameEq(condition.getUsername()), teamNameEq(condition.getTeamName()), ageGoe(condition.getAgeGoe()), ageLoe(condition.getAgeLoe()) ) .fetchCount(); return new PageImpl&lt;&gt;(content, pageable, total);&#125; 스프링 데이터 페이징 활용2 - CountQuery 최적화","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 Querydsl 페이징public interface MemberRepositoryCustom &#123; List&lt;MemberTeamDto&gt; search(MemberSearchCondition condition); Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable); Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable);&#125; QueryDSL 에서 제공하는 fetchResults 를 사용하게 되면 데이터를 가져오는 쿼리 와 가져온 데이터 수를 확인하는 Count 쿼리 총 2개의 쿼리가 발생하게 된다. @Overridepublic Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable) &#123; QueryResults&lt;MemberTeamDto&gt; results = queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where( usernameEq(condition.getUsername()), teamNameEq(condition.getTeamName()), ageGoe(condition.getAgeGoe()), ageLoe(condition.getAgeLoe()) ) .offset(pageable.getOffset()) .limit(pageable.getPageSize()) .fetchResults(); // fetchResults 를 사용하게 되면 count 쿼리가 같이 나가게 된다. List&lt;MemberTeamDto&gt; content = results.getResults(); long total = results.getTotal(); return new PageImpl&lt;&gt;(content, pageable, total);&#125; Querydsl 페이징 쿼리와 Count 쿼리 분리@Overridepublic Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable) &#123; // 전체 내용을 가져오는 쿼리 List&lt;MemberTeamDto&gt; content = queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where( usernameEq(condition.getUsername()), teamNameEq(condition.getTeamName()), ageGoe(condition.getAgeGoe()), ageLoe(condition.getAgeLoe()) ) .offset(pageable.getOffset()) .limit(pageable.getPageSize()) .fetch(); // 전체 Count 를 가져오는 쿼리 long total = queryFactory .select(ExpressionUtils.count(member)) .from(member) .leftJoin(member.team, team) .where( usernameEq(condition.getUsername()), teamNameEq(condition.getTeamName()), ageGoe(condition.getAgeGoe()), ageLoe(condition.getAgeLoe()) ) .fetchCount(); return new PageImpl&lt;&gt;(content, pageable, total);&#125; 스프링 데이터 페이징 활용2 - CountQuery 최적화 count 쿼리가 생략 가능한 경우 생략해서 처리 페이지 시작이면서 컨텐츠 사이즈가 페이지 사이즈 보다 작을때 마지막 페이지 일때(offset + 컨텐츠 사이즈를 더해서 전체 사이즈를 구함) PageableExecutionUtils 와 JPAQuery 를 이용 @Overridepublic Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable) &#123; List&lt;MemberTeamDto&gt; content = queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where( usernameEq(condition.getUsername()), teamNameEq(condition.getTeamName()), ageGoe(condition.getAgeGoe()), ageLoe(condition.getAgeLoe()) ) .offset(pageable.getOffset()) .limit(pageable.getPageSize()) .fetch(); JPAQuery&lt;Long&gt; countQuery = queryFactory .select(count(member)) .from(member) .leftJoin(member.team, team) .where( usernameEq(condition.getUsername()), teamNameEq(condition.getTeamName()), ageGoe(condition.getAgeGoe()), ageLoe(condition.getAgeLoe()) ); return PageableExecutionUtils.getPage(content, pageable, () -&gt; countQuery.fetchCount());&#125; 스프링 데이터 페이징 활용3 - 컨트롤러 개발@RestController@RequiredArgsConstructorpublic class MemberController &#123; private final MemberJpaRepository memberJpaRepository; private final MemberRepository memberRepository; @GetMapping(&quot;/v1/members&quot;) public List&lt;MemberTeamDto&gt; searchMemberV1(MemberSearchCondition condition) &#123; return memberJpaRepository.search(condition); &#125; @GetMapping(&quot;/v2/members&quot;) public Page&lt;MemberTeamDto&gt; searchMemberV2(MemberSearchCondition condition, Pageable pageable) &#123; return memberRepository.searchPageSimple(condition, pageable); &#125; @GetMapping(&quot;/v3/members&quot;) public Page&lt;MemberTeamDto&gt; searchMemberV3(MemberSearchCondition condition, Pageable pageable) &#123; return memberRepository.searchPageComplex(condition, pageable); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 사용자 정의 Repository","slug":"jpa/querydsl/querydsl-14-custom-repository","date":"2022-04-25T07:31:46.000Z","updated":"2024-02-18T16:19:54.535Z","comments":true,"path":"2022/04/25/jpa/querydsl/querydsl-14-custom-repository/","link":"","permalink":"https://ckck803.github.io/2022/04/25/jpa/querydsl/querydsl-14-custom-repository/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 참고 https://docs.spring.io/spring-data/jpa/docs/2.1.3.RELEASE/reference/html/#repositories.custom-implementations 사용자 정의 Repository 사용법 사용자 정의 인터페이스 작성 사용자 정의 인터페이스 구현 스프링 데이터 Repository 에 사용자 정의 인터페이스 상속 1. 사용자 정의 인터페이스 작성public interface MemberRepositoryCustom &#123; List&lt;MemberTeamDto&gt; search(MemberSearchCondition condition);&#125; 2. 사용자 정의 인터페이스 구현","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 참고 https://docs.spring.io/spring-data/jpa/docs/2.1.3.RELEASE/reference/html/#repositories.custom-implementations 사용자 정의 Repository 사용법 사용자 정의 인터페이스 작성 사용자 정의 인터페이스 구현 스프링 데이터 Repository 에 사용자 정의 인터페이스 상속 1. 사용자 정의 인터페이스 작성public interface MemberRepositoryCustom &#123; List&lt;MemberTeamDto&gt; search(MemberSearchCondition condition);&#125; 2. 사용자 정의 인터페이스 구현public class MemberRepositoryImpl implements MemberRepositoryCustom&#123; private final JPAQueryFactory queryFactory; public MemberRepositoryImpl(EntityManager em)&#123; this.queryFactory = new JPAQueryFactory(em); &#125; public List&lt;MemberTeamDto&gt; search(MemberSearchCondition condition) &#123; return queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where( usernameEq(condition.getUsername()), teamNameEq(condition.getTeamName()), ageGoe(condition.getAgeGoe()), ageLoe(condition.getAgeLoe()) ) .fetch(); &#125; private BooleanExpression usernameEq(String username)&#123; return StringUtils.hasText(username) ? member.username.eq(username) : null; &#125; private BooleanExpression teamNameEq(String teamName)&#123; return StringUtils.hasText(teamName) ? team.name.eq(teamName) : null; &#125; private BooleanExpression ageGoe(Integer ageGoe)&#123; return ageGoe != null ? member.age.goe(ageGoe) : null; &#125; private BooleanExpression ageLoe(Integer ageLoe)&#123; return ageLoe != null ? member.age.loe(ageLoe) : null; &#125;&#125; 3. 스프링 데이터 Repository 에 사용자 정의 인터페이스 상속MemberRepository 인터페이스는 JPA 에서 기본적으로 제공하는 JpaRepository 와 사용자가 정의한 MemberRepositoryCustom 두개의 인터페이스를 상속 받는다. @Repositorypublic interface MemberRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepositoryCustom &#123; List&lt;Member&gt; findByUsername(String username);&#125; @Testpublic void searchTest3()&#123; Team teamA = new Team(&quot;teamA&quot;); Team teamB = new Team(&quot;teamB&quot;); em.persist(teamA); em.persist(teamB); Member member1 = new Member(&quot;member1&quot;, 10, teamA); Member member2 = new Member(&quot;member2&quot;, 20, teamA); Member member3 = new Member(&quot;member3&quot;, 30, teamB); Member member4 = new Member(&quot;member4&quot;, 40, teamB); em.persist(member1); em.persist(member2); em.persist(member3); em.persist(member4); MemberSearchCondition condition = new MemberSearchCondition(); condition.setAgeGoe(35); condition.setAgeLoe(40); condition.setTeamName(&quot;teamB&quot;); List&lt;MemberTeamDto&gt; result = memberRepository.search(condition); assertThat(result).extracting(&quot;username&quot;).containsExactly(&quot;member4&quot;);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 순수 JPA 리포지토리와 Querydsl","slug":"jpa/querydsl/querydsl-12","date":"2022-04-25T03:31:46.000Z","updated":"2024-02-18T16:19:54.534Z","comments":true,"path":"2022/04/25/jpa/querydsl/querydsl-12/","link":"","permalink":"https://ckck803.github.io/2022/04/25/jpa/querydsl/querydsl-12/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 Post not found: jpa/querydsl/querydsl-10 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 순수 JPA 리포지토리와 Querydsl@Repositorypublic class MemberJpaRepository &#123; private final EntityManager em; private final JPAQueryFactory queryFactory; public MemberJpaRepository(EntityManager em)&#123; this.em = em; this.queryFactory = new JPAQueryFactory(em); &#125; public void save(Member member)&#123; em.persist(member); &#125; public Optional&lt;Member&gt; findById(Long id)&#123; Member findMember = em.find(Member.class, id); return Optional.ofNullable(findMember); &#125; public List&lt;Member&gt; findAll()&#123; return em.createQuery(&quot;select m from Member m&quot;, Member.class) .getResultList(); &#125; public List&lt;Member&gt; findByUsername(String username)&#123; return em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class) .setParameter(&quot;username&quot;, username) .getResultList(); &#125;&#125; SpringBootTest@Transactionalclass MemberJpaRepositoryTest &#123; @Autowired EntityManager em; @Autowired MemberJpaRepository memberJpaRepository; @Test public void basicTest()&#123; Member member = new Member(&quot;member1&quot;, 10); memberJpaRepository.save(member); Member findMember = memberJpaRepository.findById(member.getId()).get(); assertThat(findMember).isEqualTo(member); List&lt;Member&gt; result = memberJpaRepository.findAll(); assertThat(result).containsExactly(member); List&lt;Member&gt; result2 = memberJpaRepository.findByUsername(&quot;member1&quot;); assertThat(result2).containsExactly(member); &#125;&#125; JPQL QueryDsl 로 변경public List&lt;Member&gt; findAll()&#123; return em.createQuery(&quot;select m from Member m&quot;, Member.class) .getResultList();&#125;public List&lt;Member&gt; findAll_Querydsl()&#123; return queryFactory .selectFrom(member) .fetch();&#125;public List&lt;Member&gt; findByUsername(String username)&#123; return em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class) .setParameter(&quot;username&quot;, username) .getResultList();&#125;public List&lt;Member&gt; findByUsername_Querydsl(String username)&#123; return queryFactory .selectFrom(member) .where(member.username.eq(username)) .fetch();&#125; @Test public void basicQueryDsl()&#123; Member member = new Member(&quot;member1&quot;, 10); memberJpaRepository.save(member); Member findMember = memberJpaRepository.findById(member.getId()).get(); assertThat(findMember).isEqualTo(member); List&lt;Member&gt; result = memberJpaRepository.findAll_Querydsl(); assertThat(result).containsExactly(member); List&lt;Member&gt; result2 = memberJpaRepository.findByUsername_Querydsl(&quot;member1&quot;); assertThat(result2).containsExactly(member); &#125;","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 Post not found: jpa/querydsl/querydsl-10 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 순수 JPA 리포지토리와 Querydsl@Repositorypublic class MemberJpaRepository &#123; private final EntityManager em; private final JPAQueryFactory queryFactory; public MemberJpaRepository(EntityManager em)&#123; this.em = em; this.queryFactory = new JPAQueryFactory(em); &#125; public void save(Member member)&#123; em.persist(member); &#125; public Optional&lt;Member&gt; findById(Long id)&#123; Member findMember = em.find(Member.class, id); return Optional.ofNullable(findMember); &#125; public List&lt;Member&gt; findAll()&#123; return em.createQuery(&quot;select m from Member m&quot;, Member.class) .getResultList(); &#125; public List&lt;Member&gt; findByUsername(String username)&#123; return em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class) .setParameter(&quot;username&quot;, username) .getResultList(); &#125;&#125; SpringBootTest@Transactionalclass MemberJpaRepositoryTest &#123; @Autowired EntityManager em; @Autowired MemberJpaRepository memberJpaRepository; @Test public void basicTest()&#123; Member member = new Member(&quot;member1&quot;, 10); memberJpaRepository.save(member); Member findMember = memberJpaRepository.findById(member.getId()).get(); assertThat(findMember).isEqualTo(member); List&lt;Member&gt; result = memberJpaRepository.findAll(); assertThat(result).containsExactly(member); List&lt;Member&gt; result2 = memberJpaRepository.findByUsername(&quot;member1&quot;); assertThat(result2).containsExactly(member); &#125;&#125; JPQL QueryDsl 로 변경public List&lt;Member&gt; findAll()&#123; return em.createQuery(&quot;select m from Member m&quot;, Member.class) .getResultList();&#125;public List&lt;Member&gt; findAll_Querydsl()&#123; return queryFactory .selectFrom(member) .fetch();&#125;public List&lt;Member&gt; findByUsername(String username)&#123; return em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class) .setParameter(&quot;username&quot;, username) .getResultList();&#125;public List&lt;Member&gt; findByUsername_Querydsl(String username)&#123; return queryFactory .selectFrom(member) .where(member.username.eq(username)) .fetch();&#125; @Test public void basicQueryDsl()&#123; Member member = new Member(&quot;member1&quot;, 10); memberJpaRepository.save(member); Member findMember = memberJpaRepository.findById(member.getId()).get(); assertThat(findMember).isEqualTo(member); List&lt;Member&gt; result = memberJpaRepository.findAll_Querydsl(); assertThat(result).containsExactly(member); List&lt;Member&gt; result2 = memberJpaRepository.findByUsername_Querydsl(&quot;member1&quot;); assertThat(result2).containsExactly(member); &#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 동적 쿼리와 성능 최적화 조회","slug":"jpa/querydsl/querydsl-13","date":"2022-04-25T03:31:46.000Z","updated":"2024-02-18T16:19:54.535Z","comments":true,"path":"2022/04/25/jpa/querydsl/querydsl-13/","link":"","permalink":"https://ckck803.github.io/2022/04/25/jpa/querydsl/querydsl-13/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 동적 쿼리와 성능 최적화 조회 - Builder 사용public List&lt;MemberTeamDto&gt; searchByBuilder(MemberSearchCondition condition)&#123; BooleanBuilder builder = new BooleanBuilder(); if (StringUtils.hasText(condition.getUsername())) &#123; builder.and(member.username.eq(condition.getUsername())); &#125; if(StringUtils.hasText(condition.getTeamName()))&#123; builder.and(team.name.eq(condition.getUsername())); &#125; if(condition.getAgeGoe()!=null)&#123; builder.and(member.age.goe(condition.getAgeGoe())); &#125; if(condition.getAgeLoe()!=null)&#123; builder.and(member.age.loe(condition.getAgeLoe())); &#125; return queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where(builder) .fetch();&#125; @Testpublic void searchTest()&#123; Team teamA = new Team(&quot;teamA&quot;); Team teamB = new Team(&quot;teamB&quot;); em.persist(teamA); em.persist(teamB); Member member1 = new Member(&quot;member1&quot;, 10, teamA); Member member2 = new Member(&quot;member2&quot;, 20, teamA); Member member3 = new Member(&quot;member3&quot;, 30, teamB); Member member4 = new Member(&quot;member4&quot;, 40, teamB); em.persist(member1); em.persist(member2); em.persist(member3); em.persist(member4); MemberSearchCondition condition = new MemberSearchCondition(); condition.setAgeGoe(35); condition.setAgeLoe(40); condition.setTeamName(&quot;teamB&quot;); List&lt;MemberTeamDto&gt; result = memberJpaRepository.searchByBuilder(condition); assertThat(result).extracting(&quot;username&quot;).containsExactly(&quot;member4&quot;);&#125; /* select member1.id as memberId, member1.username, member1.age, team.id as teamId, team.name as teamName from Member member1 left join member1.team as team where team.name = ?1 and member1.age &gt;= ?2 and member1.age &lt;= ?3 */ select member0_.member_id as col_0_0_, member0_.username as col_1_0_, member0_.age as col_2_0_, team1_.team_id as col_3_0_, team1_.name as col_4_0_ from member member0_ left outer join team team1_ on member0_.team_id=team1_.team_id where team1_.name=? and member0_.age&gt;=? and member0_.age&lt;=? 동적 쿼리와 성능 최적화 조회 - where 절 파라미터 사용public List&lt;MemberTeamDto&gt; searchByBuilder(MemberSearchCondition condition)&#123; BooleanBuilder builder = new BooleanBuilder(); if (StringUtils.hasText(condition.getUsername())) &#123; builder.and(member.username.eq(condition.getUsername())); &#125; if(StringUtils.hasText(condition.getTeamName()))&#123; builder.and(team.name.eq(condition.getUsername())); &#125; if(condition.getAgeGoe()!=null)&#123; builder.and(member.age.goe(condition.getAgeGoe())); &#125; if(condition.getAgeLoe()!=null)&#123; builder.and(member.age.loe(condition.getAgeLoe())); &#125; return queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where(builder) .fetch();&#125; @Test public void searchTest()&#123; Team teamA = new Team(&quot;teamA&quot;); Team teamB = new Team(&quot;teamB&quot;); em.persist(teamA); em.persist(teamB); Member member1 = new Member(&quot;member1&quot;, 10, teamA); Member member2 = new Member(&quot;member2&quot;, 20, teamA); Member member3 = new Member(&quot;member3&quot;, 30, teamB); Member member4 = new Member(&quot;member4&quot;, 40, teamB); em.persist(member1); em.persist(member2); em.persist(member3); em.persist(member4); MemberSearchCondition condition = new MemberSearchCondition(); condition.setAgeGoe(35); condition.setAgeLoe(40); condition.setTeamName(&quot;teamB&quot;); List&lt;MemberTeamDto&gt; result = memberJpaRepository.searchByBuilder(condition); assertThat(result).extracting(&quot;username&quot;).containsExactly(&quot;member4&quot;); &#125;","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 동적 쿼리와 성능 최적화 조회 - Builder 사용public List&lt;MemberTeamDto&gt; searchByBuilder(MemberSearchCondition condition)&#123; BooleanBuilder builder = new BooleanBuilder(); if (StringUtils.hasText(condition.getUsername())) &#123; builder.and(member.username.eq(condition.getUsername())); &#125; if(StringUtils.hasText(condition.getTeamName()))&#123; builder.and(team.name.eq(condition.getUsername())); &#125; if(condition.getAgeGoe()!=null)&#123; builder.and(member.age.goe(condition.getAgeGoe())); &#125; if(condition.getAgeLoe()!=null)&#123; builder.and(member.age.loe(condition.getAgeLoe())); &#125; return queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where(builder) .fetch();&#125; @Testpublic void searchTest()&#123; Team teamA = new Team(&quot;teamA&quot;); Team teamB = new Team(&quot;teamB&quot;); em.persist(teamA); em.persist(teamB); Member member1 = new Member(&quot;member1&quot;, 10, teamA); Member member2 = new Member(&quot;member2&quot;, 20, teamA); Member member3 = new Member(&quot;member3&quot;, 30, teamB); Member member4 = new Member(&quot;member4&quot;, 40, teamB); em.persist(member1); em.persist(member2); em.persist(member3); em.persist(member4); MemberSearchCondition condition = new MemberSearchCondition(); condition.setAgeGoe(35); condition.setAgeLoe(40); condition.setTeamName(&quot;teamB&quot;); List&lt;MemberTeamDto&gt; result = memberJpaRepository.searchByBuilder(condition); assertThat(result).extracting(&quot;username&quot;).containsExactly(&quot;member4&quot;);&#125; /* select member1.id as memberId, member1.username, member1.age, team.id as teamId, team.name as teamName from Member member1 left join member1.team as team where team.name = ?1 and member1.age &gt;= ?2 and member1.age &lt;= ?3 */ select member0_.member_id as col_0_0_, member0_.username as col_1_0_, member0_.age as col_2_0_, team1_.team_id as col_3_0_, team1_.name as col_4_0_ from member member0_ left outer join team team1_ on member0_.team_id=team1_.team_id where team1_.name=? and member0_.age&gt;=? and member0_.age&lt;=? 동적 쿼리와 성능 최적화 조회 - where 절 파라미터 사용public List&lt;MemberTeamDto&gt; searchByBuilder(MemberSearchCondition condition)&#123; BooleanBuilder builder = new BooleanBuilder(); if (StringUtils.hasText(condition.getUsername())) &#123; builder.and(member.username.eq(condition.getUsername())); &#125; if(StringUtils.hasText(condition.getTeamName()))&#123; builder.and(team.name.eq(condition.getUsername())); &#125; if(condition.getAgeGoe()!=null)&#123; builder.and(member.age.goe(condition.getAgeGoe())); &#125; if(condition.getAgeLoe()!=null)&#123; builder.and(member.age.loe(condition.getAgeLoe())); &#125; return queryFactory .select(new QMemberTeamDto( member.id.as(&quot;memberId&quot;), member.username, member.age, team.id.as(&quot;teamId&quot;), team.name.as(&quot;teamName&quot;) )) .from(member) .leftJoin(member.team, team) .where(builder) .fetch();&#125; @Test public void searchTest()&#123; Team teamA = new Team(&quot;teamA&quot;); Team teamB = new Team(&quot;teamB&quot;); em.persist(teamA); em.persist(teamB); Member member1 = new Member(&quot;member1&quot;, 10, teamA); Member member2 = new Member(&quot;member2&quot;, 20, teamA); Member member3 = new Member(&quot;member3&quot;, 30, teamB); Member member4 = new Member(&quot;member4&quot;, 40, teamB); em.persist(member1); em.persist(member2); em.persist(member3); em.persist(member4); MemberSearchCondition condition = new MemberSearchCondition(); condition.setAgeGoe(35); condition.setAgeLoe(40); condition.setTeamName(&quot;teamB&quot;); List&lt;MemberTeamDto&gt; result = memberJpaRepository.searchByBuilder(condition); assertThat(result).extracting(&quot;username&quot;).containsExactly(&quot;member4&quot;); &#125; /* select member1.id as memberId, member1.username, member1.age, team.id as teamId, team.name as teamName from Member member1 left join member1.team as team where team.name = ?1 and member1.age &gt;= ?2 and member1.age &lt;= ?3 */ select member0_.member_id as col_0_0_, member0_.username as col_1_0_, member0_.age as col_2_0_, team1_.team_id as col_3_0_, team1_.name as col_4_0_ from member member0_ left outer join team team1_ on member0_.team_id=team1_.team_id where team1_.name=? and member0_.age&gt;=? and member0_.age&lt;=?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 수정, 삭제 벌크 연산","slug":"jpa/querydsl/querydsl-10-bulk","date":"2022-04-24T04:31:46.000Z","updated":"2024-02-18T16:19:54.534Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-10-bulk/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-10-bulk/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 수정, 삭제 벌크 연산 Bulk 연산은 영속성 Context 상태를 무시 하고 쿼리가 발생하기 때문에 영속성 Context 와 DB 상태가 다르게 된다. UPDATE, DELETE 와 같은 대량의 데이터를 한번에 처리하는 Bulk 연산을 진행하게 되면 JPA 가 영속성 컨텍스트에 저장된 엔티티를 우회하고 직접 데이터베이스에 접근하기 때문에, 영속성 컨텍스트에 저장된 엔티티 상태와 DB 상태가 다르게 됩니다. 따라서 Bulk 연산시에는 영속성 컨텍스트와 DB 상태간의 데이터 동기화에 주의를 해야 합니다. 수정@Testpublic void bulkUpdate()&#123; long count = queryFactory .update(member) .set(member.username, &quot;비회원&quot;) .where(member.age.lt(28)) .execute();&#125; /* update Member member1 set member1.username = ?1 where member1.age &lt; ?2 */ update member set username=? where age&lt;? @Testpublic void bulkUpdate()&#123; long count = queryFactory .update(member) .set(member.username, &quot;비회원&quot;) .where(member.age.lt(28)) .execute(); List&lt;Member&gt; result = queryFactory .selectFrom(member) .fetch(); for (Member member1 : result) &#123; System.out.println(&quot;member1 = &quot; + member1); &#125;&#125;","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 수정, 삭제 벌크 연산 Bulk 연산은 영속성 Context 상태를 무시 하고 쿼리가 발생하기 때문에 영속성 Context 와 DB 상태가 다르게 된다. UPDATE, DELETE 와 같은 대량의 데이터를 한번에 처리하는 Bulk 연산을 진행하게 되면 JPA 가 영속성 컨텍스트에 저장된 엔티티를 우회하고 직접 데이터베이스에 접근하기 때문에, 영속성 컨텍스트에 저장된 엔티티 상태와 DB 상태가 다르게 됩니다. 따라서 Bulk 연산시에는 영속성 컨텍스트와 DB 상태간의 데이터 동기화에 주의를 해야 합니다. 수정@Testpublic void bulkUpdate()&#123; long count = queryFactory .update(member) .set(member.username, &quot;비회원&quot;) .where(member.age.lt(28)) .execute();&#125; /* update Member member1 set member1.username = ?1 where member1.age &lt; ?2 */ update member set username=? where age&lt;? @Testpublic void bulkUpdate()&#123; long count = queryFactory .update(member) .set(member.username, &quot;비회원&quot;) .where(member.age.lt(28)) .execute(); List&lt;Member&gt; result = queryFactory .selectFrom(member) .fetch(); for (Member member1 : result) &#123; System.out.println(&quot;member1 = &quot; + member1); &#125;&#125; Bulk 연산은 영속성 Context 상태를 무시하고 쿼리가 발생하기 때문에 영속성 Context 와 DB 상태가 다르게 된다. member1 = Member(id=3, username=member1, age=10)member1 = Member(id=4, username=member2, age=20)member1 = Member(id=5, username=member3, age=30)member1 = Member(id=6, username=member4, age=40) 영속성 컨텍스트와 DB 동기화 진행Bulk 연산 후에는 영속성 컨텍스트와 DB 에 저장된 데이터간의 차이가 발생하기 때문에 데이터 불일치를 해결하기 위한 동기화 작업 이 필요합니다. 영속성 컨텍스트와 DB 와의 동기화를 진행하기 위해서는 일단 영속성 컨텍스트의 변경 사항을 Database 에 반영한 후 기존에 영속성 컨텍스트에 저장된 Entity 정보들을 비우고 Database 로부터 새롭게 Entity 정보를 가져오는 것으로 동기화를 진행할 수 있습니다. 우선, 영속성 컨텍스트의 변경 내용을 DB에 반영하기 위해 EntityManager 의 flush 메소드를 통해 쓰기 지연 SQL 저장소에 저장된 쿼리를 DB 로 보내 영속성 컨텍스트의 변경 내용을 DB에 반영합니다. 그 다음, 영속성 컨텍스트에서 DB 로부터 Entity 정보를 다시 가져와 저장할 수 있도록 clear 메소드를 통해 영속성 컨텍스트를 비워주도록 한다. @Testpublic void bulkUpdate()&#123; long count = queryFactory .update(member) .set(member.username, &quot;비회원&quot;) .where(member.age.lt(28)) .execute(); // 쓰기 지연 저장소에 저장된 SQL 을 DB 에 반영한다. em.flush(); // 영속성 컨텍스트를 비운다. em.clear(); List&lt;Member&gt; result = queryFactory .selectFrom(member) .fetch(); for (Member member1 : result) &#123; System.out.println(&quot;member1 = &quot; + member1); &#125;&#125; 삭제@Testpublic void bulkDelete()&#123; long count = queryFactory .delete(member) .where(member.age.gt(18)) .execute();&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - SQL Function 호출하기","slug":"jpa/querydsl/querydsl-11","date":"2022-04-24T04:31:46.000Z","updated":"2024-02-18T16:19:54.534Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-11/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-11/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 Post not found: jpa/querydsl/querydsl-10 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 SQL Function 호출하기@Testpublic void sqlFunction()&#123; List&lt;String&gt; result = queryFactory .select( Expressions.stringTemplate(&quot;function(&#x27;replace&#x27;, &#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&quot;, member.username, &quot;member&quot;, &quot;M&quot;) ).from(member) .fetch(); for (String s : result) &#123; System.out.println(&quot;s = &quot; + s); &#125;&#125; @Testpublic void sqlFunction2()&#123; queryFactory .select(member.username) .from(member) .where(member.username.eq(Expressions.stringTemplate(&quot;function(&#x27;lower&#x27;, &#123;0&#125;)&quot;, member.username)));&#125; registerColumnType( Types.BOOLEAN, &quot;boolean&quot; );registerColumnType( Types.BIGINT, &quot;bigint&quot; );registerColumnType( Types.BINARY, &quot;binary&quot; );registerColumnType( Types.BIT, &quot;boolean&quot; );registerColumnType( Types.CHAR, &quot;char($l)&quot; );registerColumnType( Types.DATE, &quot;date&quot; );registerColumnType( Types.DECIMAL, &quot;decimal($p,$s)&quot; );registerColumnType( Types.NUMERIC, buildId &gt;= 201 ? &quot;numeric($p,$s)&quot; : &quot;decimal($p,$s)&quot; );registerColumnType( Types.DOUBLE, &quot;double&quot; );registerColumnType( Types.FLOAT, &quot;float&quot; );registerColumnType( Types.INTEGER, &quot;integer&quot; );registerColumnType( Types.LONGVARBINARY, &quot;longvarbinary&quot; );// H2 does define &quot;longvarchar&quot;, but it is a simple alias to &quot;varchar&quot;registerColumnType( Types.LONGVARCHAR, String.format( &quot;varchar(%d)&quot;, Integer.MAX_VALUE ) );registerColumnType( Types.REAL, &quot;real&quot; );registerColumnType( Types.SMALLINT, &quot;smallint&quot; );registerColumnType( Types.TINYINT, &quot;tinyint&quot; );registerColumnType( Types.TIME, &quot;time&quot; );registerColumnType( Types.TIMESTAMP, &quot;timestamp&quot; );registerColumnType( Types.VARCHAR, &quot;varchar($l)&quot; );registerColumnType( Types.VARBINARY, buildId &gt;= 201 ? &quot;varbinary($l)&quot; : &quot;binary($l)&quot; );registerColumnType( Types.BLOB, &quot;blob&quot; );registerColumnType( Types.CLOB, &quot;clob&quot; );if ( isVersion2 ) &#123; registerColumnType( Types.LONGVARCHAR, &quot;character varying&quot; ); registerColumnType( Types.BINARY, &quot;binary($l)&quot; ); registerFunction( &quot;str&quot;, new SQLFunctionTemplate( StandardBasicTypes.STRING, &quot;cast(?1 as character varying)&quot;) );&#125;// Aggregations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;avg&quot;, new AvgWithArgumentCastFunction( &quot;double&quot; ) );// select topic, syntax from information_schema.help// where section like &#x27;Function%&#x27; order by section, topic//// see also -&gt; http://www.h2database.com/html/functions.html// Numeric Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;acos&quot;, new StandardSQLFunction( &quot;acos&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;asin&quot;, new StandardSQLFunction( &quot;asin&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;atan&quot;, new StandardSQLFunction( &quot;atan&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;atan2&quot;, new StandardSQLFunction( &quot;atan2&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;bitand&quot;, new StandardSQLFunction( &quot;bitand&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;bitor&quot;, new StandardSQLFunction( &quot;bitor&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;bitxor&quot;, new StandardSQLFunction( &quot;bitxor&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;ceiling&quot;, new StandardSQLFunction( &quot;ceiling&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;cos&quot;, new StandardSQLFunction( &quot;cos&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;compress&quot;, new StandardSQLFunction( &quot;compress&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;cot&quot;, new StandardSQLFunction( &quot;cot&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;decrypt&quot;, new StandardSQLFunction( &quot;decrypt&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;degrees&quot;, new StandardSQLFunction( &quot;degrees&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;encrypt&quot;, new StandardSQLFunction( &quot;encrypt&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;exp&quot;, new StandardSQLFunction( &quot;exp&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;expand&quot;, new StandardSQLFunction( &quot;compress&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;floor&quot;, new StandardSQLFunction( &quot;floor&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;hash&quot;, new StandardSQLFunction( &quot;hash&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;log&quot;, new StandardSQLFunction( &quot;log&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;log10&quot;, new StandardSQLFunction( &quot;log10&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;pi&quot;, new NoArgSQLFunction( &quot;pi&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;power&quot;, new StandardSQLFunction( &quot;power&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;radians&quot;, new StandardSQLFunction( &quot;radians&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;rand&quot;, new NoArgSQLFunction( &quot;rand&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;round&quot;, new StandardSQLFunction( &quot;round&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;roundmagic&quot;, new StandardSQLFunction( &quot;roundmagic&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;sign&quot;, new StandardSQLFunction( &quot;sign&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;sin&quot;, new StandardSQLFunction( &quot;sin&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;tan&quot;, new StandardSQLFunction( &quot;tan&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;truncate&quot;, new StandardSQLFunction( &quot;truncate&quot;, StandardBasicTypes.DOUBLE ) );// String Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;ascii&quot;, new StandardSQLFunction( &quot;ascii&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;char&quot;, new StandardSQLFunction( &quot;char&quot;, StandardBasicTypes.CHARACTER ) );registerFunction( &quot;concat&quot;, new VarArgsSQLFunction( StandardBasicTypes.STRING, &quot;(&quot;, &quot;||&quot;, &quot;)&quot; ) );registerFunction( &quot;difference&quot;, new StandardSQLFunction( &quot;difference&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;hextoraw&quot;, new StandardSQLFunction( &quot;hextoraw&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;insert&quot;, new StandardSQLFunction( &quot;lower&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;left&quot;, new StandardSQLFunction( &quot;left&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;lcase&quot;, new StandardSQLFunction( &quot;lcase&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;ltrim&quot;, new StandardSQLFunction( &quot;ltrim&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;octet_length&quot;, new StandardSQLFunction( &quot;octet_length&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;position&quot;, new StandardSQLFunction( &quot;position&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;rawtohex&quot;, new StandardSQLFunction( &quot;rawtohex&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;repeat&quot;, new StandardSQLFunction( &quot;repeat&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;replace&quot;, new StandardSQLFunction( &quot;replace&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;right&quot;, new StandardSQLFunction( &quot;right&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;rtrim&quot;, new StandardSQLFunction( &quot;rtrim&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;soundex&quot;, new StandardSQLFunction( &quot;soundex&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;space&quot;, new StandardSQLFunction( &quot;space&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;stringencode&quot;, new StandardSQLFunction( &quot;stringencode&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;stringdecode&quot;, new StandardSQLFunction( &quot;stringdecode&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;stringtoutf8&quot;, new StandardSQLFunction( &quot;stringtoutf8&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;ucase&quot;, new StandardSQLFunction( &quot;ucase&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;utf8tostring&quot;, new StandardSQLFunction( &quot;utf8tostring&quot;, StandardBasicTypes.STRING ) );// Time and Date Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;curdate&quot;, new NoArgSQLFunction( &quot;curdate&quot;, StandardBasicTypes.DATE ) );registerFunction( &quot;curtime&quot;, new NoArgSQLFunction( &quot;curtime&quot;, StandardBasicTypes.TIME ) );registerFunction( &quot;curtimestamp&quot;, new NoArgSQLFunction( &quot;curtimestamp&quot;, StandardBasicTypes.TIME ) );registerFunction( &quot;current_date&quot;, new NoArgSQLFunction( &quot;current_date&quot;, StandardBasicTypes.DATE ) );// H2 made a nasty breaking change that changed the type of// - current_timestamp to timestamp with time zone// - current_time to time with time zone// and also refuses to implicitly convert the typeregisterFunction( &quot;current_time&quot;, new NoArgSQLFunction( buildId &gt;= 200 ? &quot;localtime&quot; : &quot;current_time&quot;, StandardBasicTypes.TIME ) );registerFunction( &quot;current_timestamp&quot;, new NoArgSQLFunction( buildId &gt;= 200 ? &quot;localtimestamp&quot; : &quot;current_timestamp&quot;, StandardBasicTypes.TIMESTAMP ) );registerFunction( &quot;datediff&quot;, new StandardSQLFunction( &quot;datediff&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;dayname&quot;, new StandardSQLFunction( &quot;dayname&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;dayofmonth&quot;, new StandardSQLFunction( &quot;dayofmonth&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;dayofweek&quot;, new StandardSQLFunction( &quot;dayofweek&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;dayofyear&quot;, new StandardSQLFunction( &quot;dayofyear&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;monthname&quot;, new StandardSQLFunction( &quot;monthname&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;now&quot;, new NoArgSQLFunction( &quot;now&quot;, StandardBasicTypes.TIMESTAMP ) );registerFunction( &quot;quarter&quot;, new StandardSQLFunction( &quot;quarter&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;week&quot;, new StandardSQLFunction( &quot;week&quot;, StandardBasicTypes.INTEGER ) );// System Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;database&quot;, new NoArgSQLFunction( &quot;database&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;user&quot;, new NoArgSQLFunction( &quot;user&quot;, StandardBasicTypes.STRING ) );getDefaultProperties().setProperty( AvailableSettings.STATEMENT_BATCH_SIZE, DEFAULT_BATCH_SIZE );// http://code.google.com/p/h2database/issues/detail?id=235getDefaultProperties().setProperty( AvailableSettings.NON_CONTEXTUAL_LOB_CREATION, &quot;true&quot; );","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 Post not found: jpa/querydsl/querydsl-10 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 SQL Function 호출하기@Testpublic void sqlFunction()&#123; List&lt;String&gt; result = queryFactory .select( Expressions.stringTemplate(&quot;function(&#x27;replace&#x27;, &#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&quot;, member.username, &quot;member&quot;, &quot;M&quot;) ).from(member) .fetch(); for (String s : result) &#123; System.out.println(&quot;s = &quot; + s); &#125;&#125; @Testpublic void sqlFunction2()&#123; queryFactory .select(member.username) .from(member) .where(member.username.eq(Expressions.stringTemplate(&quot;function(&#x27;lower&#x27;, &#123;0&#125;)&quot;, member.username)));&#125; registerColumnType( Types.BOOLEAN, &quot;boolean&quot; );registerColumnType( Types.BIGINT, &quot;bigint&quot; );registerColumnType( Types.BINARY, &quot;binary&quot; );registerColumnType( Types.BIT, &quot;boolean&quot; );registerColumnType( Types.CHAR, &quot;char($l)&quot; );registerColumnType( Types.DATE, &quot;date&quot; );registerColumnType( Types.DECIMAL, &quot;decimal($p,$s)&quot; );registerColumnType( Types.NUMERIC, buildId &gt;= 201 ? &quot;numeric($p,$s)&quot; : &quot;decimal($p,$s)&quot; );registerColumnType( Types.DOUBLE, &quot;double&quot; );registerColumnType( Types.FLOAT, &quot;float&quot; );registerColumnType( Types.INTEGER, &quot;integer&quot; );registerColumnType( Types.LONGVARBINARY, &quot;longvarbinary&quot; );// H2 does define &quot;longvarchar&quot;, but it is a simple alias to &quot;varchar&quot;registerColumnType( Types.LONGVARCHAR, String.format( &quot;varchar(%d)&quot;, Integer.MAX_VALUE ) );registerColumnType( Types.REAL, &quot;real&quot; );registerColumnType( Types.SMALLINT, &quot;smallint&quot; );registerColumnType( Types.TINYINT, &quot;tinyint&quot; );registerColumnType( Types.TIME, &quot;time&quot; );registerColumnType( Types.TIMESTAMP, &quot;timestamp&quot; );registerColumnType( Types.VARCHAR, &quot;varchar($l)&quot; );registerColumnType( Types.VARBINARY, buildId &gt;= 201 ? &quot;varbinary($l)&quot; : &quot;binary($l)&quot; );registerColumnType( Types.BLOB, &quot;blob&quot; );registerColumnType( Types.CLOB, &quot;clob&quot; );if ( isVersion2 ) &#123; registerColumnType( Types.LONGVARCHAR, &quot;character varying&quot; ); registerColumnType( Types.BINARY, &quot;binary($l)&quot; ); registerFunction( &quot;str&quot;, new SQLFunctionTemplate( StandardBasicTypes.STRING, &quot;cast(?1 as character varying)&quot;) );&#125;// Aggregations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;avg&quot;, new AvgWithArgumentCastFunction( &quot;double&quot; ) );// select topic, syntax from information_schema.help// where section like &#x27;Function%&#x27; order by section, topic//// see also -&gt; http://www.h2database.com/html/functions.html// Numeric Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;acos&quot;, new StandardSQLFunction( &quot;acos&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;asin&quot;, new StandardSQLFunction( &quot;asin&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;atan&quot;, new StandardSQLFunction( &quot;atan&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;atan2&quot;, new StandardSQLFunction( &quot;atan2&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;bitand&quot;, new StandardSQLFunction( &quot;bitand&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;bitor&quot;, new StandardSQLFunction( &quot;bitor&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;bitxor&quot;, new StandardSQLFunction( &quot;bitxor&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;ceiling&quot;, new StandardSQLFunction( &quot;ceiling&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;cos&quot;, new StandardSQLFunction( &quot;cos&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;compress&quot;, new StandardSQLFunction( &quot;compress&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;cot&quot;, new StandardSQLFunction( &quot;cot&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;decrypt&quot;, new StandardSQLFunction( &quot;decrypt&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;degrees&quot;, new StandardSQLFunction( &quot;degrees&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;encrypt&quot;, new StandardSQLFunction( &quot;encrypt&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;exp&quot;, new StandardSQLFunction( &quot;exp&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;expand&quot;, new StandardSQLFunction( &quot;compress&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;floor&quot;, new StandardSQLFunction( &quot;floor&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;hash&quot;, new StandardSQLFunction( &quot;hash&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;log&quot;, new StandardSQLFunction( &quot;log&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;log10&quot;, new StandardSQLFunction( &quot;log10&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;pi&quot;, new NoArgSQLFunction( &quot;pi&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;power&quot;, new StandardSQLFunction( &quot;power&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;radians&quot;, new StandardSQLFunction( &quot;radians&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;rand&quot;, new NoArgSQLFunction( &quot;rand&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;round&quot;, new StandardSQLFunction( &quot;round&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;roundmagic&quot;, new StandardSQLFunction( &quot;roundmagic&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;sign&quot;, new StandardSQLFunction( &quot;sign&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;sin&quot;, new StandardSQLFunction( &quot;sin&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;tan&quot;, new StandardSQLFunction( &quot;tan&quot;, StandardBasicTypes.DOUBLE ) );registerFunction( &quot;truncate&quot;, new StandardSQLFunction( &quot;truncate&quot;, StandardBasicTypes.DOUBLE ) );// String Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;ascii&quot;, new StandardSQLFunction( &quot;ascii&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;char&quot;, new StandardSQLFunction( &quot;char&quot;, StandardBasicTypes.CHARACTER ) );registerFunction( &quot;concat&quot;, new VarArgsSQLFunction( StandardBasicTypes.STRING, &quot;(&quot;, &quot;||&quot;, &quot;)&quot; ) );registerFunction( &quot;difference&quot;, new StandardSQLFunction( &quot;difference&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;hextoraw&quot;, new StandardSQLFunction( &quot;hextoraw&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;insert&quot;, new StandardSQLFunction( &quot;lower&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;left&quot;, new StandardSQLFunction( &quot;left&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;lcase&quot;, new StandardSQLFunction( &quot;lcase&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;ltrim&quot;, new StandardSQLFunction( &quot;ltrim&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;octet_length&quot;, new StandardSQLFunction( &quot;octet_length&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;position&quot;, new StandardSQLFunction( &quot;position&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;rawtohex&quot;, new StandardSQLFunction( &quot;rawtohex&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;repeat&quot;, new StandardSQLFunction( &quot;repeat&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;replace&quot;, new StandardSQLFunction( &quot;replace&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;right&quot;, new StandardSQLFunction( &quot;right&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;rtrim&quot;, new StandardSQLFunction( &quot;rtrim&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;soundex&quot;, new StandardSQLFunction( &quot;soundex&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;space&quot;, new StandardSQLFunction( &quot;space&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;stringencode&quot;, new StandardSQLFunction( &quot;stringencode&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;stringdecode&quot;, new StandardSQLFunction( &quot;stringdecode&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;stringtoutf8&quot;, new StandardSQLFunction( &quot;stringtoutf8&quot;, StandardBasicTypes.BINARY ) );registerFunction( &quot;ucase&quot;, new StandardSQLFunction( &quot;ucase&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;utf8tostring&quot;, new StandardSQLFunction( &quot;utf8tostring&quot;, StandardBasicTypes.STRING ) );// Time and Date Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;curdate&quot;, new NoArgSQLFunction( &quot;curdate&quot;, StandardBasicTypes.DATE ) );registerFunction( &quot;curtime&quot;, new NoArgSQLFunction( &quot;curtime&quot;, StandardBasicTypes.TIME ) );registerFunction( &quot;curtimestamp&quot;, new NoArgSQLFunction( &quot;curtimestamp&quot;, StandardBasicTypes.TIME ) );registerFunction( &quot;current_date&quot;, new NoArgSQLFunction( &quot;current_date&quot;, StandardBasicTypes.DATE ) );// H2 made a nasty breaking change that changed the type of// - current_timestamp to timestamp with time zone// - current_time to time with time zone// and also refuses to implicitly convert the typeregisterFunction( &quot;current_time&quot;, new NoArgSQLFunction( buildId &gt;= 200 ? &quot;localtime&quot; : &quot;current_time&quot;, StandardBasicTypes.TIME ) );registerFunction( &quot;current_timestamp&quot;, new NoArgSQLFunction( buildId &gt;= 200 ? &quot;localtimestamp&quot; : &quot;current_timestamp&quot;, StandardBasicTypes.TIMESTAMP ) );registerFunction( &quot;datediff&quot;, new StandardSQLFunction( &quot;datediff&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;dayname&quot;, new StandardSQLFunction( &quot;dayname&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;dayofmonth&quot;, new StandardSQLFunction( &quot;dayofmonth&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;dayofweek&quot;, new StandardSQLFunction( &quot;dayofweek&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;dayofyear&quot;, new StandardSQLFunction( &quot;dayofyear&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;monthname&quot;, new StandardSQLFunction( &quot;monthname&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;now&quot;, new NoArgSQLFunction( &quot;now&quot;, StandardBasicTypes.TIMESTAMP ) );registerFunction( &quot;quarter&quot;, new StandardSQLFunction( &quot;quarter&quot;, StandardBasicTypes.INTEGER ) );registerFunction( &quot;week&quot;, new StandardSQLFunction( &quot;week&quot;, StandardBasicTypes.INTEGER ) );// System Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~registerFunction( &quot;database&quot;, new NoArgSQLFunction( &quot;database&quot;, StandardBasicTypes.STRING ) );registerFunction( &quot;user&quot;, new NoArgSQLFunction( &quot;user&quot;, StandardBasicTypes.STRING ) );getDefaultProperties().setProperty( AvailableSettings.STATEMENT_BATCH_SIZE, DEFAULT_BATCH_SIZE );// http://code.google.com/p/h2database/issues/detail?id=235getDefaultProperties().setProperty( AvailableSettings.NON_CONTEXTUAL_LOB_CREATION, &quot;true&quot; );","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 동적 쿼리","slug":"jpa/querydsl/querydsl-09-dynamic","date":"2022-04-24T03:31:46.000Z","updated":"2024-02-18T16:19:54.534Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-09-dynamic/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-09-dynamic/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 동적 쿼리를 해결하는 두가지 방식 BooleanBuilder Where 다중 파라미터 사용 동적 쿼리 - BooleanBuilderBooleanBuilder 를 이용해 동적 쿼리를 작성할 수 있다. @Testpublic void dynamicQuery_BooleanBuilder()&#123; String usernameParam = &quot;member1&quot;; Integer ageParam = 10; List&lt;Member&gt; result = searchMember1(usernameParam, ageParam); assertThat(result.size()).isEqualTo(1);&#125;private List&lt;Member&gt; searchMember1(String usernameCond, Integer ageCond)&#123; BooleanBuilder builder = new BooleanBuilder(); if(usernameCond != null)&#123; builder.and(member.username.eq(usernameCond)); &#125; if(ageCond != null)&#123; builder.and(member.age.eq(ageCond)); &#125; return queryFactory .selectFrom(member) .where(builder) .fetch();&#125; /* select member1 from Member member1 where member1.username = ?1 and member1.age = ?2 */ select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ where member0_.username=? and member0_.age=? 동적 쿼리 - Where 다중 파라미터 사용","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 동적 쿼리를 해결하는 두가지 방식 BooleanBuilder Where 다중 파라미터 사용 동적 쿼리 - BooleanBuilderBooleanBuilder 를 이용해 동적 쿼리를 작성할 수 있다. @Testpublic void dynamicQuery_BooleanBuilder()&#123; String usernameParam = &quot;member1&quot;; Integer ageParam = 10; List&lt;Member&gt; result = searchMember1(usernameParam, ageParam); assertThat(result.size()).isEqualTo(1);&#125;private List&lt;Member&gt; searchMember1(String usernameCond, Integer ageCond)&#123; BooleanBuilder builder = new BooleanBuilder(); if(usernameCond != null)&#123; builder.and(member.username.eq(usernameCond)); &#125; if(ageCond != null)&#123; builder.and(member.age.eq(ageCond)); &#125; return queryFactory .selectFrom(member) .where(builder) .fetch();&#125; /* select member1 from Member member1 where member1.username = ?1 and member1.age = ?2 */ select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ where member0_.username=? and member0_.age=? 동적 쿼리 - Where 다중 파라미터 사용 메서드를 다른 쿼리에서도 재사용 할 수 있다. 쿼리 자체의 가독성이 높아진다. @Testpublic void dynamicQuery_WhereParam() &#123; String usernameParam = &quot;member1&quot;; Integer ageParam = 10; List&lt;Member&gt; result = searchMember2(usernameParam, ageParam); assertThat(result.size()).isEqualTo(1);&#125;private List&lt;Member&gt; searchMember2(String usernameCond, Integer ageCond) &#123; return queryFactory .selectFrom(member) // where 에 null 값이 전달 되면 조건을 무시한다. .where(usernameEq(usernameCond), ageEq(ageCond)) .fetch();&#125;private Predicate usernameEq(String usernameCond) &#123; // 전달받은 usernameCond 파라미터가 없을 경우 null 을 반환하도록 한다. if (usernameCond == null) &#123; return null; &#125; return member.username.eq(usernameCond);&#125;private Predicate ageEq(Integer ageCond) &#123; if (ageCond == null) &#123; return null; &#125; return member.age.eq(ageCond);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 프로젝션과 결과 반환","slug":"jpa/querydsl/querydsl-08-projection","date":"2022-04-24T03:31:46.000Z","updated":"2024-02-18T16:19:54.534Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-08-projection/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-08-projection/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 프로젝션과 결과 반환 프로젝션(Projection) 은 쿼리 결과를 가져올 때 반환할 필드를 지정하는 것 프로젝션 : select 대상 지정 프로젝션 대상이 하나면 타입을 명확하게 지정할 수 있다. 프로젝션 대상이 둘 이상이면 튜플 이나 DTO 로 조회한다. List&lt;String&gt; result = queryFactory .select(member.username.concat(&quot;_&quot;).concat(member.age.stringValue())) .from(member) .where(member.username.eq(&quot;member1&quot;)) .fetch(); 튜플 조회@Testpublic void tupleProjection()&#123; List&lt;Tuple&gt; result = queryFactory .select(member.username, member.age) .from(member) .fetch(); for (Tuple tuple : result)&#123; String username = tuple.get(member.username); Integer age = tuple.get(member.age); System.out.println(&quot;username = &quot; + username); System.out.println(&quot;age = &quot; + age); &#125;&#125;","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 프로젝션과 결과 반환 프로젝션(Projection) 은 쿼리 결과를 가져올 때 반환할 필드를 지정하는 것 프로젝션 : select 대상 지정 프로젝션 대상이 하나면 타입을 명확하게 지정할 수 있다. 프로젝션 대상이 둘 이상이면 튜플 이나 DTO 로 조회한다. List&lt;String&gt; result = queryFactory .select(member.username.concat(&quot;_&quot;).concat(member.age.stringValue())) .from(member) .where(member.username.eq(&quot;member1&quot;)) .fetch(); 튜플 조회@Testpublic void tupleProjection()&#123; List&lt;Tuple&gt; result = queryFactory .select(member.username, member.age) .from(member) .fetch(); for (Tuple tuple : result)&#123; String username = tuple.get(member.username); Integer age = tuple.get(member.age); System.out.println(&quot;username = &quot; + username); System.out.println(&quot;age = &quot; + age); &#125;&#125; /* select member1.username, member1.age from Member member1 */ select member0_.username as col_0_0_, member0_.age as col_1_0_ from member member0_ DTO 를 이용한 결과 반환 Projections 를 사용하면 쿼리 결과를 DTO 로 변환할 수 있다. Projections 을 이용한 DTO 반환 방식은 3가지 방법을 지원한다. Setter 를 이용한 방식 Field 에 직접 접근하는 방식 생성자를 이용한 방식 Setter 를 활용하는 방법setter 를 이용한 방식은 Projections.bean 메소드를 이용해 쿼리 결과를 반환하도록 한다. @Testpublic void findDtoBySetter()&#123; List&lt;MemberDto&gt; result = queryFactory .select(Projections.bean(MemberDto.class, member.username, member.age)) .from(member) .fetch(); for (MemberDto memberDto : result) &#123; System.out.println(&quot;memberDto = &quot; + memberDto); &#125;&#125; 필드 직접 접근field 를 이용한 방식은 Projections.fields 메소드를 이용해 쿼리 결과를 반환하도록 한다. @Testpublic void findDtoByField()&#123; List&lt;MemberDto&gt; result = queryFactory .select(Projections.fields(MemberDto.class, member.username, member.age)) .from(member) .fetch(); for (MemberDto memberDto : result) &#123; System.out.println(&quot;memberDto = &quot; + memberDto); &#125;&#125; 생성자 사용생성자를 이용한 방식은 Projections.constructor 메소드를 이용해 쿼리 결과를 반환하도록 한다. @Testpublic void findDtoByConstructor()&#123; List&lt;MemberDto&gt; result = queryFactory .select(Projections.constructor(MemberDto.class, member.username, member.age)) .from(member) .fetch(); for (MemberDto memberDto : result) &#123; System.out.println(&quot;memberDto = &quot; + memberDto); &#125;&#125; DTO 와 Entity 의 Attribute 의 alias 가 서로 다를 경우@Testpublic void findUserDto()&#123; List&lt;UserDto&gt; result = queryFactory .select(Projections.fields(UserDto.class, member.username.as(&quot;name&quot;), member.age)) .from(member) .fetch(); for (UserDto userDto : result) &#123; System.out.println(&quot;userDto = &quot; + userDto); &#125;&#125; 서브 쿼리에 alias 사용ExpressionUtils.as @Testpublic void findUserDto()&#123; QMember memberSub = new QMember(&quot;memberSub&quot;); List&lt;UserDto&gt; result = queryFactory .select(Projections.fields(UserDto.class , member.username.as(&quot;name&quot;) , ExpressionUtils.as(JPAExpressions .select(memberSub.age.max()) .from(memberSub), &quot;age&quot;))) .from(member) .fetch(); for (UserDto userDto : result) &#123; System.out.println(&quot;userDto = &quot; + userDto); &#125;&#125; @Testpublic void findDtoByConstructor()&#123; List&lt;MemberDto&gt; result = queryFactory .select(Projections.constructor(MemberDto.class, member.username, member.age)) .from(member) .fetch(); for (MemberDto memberDto : result) &#123; System.out.println(&quot;memberDto = &quot; + memberDto); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 조인","slug":"jpa/querydsl/querydsl-07","date":"2022-04-24T01:31:46.000Z","updated":"2024-02-18T16:19:54.534Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-07/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-07/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 기본 조인첫 번째 파라미터에 조인 대상을 지정하고, 두번째 파라미터에 별칭으로 사용할 Q 타입을 지정하면 된다. @Testpublic void join()&#123; List&lt;Member&gt; result = queryFactory.selectFrom(member) .join(member.team, team) .where(team.name.eq(&quot;teamA&quot;)) .fetch(); assertThat(result) .extracting(&quot;username&quot;) .containsExactly(&quot;member1&quot;, &quot;member2&quot;);&#125; /* select member1 from Member member1 inner join member1.team as team where team.name = ?1 */ select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ inner join team team1_ on member0_.team_id=team1_.team_id where team1_.name=? Seta Join From 절에 여러 엔티티를 선택해서 세타 조인이 가능하다. 외부 조인 불가능 조인 on 을 사용하면 외부 조인 가능 @Testpublic void setaJoin()&#123; em.persist(new Member(&quot;teamA&quot;)); em.persist(new Member(&quot;teamB&quot;)); List&lt;Member&gt; result = queryFactory.select(member) .from(member, team) .where(member.username.eq(team.name)) .fetch(); assertThat(result) .extracting(&quot;username&quot;) .containsExactly(&quot;teamA&quot;, &quot;teamB&quot;);&#125;","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 기본 조인첫 번째 파라미터에 조인 대상을 지정하고, 두번째 파라미터에 별칭으로 사용할 Q 타입을 지정하면 된다. @Testpublic void join()&#123; List&lt;Member&gt; result = queryFactory.selectFrom(member) .join(member.team, team) .where(team.name.eq(&quot;teamA&quot;)) .fetch(); assertThat(result) .extracting(&quot;username&quot;) .containsExactly(&quot;member1&quot;, &quot;member2&quot;);&#125; /* select member1 from Member member1 inner join member1.team as team where team.name = ?1 */ select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ inner join team team1_ on member0_.team_id=team1_.team_id where team1_.name=? Seta Join From 절에 여러 엔티티를 선택해서 세타 조인이 가능하다. 외부 조인 불가능 조인 on 을 사용하면 외부 조인 가능 @Testpublic void setaJoin()&#123; em.persist(new Member(&quot;teamA&quot;)); em.persist(new Member(&quot;teamB&quot;)); List&lt;Member&gt; result = queryFactory.select(member) .from(member, team) .where(member.username.eq(team.name)) .fetch(); assertThat(result) .extracting(&quot;username&quot;) .containsExactly(&quot;teamA&quot;, &quot;teamB&quot;);&#125; /* select member1 from Member member1, Team team where member1.username = team.name */ select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ cross join team team1_ where member0_.username=team1_.name ON절을 이용한 JOIN on 절을 활용한 조인 조인 대상 필터링 연관관계 없는 엔티티 외부 조인 @Testpublic void join_on_filtering() &#123; List&lt;Tuple&gt; result = queryFactory .select(member, team) .from(member) .leftJoin(member.team, team).on(team.name.eq(&quot;teamA&quot;)) .fetch(); for (Tuple tuple : result) &#123; System.out.println(&quot;tuple = &quot; + tuple); &#125;&#125; /* select member1, team from Member member1 left join member1.team as team with team.name = ?1 */ select member0_.member_id as member_i1_1_0_, team1_.team_id as team_id1_2_1_, member0_.age as age2_1_0_, member0_.team_id as team_id4_1_0_, member0_.username as username3_1_0_, team1_.name as name2_2_1_ from member member0_ left outer join team team1_ on member0_.team_id=team1_.team_id and ( team1_.name=? ) 연관관계가 없는 엔티티 외부 조인@Testpublic void join_on_no_relation()&#123; em.persist(new Member(&quot;teamA&quot;)); em.persist(new Member(&quot;teamB&quot;)); em.persist(new Member(&quot;teamB&quot;)); List&lt;Tuple&gt; fetch = queryFactory .select(member, team) .from(member) .leftJoin(team).on(member.username.eq(team.name)) .fetch(); for (Tuple tuple : fetch) &#123; System.out.println(&quot;tuple = &quot; + tuple); &#125;&#125; /* select member1, team from Member member1 left join Team team with member1.username = team.name */ select member0_.member_id as member_i1_1_0_, team1_.team_id as team_id1_2_1_, member0_.age as age2_1_0_, member0_.team_id as team_id4_1_0_, member0_.username as username3_1_0_, team1_.name as name2_2_1_ from member member0_ left outer join team team1_ on ( member0_.username=team1_.name )","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 집계","slug":"jpa/querydsl/querydsl-06","date":"2022-04-24T00:31:46.000Z","updated":"2024-02-18T16:19:54.533Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-06/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-06/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 집계 함수@Testpublic void aggregation()&#123; List&lt;Tuple&gt; result = queryFactory.select( member.count(), member.age.sum(), member.age.avg(), member.age.max(), member.age.min() ) .from(member) .fetch(); Tuple tuple = result.get(0); assertThat(tuple.get(member.count())).isEqualTo(4); assertThat(tuple.get(member.age.sum())).isEqualTo(100); assertThat(tuple.get(member.age.avg())).isEqualTo(25); assertThat(tuple.get(member.age.max())).isEqualTo(40); assertThat(tuple.get(member.age.min())).isEqualTo(10);&#125; Group by@Testpublic void group() &#123; List&lt;Tuple&gt; result = queryFactory.select(team.name, member.age.avg()) .from(member) .join(member.team, team) .groupBy(team.name) .fetch(); Tuple teamA = result.get(0); Tuple teamB = result.get(1); assertThat(teamA.get(team.name)).isEqualTo(&quot;teamA&quot;); assertThat(teamA.get(member.age.avg())).isEqualTo(15); assertThat(teamB.get(team.name)).isEqualTo(&quot;teamB&quot;); assertThat(teamB.get(member.age.avg())).isEqualTo(35);&#125;","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 집계 함수@Testpublic void aggregation()&#123; List&lt;Tuple&gt; result = queryFactory.select( member.count(), member.age.sum(), member.age.avg(), member.age.max(), member.age.min() ) .from(member) .fetch(); Tuple tuple = result.get(0); assertThat(tuple.get(member.count())).isEqualTo(4); assertThat(tuple.get(member.age.sum())).isEqualTo(100); assertThat(tuple.get(member.age.avg())).isEqualTo(25); assertThat(tuple.get(member.age.max())).isEqualTo(40); assertThat(tuple.get(member.age.min())).isEqualTo(10);&#125; Group by@Testpublic void group() &#123; List&lt;Tuple&gt; result = queryFactory.select(team.name, member.age.avg()) .from(member) .join(member.team, team) .groupBy(team.name) .fetch(); Tuple teamA = result.get(0); Tuple teamB = result.get(1); assertThat(teamA.get(team.name)).isEqualTo(&quot;teamA&quot;); assertThat(teamA.get(member.age.avg())).isEqualTo(15); assertThat(teamB.get(team.name)).isEqualTo(&quot;teamB&quot;); assertThat(teamB.get(member.age.avg())).isEqualTo(35);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 결과 조회","slug":"jpa/querydsl/querydsl-05","date":"2022-04-23T23:31:46.000Z","updated":"2024-02-18T16:19:54.533Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-05/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-05/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 Querydsl 결과 조회 fetch : 리스트 조회, 데이터가 없으면 빈 리스트 반환 fetchOne : 단건 조회 결과가 없으면 : null 결과가 둘 이상이면 NonUniqueResultException fetchFirst : limit(1).fetchOne() 와 의미가 동일하다. fetchResults : 페이징 정보 포함, total count 쿼리 추가 실행 fetchCount : count 쿼리로 변경해서 count 수 조회 @Testpublic void resultFetch()&#123;List&lt;Member&gt; fetch = queryFactory.selectFrom(member) .fetch();Member fetchOne = queryFactory.selectFrom(QMember.member) .fetchOne();Member fetchFirst = queryFactory.selectFrom(QMember.member) .fetchFirst();QueryResults&lt;Member&gt; results = queryFactory.selectFrom(member) .fetchResults();results.getTotal();List&lt;Member&gt; content = results.getResults();// Deprecatedlong total = queryFactory .selectFrom(member) .fetchCount();// Count 쿼리 작성long totalCount = queryFactory .select(member.count()) .from(member) .fetchOne(); fetchResults : 페이징 쿼리가 복잡해지면 content 를 가져오는 쿼리와 total count 를 가져오는 쿼리가 다를 때가 있어서 해당 메소드를 사용하면 안된다. 정렬@Testpublic void sort()&#123; em.persist(new Member(null, 100)); em.persist(new Member(&quot;member5&quot;, 100)); em.persist(new Member(&quot;member6&quot;, 100)); List&lt;Member&gt; result = queryFactory .selectFrom(member) .where(member.age.eq(100)) .orderBy(member.age.desc(), member.username.asc().nullsLast()) .fetch(); Member member5 = result.get(0); Member member6 = result.get(1); Member memberNull = result.get(2); assertThat(member5.getUsername()).isEqualTo(&quot;member5&quot;); assertThat(member6.getUsername()).isEqualTo(&quot;member6&quot;); assertThat(memberNull.getUsername()).isNull();&#125; 페이징","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 Querydsl 결과 조회 fetch : 리스트 조회, 데이터가 없으면 빈 리스트 반환 fetchOne : 단건 조회 결과가 없으면 : null 결과가 둘 이상이면 NonUniqueResultException fetchFirst : limit(1).fetchOne() 와 의미가 동일하다. fetchResults : 페이징 정보 포함, total count 쿼리 추가 실행 fetchCount : count 쿼리로 변경해서 count 수 조회 @Testpublic void resultFetch()&#123;List&lt;Member&gt; fetch = queryFactory.selectFrom(member) .fetch();Member fetchOne = queryFactory.selectFrom(QMember.member) .fetchOne();Member fetchFirst = queryFactory.selectFrom(QMember.member) .fetchFirst();QueryResults&lt;Member&gt; results = queryFactory.selectFrom(member) .fetchResults();results.getTotal();List&lt;Member&gt; content = results.getResults();// Deprecatedlong total = queryFactory .selectFrom(member) .fetchCount();// Count 쿼리 작성long totalCount = queryFactory .select(member.count()) .from(member) .fetchOne(); fetchResults : 페이징 쿼리가 복잡해지면 content 를 가져오는 쿼리와 total count 를 가져오는 쿼리가 다를 때가 있어서 해당 메소드를 사용하면 안된다. 정렬@Testpublic void sort()&#123; em.persist(new Member(null, 100)); em.persist(new Member(&quot;member5&quot;, 100)); em.persist(new Member(&quot;member6&quot;, 100)); List&lt;Member&gt; result = queryFactory .selectFrom(member) .where(member.age.eq(100)) .orderBy(member.age.desc(), member.username.asc().nullsLast()) .fetch(); Member member5 = result.get(0); Member member6 = result.get(1); Member memberNull = result.get(2); assertThat(member5.getUsername()).isEqualTo(&quot;member5&quot;); assertThat(member6.getUsername()).isEqualTo(&quot;member6&quot;); assertThat(memberNull.getUsername()).isNull();&#125; 페이징 offset 은 시작 위치를 가르킨다 (0 부터 시작한다.) limit 는 몇개를 가져올지를 설정한다. @Testpublic void paging1()&#123; List&lt;Member&gt; result = queryFactory .selectFrom(member) .orderBy(member.username.desc()) .offset(1) .limit(2) .fetch(); assertThat(result.size()).isEqualTo(2);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - 검색 조건 쿼리","slug":"jpa/querydsl/querydsl-04","date":"2022-04-23T22:31:46.000Z","updated":"2024-02-18T16:19:54.533Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-04/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-04/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 @Testpublic void startQuerydsl()&#123; QMember qMember = new QMember(&quot;m&quot;); Member findMember = queryFactory .select(qMember) .from(qMember) .where(qMember.username.eq(&quot;member1&quot;)) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; @Testpublic void search()&#123; Member findMember = queryFactory .selectFrom(member) .where(member.username.eq(&quot;member1&quot;).and(member.age.eq(10))) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; and 를 풀어내는 방식 - and 메소드 사용 @Testpublic void search()&#123; Member findMember = queryFactory .selectFrom(member) .where( member.username.eq(&quot;member1&quot;).and(member.age.eq(10)) ) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; and 를 풀어내는 방식 - 파라미터로 넘기는 방법 @Testpublic void search()&#123; Member findMember = queryFactory .selectFrom(member) .where( member.username.eq(&quot;member1&quot;), member.age.eq(10) ) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; Querydsl 에서 사용하는 검색 조건","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 @Testpublic void startQuerydsl()&#123; QMember qMember = new QMember(&quot;m&quot;); Member findMember = queryFactory .select(qMember) .from(qMember) .where(qMember.username.eq(&quot;member1&quot;)) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; @Testpublic void search()&#123; Member findMember = queryFactory .selectFrom(member) .where(member.username.eq(&quot;member1&quot;).and(member.age.eq(10))) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; and 를 풀어내는 방식 - and 메소드 사용 @Testpublic void search()&#123; Member findMember = queryFactory .selectFrom(member) .where( member.username.eq(&quot;member1&quot;).and(member.age.eq(10)) ) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; and 를 풀어내는 방식 - 파라미터로 넘기는 방법 @Testpublic void search()&#123; Member findMember = queryFactory .selectFrom(member) .where( member.username.eq(&quot;member1&quot;), member.age.eq(10) ) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; Querydsl 에서 사용하는 검색 조건JPQL 이 제공하는 모든 검색 조건 member.username.eq(&quot;member1&quot;) // username = &#x27;member1&#x27;member.username.ne(&quot;member1&quot;) //username != &#x27;member1&#x27;member.username.eq(&quot;member1&quot;).not() // username != &#x27;member1&#x27;member.username.isNotNull() //이름이 is not nullmember.age.in(10, 20) // age in (10,20)member.age.notIn(10, 20) // age not in (10, 20)member.age.between(10,30) //between 10, 30member.age.goe(30) // age &gt;= 30member.age.gt(30) // age &gt; 30member.age.loe(30) // age &lt;= 30member.age.lt(30) // age &lt; 30member.username.like(&quot;member%&quot;) //like 검색 member.username.contains(&quot;member&quot;) // like ‘%member%’ 검색 member.username.startsWith(&quot;member&quot;) //like ‘member%’ 검색","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - Q-Type 활용","slug":"jpa/querydsl/querydsl-03-qtype","date":"2022-04-23T21:31:46.000Z","updated":"2024-02-18T16:19:54.533Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-03-qtype/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-03-qtype/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 Q 클래스 인스턴스를 사용하는 2가지 방법 생성자기 parameter 를 넘기게 되면 해당 값으로 alias 가 걸리게 된다. // 별칭 직접 지정 QMember qMember = new QMember(&quot;m&quot;); // 기본 인스턴스 사용QMember qMember = QMember.member; use_sql_comments 옵션을 true 로 설정하게 되면 jpql comment 를 볼 수 있다. Configspring: datasource:# url: jdbc:h2:~/querydsl url: jdbc:h2:tcp://localhost/~/querydsl username: sa password: driver-class-name: org.h2.Driver jpa: hibernate: ddl-auto: create-drop properties: hibernate:# show_sql: true format_sql: true use_sql_comments: truelogging.level: org.hibernate.SQL: debug # org.hibernate.type: trace /* select m from Member m where m.username = :username */ select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ where member0_.username=?","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 Q 클래스 인스턴스를 사용하는 2가지 방법 생성자기 parameter 를 넘기게 되면 해당 값으로 alias 가 걸리게 된다. // 별칭 직접 지정 QMember qMember = new QMember(&quot;m&quot;); // 기본 인스턴스 사용QMember qMember = QMember.member; use_sql_comments 옵션을 true 로 설정하게 되면 jpql comment 를 볼 수 있다. Configspring: datasource:# url: jdbc:h2:~/querydsl url: jdbc:h2:tcp://localhost/~/querydsl username: sa password: driver-class-name: org.h2.Driver jpa: hibernate: ddl-auto: create-drop properties: hibernate:# show_sql: true format_sql: true use_sql_comments: truelogging.level: org.hibernate.SQL: debug # org.hibernate.type: trace /* select m from Member m where m.username = :username */ select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ where member0_.username=?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"JPA JPQL vs Querydsl","slug":"jpa/querydsl/querydsl-02","date":"2022-04-23T20:31:46.000Z","updated":"2024-02-18T16:23:18.178Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-02/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-02/","excerpt":"목차 Post not found: jpa/querydsl/querydsl-15 Post not found: jpa/querydsl/querydsl-14 QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 Post not found: jpa/querydsl/querydsl-10 Post not found: jpa/querydsl/querydsl-09 Post not found: jpa/querydsl/querydsl-08 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 Post not found: jpa/querydsl/querydsl-03 JPA JPQL vs Querydsl QueryDSL 시작하기 JPQL@Testpublic void startJPQL()&#123; // member1 을 찾아라 Member findByJPQL = em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class) .setParameter(&quot;username&quot;, &quot;member1&quot;) .getSingleResult(); assertThat(findByJPQL.getUsername()).isEqualTo(&quot;member1&quot;);&#125; Querydsl@Testpublic void startQuerydsl()&#123; JPAQueryFactory queryFactory = new JPAQueryFactory(em); QMember qMember = new QMember(&quot;m&quot;); Member findMember = queryFactory .select(qMember) .from(qMember) .where(qMember.username.eq(&quot;member1&quot;)) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; Querydsl 은 기본적으로 parameter binding 시 preparedStatement 의 parameter binding 을 사용해 SQL injection 공격으로부터 안전하다. select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ where member0_.username=? jpql 은 런타임 오류가 발생하나 querydsl 은 컴파일시 에러가 발생하게 된다.","text":"목차 Post not found: jpa/querydsl/querydsl-15 Post not found: jpa/querydsl/querydsl-14 QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 Post not found: jpa/querydsl/querydsl-10 Post not found: jpa/querydsl/querydsl-09 Post not found: jpa/querydsl/querydsl-08 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 Post not found: jpa/querydsl/querydsl-03 JPA JPQL vs Querydsl QueryDSL 시작하기 JPQL@Testpublic void startJPQL()&#123; // member1 을 찾아라 Member findByJPQL = em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class) .setParameter(&quot;username&quot;, &quot;member1&quot;) .getSingleResult(); assertThat(findByJPQL.getUsername()).isEqualTo(&quot;member1&quot;);&#125; Querydsl@Testpublic void startQuerydsl()&#123; JPAQueryFactory queryFactory = new JPAQueryFactory(em); QMember qMember = new QMember(&quot;m&quot;); Member findMember = queryFactory .select(qMember) .from(qMember) .where(qMember.username.eq(&quot;member1&quot;)) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; Querydsl 은 기본적으로 parameter binding 시 preparedStatement 의 parameter binding 을 사용해 SQL injection 공격으로부터 안전하다. select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ where member0_.username=? jpql 은 런타임 오류가 발생하나 querydsl 은 컴파일시 에러가 발생하게 된다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL - JPA JPQL vs JPA QueryDSL","slug":"jpa/querydsl/querydsl-02-jpql-querydsl","date":"2022-04-23T20:31:46.000Z","updated":"2024-02-18T16:19:54.532Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-02-jpql-querydsl/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-02-jpql-querydsl/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 JPA JPQL JPQL 은 EntityManager 객체내 creatQuery 메소드를 이용해 쿼리를 작성한 후 실행한다. @Testpublic void startJPQL()&#123; // member1 을 찾아라 Member findByJPQL = em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class) .setParameter(&quot;username&quot;, &quot;member1&quot;) .getSingleResult(); assertThat(findByJPQL.getUsername()).isEqualTo(&quot;member1&quot;);&#125; JPA QueryDSL JPA QueryDSL 은 JPA Entity 와 관련해 정적 타입으로 쿼리를 작성 하게 해주는 라이브러리 JPA QueryDSL 에서는 JPAQueryFactory 객체를 이용해 쿼리를 작성합니다. JPAQueryFactory 객체를 통해 생성된 쿼리가 JPA Entity 를 대상으로 쿼리를 생성하고 실행하고 상태를 관리하기 위해서는 EntityMagager 인스턴스가 필요합니다. 따라서, JPA 기능을 사용하고 Entity 를 대상으로 쿼리를 수행할 수 있도록 EntityMagager 객체를 JPAQueryFactory 객체 생성시 전달할 필요가 있습니다.","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 JPA JPQL JPQL 은 EntityManager 객체내 creatQuery 메소드를 이용해 쿼리를 작성한 후 실행한다. @Testpublic void startJPQL()&#123; // member1 을 찾아라 Member findByJPQL = em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class) .setParameter(&quot;username&quot;, &quot;member1&quot;) .getSingleResult(); assertThat(findByJPQL.getUsername()).isEqualTo(&quot;member1&quot;);&#125; JPA QueryDSL JPA QueryDSL 은 JPA Entity 와 관련해 정적 타입으로 쿼리를 작성 하게 해주는 라이브러리 JPA QueryDSL 에서는 JPAQueryFactory 객체를 이용해 쿼리를 작성합니다. JPAQueryFactory 객체를 통해 생성된 쿼리가 JPA Entity 를 대상으로 쿼리를 생성하고 실행하고 상태를 관리하기 위해서는 EntityMagager 인스턴스가 필요합니다. 따라서, JPA 기능을 사용하고 Entity 를 대상으로 쿼리를 수행할 수 있도록 EntityMagager 객체를 JPAQueryFactory 객체 생성시 전달할 필요가 있습니다. @Testpublic void startQuerydsl()&#123; // JPAQueryFactory 객체 생성시 EntityManager 를 인자로 넘겨줘 Entity 에 대한 쿼리를 작성할 수 있도록 한다. JPAQueryFactory queryFactory = new JPAQueryFactory(entityManager); QMember qMember = new QMember(&quot;m&quot;); Member findMember = queryFactory .select(qMember) .from(qMember) .where(qMember.username.eq(&quot;member1&quot;)) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);&#125; 결과select member0_.member_id as member_i1_1_, member0_.age as age2_1_, member0_.team_id as team_id4_1_, member0_.username as username3_1_ from member member0_ where member0_.username=? QueryDSL 특징 Querydsl 은 Parameter binding 시 PreparedStatement 의 Parameter binding 을 사용해 SQL Injection 공격으로부터 안전하다. JPQL 은 런타임 오류가 발생하나 QueryDsl 은 컴파일시 에러가 발생하게 된다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"QueryDSL 시작하기","slug":"jpa/querydsl/querydsl-01","date":"2022-04-23T19:31:46.000Z","updated":"2024-02-18T16:19:54.532Z","comments":true,"path":"2022/04/24/jpa/querydsl/querydsl-01/","link":"","permalink":"https://ckck803.github.io/2022/04/24/jpa/querydsl/querydsl-01/","excerpt":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 QueryDSL 이란? QueryDSL 은 Query Domain Specific Language 의 약자로 쿼리를 코드로 작성할 수 있도록 해주는 쿼리 빌더 프레임워크 QueryDSL은 자바코드로 쿼리를 작성할 수 있으며, JPA, JDO, Hibernate, MongoDB, SQL, Lucene 등 다양한 데이터베이스를 지원합니다. QueryDSL은 코드 자동 완성 기능을 제공하므로 오타나 잘못된 쿼리를 작성하는 일을 방지하며, 런타임 오류를 방지할 수 있습니다. Plugin 추가plugins &#123; id &#x27;org.springframework.boot&#x27; version ‘2.2.2.RELEASE&#x27; id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.8.RELEASE&#x27; //querydsl 추가 id &quot;com.ewerk.gradle.plugins.querydsl&quot; version &quot;1.0.10&quot; id &#x27;java&#x27;&#125; 라이브러리 추가//querydsl 추가implementation &#x27;com.querydsl:querydsl-jpa&#x27;","text":"목차 QueryDSL - QueryDsl 페이징 사용하기 QueryDSL - 사용자 정의 Repository QueryDSL - 동적 쿼리와 성능 최적화 조회 QueryDSL - 순수 JPA 리포지토리와 Querydsl QueryDSL - SQL Function 호출하기 QueryDSL - 수정, 삭제 벌크 연산 QueryDSL - 동적 쿼리 QueryDSL - 프로젝션과 결과 반환 QueryDSL - 조인 QueryDSL - 집계 QueryDSL - 결과 조회 QueryDSL - 검색 조건 쿼리 QueryDSL - Q-Type 활용 QueryDSL - JPA JPQL vs JPA QueryDSL QueryDSL 시작하기 QueryDSL 이란? QueryDSL 은 Query Domain Specific Language 의 약자로 쿼리를 코드로 작성할 수 있도록 해주는 쿼리 빌더 프레임워크 QueryDSL은 자바코드로 쿼리를 작성할 수 있으며, JPA, JDO, Hibernate, MongoDB, SQL, Lucene 등 다양한 데이터베이스를 지원합니다. QueryDSL은 코드 자동 완성 기능을 제공하므로 오타나 잘못된 쿼리를 작성하는 일을 방지하며, 런타임 오류를 방지할 수 있습니다. Plugin 추가plugins &#123; id &#x27;org.springframework.boot&#x27; version ‘2.2.2.RELEASE&#x27; id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.8.RELEASE&#x27; //querydsl 추가 id &quot;com.ewerk.gradle.plugins.querydsl&quot; version &quot;1.0.10&quot; id &#x27;java&#x27;&#125; 라이브러리 추가//querydsl 추가implementation &#x27;com.querydsl:querydsl-jpa&#x27; //querydsl 추가 시작def querydslDir = &quot;$buildDir/generated/querydsl&quot;querydsl &#123; jpa = true querydslSourcesDir = querydslDir&#125;sourceSets &#123; main.java.srcDir querydslDir&#125;configurations &#123; querydsl.extendsFrom compileClasspath&#125;compileQuerydsl &#123; options.annotationProcessorPath = configurations.querydsl&#125;//querydsl 추가 끝 Unable to load class ‘com.mysema.codegen.model.Type’. 에러위 Error 는 Gradle 5.0 이상에서 발생하는 Error 다. 해결하기 위해서는 아래와 같이 설정해주면 된다. buildscript &#123; ext &#123; queryDslVersion = &quot;5.0.0&quot; &#125;&#125;plugins &#123; id &#x27;org.springframework.boot&#x27; version &#x27;2.6.2&#x27; id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.11.RELEASE&#x27; //querydsl 추가 id &quot;com.ewerk.gradle.plugins.querydsl&quot; version &quot;1.0.10&quot; id &#x27;java&#x27;&#125;group = &#x27;com.example&#x27;version = &#x27;0.0.1-SNAPSHOT&#x27;sourceCompatibility = &#x27;11&#x27;configurations &#123; compileOnly &#123; extendsFrom annotationProcessor &#125;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; //querydsl 추가 implementation &quot;com.querydsl:querydsl-jpa:$&#123;queryDslVersion&#125;&quot; implementation &quot;com.querydsl:querydsl-apt:$&#123;queryDslVersion&#125;&quot; compileOnly &#x27;org.projectlombok:lombok&#x27; runtimeOnly &#x27;com.h2database:h2&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; //테스트에서 lombok 사용 testCompileOnly &#x27;org.projectlombok:lombok&#x27; testAnnotationProcessor &#x27;org.projectlombok:lombok&#x27; testImplementation(&#x27;org.springframework.boot:spring-boot-starter-test&#x27;) &#123; exclude group: &#x27;org.junit.vintage&#x27;, module: &#x27;junit-vintage-engine&#x27; &#125; &#125;test &#123; useJUnitPlatform()&#125;//querydsl 추가 시작def querydslDir = &quot;$buildDir/generated/querydsl&quot;querydsl &#123; jpa = true querydslSourcesDir = querydslDir&#125;sourceSets &#123; main.java.srcDir querydslDir&#125;configurations &#123; querydsl.extendsFrom compileClasspath&#125;compileQuerydsl &#123; options.annotationProcessorPath = configurations.querydsl&#125;//querydsl 추가 끝 Q-Type 생성@Entity@Getter@Setterpublic class Hello &#123; @Id @GeneratedValue private Long id;&#125; Entity 를 작성한 후 아래 명령어를 치면 build/generated/querydsl 폴더에 QHello 파일의 Q-Type 이 생성된 것을 확인할 수 있다. 또한, Q-Type 은 컴파일 시점에 자동적으로 생성이 된다. .&#x2F;gradlew clean compileQuerydsl @SpringBootTest@Transactionalclass QuerydslApplicationTests &#123; @Autowired EntityManager em; @Test void contextLoads() &#123; Hello hello = new Hello(); em.persist(hello); JPAQueryFactory query = new JPAQueryFactory(em); QHello qHello = new QHello(&quot;h&quot;); Hello result = query .selectFrom(qHello) .fetchOne(); assertThat(result).isEqualTo(hello); assertThat(result.getId()).isEqualTo(hello.getId()); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"}],"tags":[]},{"title":"JPA 연관 관계 - 고아 객체","slug":"jpa/jpa-programming/mapping/jpa-orphanRemoval","date":"2022-04-21T02:31:46.000Z","updated":"2024-02-18T16:19:54.530Z","comments":true,"path":"2022/04/21/jpa/jpa-programming/mapping/jpa-orphanRemoval/","link":"","permalink":"https://ckck803.github.io/2022/04/21/jpa/jpa-programming/mapping/jpa-orphanRemoval/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 고아 객체란? 부모 엔티티와 연관관계가 끊어진 자식 엔티티 고아 객체 제거 부모 엔티티와 연관관계 가 끊어진 자식 엔티티를 자동으로 제거 @OneToOne, @OneToMany 만 가능하다. orphanRemoval &#x3D; true @Entity@Getter@Setterpublic class Parent &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; @OneToMany(mappedBy = &quot;parent&quot;, cascade = CascadeType.ALL, orphanRemoval = true) private List&lt;Child&gt; childList = new ArrayList&lt;&gt;(); public void addChild(Child child)&#123; childList.add(child); child.setParent(this); &#125;&#125; public class JpaMain &#123; public static void main(String[] ars) &#123; EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = entityManagerFactory.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); try &#123; Child child1 = new Child(); Child child2 = new Child(); Parent parent = new Parent(); parent.addChild(child1); parent.addChild(child2); em.persist(parent); em.flush(); em.clear(); Parent savedParent = em.find(Parent.class, parent.getId()); savedParent.getChildList().remove(0); transaction.commit(); &#125; catch (Exception e) &#123; transaction.rollback(); &#125; finally &#123; em.close(); &#125; entityManagerFactory.close(); &#125;&#125; Parent 에서 Child를 삭제할 때 delete 쿼리가 발생하게 된다.","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 고아 객체란? 부모 엔티티와 연관관계가 끊어진 자식 엔티티 고아 객체 제거 부모 엔티티와 연관관계 가 끊어진 자식 엔티티를 자동으로 제거 @OneToOne, @OneToMany 만 가능하다. orphanRemoval &#x3D; true @Entity@Getter@Setterpublic class Parent &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; @OneToMany(mappedBy = &quot;parent&quot;, cascade = CascadeType.ALL, orphanRemoval = true) private List&lt;Child&gt; childList = new ArrayList&lt;&gt;(); public void addChild(Child child)&#123; childList.add(child); child.setParent(this); &#125;&#125; public class JpaMain &#123; public static void main(String[] ars) &#123; EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = entityManagerFactory.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); try &#123; Child child1 = new Child(); Child child2 = new Child(); Parent parent = new Parent(); parent.addChild(child1); parent.addChild(child2); em.persist(parent); em.flush(); em.clear(); Parent savedParent = em.find(Parent.class, parent.getId()); savedParent.getChildList().remove(0); transaction.commit(); &#125; catch (Exception e) &#123; transaction.rollback(); &#125; finally &#123; em.close(); &#125; entityManagerFactory.close(); &#125;&#125; Parent 에서 Child를 삭제할 때 delete 쿼리가 발생하게 된다. Hibernate: /* insert hellojpa.Parent */ insert into Parent (id, name) values (null, ?)Hibernate: /* insert hellojpa.Child */ insert into Child (id, name, parent_id) values (null, ?, ?)Hibernate: /* insert hellojpa.Child */ insert into Child (id, name, parent_id) values (null, ?, ?)Hibernate: select parent0_.id as id1_6_0_, parent0_.name as name2_6_0_ from Parent parent0_ where parent0_.id=?Hibernate: select childlist0_.parent_id as parent_i3_2_0_, childlist0_.id as id1_2_0_, childlist0_.id as id1_2_1_, childlist0_.name as name2_2_1_, childlist0_.parent_id as parent_i3_2_1_ from Child childlist0_ where childlist0_.parent_id=?Hibernate: /* delete hellojpa.Child */ delete from Child where id=? 고아 객체 - 주의 참조하는 곳이 하나 일 때 사용해야 한다. 특정 엔티티가 개인 소유할 때 사용한다. 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께 제거된다.(CascadeType.REMOVE 처럼 동작) 영속성 전이 + 고아 객체, 생명주기 스스로 생명 주기를 관리하는 엔티티는 em.persist() 로 영속화, em.remove() 로 제거 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식 엔티티 생명 주기를 관리할 수 있다. 도메인 주도 설계(DDD) 의 Aggregate Root 개면을 구현할 때 유용하다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"JPA 연관 관계 - 즉시로딩과 지연로딩","slug":"jpa/jpa-programming/mapping/lazy-eager","date":"2022-04-19T22:31:46.000Z","updated":"2024-02-18T16:19:54.530Z","comments":true,"path":"2022/04/20/jpa/jpa-programming/mapping/lazy-eager/","link":"","permalink":"https://ckck803.github.io/2022/04/20/jpa/jpa-programming/mapping/lazy-eager/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 N + 1 문제 하나의 쿼리(1) 를 날린 후 조회된 결과 값과 연관된 데이터 를 가져오기 위해 결과의 행수(N) 만큼 추가 쿼리가 발생하는 문제 즉시로딩 FetchType.EAGER 로 설정하게 되면 즉시 조회하게 된다. Join 해서 한방 쿼리로 가져오는 방법 데이터를 가져온 후 후속 쿼리를 날리는 기법, 해당 방법은 N + 1 문제를 일으킨다. @ManyToOne(fetch = FetchType.EAGER)@JoinColumn(name = &quot;TEAM_ID&quot;)private Team team; 프록시와 즉시로딩 주의 즉시 로딩을 적용하면 예상하지 못한 SQL 이 발생 즉시 로딩은 JPQL 에서 N + 1 문제를 일으킨다. JPA 가 만들어주는 쿼리는 내부적으로 최적화가 이뤄진다. JPQL 은 내부적으로 SQL 로 번역된 후 데이터를 가져온 다음에 연관 데이터에 대해 후속적으로 쿼리가 발생한다. 해결법 1 : fetch join 해결법 2 : @EntityGraph 해결법 3 : batch size @ManyToOne, @OneToOne 은 기본이 즉시 로딩 LAZY 로 설정한다. @OneToMany, @ManyToMany 는 기본이 지연 로딩 지연로딩","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 N + 1 문제 하나의 쿼리(1) 를 날린 후 조회된 결과 값과 연관된 데이터 를 가져오기 위해 결과의 행수(N) 만큼 추가 쿼리가 발생하는 문제 즉시로딩 FetchType.EAGER 로 설정하게 되면 즉시 조회하게 된다. Join 해서 한방 쿼리로 가져오는 방법 데이터를 가져온 후 후속 쿼리를 날리는 기법, 해당 방법은 N + 1 문제를 일으킨다. @ManyToOne(fetch = FetchType.EAGER)@JoinColumn(name = &quot;TEAM_ID&quot;)private Team team; 프록시와 즉시로딩 주의 즉시 로딩을 적용하면 예상하지 못한 SQL 이 발생 즉시 로딩은 JPQL 에서 N + 1 문제를 일으킨다. JPA 가 만들어주는 쿼리는 내부적으로 최적화가 이뤄진다. JPQL 은 내부적으로 SQL 로 번역된 후 데이터를 가져온 다음에 연관 데이터에 대해 후속적으로 쿼리가 발생한다. 해결법 1 : fetch join 해결법 2 : @EntityGraph 해결법 3 : batch size @ManyToOne, @OneToOne 은 기본이 즉시 로딩 LAZY 로 설정한다. @OneToMany, @ManyToMany 는 기본이 지연 로딩 지연로딩 FetchType.LAZY 로 설정하게 되면 Proxy 로 조회하게 된다. 실제 해당 객체를 사용하는 시점에 초기화를 진행한다. @ManyToOne(fetch = FetchType.LAZY)@JoinColumn(name = &quot;TEAM_ID&quot;)private Team team;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"JPA 연관 관계 - 프록시 객체","slug":"jpa/jpa-programming/mapping/proxy","date":"2022-04-19T21:31:46.000Z","updated":"2024-02-18T16:19:54.531Z","comments":true,"path":"2022/04/20/jpa/jpa-programming/mapping/proxy/","link":"","permalink":"https://ckck803.github.io/2022/04/20/jpa/jpa-programming/mapping/proxy/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 프록시 객체의 특징 실제 클래스를 상속 받아서 만들어진다. 실제 클래스와 겉 모양이 같다. 사용자 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다. 프록시 객체는 실제 객체의 참조를 보관한다. 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다. 프록시 객체는 처음 사용할 때 한번만 초기화 프록시 객체를 초기화 할때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 초기화 되면 프록시 객체를 통해 실제 엔티티에 접근이 가능하다. 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야 한다. (&#x3D;&#x3D; 비교 실패, 대신 instance of 사용) 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference() 를 호추랳도 실제 엔티티를 반환한다. 영속성 컨텍스트의 도움을 받을 수 없는 준 영속 상태일때, 프록시를 초기화 하면 문제 발생 org.hibernate.LazyInitializationException 예외를 터트린다. em.find() vs em.getReference() em.find() 데이터 베이스를 통해 실제 엔티티 객체를 조회한다. em.getReference() 데이터 베이스 조회를 미루는 가짜(프록시) 엔티티 객체 를 조회한다. public class JpaMain &#123; public static void main(String[] ars) &#123; EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = entityManagerFactory.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); try &#123; Member member = new Member(); member.setUsername(&quot;hello&quot;); em.persist(member); em.flush(); em.clear(); Member savedMember = em.find(Member.class, 1L); printMemberAndTeam(savedMember); transaction.commit(); &#125; catch (Exception e) &#123; transaction.rollback(); &#125; finally &#123; em.close(); &#125; entityManagerFactory.close(); &#125; private static void printMember(Member member)&#123; System.out.println(&quot;member = &quot; + member.getUsername()); &#125; private static void printMemberAndTeam(Member member) &#123; String username = member.getUsername(); System.out.println(&quot;username = &quot; + username); Team team = member.getTeam(); System.out.println(&quot;team = &quot; + team.getName()); &#125;&#125;","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 프록시 객체의 특징 실제 클래스를 상속 받아서 만들어진다. 실제 클래스와 겉 모양이 같다. 사용자 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다. 프록시 객체는 실제 객체의 참조를 보관한다. 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다. 프록시 객체는 처음 사용할 때 한번만 초기화 프록시 객체를 초기화 할때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 초기화 되면 프록시 객체를 통해 실제 엔티티에 접근이 가능하다. 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야 한다. (&#x3D;&#x3D; 비교 실패, 대신 instance of 사용) 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference() 를 호추랳도 실제 엔티티를 반환한다. 영속성 컨텍스트의 도움을 받을 수 없는 준 영속 상태일때, 프록시를 초기화 하면 문제 발생 org.hibernate.LazyInitializationException 예외를 터트린다. em.find() vs em.getReference() em.find() 데이터 베이스를 통해 실제 엔티티 객체를 조회한다. em.getReference() 데이터 베이스 조회를 미루는 가짜(프록시) 엔티티 객체 를 조회한다. public class JpaMain &#123; public static void main(String[] ars) &#123; EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = entityManagerFactory.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); try &#123; Member member = new Member(); member.setUsername(&quot;hello&quot;); em.persist(member); em.flush(); em.clear(); Member savedMember = em.find(Member.class, 1L); printMemberAndTeam(savedMember); transaction.commit(); &#125; catch (Exception e) &#123; transaction.rollback(); &#125; finally &#123; em.close(); &#125; entityManagerFactory.close(); &#125; private static void printMember(Member member)&#123; System.out.println(&quot;member = &quot; + member.getUsername()); &#125; private static void printMemberAndTeam(Member member) &#123; String username = member.getUsername(); System.out.println(&quot;username = &quot; + username); Team team = member.getTeam(); System.out.println(&quot;team = &quot; + team.getName()); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"JPA 연관 관계 - 일대다","slug":"jpa/jpa-programming/mapping/one-to-many","date":"2022-04-19T20:31:46.000Z","updated":"2024-02-18T16:19:54.531Z","comments":true,"path":"2022/04/20/jpa/jpa-programming/mapping/one-to-many/","link":"","permalink":"https://ckck803.github.io/2022/04/20/jpa/jpa-programming/mapping/one-to-many/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 공통 Mapping 정보를 관리하기 위한 MappedSuperclass Entity 에 공통적으로 들어가는 Mapping 정보를 관리해 코드가 중복해서 작성하는 것을 방지하기 위해 사용하는 어노테이션 상속관계 Mapping 이 아니다. 부모 클래스를 상속 받는 자식 클래스에 Mapping 정보만 을 제공한다. 직접 생성해서 사용할 일이 없으므로 추상클래스(abstract) 를 사용하는 것이 좋다. MappedSuperclass 클래스를 상속 받기 위해서는 같은 @MappedSuperclass 를 사용한 클래스나 @Entity 을 이용한 클래스만 상속이 가능하다. 요구 사항 모든 Entity 에는 생성자, 생성일, 수정자, 수정일 정보가 들어가야 한다. 모든 Entity 에 공통적으로 들어가는 Mapping 정보 를 관리하기 위한 BaseEntity 클래스를 생성한다. @MappedSuperclasspublic abstract class BaseEntity &#123; private String createdBy; private LocalDateTime createdDate; private String lastModifiedBy; private LocalDateTime lastModifiedDate;&#125; 공통 Mapping 정보는 상속 을 통해 현재 Entity 에 적용할 수 있다.","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 공통 Mapping 정보를 관리하기 위한 MappedSuperclass Entity 에 공통적으로 들어가는 Mapping 정보를 관리해 코드가 중복해서 작성하는 것을 방지하기 위해 사용하는 어노테이션 상속관계 Mapping 이 아니다. 부모 클래스를 상속 받는 자식 클래스에 Mapping 정보만 을 제공한다. 직접 생성해서 사용할 일이 없으므로 추상클래스(abstract) 를 사용하는 것이 좋다. MappedSuperclass 클래스를 상속 받기 위해서는 같은 @MappedSuperclass 를 사용한 클래스나 @Entity 을 이용한 클래스만 상속이 가능하다. 요구 사항 모든 Entity 에는 생성자, 생성일, 수정자, 수정일 정보가 들어가야 한다. 모든 Entity 에 공통적으로 들어가는 Mapping 정보 를 관리하기 위한 BaseEntity 클래스를 생성한다. @MappedSuperclasspublic abstract class BaseEntity &#123; private String createdBy; private LocalDateTime createdDate; private String lastModifiedBy; private LocalDateTime lastModifiedDate;&#125; 공통 Mapping 정보는 상속 을 통해 현재 Entity 에 적용할 수 있다. Member 테이블이 생성될 때 공통 Mapping 가 적용될 수 있도록 BaseEntity 를 상속 받는다. @Entitypublic class Member extends BaseEntity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;MEMBER_ID&quot;) private long id; @Column(name = &quot;USERNAME&quot;) private String username; @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; public void changeTeam(Team team)&#123; this.team = team; team.getMembers().add(this); &#125;&#125; Member 테이블이 생성될 때 createdBy, createdDate, lastModifiedBy, lastModifiedDate 컬럼이 생성된 것을 확인할 수 있다. Team 테이블이 생성될 때 공통 Mapping 가 적용될 수 있도록 BaseEntity 를 상속 받는다. @Entitypublic class Team extends BaseEntity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;TEAM_ID&quot;) private Long id; private String name; @OneToMany(mappedBy = &quot;team&quot;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;(); public void addMember(Member member)&#123; member.setTeam(this); members.add(member); &#125;&#125; Team 테이블이 생성될 때 createdBy, createdDate, lastModifiedBy, lastModifiedDate 컬럼이 생성된 것을 확인할 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"JPA 연관 관계 - 다대일","slug":"jpa/jpa-programming/mapping/many-to-one","date":"2022-04-19T19:31:46.000Z","updated":"2024-02-18T16:19:54.531Z","comments":true,"path":"2022/04/20/jpa/jpa-programming/mapping/many-to-one/","link":"","permalink":"https://ckck803.github.io/2022/04/20/jpa/jpa-programming/mapping/many-to-one/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 다 대 일연관관계 매핑시 고려사항 다중성 단방향, 양방향 연관관계 주인 테이블 외래키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 연관관계 주인","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 다 대 일연관관계 매핑시 고려사항 다중성 단방향, 양방향 연관관계 주인 테이블 외래키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 연관관계 주인 테이블은 외래키 하나로 두 테이블이 연관관계를 맺음 객체의 방향은 A → B, B → A 처럼 참조가 2군데 객체 양방향 관계는 참조가 2군데 있음, 둘중 테이블의 외래 키를 관리할 곳을 지정해야함 연관관계의 주인 : 외래 키를 관리하는 참조 주인의 반대편 : 외래 키에 영향을 주지 않음, 단순 조회만 가능 다대일 단방향 다대일 양방향 반대쪽 사이드를 하나 넣어주면 된다. 반대쪽 사이드를 넣는다고 해도 테이블에 전혀 영향이 없다. 객체에서만 관리를 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"Spring Security -  DelegateFilterProxy","slug":"spring/spring-security/security/filter/DelegateFilterProxy","date":"2022-04-19T13:25:35.000Z","updated":"2024-02-26T16:27:37.391Z","comments":true,"path":"2022/04/19/spring/spring-security/security/filter/DelegateFilterProxy/","link":"","permalink":"https://ckck803.github.io/2022/04/19/spring/spring-security/security/filter/DelegateFilterProxy/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 Filter 란 기본적으로 Filter 는 Servlet Filter 를 의미한다. Servlet Filter 는 서블릿 스펙에 정의된 기술 서블릿 컨테이너에서 생성되고 실행된다. Filter 는 Spring 에서 생성한 Bean 을 사용하거나 Spring 기술을 사용할 수 없다. Filter 를 사용해 자원에 대한 접근 전&#x2F;후에 대한 처리를 진행할 수 있다. DelegatingFilterProxy Servlet Container 와 Spring Container 사이에 다리 역할을 해 Spring Bean 으로 등록된 Filter 를 찾아 요청을 위임하는 역할을 한다. Servlet Container 위에 구현된 Filter Servelt Filter 가 요청을 DelegatingFilterProxy 로 전달 DelegatingFilterProxy 는 들어온 요청을 Spring Container 위에 생성된 Filter Bean 에 요청을 위임 springSecurityFilterChain 이름으로 생성된 Bean 을 찾아 요청을 위임한다. FilterChainProxy","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 Filter 란 기본적으로 Filter 는 Servlet Filter 를 의미한다. Servlet Filter 는 서블릿 스펙에 정의된 기술 서블릿 컨테이너에서 생성되고 실행된다. Filter 는 Spring 에서 생성한 Bean 을 사용하거나 Spring 기술을 사용할 수 없다. Filter 를 사용해 자원에 대한 접근 전&#x2F;후에 대한 처리를 진행할 수 있다. DelegatingFilterProxy Servlet Container 와 Spring Container 사이에 다리 역할을 해 Spring Bean 으로 등록된 Filter 를 찾아 요청을 위임하는 역할을 한다. Servlet Container 위에 구현된 Filter Servelt Filter 가 요청을 DelegatingFilterProxy 로 전달 DelegatingFilterProxy 는 들어온 요청을 Spring Container 위에 생성된 Filter Bean 에 요청을 위임 springSecurityFilterChain 이름으로 생성된 Bean 을 찾아 요청을 위임한다. FilterChainProxy springSeuciryFilterChain 이름으로 생성되는 Filter Bean DelegatingFilterProxy 로부터 요청을 위임 받고 실제로 보안 처리를 진행한다. Filter 를 관리하고 제어하며 호출 돼 실제로 보안 처리를 진행한다. Spirng Security 가 기본적으로 생성하는 Filter 설정 클래스(Config) 클래스에서 추가시 생성되는 Filter 사용자 요청을 필터 순서대로 호출하여 그 다음 Filter 로 전달한다. 마지막 Filter 까지 진행이 되면 Servlet 에 접근할 수 있다. DelegatingFilterProxy 처리 과정 사용자가 요청을 하게 되면 Servlet 에 존재하는 Filter 가 가장 먼저 받게 된다. DelegatingFilterProxy 가 사용자 요청을 받게 되면 요청 객체를 FilterChainProxy 에 위임한다. FilterChainProxy 는 요청에 대해 Filter 별로 호출을 해 보안 처리를 진행 인증&#x2F;인가가 완료된 후 요청을 DispatcherServlet 에 넘긴다. SecurityFilterAutoConfiguration securityFilterChainRegistration 을 springSecurityFilterChain 이름으로 Spring 에 등록한다. DelegatingFilterProxyRegistrationBean 을 생성하게 될 경우 DelegatingFilterProxy 생성자가 실행된다. DelegatingFilterProxy DelegatingFilterProxy 생성자는 요청을 위임할 Bean 이름을 springSecurityFilterChain 를 설정한다. WebSecurityConfiguration springSeuciryFilterChain 이름을 가진 Bean 을 생성한다. webSecurity.build 메서드를 실행할 경우 WebSecurity 객체의 performBuild 메서드가 실행된다. WebSecurity FilterChainProxy 객체를 생성한다. 사용자 요청이 들어왔을 때DelegationFilterProxy DelegationFilterProxy 에서 요청을 받고 요청을 위임할 Filter (springSecurityFilterChain) 을 찾아 요청을 위임한다. FilterChainProxy getFilters 메서드를 통해 Spring Security 가 초기화 되면서 생성되는 Filter 목록들을 가져와 VirtualFilterChain 객체를 생성해 Filter 를 전달하면 순서대로 Filter 를 실행시킨다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Filter","slug":"Spring/Spring-Security/Filter","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Filter/"}],"tags":[]},{"title":"JPA JPQL - Fetch Join","slug":"jpa/jpa-programming/jpql/fetch-join","date":"2022-04-18T19:31:46.000Z","updated":"2024-02-18T16:19:54.528Z","comments":true,"path":"2022/04/19/jpa/jpa-programming/jpql/fetch-join/","link":"","permalink":"https://ckck803.github.io/2022/04/19/jpa/jpa-programming/jpql/fetch-join/","excerpt":"목차 JPA JPQL - Fetch Join JPA JPQL - Projection (Select) JPA JPQL (Java Persistence Query Language) JPA - 객체지향 쿼리 언어 N+1 문제란 ? 데이터 조회를 위해 한번의 쿼리가 발생하지만 연관관계에 의해 연관된 객체 모두를 가져오기 위해 N 번의 쿼리가 발생하는 문제 필요한 데이터 조회를 위해 한번의 Select 쿼리가 발생해 객체를 가져왔지만, 연관관계가 설정된 객체는 Lazy 설정 으로 인해 실제 값이 아닌 Proxy 객체 로 대체하는데 해당 객체에 접근할 경우 실제 데이터를 가져오기 위해 처음에 조회된 데이터 만큼 쿼리가 추가적으로 발생하는 문제 Fetch Join Lazy 설정을 무시하고 연관된 객체를 한번에 가져온다. JPQL 에서는 N + 1 문제를 해결하기 위해 fetch join 을 제공한다. fetch join 을 이용해 JPQL 을 작성하게 되면 Lazy 설정을 무시하고, Order 조회시 Member 객체와 Delivery 객체를 전부 다 가져온다. public List&lt;Order&gt; findAllWithMemberDelivery()&#123; return em.createQuery( &quot;select o from Order o&quot;+ &quot; join fetch o.member m&quot; + &quot; join fetch o.delivery d&quot;, Order.class ).getResultList();&#125;","text":"목차 JPA JPQL - Fetch Join JPA JPQL - Projection (Select) JPA JPQL (Java Persistence Query Language) JPA - 객체지향 쿼리 언어 N+1 문제란 ? 데이터 조회를 위해 한번의 쿼리가 발생하지만 연관관계에 의해 연관된 객체 모두를 가져오기 위해 N 번의 쿼리가 발생하는 문제 필요한 데이터 조회를 위해 한번의 Select 쿼리가 발생해 객체를 가져왔지만, 연관관계가 설정된 객체는 Lazy 설정 으로 인해 실제 값이 아닌 Proxy 객체 로 대체하는데 해당 객체에 접근할 경우 실제 데이터를 가져오기 위해 처음에 조회된 데이터 만큼 쿼리가 추가적으로 발생하는 문제 Fetch Join Lazy 설정을 무시하고 연관된 객체를 한번에 가져온다. JPQL 에서는 N + 1 문제를 해결하기 위해 fetch join 을 제공한다. fetch join 을 이용해 JPQL 을 작성하게 되면 Lazy 설정을 무시하고, Order 조회시 Member 객체와 Delivery 객체를 전부 다 가져온다. public List&lt;Order&gt; findAllWithMemberDelivery()&#123; return em.createQuery( &quot;select o from Order o&quot;+ &quot; join fetch o.member m&quot; + &quot; join fetch o.delivery d&quot;, Order.class ).getResultList();&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"JPA JPQL (Java Persistence Query Language)","slug":"jpa/jpa-programming/jpql/jpql","date":"2022-04-17T19:31:46.000Z","updated":"2024-02-18T16:19:54.529Z","comments":true,"path":"2022/04/18/jpa/jpa-programming/jpql/jpql/","link":"","permalink":"https://ckck803.github.io/2022/04/18/jpa/jpa-programming/jpql/jpql/","excerpt":"목차 JPA JPQL - Fetch Join JPA JPQL - Projection (Select) JPA JPQL (Java Persistence Query Language) JPA - 객체지향 쿼리 언어 JPQL JPQL 은 객체지향 쿼리 언어 로 테이블 을 대상으로 쿼리하는 것이 아니라 엔티티 객체 를 대상으로 쿼리한다.JPQL 은 SQL 을 추상화 해서 특정 데이터 베이스 SQL 에 의존하지 않는다. JPQL 문법 select m from Memeber as m where m.age &gt; 18 Entity 와 속성 은 대소문자 구분 O (Member, age) JPQL 키워드 는 대소문자 구분 X (select, from, where) 엔티티 이름 사용, 테이블 이름이 아님 별칭(alias) 은 필수 (m) TypeQuery, Query 반환 타입 형태에 따라 사용하는 타입이 다르다.","text":"목차 JPA JPQL - Fetch Join JPA JPQL - Projection (Select) JPA JPQL (Java Persistence Query Language) JPA - 객체지향 쿼리 언어 JPQL JPQL 은 객체지향 쿼리 언어 로 테이블 을 대상으로 쿼리하는 것이 아니라 엔티티 객체 를 대상으로 쿼리한다.JPQL 은 SQL 을 추상화 해서 특정 데이터 베이스 SQL 에 의존하지 않는다. JPQL 문법 select m from Memeber as m where m.age &gt; 18 Entity 와 속성 은 대소문자 구분 O (Member, age) JPQL 키워드 는 대소문자 구분 X (select, from, where) 엔티티 이름 사용, 테이블 이름이 아님 별칭(alias) 은 필수 (m) TypeQuery, Query 반환 타입 형태에 따라 사용하는 타입이 다르다. TypeQuery 쿼리 결과 반환 타입이 명확할 때 사용 Query 반환 타입이 명확하지 않을 때 사용한다. // Member 타입을 반환TypedQuery&lt;Member&gt; tQuery = em.createQuery(&quot;select m from Member m&quot;, Member.class);// 타입이 명확하지 않기 때문에 지정하지 않는다.// m.username : string, m.age : intQuery query = em.createQuery(&quot;select m.username, m.age from Member m&quot;); 결과 조회 API 반환 결과에 따라 getSingleResult 와 getResultList 를 선택해 사용한다. getSingleResult 결과가 정확히 하나, 단일 객체 반환 결과가 없으면 NoResultException 반환 둘 이상일 경우 NonUniqueResultException 을 반환한다. getResultList 결과가 하나 이상일 때, 리스트 반환 결과가 없으면 빈 리스트를 반환 // 쿼리 결과가 한개일 경우TypedQuery&lt;Member&gt; tQuery = em.createQuery(&quot;select m from Member m where m.username = &#x27;member1&#x27;&quot;, Member.class);Member singleResult = tQuery.getSingleResult();// 쿼리 결과가 여러개 일 경우TypedQuery&lt;Member&gt; tQuery = em.createQuery(&quot;select m from Member m&quot;, Member.class);List&lt;Member&gt; memberList = tQuery.getResultList(); 파라미터 바인딩 - 이름 기준, 위치 기준이름 기준 Parameter Binding 동적 Parameter Binding 과 유사하다. // Parameter BindingTypedQuery&lt;Member&gt; tQuery = em.createQuery(&quot;select m from Member m where m.username = :username&quot;, Member.class);tQuery.setParameter(&quot;username&quot;, &quot;member1&quot;); 위치 기준 Parameter Binding 헷깔릴 위험이 있어 이름 기준 Parameter Binding 에 비해 비 선호되는 방식 // Parameter BindingTypedQuery&lt;Member&gt; tQuery = em.createQuery(&quot;select m from Member m where m.username = ?1&quot;, Member.class);tQuery.setParameter(&quot;?1&quot;, &quot;member1&quot;); 동적 파라미터 Binding 결과 쿼리Hibernate: /* select m from Member m where m.username = :username */ select member0_.id as id1_0_, member0_.age as age2_0_, member0_.TEAM_ID as TEAM_ID4_0_, member0_.username as username3_0_ from Member member0_ where member0_.username=?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"JPA JPQL - Projection (Select)","slug":"jpa/jpa-programming/jpql/projection-select","date":"2022-04-17T19:31:46.000Z","updated":"2024-02-18T16:19:54.529Z","comments":true,"path":"2022/04/18/jpa/jpa-programming/jpql/projection-select/","link":"","permalink":"https://ckck803.github.io/2022/04/18/jpa/jpa-programming/jpql/projection-select/","excerpt":"목차 JPA JPQL - Fetch Join JPA JPQL - Projection (Select) JPA JPQL (Java Persistence Query Language) JPA - 객체지향 쿼리 언어 Projection 대상 Entity, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 타입) // Entity select m from Member m// Entity select m.team from Member m// 임베디드 타입select m.address from Member m// 스칼라 타입select m.username, m.age from Member m","text":"목차 JPA JPQL - Fetch Join JPA JPQL - Projection (Select) JPA JPQL (Java Persistence Query Language) JPA - 객체지향 쿼리 언어 Projection 대상 Entity, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 타입) // Entity select m from Member m// Entity select m.team from Member m// 임베디드 타입select m.address from Member m// 스칼라 타입select m.username, m.age from Member m","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"JPA - 객체지향 쿼리 언어","slug":"jpa/jpa-programming/jpql/object-query","date":"2022-04-17T19:31:46.000Z","updated":"2024-02-18T16:19:54.529Z","comments":true,"path":"2022/04/18/jpa/jpa-programming/jpql/object-query/","link":"","permalink":"https://ckck803.github.io/2022/04/18/jpa/jpa-programming/jpql/object-query/","excerpt":"목차 JPA JPQL - Fetch Join JPA JPQL - Projection (Select) JPA JPQL (Java Persistence Query Language) JPA - 객체지향 쿼리 언어 객체 지향 쿼리 언어 종류 JPQL JPA Criteria QueryDSL 네이티브 SQL JDBC API 직접 사용, MyBatis, SrpignjdbcTemplate 함께 사용 JPQL JPA 를 사용하면 엔티티 객체 를 중심으로 개발 문제는 검색 쿼리 검색을 할때도 테이블이 나닌 엔티티 객체 를 대상으로 검색 모든 DB 데이터를 객체로 변화해서 검색하는 것은 불가능 애플리케이션이 필요한 데이터만 DB 에서 불러오려면 결국 검색 조건인 포함된 SQL 이 필요 JPA 는 SQL 을 추상화한 JPQL 이라는 객체지향 쿼리 언어 제공 SQL 과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원 JPQL 은 엔티티 객체를 대상으로 쿼리 SQL 은 데이터 베이스 테이블을 대상으로 쿼리 public class JpaMain &#123; public static void main(String[] ars) &#123; EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = entityManagerFactory.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); try &#123; String qlString = &quot;select m from Member m where m.username like &#x27;%kim%&#x27;&quot;; List&lt;Member&gt; result = em.createQuery(qlString, Member.class) .getResultList(); &#125; catch (Exception e) &#123; transaction.rollback(); &#125; finally &#123; em.close(); &#125; entityManagerFactory.close(); &#125;&#125;","text":"목차 JPA JPQL - Fetch Join JPA JPQL - Projection (Select) JPA JPQL (Java Persistence Query Language) JPA - 객체지향 쿼리 언어 객체 지향 쿼리 언어 종류 JPQL JPA Criteria QueryDSL 네이티브 SQL JDBC API 직접 사용, MyBatis, SrpignjdbcTemplate 함께 사용 JPQL JPA 를 사용하면 엔티티 객체 를 중심으로 개발 문제는 검색 쿼리 검색을 할때도 테이블이 나닌 엔티티 객체 를 대상으로 검색 모든 DB 데이터를 객체로 변화해서 검색하는 것은 불가능 애플리케이션이 필요한 데이터만 DB 에서 불러오려면 결국 검색 조건인 포함된 SQL 이 필요 JPA 는 SQL 을 추상화한 JPQL 이라는 객체지향 쿼리 언어 제공 SQL 과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원 JPQL 은 엔티티 객체를 대상으로 쿼리 SQL 은 데이터 베이스 테이블을 대상으로 쿼리 public class JpaMain &#123; public static void main(String[] ars) &#123; EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = entityManagerFactory.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); try &#123; String qlString = &quot;select m from Member m where m.username like &#x27;%kim%&#x27;&quot;; List&lt;Member&gt; result = em.createQuery(qlString, Member.class) .getResultList(); &#125; catch (Exception e) &#123; transaction.rollback(); &#125; finally &#123; em.close(); &#125; entityManagerFactory.close(); &#125;&#125; 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리 SQL 을 추상화 해서 특정 데이터베이스 SQL 에 의존 X JPQL 을 한마디로 정의하면 객체 지향 SQL Hibernate: /* select m from Member m where m.username like &#x27;%kim%&#x27; */ select member0_.MEMBER_ID as MEMBER_I1_4_, member0_.createdBy as createdB2_4_, member0_.createdDate as createdD3_4_, member0_.lastModifiedBy as lastModi4_4_, member0_.lastModifiedDate as lastModi5_4_, member0_.TEAM_ID as TEAM_ID7_4_, member0_.USERNAME as USERNAME6_4_ from Member member0_ where member0_.USERNAME like &#x27;%kim%&#x27; Criteria 동적 쿼리를 작성하는데 쉬운 장점이 있다. 컴파일 에러가 발생하기 때문에 쉽게 파악할 수 있다는 장점이 있다. 단점은 너무 복잡하다는 문제가 있다. public class JpaMain &#123; public static void main(String[] ars) &#123; EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = entityManagerFactory.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); try &#123; CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class); Root&lt;Member&gt; m = query.from(Member.class); CriteriaQuery&lt;Member&gt; cq = query.select(m).where(cb.equal(m.get(&quot;username&quot;), &quot;kim&quot;)); List&lt;Member&gt; resultLit = em.createQuery(cq) .getResultList(); &#125; catch (Exception e) &#123; transaction.rollback(); &#125; finally &#123; em.close(); &#125; entityManagerFactory.close(); &#125;&#125; Hibernate: /* select generatedAlias0 from Member as generatedAlias0 where generatedAlias0.username=:param0 */ select member0_.MEMBER_ID as MEMBER_I1_4_, member0_.createdBy as createdB2_4_, member0_.createdDate as createdD3_4_, member0_.lastModifiedBy as lastModi4_4_, member0_.lastModifiedDate as lastModi5_4_, member0_.TEAM_ID as TEAM_ID7_4_, member0_.USERNAME as USERNAME6_4_ from Member member0_ where member0_.USERNAME=? Query DSL 소개네이티브 SQL 소개 JPA 가 제공하는 SQL 을 직접 사용하는 기능 JPQL 로 해결할 수 없는 특정 데이터베이스에 의존적인 기능 오라클 CONNECT BY 특정 DB 만 사용하는 SQL 힌트 public class JpaMain &#123; public static void main(String[] ars) &#123; EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = entityManagerFactory.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); try &#123; em.createNativeQuery(&quot;select MEMBER_ID, city, street, zipcode, USERNAME from MEMBER&quot;) .getResultList(); &#125; catch (Exception e) &#123; transaction.rollback(); &#125; finally &#123; em.close(); &#125; entityManagerFactory.close(); &#125;&#125; /* dynamic native SQL query */ select MEMBER_ID, city, street, zipcode, USERNAME from MEMBER JDBC 직접 사용, SpringJdbcTemplate 등 JPA 를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스 등을 함께 사용 가능 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요 flush 가 되는 시점 commit 을 실행했을 경우 JPA 가 Query 를 날리기 전 시점에 발생한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"Spring Batch - 배치 초기화 설정","slug":"spring/spring-batch/job/spring-batch-12-JobLauncherApplicationRunner copy","date":"2022-04-12T06:25:35.000Z","updated":"2024-02-26T15:29:13.257Z","comments":true,"path":"2022/04/12/spring/spring-batch/job/spring-batch-12-JobLauncherApplicationRunner copy/","link":"","permalink":"https://ckck803.github.io/2022/04/12/spring/spring-batch/job/spring-batch-12-JobLauncherApplicationRunner%20copy/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobLauncherApplicationRunner Spring Batch 작업을 시작하는 ApplicationRunner 로서 BatchAutoConfiguration 에서 생성된다. Spring boot 에서 제공하는 ApplicationRunner 의 구현체로 어플리케이션이 정상적으로 구동되자 마자 실행된다. Bean 으로 등록된 모든 Job 을 실행시킨다. BatchProperties Spring Batch 의 환경 설정 클래스 Job 이름, 스키마 초기화 설정, 테이블 Prefix 등의 값을 설정할 수 있다. application.properties or application.yml 파일에 설정한다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobLauncherApplicationRunner Spring Batch 작업을 시작하는 ApplicationRunner 로서 BatchAutoConfiguration 에서 생성된다. Spring boot 에서 제공하는 ApplicationRunner 의 구현체로 어플리케이션이 정상적으로 구동되자 마자 실행된다. Bean 으로 등록된 모든 Job 을 실행시킨다. BatchProperties Spring Batch 의 환경 설정 클래스 Job 이름, 스키마 초기화 설정, 테이블 Prefix 등의 값을 설정할 수 있다. application.properties or application.yml 파일에 설정한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"}],"tags":[]},{"title":"Spring Batch - 13. JobLauncher","slug":"spring/spring-batch/job/spring-batch-13-JobLauncher","date":"2022-04-12T06:25:35.000Z","updated":"2024-02-26T15:29:22.812Z","comments":true,"path":"2022/04/12/spring/spring-batch/job/spring-batch-13-JobLauncher/","link":"","permalink":"https://ckck803.github.io/2022/04/12/spring/spring-batch/job/spring-batch-13-JobLauncher/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobLauncher Batch Job 을 실행시키는 역할 Job 과 JobParameters 를 인자로 받으며 요청된 Batch 작업을 수행한 후 최종 Client 에게 JobExecution 을 반환한다. Spring Batch 가 구동 되면 JobLauncher Bean 이 자동 생성된다. JobLauncher 를 이용한 Job 실행 Spring boot Batch 에서는 JobLauncherApplicationRunner 가 자동적으로 JobLauncher 를 실행시킨다. 동기적 실행 taskExecutor 를 SyncTaskExecutor 로 설정할 경우 JobExecution 을 획득하고 배치 처리를 최종 완료한 후 Client 에게 JobExecution 을 반환한다. 스케줄러 에 의한 배치처리에 적합하다. 비 동기적 실행 taksExecutor 가 SimpleAsyncTaskExecutor 로 설정할 경우 JobExecution 을 획득한 후 Client 에게 바로 JobExecution 을 반환하고 배치처리를 완료한다. HTTP 요청 에 의한 배치처리에 적합하다. 배치 처리 시간이 길어질 경우 응답이 늦어지지 않도록 한다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobLauncher Batch Job 을 실행시키는 역할 Job 과 JobParameters 를 인자로 받으며 요청된 Batch 작업을 수행한 후 최종 Client 에게 JobExecution 을 반환한다. Spring Batch 가 구동 되면 JobLauncher Bean 이 자동 생성된다. JobLauncher 를 이용한 Job 실행 Spring boot Batch 에서는 JobLauncherApplicationRunner 가 자동적으로 JobLauncher 를 실행시킨다. 동기적 실행 taskExecutor 를 SyncTaskExecutor 로 설정할 경우 JobExecution 을 획득하고 배치 처리를 최종 완료한 후 Client 에게 JobExecution 을 반환한다. 스케줄러 에 의한 배치처리에 적합하다. 비 동기적 실행 taksExecutor 가 SimpleAsyncTaskExecutor 로 설정할 경우 JobExecution 을 획득한 후 Client 에게 바로 JobExecution 을 반환하고 배치처리를 완료한다. HTTP 요청 에 의한 배치처리에 적합하다. 배치 처리 시간이 길어질 경우 응답이 늦어지지 않도록 한다. public interface JobLauncher &#123; public JobExecution run(Job job, JobParameters jobParameters) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException;&#125; 동기적 방식JobLauncher @RestControllerpublic class JobLaunchingController &#123; @Autowired private Job job; @Autowired private JobLauncher jobLauncher; @PostMapping(value = &quot;/batch&quot;) public String launch(@RequestBody Member member) throws Exception &#123; JobParameters jobParameters = new JobParametersBuilder() .addString(&quot;id&quot;, member.getId()) .addDate(&quot;date&quot;, new Date()) .toJobParameters(); jobLauncher.run(job, jobParameters); System.out.println(&quot;Job is completed&quot;); return &quot;batch completed&quot;; &#125;&#125; 실행 결과 비 동기적 방식 SimpleJobLauncher 는 Bean 으로 생성되지 않는다. 때문에 BasicBatchConfigurer Bean 을 이용해 SimpleJobLauncher 객체를 가져오도록 한다. @RestControllerpublic class JobLaunchingController &#123; @Autowired private Job job; @Autowired private JobLauncher simpleLauncher; // 비 동기적 방식으로 실행하기 위해서는 BasicBatchConfigurer 객체가 필요 @Autowired private BasicBatchConfigurer basicBatchConfigurer; @PostMapping(value = &quot;/batch&quot;) public String launch(@RequestBody Member member) throws Exception &#123; JobParameters jobParameters = new JobParametersBuilder() .addString(&quot;id&quot;, member.getId()) .addDate(&quot;date&quot;, new Date()) .toJobParameters(); // 다음과 같이 사용할 경우 ClassCastingException 오류를 발생한다. SimpleJobLauncher jobLauncher = (SimpleJobLauncher)simpleLauncher; // BasicBatchConfigurer 로부터 SimpleJobLauncher 객체를 가져온다. SimpleJobLauncher jobLauncher = (SimpleJobLauncher) basicBatchConfigurer.getJobLauncher(); jobLauncher.setTaskExecutor(new SimpleAsyncTaskExecutor()); jobLauncher.run(job, jobParameters); System.out.println(&quot;Job is completed&quot;); return &quot;batch completed&quot;; &#125;&#125; 실행 결과","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Spring Batch - 12. JobRepository","slug":"spring/spring-batch/job/spring-batch-12-JobRepository","date":"2022-04-12T05:25:35.000Z","updated":"2024-02-26T15:29:18.511Z","comments":true,"path":"2022/04/12/spring/spring-batch/job/spring-batch-12-JobRepository/","link":"","permalink":"https://ckck803.github.io/2022/04/12/spring/spring-batch/job/spring-batch-12-JobRepository/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobRepository Batch 작업 중에 생성되거나 변경되는 메타데이터들을 저장하는 저장소 역할 JobRepository는 스프링 배치의 핵심 컴포넌트 중 하나로, Job을 실행하거나 재시작할 때 사용되는 메타데이터를 관리합니다. 이 메타데이터에는 Job의 실행 상태, Job의 실행에 필요한 파라미터, 실행 시간 등의 정보가 포함됩니다. JobRepository는 Job의 실행 상태를 추적하고, Job이 실행되는 동안 발생하는 예외를 처리하고, 재시작을 위해 이전 실행 정보를 보관합니다. Job 이 언제 수행됐고, 언제 끝났으며, 몇 번 실행됐고 실행에 대한 결과 등의 배치 작업 실행과 관련된 모든 Meta Data 를 저장한다. JobLauncher, Job, Step 구현체 내부에서 CRUD 기능을 처리한다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobRepository Batch 작업 중에 생성되거나 변경되는 메타데이터들을 저장하는 저장소 역할 JobRepository는 스프링 배치의 핵심 컴포넌트 중 하나로, Job을 실행하거나 재시작할 때 사용되는 메타데이터를 관리합니다. 이 메타데이터에는 Job의 실행 상태, Job의 실행에 필요한 파라미터, 실행 시간 등의 정보가 포함됩니다. JobRepository는 Job의 실행 상태를 추적하고, Job이 실행되는 동안 발생하는 예외를 처리하고, 재시작을 위해 이전 실행 정보를 보관합니다. Job 이 언제 수행됐고, 언제 끝났으며, 몇 번 실행됐고 실행에 대한 결과 등의 배치 작업 실행과 관련된 모든 Meta Data 를 저장한다. JobLauncher, Job, Step 구현체 내부에서 CRUD 기능을 처리한다. JobRepository 인터페이스JobRepository 인터페이스는 JobInstance 와 JobExecution 을 생성하거나 기존에 생성된 객체가 을 경우 가져와 상태를 업데이트 하는 메소드를 지원한다. public interface JobRepository &#123; boolean isJobInstanceExists(String jobName, JobParameters jobParameters); JobInstance createJobInstance(String jobName, JobParameters jobParameters); JobExecution createJobExecution(JobInstance jobInstance, JobParameters jobParameters, String jobConfigurationLocation); JobExecution createJobExecution(String jobName, JobParameters jobParameters) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException; void update(JobExecution jobExecution); void add(StepExecution stepExecution); void addAll(Collection&lt;StepExecution&gt; stepExecutions); void update(StepExecution stepExecution); void updateExecutionContext(StepExecution stepExecution); void updateExecutionContext(JobExecution jobExecution); @Nullable StepExecution getLastStepExecution(JobInstance jobInstance, String stepName); int getStepExecutionCount(JobInstance jobInstance, String stepName); @Nullable JobExecution getLastJobExecution(String jobName, JobParameters jobParameters);&#125; JobRepository 설정@EnableBatchProcessing 를 선언하면 JobRepository 가 자동으로 Bean 으로 등록됩니다. BatcConfigurer 인터페이스를 구현하거나 BasicBatchConfigurer 를 상속해서 JobRepository 설정을 커스터마이징 할 수 있습니다. JDBC 방식으로 설정 - JobRepositoryFactoryBean 내부적으로 AOP 기술을 통해 트랜잭션 처리를 해주고 있다. 트랜잭션 isolation 의 기본값은 SERIALIZEBLE 로 최고 수준, 다른 레벨 (READ_COMMITED, REPEATABLE_READ) 로 지정이 가능하다. 메타테이블의 Table Prefix 를 변경할 수 있다. In Memory 방식으로 설정 - MapJobRepositoryFactoryBean 성능 등의 이유로 도메인 오브젝트를 굳이 데이터 베이스에 저장하고 싶지 않은 경우 보통 Test 나 프로토타입의 빠른 개발이 필요할 때 사용한다. @Componentpublic class JobRepositoryListener implements JobExecutionListener &#123; @Autowired private JobRepository jobRepository; @Override public void beforeJob(JobExecution jobExecution) &#123; &#125; @Override public void afterJob(JobExecution jobExecution) &#123; String jobName = jobExecution.getJobInstance().getJobName(); JobParameters jobParameters = new JobParametersBuilder() .addString(&quot;requestDate&quot;, &quot;20210102&quot;) .toJobParameters(); JobExecution lastExecution = jobRepository.getLastJobExecution(jobName, jobParameters); if(lastExecution != null) &#123; for (StepExecution execution : lastExecution.getStepExecutions()) &#123; BatchStatus status = execution.getStatus(); System.out.println(&quot;BatchStatus = &quot; + status.isRunning()); System.out.println(&quot;BatchStatus = &quot; + status.name()); &#125; &#125; &#125;&#125; JobRepository 설정 변경 BatcConfigurer 를 구현하거나 BasicBatchConfigurer 를 상속을 통해 JobRepository 설정을 변경할 수 있다. JobRepositoryFactoryBean 을 통해 DataSource , Transaction , Isolation Level 등을 설정할 수 있다. @Configurationpublic class CustomBatchConfigurer extends BasicBatchConfigurer &#123; private final DataSource dataSource; protected CustomBatchConfigurer(BatchProperties properties, DataSource dataSource, TransactionManagerCustomizers transactionManagerCustomizers) &#123; super(properties, dataSource, transactionManagerCustomizers); this.dataSource = dataSource; &#125; @Override protected JobRepository createJobRepository() throws Exception &#123; JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean(); factory.setDataSource(dataSource); factory.setTransactionManager(getTransactionManager()); factory.setIsolationLevelForCreate(&quot;ISOLATION_READ_COMMITED&quot;); // isolation 수준을 변경한다. factory.setTablePrefix(&quot;SYSTEM_&quot;); // Spring Batch 가 사용하는 테이블 Prefix 를 설정한다. 기본값은 “BATCH_”, factory.setMaxVarCharLength(1000); // varchar 최대 길이(기본값 2500) return factory.getObject(); // Proxy 객체가 생성됨 (트랜잭션 Advice 적용 등을 위해 AOP 기술 적용) &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Spring Batch - 11. ExecutionContext","slug":"spring/spring-batch/spring-batch-11-ExecutionContext","date":"2022-04-12T03:25:35.000Z","updated":"2024-02-26T15:30:43.292Z","comments":true,"path":"2022/04/12/spring/spring-batch/spring-batch-11-ExecutionContext/","link":"","permalink":"https://ckck803.github.io/2022/04/12/spring/spring-batch/spring-batch-11-ExecutionContext/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing ExecutionContext 프레잌워크에서 유지 및 관리하는 Key&#x2F;Value 컬렉션으로 JobExecution, StepExecution 객체의 상태를 저장하는 공유 객체 DB 에 직렬화 한 값으로 저장된다. Job 재 시작시 이미 처리한 Row 데이터는 건너뛰고 이후로 수행하도록 할 때 상태 정보를 활용한다. ExecutionContext 는 Job 또는 Step 의 실행 중에 데이터를 공유하거나 저장하기 위한 메커니즘으로 JobExecution, StepExecution 및 JobParameter 와 함께 사용됩니다. ExecutionContext 는 JobExecutionContext 와 StepExecutionContext 로 구분됩니다. JobExecutionContext 는 Job 의 실행 컨텍스트를 나타내며, StepExecutionContext 는 Step 의 실행 컨텍스트를 나타냅니다. JobExecutionContext 는 모든 Step에서 공유됩니다. 그러나 StepExecutionContext 는 Step 간에 공유되지 않으며, 각 Step 에서 고유한 ExecutionContext 를 유지합니다. ExecutionContext 는 기본적으로 Map&lt;String, Object&gt; 타입으로 사용자가 직접 데이터를 추가, 수정, 삭제할 수 있습니다. 예를 들어, Job 또는 Step 실행 중에 사용자 데이터를 저장하고 싶은 경우, ExecutionContext 를 사용하여 저장할 수 있습니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing ExecutionContext 프레잌워크에서 유지 및 관리하는 Key&#x2F;Value 컬렉션으로 JobExecution, StepExecution 객체의 상태를 저장하는 공유 객체 DB 에 직렬화 한 값으로 저장된다. Job 재 시작시 이미 처리한 Row 데이터는 건너뛰고 이후로 수행하도록 할 때 상태 정보를 활용한다. ExecutionContext 는 Job 또는 Step 의 실행 중에 데이터를 공유하거나 저장하기 위한 메커니즘으로 JobExecution, StepExecution 및 JobParameter 와 함께 사용됩니다. ExecutionContext 는 JobExecutionContext 와 StepExecutionContext 로 구분됩니다. JobExecutionContext 는 Job 의 실행 컨텍스트를 나타내며, StepExecutionContext 는 Step 의 실행 컨텍스트를 나타냅니다. JobExecutionContext 는 모든 Step에서 공유됩니다. 그러나 StepExecutionContext 는 Step 간에 공유되지 않으며, 각 Step 에서 고유한 ExecutionContext 를 유지합니다. ExecutionContext 는 기본적으로 Map&lt;String, Object&gt; 타입으로 사용자가 직접 데이터를 추가, 수정, 삭제할 수 있습니다. 예를 들어, Job 또는 Step 실행 중에 사용자 데이터를 저장하고 싶은 경우, ExecutionContext 를 사용하여 저장할 수 있습니다. Spring Batch에서 ExecutionContext 를 사용하면 다음 Step 에서 이전 Step 에서 처리된 데이터를 전달하거나 Job 에서 여러 Step 에서 공유하는 데이터를 전달할 수 있습니다. ExecutionContext 를 사용하여 Job 또는 Step 간 데이터 공유를 효율적으로 관리할 수 있습니다. ExecutionContext 공유 범위 JobExecutionContext 범위 각 Job 의 JobExecution 에 저장되며 Job 간 서로 공유가 안되며 해당 Job 의 Step 간 서로 공유가 가능하다. StepExecutionContext 범위 각 Step 의 StepExecution 에 저장되며 Step 간 서로 공유가 안된다. @RequiredArgsConstructor@Configurationpublic class ExecutionContextConfiguration &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; private final ExecutionContextTasklet1 executionContextTasklet1; private final ExecutionContextTasklet2 executionContextTasklet2; private final ExecutionContextTasklet3 executionContextTasklet3; private final ExecutionContextTasklet4 executionContextTasklet4; @Bean public Job BatchJob() &#123; return this.jobBuilderFactory.get(&quot;Job&quot;) .start(step1()) .next(step2()) .next(step3()) .next(step4()) .build(); &#125; @Bean public Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(executionContextTasklet1) .build(); &#125; @Bean public Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet(executionContextTasklet2) .build(); &#125; @Bean public Step step3() &#123; return stepBuilderFactory.get(&quot;step3&quot;) .tasklet(executionContextTasklet3) .build(); &#125; @Bean public Step step4() &#123; return stepBuilderFactory.get(&quot;step4&quot;) .tasklet(executionContextTasklet4) .build(); &#125;&#125; @Componentpublic class ExecutionContextTasklet1 implements Tasklet &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; ExecutionContext jobExecutionContext = contribution.getStepExecution().getJobExecution().getExecutionContext(); ExecutionContext stepExecutionContext = contribution.getStepExecution().getExecutionContext(); String jobName = chunkContext.getStepContext().getStepExecution().getJobExecution().getJobInstance().getJobName(); String stepName = chunkContext.getStepContext().getStepExecution().getStepName(); if(jobExecutionContext.get(&quot;jobName&quot;) == null)&#123; jobExecutionContext.put(&quot;jobName&quot;, jobName); &#125; if(stepExecutionContext.get(&quot;stepName&quot;) == null) &#123; stepExecutionContext.put(&quot;stepName&quot;, stepName); &#125; System.out.println(&quot;jobName: &quot; + jobExecutionContext.get(&quot;jobName&quot;)); System.out.println(&quot;stepName: &quot; + stepExecutionContext.get(&quot;stepName&quot;)); return RepeatStatus.FINISHED; &#125;&#125; @Componentpublic class ExecutionContextTasklet2 implements Tasklet &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; ExecutionContext jobExecutionContext = chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext(); ExecutionContext stepExecutionContext = chunkContext.getStepContext().getStepExecution().getExecutionContext(); System.out.println(&quot;jobName: &quot; + jobExecutionContext.get(&quot;jobName&quot;)); System.out.println(&quot;stepName: &quot; + stepExecutionContext.get(&quot;stepName&quot;)); String stepName = chunkContext.getStepContext().getStepExecution().getStepName(); if(stepExecutionContext.get(&quot;stepName&quot;) == null) &#123; stepExecutionContext.put(&quot;stepName&quot;, stepName); &#125; return RepeatStatus.FINISHED; &#125;&#125; @Componentpublic class ExecutionContextTasklet3 implements Tasklet &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; Object name = chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext().get(&quot;name&quot;); if(name == null)&#123; chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext().put(&quot;name&quot;, &quot;user1&quot;); throw new RuntimeException(&quot;step has failed&quot;); &#125; return RepeatStatus.FINISHED; &#125;&#125; @Componentpublic class ExecutionContextTasklet4 implements Tasklet &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; System.out.println(&quot;name: &quot; + chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext().get(&quot;name&quot;)); return RepeatStatus.FINISHED; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Spring Batch - 10. StepContribution","slug":"spring/spring-batch/step/spring-batch-10-StepContribution","date":"2022-04-12T02:25:35.000Z","updated":"2024-02-26T15:30:19.407Z","comments":true,"path":"2022/04/12/spring/spring-batch/step/spring-batch-10-StepContribution/","link":"","permalink":"https://ckck803.github.io/2022/04/12/spring/spring-batch/step/spring-batch-10-StepContribution/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing StepContribution Chunk 프로세스의 변경 사항을 버퍼링 한 후 StepExecution 상태를 업데이트 하는 객체 Chunk Commit 직전에 StepExecution 의 apply 메서드를 호출해 상태르르 업데이트 한다. ExitStatus 의 기본 종료 코드 외 사용자 정의 종료 코드를 생성해서 적용할 수 있다. TaskletStep 클래스내 doInTransaction 메서드에서 StepExecution 객체를 이용해 StepContribution 객체를 생성한다. Tasklet 을 실행시킨다. TaskletStep.java","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing StepContribution Chunk 프로세스의 변경 사항을 버퍼링 한 후 StepExecution 상태를 업데이트 하는 객체 Chunk Commit 직전에 StepExecution 의 apply 메서드를 호출해 상태르르 업데이트 한다. ExitStatus 의 기본 종료 코드 외 사용자 정의 종료 코드를 생성해서 적용할 수 있다. TaskletStep 클래스내 doInTransaction 메서드에서 StepExecution 객체를 이용해 StepContribution 객체를 생성한다. Tasklet 을 실행시킨다. TaskletStep.java @Overridepublic RepeatStatus doInTransaction(TransactionStatus status) &#123; TransactionSynchronizationManager.registerSynchronization(this); RepeatStatus result = RepeatStatus.CONTINUABLE; // StepContribution 객체를 생성한다. StepContribution contribution = stepExecution.createStepContribution(); chunkListener.beforeChunk(chunkContext); oldVersion = new StepExecution(stepExecution.getStepName(), stepExecution.getJobExecution()); copy(stepExecution, oldVersion); try &#123; try &#123; try &#123; // Tasklet 을 실행시킨다. result = tasklet.execute(contribution, chunkContext); if (result == null) &#123; result = RepeatStatus.FINISHED; &#125; &#125; catch (Exception e) &#123; if (transactionAttribute.rollbackOn(e)) &#123; chunkContext.setAttribute(ChunkListener.ROLLBACK_EXCEPTION_KEY, e); throw e; &#125; &#125; &#125; finally &#123; try &#123; semaphore.acquire(); locked = true; &#125; catch (InterruptedException e) &#123; logger.error(&quot;Thread interrupted while locking for repository update&quot;); stepExecution.setStatus(BatchStatus.STOPPED); stepExecution.setTerminateOnly(); Thread.currentThread().interrupt(); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Applying contribution: &quot; + contribution); &#125; // StepContribution 결과를 StepExecution 객체내에 저장한다. stepExecution.apply(contribution); &#125; stepExecutionUpdated = true; stream.update(stepExecution.getExecutionContext()); try &#123; // Going to attempt a commit. If it fails this flag will // stay false and we can use that later. getJobRepository().updateExecutionContext(stepExecution); stepExecution.incrementCommitCount(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Saving step execution before commit: &quot; + stepExecution); &#125; getJobRepository().update(stepExecution); &#125; catch (Exception e) &#123; // If we get to here there was a problem saving the step // execution and we have to fail. String msg = &quot;JobRepository failure forcing rollback&quot;; logger.error(msg, e); throw new FatalStepExecutionException(msg, e); &#125; &#125; catch (Error e) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Rollback for Error: &quot; + e.getClass().getName() + &quot;: &quot; + e.getMessage()); &#125; rollback(stepExecution); throw e; &#125; catch (RuntimeException e) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Rollback for RuntimeException: &quot; + e.getClass().getName() + &quot;: &quot; + e.getMessage()); &#125; rollback(stepExecution); throw e; &#125; catch (Exception e) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Rollback for Exception: &quot; + e.getClass().getName() + &quot;: &quot; + e.getMessage()); &#125; rollback(stepExecution); // Allow checked exceptions throw new UncheckedTransactionException(e); &#125; return result;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"}],"tags":[]},{"title":"Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블","slug":"spring/spring-batch/step/spring-batch-09-StepExecution","date":"2022-04-12T01:25:35.000Z","updated":"2024-02-26T15:30:15.064Z","comments":true,"path":"2022/04/12/spring/spring-batch/step/spring-batch-09-StepExecution/","link":"","permalink":"https://ckck803.github.io/2022/04/12/spring/spring-batch/step/spring-batch-09-StepExecution/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing StepExecution Step 에 대한 한번의 시도를 의미하는 객체로서 Step 실행 중에 발생한 정보들을 저장하고 있는 객체BATCH_STEP_EXECUTION 테이블과 매핑된다. StepExecution 객체는 Step 이 매번 시도될 때마다 각 Step 별로 생성되며 JobRepository 를 통해 저장됩니다. 이를 통해 실행 중인 Step의 정보를 추적하고, 필요한 경우 실행을 재개하거나 롤백할 수 있습니다. Job 이 재시작 하더라도 이미 성공적으로 완료된 Step 은 재 실행되지 않고 실패한 Step 만 실행됩니다. 이전 단계 Step 이 실패해서 현재 Step 을 실행하지 않는다면 StepExecetoin 객체를 생성하지 않는다. StepExecution 인터페이스public interface StepExecution &#123; public long getStepExecutionId(); public String getStepName(); public BatchStatus getBatchStatus(); public Date getStartTime(); public Date getEndTime(); public String getExitStatus(); public Serializable getPersistentUserData(); public Metric[] getMetrics();&#125;","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing StepExecution Step 에 대한 한번의 시도를 의미하는 객체로서 Step 실행 중에 발생한 정보들을 저장하고 있는 객체BATCH_STEP_EXECUTION 테이블과 매핑된다. StepExecution 객체는 Step 이 매번 시도될 때마다 각 Step 별로 생성되며 JobRepository 를 통해 저장됩니다. 이를 통해 실행 중인 Step의 정보를 추적하고, 필요한 경우 실행을 재개하거나 롤백할 수 있습니다. Job 이 재시작 하더라도 이미 성공적으로 완료된 Step 은 재 실행되지 않고 실패한 Step 만 실행됩니다. 이전 단계 Step 이 실패해서 현재 Step 을 실행하지 않는다면 StepExecetoin 객체를 생성하지 않는다. StepExecution 인터페이스public interface StepExecution &#123; public long getStepExecutionId(); public String getStepName(); public BatchStatus getBatchStatus(); public Date getStartTime(); public Date getEndTime(); public String getExitStatus(); public Serializable getPersistentUserData(); public Metric[] getMetrics();&#125; JobExecution 과의 관계 Step 의 StepExecution 이 모두 정상적으로 완료 되어야 JobExecution 이 정상적으로 완료된다. Step 의 StepExecution 중 하나라도 실패하면 JobExecution 은 실패한다. Job &amp; Step 이해하기 Job 과 JobParamter 를 이용해 JobInstance 를 생성 후 실행시 JobExecution 을 생성한다. JobExecution 이 실행되면 각 Step 별로 StepExecution 이 생성된다. 같은 Job 내 StepExecution 의 Job 정보는 동일하다. 각 Step 별로 관리되는 값은 서로 상이하다. StepExecution 이 모두 COMPLETED 로 완료된 결우 JobExecution 상태도 COMPLETED 로 완료된다. StepExecution 이 하나라도 FAILED 로 끝날 경우 JobExecution 상태는 FAILED 상태가 된다. @RequiredArgsConstructor@Configurationpublic class StepExecutionConfiguration &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; @Bean public Job BatchJob() &#123; return this.jobBuilderFactory.get(&quot;Job&quot;) .start(step1()) .next(step2()) .build(); &#125; @Bean public Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; System.out.println(&quot;step1 has executed&quot;); return RepeatStatus.FINISHED; &#125; &#125;) .build(); &#125; @Bean public Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; System.out.println(&quot;step2 has executed&quot;); return RepeatStatus.FINISHED; &#125;) .build(); &#125; /* @Bean public Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(executionContextTasklet1) .build(); &#125; @Bean public Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet(executionContextTasklet2) .build(); &#125; @Bean public Step step3() &#123; return stepBuilderFactory.get(&quot;step3&quot;) .tasklet(executionContextTasklet3) .build(); &#125;*/&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"}],"tags":[]},{"title":"Spring Batch - 08. Step","slug":"spring/spring-batch/step/spring-batch-08-Step","date":"2022-04-12T00:25:35.000Z","updated":"2024-02-26T15:30:11.748Z","comments":true,"path":"2022/04/12/spring/spring-batch/step/spring-batch-08-Step/","link":"","permalink":"https://ckck803.github.io/2022/04/12/spring/spring-batch/step/spring-batch-08-Step/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing Step Batch Job 을 구성하는 독립적인 하나의 단계로서 실제 배치 처리를 정의하고 컨트롤하는 데 필요한 모든 정보를 가지고 있는 도메인 객체 단순한 단일 테스크 뿐 아리나 입력, 처리 그리고 출력과 관련된 복잡한 비즈니스 로직을 포함하는 모든 설정들을 담고 있다. 배치 작업을 어떻게 구성하고 실행할 것인지 Job 의 세부 작업을 Task 기반으로 설정하고 명세해 놓은 객체 모든 Job 은 하나 이상의 step 으로 구성된다. Step은 하나 이상의 Batch 작업을 수행하는 논리적인 단위입니다. 각 Step은 하나의 Tasklet 또는 하나 이상의 Reader, Processor 및 Writer 구성 요소를 포함할 수 있습니다. Reader는 데이터 소스에서 데이터를 읽고 Processor는 읽어온 데이터를 가공하고 Writer는 가공된 데이터를 결과 저장소에 씁니다. 이러한 구성 요소는 일련의 스텝으로 연결되어 Batch 작업의 흐름을 제어합니다. Step은 각 스텝의 실행 전&#x2F;후에 수행해야 할 작업을 처리하기 위한 Tasklet도 지원합니다. 예를 들어, 스텝이 실행되기 전에 데이터베이스 테이블을 비워야 하는 경우, 이러한 작업을 Tasklet에 포함시킬 수 있습니다. Spring Batch는 스텝 간에 데이터를 공유하는 방법도 제공합니다. 이를 통해 하나의 스텝이 처리한 결과를 다음 스텝에서 사용할 수 있습니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing Step Batch Job 을 구성하는 독립적인 하나의 단계로서 실제 배치 처리를 정의하고 컨트롤하는 데 필요한 모든 정보를 가지고 있는 도메인 객체 단순한 단일 테스크 뿐 아리나 입력, 처리 그리고 출력과 관련된 복잡한 비즈니스 로직을 포함하는 모든 설정들을 담고 있다. 배치 작업을 어떻게 구성하고 실행할 것인지 Job 의 세부 작업을 Task 기반으로 설정하고 명세해 놓은 객체 모든 Job 은 하나 이상의 step 으로 구성된다. Step은 하나 이상의 Batch 작업을 수행하는 논리적인 단위입니다. 각 Step은 하나의 Tasklet 또는 하나 이상의 Reader, Processor 및 Writer 구성 요소를 포함할 수 있습니다. Reader는 데이터 소스에서 데이터를 읽고 Processor는 읽어온 데이터를 가공하고 Writer는 가공된 데이터를 결과 저장소에 씁니다. 이러한 구성 요소는 일련의 스텝으로 연결되어 Batch 작업의 흐름을 제어합니다. Step은 각 스텝의 실행 전&#x2F;후에 수행해야 할 작업을 처리하기 위한 Tasklet도 지원합니다. 예를 들어, 스텝이 실행되기 전에 데이터베이스 테이블을 비워야 하는 경우, 이러한 작업을 Tasklet에 포함시킬 수 있습니다. Spring Batch는 스텝 간에 데이터를 공유하는 방법도 제공합니다. 이를 통해 하나의 스텝이 처리한 결과를 다음 스텝에서 사용할 수 있습니다. Spring Batch에서는 JobLauncher를 사용하여 Batch 작업을 실행합니다. JobLauncher는 Job을 실행하고 Job은 하나 이상의 Step을 포함합니다. Step은 각각의 Batch 작업을 실행하고 결과를 제공합니다. 따라서 Spring Batch에서 Step은 Batch 작업의 핵심적인 구성 요소 중 하나이며, 데이터를 처리하고 흐름을 제어하는 데 중요한 역할을 합니다. Step 인터페이스public interface Step &#123; static final String STEP_TYPE_KEY = &quot;batch.stepType&quot;; String getName(); boolean isAllowStartIfComplete(); int getStartLimit(); void execute(StepExecution stepExecution) throws JobInterruptedException;&#125; Step 기본 구현체 TaskletStep 가장 기본이 되는 클래스로 Tasklet 타입의 구현체들을 제어한다. PartitionStep 멀티 스레드 방식으로 Step 을 여러개로 분리해 실행한다. JobStep Step 내에서 Job 을 실행하도록 한다. FlowStep Step 내에서 Flow 를 실행하도록 한다. Step 생성 @RequiredArgsConstructor@Configurationpublic class StepConfiguration &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; @Bean public Job BatchJob() &#123; return this.jobBuilderFactory.get(&quot;Job&quot;) .start(step1()) .next(step2()) .build(); &#125; @Bean public Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; System.out.println(&quot;step1 has executed&quot;); return RepeatStatus.FINISHED; &#125; &#125;) .build(); &#125; @Bean public Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; System.out.println(&quot;step2 has executed&quot;); return RepeatStatus.FINISHED; &#125;) .build(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"}],"tags":[]},{"title":"Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블","slug":"spring/spring-batch/job/spring-batch-07-JobExecution","date":"2022-04-11T23:25:35.000Z","updated":"2024-02-26T15:29:09.290Z","comments":true,"path":"2022/04/12/spring/spring-batch/job/spring-batch-07-JobExecution/","link":"","permalink":"https://ckck803.github.io/2022/04/12/spring/spring-batch/job/spring-batch-07-JobExecution/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobExecution Job 실행 중에 발생한 정보들을 저장하고 있는 객체, JobInstance 에 대한 시도를 의미하는 객체로서 1:N 의 관계를 갖는다.BATCH_JOB_EXECUTION 테이블과 매핑되고 로서 JobInstance 에 대한 성공 &#x2F; 실패 내역을 관리한다. JobExecution 객체는 JobInstance 가 실행될 때 마다 생성됩니다. JobExecution 객체는 Job 의 실행 결과 FAILED 또는 COMPLETED 등의 값을 관리합니다. JobExecution 의 실행 결과가 COMPLETED 면 JobInstance 실행이 완료된 것으로 간주해 동일한 JobParameter 를 이용한 재실행이 불가능합니다. JobExecution 의 실행 결과가 FAILED 면 JobInstance 실행이 완료되지 않은 것으로 간주해 동일한 JobParameter 를 이용한 재실행이 가능합니다. 또한, JobExecution 의 실행 결과가 COMPLETED 될 때까지 하나의 JobInstance 내에서 여러 번의 시도가 생길 수 있다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobExecution Job 실행 중에 발생한 정보들을 저장하고 있는 객체, JobInstance 에 대한 시도를 의미하는 객체로서 1:N 의 관계를 갖는다.BATCH_JOB_EXECUTION 테이블과 매핑되고 로서 JobInstance 에 대한 성공 &#x2F; 실패 내역을 관리한다. JobExecution 객체는 JobInstance 가 실행될 때 마다 생성됩니다. JobExecution 객체는 Job 의 실행 결과 FAILED 또는 COMPLETED 등의 값을 관리합니다. JobExecution 의 실행 결과가 COMPLETED 면 JobInstance 실행이 완료된 것으로 간주해 동일한 JobParameter 를 이용한 재실행이 불가능합니다. JobExecution 의 실행 결과가 FAILED 면 JobInstance 실행이 완료되지 않은 것으로 간주해 동일한 JobParameter 를 이용한 재실행이 가능합니다. 또한, JobExecution 의 실행 결과가 COMPLETED 될 때까지 하나의 JobInstance 내에서 여러 번의 시도가 생길 수 있다. @RequiredArgsConstructor@Configurationpublic class JobExecutionConfiguration &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; @Bean public Job BatchJob() &#123; return this.jobBuilderFactory.get(&quot;Job&quot;) .start(step1()) .next(step2()) .build(); &#125; @Bean public Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; JobExecution jobExecution = contribution.getStepExecution().getJobExecution(); System.out.println(&quot;jobExecution = &quot; + jobExecution); System.out.println(&quot;step1 has executed&quot;); return RepeatStatus.FINISHED; &#125; &#125;) .build(); &#125; @Bean public Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet((contribution, chunkContext) -&gt; &#123;// throw new RuntimeException(&quot;JobExecution has failed&quot;); System.out.println(&quot;step2 has executed&quot;); return RepeatStatus.FINISHED; &#125;) .build(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블","slug":"spring/spring-batch/job/spring-batch-06-JobParameter","date":"2022-04-11T22:25:35.000Z","updated":"2024-02-26T15:29:05.980Z","comments":true,"path":"2022/04/12/spring/spring-batch/job/spring-batch-06-JobParameter/","link":"","permalink":"https://ckck803.github.io/2022/04/12/spring/spring-batch/job/spring-batch-06-JobParameter/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobParameter Job 을 실행할 때 함께 포함돼 사용되는 파라미터를 가진 도메인 객체 하나의 Job 에 존재할 수 있는 여러개의 JobInstancee 를 구분하기 위한 용도 JobParameter 와 JobInstance 는 1:1 관계다. JobParameter 생성 방법 BATCH_JOB_EXECUTION_PARAM 테이블과 매핑된다. 어플리케이션 실행 시 주입 Java -jar LogBatch.jar requestDate&#x3D;20220101 코드로 실행 JobParameterBuilder, DefaultJobParametersConverter SpEL 이용 @Value(“#{jobParameter[requestDate]}”), @JobScopre, @StepScope 선언 필수 외부에서 전달하는 값이 표현식에 전달돼 저장된다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobParameter Job 을 실행할 때 함께 포함돼 사용되는 파라미터를 가진 도메인 객체 하나의 Job 에 존재할 수 있는 여러개의 JobInstancee 를 구분하기 위한 용도 JobParameter 와 JobInstance 는 1:1 관계다. JobParameter 생성 방법 BATCH_JOB_EXECUTION_PARAM 테이블과 매핑된다. 어플리케이션 실행 시 주입 Java -jar LogBatch.jar requestDate&#x3D;20220101 코드로 실행 JobParameterBuilder, DefaultJobParametersConverter SpEL 이용 @Value(“#{jobParameter[requestDate]}”), @JobScopre, @StepScope 선언 필수 외부에서 전달하는 값이 표현식에 전달돼 저장된다. @Componentpublic class JobParameterTest implements ApplicationRunner &#123; @Autowired JobLauncher jobLauncher; @Autowired Job job; @Override public void run(ApplicationArguments args) throws Exception &#123; JobParameters jobParameters = new JobParametersBuilder().addString(&quot;name&quot;, &quot;user1&quot;) .addString(&quot;name&quot;, &quot;user1&quot;) .addLong(&quot;seq&quot;, 1L) .addDate(&quot;date&quot;, new Date()) .addDouble(&quot;age&quot;, 16.5) .toJobParameters(); jobLauncher.run(job, jobParameters); &#125;&#125; StepContribution 클래스내 StepExecution 클래스내 JobExecution 클래스에서 JobParameters 객체를 관리한다. ChunkContext 클래스를 통해서는 Map 객체 로 JobParameters 를 얻어올 수 있다. JobParameters 객체에서 Type 별로 Key 값을 주면 Value 를 얻을 수 있다. @RequiredArgsConstructor@Configurationpublic class JobParameterConfiguration &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; @Bean public Job BatchJob() &#123; return this.jobBuilderFactory.get(&quot;Job&quot;) .start(step1()) .next(step2()) .build(); &#125; @Bean public Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; JobParameters jobParameters = contribution.getStepExecution().getJobParameters(); String name = jobParameters.getString(&quot;name&quot;); long seq = jobParameters.getLong(&quot;seq&quot;); Date date = jobParameters.getDate(&quot;date&quot;); System.out.println(&quot;===========================&quot;); System.out.println(&quot;name:&quot; + name); System.out.println(&quot;seq: &quot; + seq); System.out.println(&quot;date: &quot; + date); System.out.println(&quot;===========================&quot;); Map&lt;String, Object&gt; jobParameters2 = chunkContext.getStepContext().getJobParameters(); String name2 = (String)jobParameters2.get(&quot;name&quot;); long seq2 = (long)jobParameters2.get(&quot;seq&quot;); System.out.println(&quot;step1 has executed&quot;); return RepeatStatus.FINISHED; &#125; &#125;) .build(); &#125; @Bean public Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; System.out.println(&quot;step1 has executed&quot;); return RepeatStatus.FINISHED; &#125; &#125;) .build(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블","slug":"spring/spring-batch/job/spring-batch-05-JobInstance","date":"2022-04-11T14:25:35.000Z","updated":"2024-02-26T15:29:01.770Z","comments":true,"path":"2022/04/11/spring/spring-batch/job/spring-batch-05-JobInstance/","link":"","permalink":"https://ckck803.github.io/2022/04/11/spring/spring-batch/job/spring-batch-05-JobInstance/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobInstance 생성 및 실행 JobInstance란 Job에 JobParameters가 전달되어 만들어지는 실행가능한 논리적 작업 단위 객체이다. JobInstance 는 JobLauncher 가 샐행될 때 생성된다. JobLauncher 가 실행될 때는 새로운 JobInstance 생성 하거나 기존에 생성된 JobInstance 를 반환한다. 처음 시작하는 Job, JobParameter 일 경우 새로운 JobInstance 가 생성된다. 이전과 동일한 Job, JobParameter 로 실행 할 경우 이미 존재하는 JobInstance 를 반환한다. 내부적으로 JobName 과 JobKey 를 갖고 JobInstance 객체를 얻는다. Job 과 JobInstance 와의 관계는 1:N 관계를 갖는다. BATCH_JOB_INSTANCE 테이블과 매핑 JOB_NAME(Job) 과 JOB_KEY(JobParamter 해시값) 이 동일한 데이터는 중복해서 저장할 수 없다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobInstance 생성 및 실행 JobInstance란 Job에 JobParameters가 전달되어 만들어지는 실행가능한 논리적 작업 단위 객체이다. JobInstance 는 JobLauncher 가 샐행될 때 생성된다. JobLauncher 가 실행될 때는 새로운 JobInstance 생성 하거나 기존에 생성된 JobInstance 를 반환한다. 처음 시작하는 Job, JobParameter 일 경우 새로운 JobInstance 가 생성된다. 이전과 동일한 Job, JobParameter 로 실행 할 경우 이미 존재하는 JobInstance 를 반환한다. 내부적으로 JobName 과 JobKey 를 갖고 JobInstance 객체를 얻는다. Job 과 JobInstance 와의 관계는 1:N 관계를 갖는다. BATCH_JOB_INSTANCE 테이블과 매핑 JOB_NAME(Job) 과 JOB_KEY(JobParamter 해시값) 이 동일한 데이터는 중복해서 저장할 수 없다. JobRepository 는 Job 실행중에 발생하는 메타 데이터를 DB 에 저장하는 역할을 거친다. Job 을 실행할 때 넘겨진 Job 과 JobParameter 값을 갖고 DB 에 확인하는 역할을 한다. Job 이 처음 실행하는 Job 인지 확인한다. 처음 실행하는 Job 이면 새로운 JobInstance 를 반환한다. 존재하는 값이면 기존 JobInstance 를 반환한다. 더 이상 Job 이 실행되지 않고 JobInstanceAlreadyCompleteException 예외를 반환한다. @RequiredArgsConstructor@Configurationpublic class JobInstanceConfiguration &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; @Bean public Job BatchJob() &#123; return this.jobBuilderFactory.get(&quot;Job&quot;) .start(step1()) .next(step2()) .build(); &#125; @Bean public Step step1() &#123; return stepBuilderFactory.get(&quot;step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; JobInstance jobInstance = contribution.getStepExecution().getJobExecution().getJobInstance(); System.out.println(&quot;jobInstance.getId() : &quot; + jobInstance.getId()); System.out.println(&quot;jobInstance.getInstanceId() : &quot; + jobInstance.getInstanceId()); System.out.println(&quot;jobInstance.getJobName() : &quot; + jobInstance.getJobName()); System.out.println(&quot;jobInstance.getJobVersion : &quot; + jobInstance.getVersion()); return RepeatStatus.FINISHED; &#125; &#125;) .build(); &#125; @Bean public Step step2() &#123; return stepBuilderFactory.get(&quot;step2&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; System.out.println(&quot;step2 has executed&quot;); return RepeatStatus.FINISHED; &#125;) .build(); &#125;&#125; ApplicationRunner 를 구현한 JobRunner 를 이용해 Job 을 실행시키도록 한다. Job 과 JobParameter 객체를 생성해 JobLauncher 를 실행하도록 한다. @Componentpublic class JobRunner implements ApplicationRunner &#123; @Autowired private JobLauncher jobLauncher; @Autowired private Job job; @Override public void run(ApplicationArguments args) throws Exception &#123; JobParameters jobParameters = new JobParametersBuilder() .addString(&quot;name&quot;, &quot;user1&quot;)// .addDate(&quot;reqDate&quot;, new Date()) .toJobParameters(); jobLauncher.run(job,jobParameters); &#125;&#125; spring.batch.job.enabled 를 false 로 설정함으로써 Spring boot 에서 자동으로 실행시키지 않도록 한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"}],"tags":[]},{"title":"Spring Batch - 04. JobLauncher","slug":"spring/spring-batch/job/spring-batch-04-JobLauncher","date":"2022-04-11T14:25:35.000Z","updated":"2024-02-26T15:28:57.286Z","comments":true,"path":"2022/04/11/spring/spring-batch/job/spring-batch-04-JobLauncher/","link":"","permalink":"https://ckck803.github.io/2022/04/11/spring/spring-batch/job/spring-batch-04-JobLauncher/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobLauncher JobLauncher 인터페이스는 Job 을 실행시키는 역할을 한다 JobLauncher 는 Job 과 JobParameter 객체를 이용해 Job 을 실행한 후 JobExecution 객체를 반환합니다. JobLauncher를 사용하여 Job을 실행하면 Spring Batch가 Job의 모든 단계를 처리하고, 각 단계에서 발생한 모든 예외를 처리합니다. 또한 Job의 실행 상태를 추적하고 Job의 진행 상황 및 결과를 보고합니다. Spring Batch는 다양한 유형의 JobLauncher를 제공합니다. 각 JobLauncher는 다른 방식으로 Job을 실행하고 반환하는 JobExecution 객체의 속성이 다를 수 있습니다. 일반적으로 Spring Batch에서는 SimpleJobLauncher를 사용하여 Job을 실행합니다. SimpleJobLauncher는 가장 간단한 방식으로 Job을 실행하고 JobExecution 객체를 반환합니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing JobLauncher JobLauncher 인터페이스는 Job 을 실행시키는 역할을 한다 JobLauncher 는 Job 과 JobParameter 객체를 이용해 Job 을 실행한 후 JobExecution 객체를 반환합니다. JobLauncher를 사용하여 Job을 실행하면 Spring Batch가 Job의 모든 단계를 처리하고, 각 단계에서 발생한 모든 예외를 처리합니다. 또한 Job의 실행 상태를 추적하고 Job의 진행 상황 및 결과를 보고합니다. Spring Batch는 다양한 유형의 JobLauncher를 제공합니다. 각 JobLauncher는 다른 방식으로 Job을 실행하고 반환하는 JobExecution 객체의 속성이 다를 수 있습니다. 일반적으로 Spring Batch에서는 SimpleJobLauncher를 사용하여 Job을 실행합니다. SimpleJobLauncher는 가장 간단한 방식으로 Job을 실행하고 JobExecution 객체를 반환합니다. Spring Batch는 JobLauncher를 사용하여 대량의 데이터를 처리하고 실패한 작업을 자동으로 재시작하고 작업의 상태를 추적하고 각 작업의 결과를 보고하는 등의 기능을 제공합니다. JobLauncher.java public interface JobLauncher &#123; public JobExecution run(Job job, JobParameters jobParameters) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"}],"tags":[]},{"title":"Thread Safe","slug":"computer-science/os/thread/thread-safe","date":"2022-04-10T18:16:13.000Z","updated":"2024-03-03T05:21:48.825Z","comments":true,"path":"2022/04/11/computer-science/os/thread/thread-safe/","link":"","permalink":"https://ckck803.github.io/2022/04/11/computer-science/os/thread/thread-safe/","excerpt":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) Thread Safe 란?Thread 는 프로세스와 다르게 프로세스 내부에서 할당 받은 자원을 공유 한다. 멀티 쓰레드 환경에서 한번에 공유 자원에 접근하는 Race Condition 이 발생해도 올바른 실행 결과가 나오게 보장함을 의미한다. Thread Safe 를 지키는 방법 Re-entrancy 어떤 함수가 한 스레드에 의해 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다. Thread Local Storage 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는다. 이 방식은 동기화 방법과 관련되어 있고, 또한 공유상태를 피할 수 없을 때 사용하는 방식이다. Mutual Exclusion Thread에 Lock, Semaphore, Mutex 를 걸어서 공유자원에는 하나의 thread만 접근 가능하게 한다. Atomic operations 데이터 변경시 atomic하게 데이터에 접근하도록 만듭니다. Immutable Object 자바의 Final 처럼 객체를 생성한 후 수정이 불가능 하게 한다. Thread 동기화 실행 순서 에 따른 동기화 메모리 접근 에 대한 동기화 실행 순서에 따른 동기화 쓰레드의 실행 순서를 정하고 정해진 순서에 따라 작업을 처리하도록 한다.","text":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) Thread Safe 란?Thread 는 프로세스와 다르게 프로세스 내부에서 할당 받은 자원을 공유 한다. 멀티 쓰레드 환경에서 한번에 공유 자원에 접근하는 Race Condition 이 발생해도 올바른 실행 결과가 나오게 보장함을 의미한다. Thread Safe 를 지키는 방법 Re-entrancy 어떤 함수가 한 스레드에 의해 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다. Thread Local Storage 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는다. 이 방식은 동기화 방법과 관련되어 있고, 또한 공유상태를 피할 수 없을 때 사용하는 방식이다. Mutual Exclusion Thread에 Lock, Semaphore, Mutex 를 걸어서 공유자원에는 하나의 thread만 접근 가능하게 한다. Atomic operations 데이터 변경시 atomic하게 데이터에 접근하도록 만듭니다. Immutable Object 자바의 Final 처럼 객체를 생성한 후 수정이 불가능 하게 한다. Thread 동기화 실행 순서 에 따른 동기화 메모리 접근 에 대한 동기화 실행 순서에 따른 동기화 쓰레드의 실행 순서를 정하고 정해진 순서에 따라 작업을 처리하도록 한다. 메모리 접근에 대한 동기화 공용 메모리에 하나의 Thread 만 접근이 가능하도록 해 Thread safe 를 실현한다. 동기화 기법유저 모드 동기화 (User Mode Synchronize) 동기화가 진행되는 과정에서 커널 의 힘을 빌리지 않는 동기화 기법이다. 따라서 동기화를 위해서 커널 모드 로의 전환이 불필요해 성능상의 이점이 있다. 그러나 그만큼 기능상의 제한도 있다. 크리티컬 섹션 기반의 동기화, 인터락 함수 기반의 동기화 커널 모드 동기화 (Kernel Mode Synchronize) 커널에서 제공하는 동기화 기능을 활용하는 방법이다. 따라서 동기화에 관련된 함수가 호출될 때마다 커널 모드로의 변경이 필요하고, 성능 저하로 이어지게 된다. 하지만 그만큼 유저 모드 동기화에서 제공하지 못하는 기능을 제공받을 수 있다. 뮤텍스 기반의 동기화, 세마포어 기반의 동기화, 이름있는 뮤텍스 기반의 프로세스 동기화, 이벤트 기반의 동기화","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"tags":[]},{"title":"Spring Batch - 03. Job","slug":"spring/spring-batch/job/spring-batch-03-Job","date":"2022-04-10T14:25:35.000Z","updated":"2024-02-26T15:28:53.334Z","comments":true,"path":"2022/04/10/spring/spring-batch/job/spring-batch-03-Job/","link":"","permalink":"https://ckck803.github.io/2022/04/10/spring/spring-batch/job/spring-batch-03-Job/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing Job 이란 Batch 계층 구조에서 가장 상위에 있는 개념으로 하나의 Batch 작업 자체를 의미한다. Job Configuration 을 통해 생성되는 객체 단위로서 Batch 작업을 어떻게 구성하고 실행할지를 명세해 놓은 객체 Batch Job 을 구성하기 위한 최상위 인터페이스며 Spring Batch 가 기본 구현체를 제공한다. 여러 Step 을 포함하는 컨테이너로서 반드시 한개 이상의 Step 으로 구성돼야 한다. Spring Batch에서 Job은 하나 이상의 Step으로 구성된 일련의 작업 흐름을 정의하는 개념입니다. Job은 일괄 처리 작업의 논리적인 단위이며, 배치 작업을 실행하는데 필요한 모든 정보를 포함합니다. Job은 일괄 처리 작업을 실행하는데 필요한 다양한 설정을 제공합니다. 예를 들어, Job은 어떤 Step이 실행되어야 하는지, 어떤 파라미터를 사용해야 하는지, 어떤 예외 상황에 대처해야 하는지 등의 정보를 포함합니다. 또한 Job은 실행 순서, 종료 조건, 중지&#x2F;재시작 가능 여부 등의 작업 흐름을 제어하는 데 사용됩니다. Spring Batch에서 Job은 JobBuilderFactory를 사용하여 생성됩니다. JobBuilderFactory는 JobBuilder 객체를 생성하고, 이를 사용하여 Job을 구성합니다. JobBuilder 객체를 사용하여 Job의 이름, 작업 수행에 필요한 Step, 파라미터 등을 정의할 수 있습니다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing Job 이란 Batch 계층 구조에서 가장 상위에 있는 개념으로 하나의 Batch 작업 자체를 의미한다. Job Configuration 을 통해 생성되는 객체 단위로서 Batch 작업을 어떻게 구성하고 실행할지를 명세해 놓은 객체 Batch Job 을 구성하기 위한 최상위 인터페이스며 Spring Batch 가 기본 구현체를 제공한다. 여러 Step 을 포함하는 컨테이너로서 반드시 한개 이상의 Step 으로 구성돼야 한다. Spring Batch에서 Job은 하나 이상의 Step으로 구성된 일련의 작업 흐름을 정의하는 개념입니다. Job은 일괄 처리 작업의 논리적인 단위이며, 배치 작업을 실행하는데 필요한 모든 정보를 포함합니다. Job은 일괄 처리 작업을 실행하는데 필요한 다양한 설정을 제공합니다. 예를 들어, Job은 어떤 Step이 실행되어야 하는지, 어떤 파라미터를 사용해야 하는지, 어떤 예외 상황에 대처해야 하는지 등의 정보를 포함합니다. 또한 Job은 실행 순서, 종료 조건, 중지&#x2F;재시작 가능 여부 등의 작업 흐름을 제어하는 데 사용됩니다. Spring Batch에서 Job은 JobBuilderFactory를 사용하여 생성됩니다. JobBuilderFactory는 JobBuilder 객체를 생성하고, 이를 사용하여 Job을 구성합니다. JobBuilder 객체를 사용하여 Job의 이름, 작업 수행에 필요한 Step, 파라미터 등을 정의할 수 있습니다. Spring Batch에서 Job은 JobRepository에 저장됩니다. JobRepository는 Job의 실행 상태, 실행 시간 등의 정보를 관리하고, 작업이 성공적으로 완료되었는지, 실패했는지 등의 상태를 추적합니다. Spring Batch에서 Job은 JobLauncher를 사용하여 실행됩니다. JobLauncher는 JobRepository를 사용하여 Job을 실행하고, 실행 결과를 반환합니다. Job을 실행할 때는 JobParameters를 전달하여 Job을 구성할 수 있습니다. Spring Batch에서 Job은 대규모 데이터 처리 작업을 일괄적으로 처리하는데 사용되며, 작업의 실행, 모니터링, 실패한 작업 처리, 작업 재시작 등의 기능을 제공합니다. Job 의 구성 하나의 Job은 여러개의 Step 으로 구성돼 있고, 하나의 Step 내에서는 여러개의 tasklet 을 가질 수 있다. Job은 단일 작업 또는 여러 단계 작업을 수행할 수 있으며, 각 단계는 하나 이상의 스텝으로 구성됩니다. 예를 들어, 데이터베이스에서 데이터를 추출하고 가공한 후 결과를 다시 데이터베이스에 로드하는 작업을 정의할 수 있습니다. 이러한 작업은 여러 스텝으로 구성될 수 있습니다. 첫 번째 스텝은 데이터베이스에서 데이터를 추출하는 것이며, 두 번째 스텝은 추출된 데이터를 처리하는 것이며, 마지막 스텝은 처리된 데이터를 데이터베이스에 로드하는 것입니다. Job 인터페이스public interface Job &#123; String getName(); boolean isRestartable(); void execute(JobExecution execution); @Nullable JobParametersIncrementer getJobParametersIncrementer(); JobParametersValidator getJobParametersValidator();&#125; Spring Batch Job 기본 구현체Spring Batch 는 대표적인 Job 의 구현체로 SimpleJob 과 FlowJob 을 제공합니다. SimpleJob 순차적 으로 Step 을 실행시키는 Job 모든 Job 에서 사용할 수 있는 표준 기능을 가지고 있다. FlowJob 특정한 조건 과 흐름 에 따라 Step 을 구성해 실행시키는 Job Flow 객체를 실행시켜서 작업을 진행한다. 코드 예시@Configuration@RequiredArgsConstructor@Slf4jpublic class HelloJobConfiguration &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; @Bean public Job helloJob() &#123; return jobBuilderFactory.get(&quot;Hello Job&quot;) .start(helloStep1()) .next(helloStep2()) .build(); &#125; public Step helloStep1() &#123; return stepBuilderFactory.get(&quot;Hello Step1&quot;) .tasklet(new Tasklet() &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; log.info(&quot; ========================&quot;); log.info(&quot; &gt;&gt; Hello Spring Batch!!&quot;); log.info(&quot; ========================&quot;); return RepeatStatus.FINISHED; &#125; &#125; ).build(); &#125; public Step helloStep2() &#123; return stepBuilderFactory.get(&quot;Hello Step2&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; log.info(&quot; ========================&quot;); log.info(&quot; &gt;&gt; Hello Spring Batch2!!&quot;); log.info(&quot; ========================&quot;); return RepeatStatus.FINISHED; &#125;).build(); &#125;&#125; BatchAutoConfigurationBatchAutoConfiguration 에서는 JobLauncherApplicationRunner 를 이용해 Job 을 실행 시킨다. BatchAutoConfiguration.java public JobLauncherApplicationRunner jobLauncherApplicationRunner(JobLauncher jobLauncher, JobExplorer jobExplorer, JobRepository jobRepository, BatchProperties properties) &#123; JobLauncherApplicationRunner runner = new JobLauncherApplicationRunner(jobLauncher, jobExplorer, jobRepository); String jobNames = properties.getJob().getNames(); if (StringUtils.hasText(jobNames)) &#123; runner.setJobNames(jobNames); &#125; return runner;&#125; JobLauncherApplicationRunnerJobLauncherApplicationRunner 는 JobLauncher 객체를 이용해 Job 과 Parameter 를 받아 Job 을 실행시킨다. JobLauncherApplicationRunner protected void execute(Job job, JobParameters jobParameters) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException, JobParametersNotFoundException &#123; JobParameters parameters = this.getNextJobParameters(job, jobParameters); JobExecution execution = this.jobLauncher.run(job, parameters); if (this.publisher != null) &#123; this.publisher.publishEvent(new JobExecutionEvent(execution)); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"}],"tags":[]},{"title":"Spring Batch - 02. Batch 에서 사용하는 Table","slug":"spring/spring-batch/spring-batch-02-batch-table","date":"2022-04-10T13:25:35.000Z","updated":"2024-02-26T15:30:39.599Z","comments":true,"path":"2022/04/10/spring/spring-batch/spring-batch-02-batch-table/","link":"","permalink":"https://ckck803.github.io/2022/04/10/spring/spring-batch/spring-batch-02-batch-table/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing Spring Batch 메타 데이터 스프링 배치의 실행 및 관리를 위한 목적으로 여러 도메인들(Job, Step, JobParameters 등) 의 정보들을 저장, 업데이트, 조회할 수 있는 스키마 를 제공한다. 과거, 현재의 실행에 대한 세세한 정보, 실행에 대한 성공과 실패 여부등을 일목요연하게 관리함으로서 배치운용에 있어 리스크 발생시 빠른 대처 가능 DB 와 연동할 경우 필수적으로 메타 테이블이 생성 돼야 함 스키마 생성 설정 수동 생성 : 쿼리 복사 후 직접 실행 자동 생성 - spring.batch.jdbc.initialize-schema 설정 ALWAYS 스크립트 항상 실행 RDBMS 설정이 돼 있을 경우 내장 DB 보다 우선적으로 실행 EMBEDDED (기본 값) 내장 DB 일 때만 실행되며 스키마가 자동 생성됨 NEBER 스크립트가 항상 실행 안된다. 내장 DB 일 경우 스크립트가 생성이 안되기 때문에 오류가 발생 운영에서는 수동으로 스크립트 생성 후 설정하는 것을 권장 # ALWAYS 로 설정spring.batch.jdbc.initialize-schema: always# EMBEDED 로 설정spring.batch.jdbc.initialize-schema: embedded# NEVER 로 설정spring.batch.jdbc.initialize-schema: never","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing Spring Batch 메타 데이터 스프링 배치의 실행 및 관리를 위한 목적으로 여러 도메인들(Job, Step, JobParameters 등) 의 정보들을 저장, 업데이트, 조회할 수 있는 스키마 를 제공한다. 과거, 현재의 실행에 대한 세세한 정보, 실행에 대한 성공과 실패 여부등을 일목요연하게 관리함으로서 배치운용에 있어 리스크 발생시 빠른 대처 가능 DB 와 연동할 경우 필수적으로 메타 테이블이 생성 돼야 함 스키마 생성 설정 수동 생성 : 쿼리 복사 후 직접 실행 자동 생성 - spring.batch.jdbc.initialize-schema 설정 ALWAYS 스크립트 항상 실행 RDBMS 설정이 돼 있을 경우 내장 DB 보다 우선적으로 실행 EMBEDDED (기본 값) 내장 DB 일 때만 실행되며 스키마가 자동 생성됨 NEBER 스크립트가 항상 실행 안된다. 내장 DB 일 경우 스크립트가 생성이 안되기 때문에 오류가 발생 운영에서는 수동으로 스크립트 생성 후 설정하는 것을 권장 # ALWAYS 로 설정spring.batch.jdbc.initialize-schema: always# EMBEDED 로 설정spring.batch.jdbc.initialize-schema: embedded# NEVER 로 설정spring.batch.jdbc.initialize-schema: never JOB 관련 테이블Spring Batch 에서 Job 관련 메타데이터를 저장하기 위해 BATCH_JOB_INSTANCE, BATCH_JOB_EXECUTION, BATCH_JOB_EXECUTION_PARAMS, BATCH_JOB_EXECUTION_CONTEXT 4개의 테이블이 생성됩니다. BATCH_JOB_INSTANCE Job 이 실행될 때 생성되는 JobInstance 관련 정보 저장하는 테이블 job_name 과 job_key 를 키로 하여 하나의 데이터가 저장된다. 동일한 job_name 과 job_key 로 중복 저장될 수 없다. BATCH_JOB_EXECUTION Job 의 실행 상태를 관리하는 JobExecution 정보를 저장한다. job 의 실행정보가 저장되며 Job 의 생성, 시작시간, 종료시간, 실행 상태, 메시지등을 저장하는 테이블 BATCH_JOB_INSTANCE 테이블과 BATCH_JOB_EXECUTION 테이블은 1:N 관계를 가지고 있다. BATCH_JOB_EXECUTION 테이블 컬럼 Column 설명 특징 JOB_EXECUTION_ID BATCH_JOB_EXECUTION 의 기본 키 VERSION 업데이트 될때마다 1씩 증가 JOB_INSTANCE_ID JOB_INSTANCE 의 키 값을 저장한다. CREATE_TIME JOB_EXECUTION 이 생성된 시간을 저장한다. START_TIME JOB_EXECUTION 이 시작된 시간을 저장한다. END_TIME JOB_EXECUTION 의 종료 시간을 저장 Job 실행 도중 중단 되면 값이 저장되지 않을 수 있다 (null) STATUS JOB_EXECUTION 의 실행 상태를 저장한다. COMPLETED, FAILED, STOPPED 등 EXIT_CODE JOB_EXECUTION 의 실행 종료 코드를 저장한다 COMPLETED, FAILED 등 EXIT_MESSAGE STATUS 가 FAIL 일 경우 실패 원인 내용을 저장한다. LAST_UPDATED 마지막 실행 시점을 TIMESTAMP 로 저장한다. BATCH_JOB_EXECUTION_PARAMS Job 과 함께 실행되는 JobParameter 정보를 저장한다. BATCH_JOB_EXECUTION 와 BATCH_JOB_EXECUTION_PARAMS 관계는 1:N 의 관계를 갖는다. BATCH_JOB_EXECUTION_PARAMS 테이블 컬럼 Column 설명 특징 JOB_EXECUTION_ID BATCH_JOB_EXECUTION 테이블 KEY 값을 저장 1:N 관계 TYPE_CD String, Long, Double 등의 타입 정보를 저장 KEY_NAME Parameter Key 값 STRING_VAL Parameter 문자 값 DATE_VAL Parameter 날짜 값 LONG_VAL Parameter LONG 값 DOUBLE_VAL Parameter DOUBLE 값 IDENTIFYING 식별여부 (TRUE, FALSE) BATCH_JOB_EXECUTION_CONTEXT Job 의 실행동안 여러가지 상태정보, 공유 데이터를 직렬화 해서 저장 Step 간 서로 공유가 가능하다. BATCH_JOB_EXECUTION 와 BATCH_JOB_EXECUTION_CONTEXT 관계는 1:N 의 관계를 갖는다. BATCH_JOB_EXECUTION_CONTEXT 테이블 컬럼 Column 설명 특징 JOB_EXECUTION_ID BATCH_JOB_EXECUTION 테이블 KEY 값을 저장 JOB_EXECUTION 마다 생성된다. SHORT_CONTEXT JOB 의 실행 상태 정보, 공유 데이터등의 정보를 문자열로 저장 SERIALIZED_CONTEXT 직렬화(SERIALIZED) 된 전체 Context STEP 관련 테이블Spring Batch 에서 Step 관련 메타데이터를 저장하기 위해 BATCH_STEP_EXECUTION, BATCH_STEP_EXECUTION_CONTEXT 2개의 테이블이 생성됩니다. BATCH_STEP_EXECUTION Step 의 실행정보가 저장되며 생성, 시작시간, 종료시간, 실행상태, 메시지 등을 저장하는 테이블 BATCH_JOB_EXECUTION 테이블과 BATCH_STEP_EXECUTION 테이블은 1:N 관계를 갖는다. BATCH_STEP_EXECUTION 테이블 컬럼 Column 설명 특징 STEP_EXECUTION_ID Step 의 실행 정보를 고유하게 식별할 수 있는 Key VERSION Update 될때마다 1씩 증가 STEP_NAME Step 을 구성할 때 부여하는 Step 이름 JOB_EXECUTION_ID JobExecution 기본 키 JobExecution 과는 1:N 관계 START_TIME BATCH_JOB_EXECUTION 의 시작 시간 END_TIME BATCH_JOB_EXECUTION 의 종료 시간 STATUS BATCH_JOB_EXECUTION 의 상태 정보 COMMIT_COUNT 트랜잭션 당 Commit 되는 Count READ_COUNT 실행 시점에 READ 한 ITEM 수를 Count FILTER_COUNT 실행 시점에 FILTER 된 ITEM 수를 Count WRITE_COUNT 실행 시점에 저장하고 수정된 ITEM 수를 Count READ_SKIP_COUNT 실행 도중 READ 가 SKIP 된 ITEM 수를 Count WRITE_SKIP_COUNT 실행 도중 WRITE 가 SKIP 된 ITEM 수를 Count PROCESS_SKIP_COUNT 실행 도중 PROCESS 가 SKIP 된 ITEM 수를 Count ROLLBACK_COUNT 실행 도중 ROLLBACK 된 ITEM 수를 Count EXIT_CODE 실행 종료 코드를 저장한다. EXIT_MESSAGE STATUS 가 실패일 경우 실패 원인을 저장한다. LAST_UPDATED 마지막 실행 시점을 TIMESTAMP 로 저장한다. BATCH_STEP_EXECUTION_CONTEXT Step의 실행동안 여러가지 상태 정보, 공유 데이터를 직렬화 해서 저장 BATCH_JOB_EXECUTION_CONTEXT 와는 다르게 Step 별로 저장되며 Step 간 서로 공유 할 수 없음 BATCH_STEP_EXECUTION_CONTEXT 테이블 컬럼 Column 설명 특징 STEP_EXECUTION_ID StepExecution 식별 키 STEP_EXECUTION 마다 생성 SHORT_CONTEXT Step 의 실행 상태 및 정보들을 문자열로 저장한다. SERIALIZED_CONTEXT 직렬화(SERIALIZED) 된 전체 Context","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Spring Batch - 01. @EnableBatchProcessing","slug":"spring/spring-batch/spring-batch-01-EnableBatchProcessing","date":"2022-04-09T14:25:35.000Z","updated":"2024-02-26T15:30:35.933Z","comments":true,"path":"2022/04/09/spring/spring-batch/spring-batch-01-EnableBatchProcessing/","link":"","permalink":"https://ckck803.github.io/2022/04/09/spring/spring-batch/spring-batch-01-EnableBatchProcessing/","excerpt":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing @EnableBatchProcessing @EnableBatchProcessing 을 이용해 어플리케이션이 Spring Batch 로 실행될 수 있도록 자동으로 설정해준다. @SpringBootApplication@EnableBatchProcessing // Spring Batch 활성화public class SpringBatchApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBatchApplication.class, args); &#125;&#125; Spring Batch 초기화 과정@EnableBatchProcessing 을 명시해주면 Batch 관련 설정 클래스 SimpleBatchConfiguration, BatchConfigurerConfiguration, BatchAutoConfiguration 를 실행시켜 Spring Batch 초기화 및 실행 구성이 이뤄진다.","text":"출처 해당 포스트는 정수원 강사님의 스프링 배치 - Spring Boot 기반으로 개발하는 Spring Batch 강의를 바탕으로 작성 됐습니다. 목차 Spring Batch - 14. 배치 초기화 설정 (application.properties) Spring Batch - 13. JobLauncher Spring Batch - 12. JobRepository Spring Batch - 11. ExecutionContext Spring Batch - 10. StepContribution Spring Batch - 09. StepExecution 와 STEP_EXECUTION 테이블 Spring Batch - 08. Step Spring Batch - 07. JobExecution 와 JOB_EXECUTION 테이블 Spring Batch - 06. JobParameter 와 JOB_EXECUTION_PARAM 테이블 Spring Batch - 05. JobInstance 와 JOB_INSTANCE 테이블 Spring Batch - 04. JobLauncher Spring Batch - 03. Job Spring Batch - 02. Batch 에서 사용하는 Table Spring Batch - 01. @EnableBatchProcessing @EnableBatchProcessing @EnableBatchProcessing 을 이용해 어플리케이션이 Spring Batch 로 실행될 수 있도록 자동으로 설정해준다. @SpringBootApplication@EnableBatchProcessing // Spring Batch 활성화public class SpringBatchApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBatchApplication.class, args); &#125;&#125; Spring Batch 초기화 과정@EnableBatchProcessing 을 명시해주면 Batch 관련 설정 클래스 SimpleBatchConfiguration, BatchConfigurerConfiguration, BatchAutoConfiguration 를 실행시켜 Spring Batch 초기화 및 실행 구성이 이뤄진다. SimpleBatchConfiguration SimpleBatchConfiguration은 Spring Batch에서 배치 처리를 위한 기본 설정 을 제공하는 클래스 SimpleBatchConfiguration 클래스는 SimpleBatchConfigurer 클래스에서 설정한 값을 기반으로 배치 처리를 위한 JobRepository, JobLauncher, JobExplorer 등을 설정합니다. JobBuilderFactory 와 StepBuilderFactory 를 생성한다. SimpleBatchConfiguration.java @Configuration(proxyBeanMethods = false)public class SimpleBatchConfiguration extends AbstractBatchConfiguration &#123; @Autowired private ApplicationContext context; private boolean initialized = false; private AtomicReference&lt;JobRepository&gt; jobRepository = new AtomicReference&lt;&gt;(); private AtomicReference&lt;JobLauncher&gt; jobLauncher = new AtomicReference&lt;&gt;(); private AtomicReference&lt;JobRegistry&gt; jobRegistry = new AtomicReference&lt;&gt;(); private AtomicReference&lt;PlatformTransactionManager&gt; transactionManager = new AtomicReference&lt;&gt;(); private AtomicReference&lt;JobExplorer&gt; jobExplorer = new AtomicReference&lt;&gt;(); @Override @Bean public JobRepository jobRepository() throws Exception &#123; return createLazyProxy(jobRepository, JobRepository.class); &#125; @Override @Bean public JobLauncher jobLauncher() throws Exception &#123; return createLazyProxy(jobLauncher, JobLauncher.class); &#125; @Override @Bean public JobRegistry jobRegistry() throws Exception &#123; return createLazyProxy(jobRegistry, JobRegistry.class); &#125; @Override @Bean public JobExplorer jobExplorer() &#123; return createLazyProxy(jobExplorer, JobExplorer.class); &#125; @Override @Bean public PlatformTransactionManager transactionManager() throws Exception &#123; return createLazyProxy(transactionManager, PlatformTransactionManager.class); &#125; private &lt;T&gt; T createLazyProxy(AtomicReference&lt;T&gt; reference, Class&lt;T&gt; type) &#123; ProxyFactory factory = new ProxyFactory(); factory.setTargetSource(new ReferenceTargetSource&lt;&gt;(reference)); factory.addAdvice(new PassthruAdvice()); factory.setInterfaces(new Class&lt;?&gt;[] &#123; type &#125;); @SuppressWarnings(&quot;unchecked&quot;) T proxy = (T) factory.getProxy(); return proxy; &#125; protected void initialize() throws Exception &#123; if (initialized) &#123; return; &#125; BatchConfigurer configurer = getConfigurer(context.getBeansOfType(BatchConfigurer.class).values()); jobRepository.set(configurer.getJobRepository()); jobLauncher.set(configurer.getJobLauncher()); transactionManager.set(configurer.getTransactionManager()); jobRegistry.set(new MapJobRegistry()); jobExplorer.set(configurer.getJobExplorer()); initialized = true; &#125; private class PassthruAdvice implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; return invocation.proceed(); &#125; &#125; private class ReferenceTargetSource&lt;T&gt; extends AbstractLazyCreationTargetSource &#123; private AtomicReference&lt;T&gt; reference; public ReferenceTargetSource(AtomicReference&lt;T&gt; reference) &#123; this.reference = reference; &#125; @Override protected Object createObject() throws Exception &#123; initialize(); return reference.get(); &#125; &#125;&#125; BatchConfigurerConfiguration BatchConfigurerConfiguration 은 Spring Batch 에서 배치 처리를 위한 데이터베이스 연결, 트랜잭션 관리 등을 수행하는 BatchConfigurer 를 설정하는 자동 구성 클래스 BatchConfigurerConfiguration 클래스는 JdbcBatchConfiguration 와 JpaBatchConfiguration 두개의 정적 클래스를 제공한다. JdbcBatchConfiguration JdbcBatchConfiguration은 JDBC 기반의 데이터베이스 연동을 처리 JdbcBatchConfiguration 은 Spring Batch에서 JDBC 기반의 데이터베이스 연동을 위해 사용됩니다. 이 클래스는 JobRepository, TransactionManager, DataSource, JobLauncher 등을 설정합니다. JdbcBatchConfiguration 은 H2 데이터베이스를 사용하여 JobRepository를 생성합니다. 따라서 개발자가 H2 데이터베이스를 사용하지 않고 다른 데이터베이스를 사용하려면, JdbcBatchConfiguration 클래스를 상속받아 새로운 설정 클래스를 작성해야 합니다. JdbcBatchConfiguration 는 BasicBatchConfigurer 객체를 생성하고 Bean 으로 등록하기 때문에 필요할때 의존성 주입을 통해 BasicBatchConfigurer 객체를 사용할 수 있다. BasicBatchConfigurerBasicBatchConfigurer 객체는 SimpleBatchConfiguration 에서 생성한 프록시 객체의 실제 대상 객체를 생성한다. BasicBatchConfigurer는 Batch의 다양한 구성 요소를 구성하는 데 사용됩니다. 예를 들어, JobRepository, JobLauncher, TaskExecutor 등의 구성 요소를 구성합니다. 또한, BasicBatchConfigurer는 필요한 데이터베이스 연결 정보를 설정하고, 트랜잭션 관리를 위한 트랜잭션 매니저를 구성하는 등의 일을 처리합니다. Spring Batch에서는 개발자가 직접 BasicBatchConfigurer를 상속하여 필요한 Batch 환경을 구성할 수도 있습니다. 이를 통해, 개발자는 Batch Job의 실행 시나리오에 맞게 Batch 환경을 유연하게 구성할 수 있습니다. BasicBatchConfigurer는 일반적으로 SimpleBatchConfiguration을 기반으로 구현됩니다. SimpleBatchConfiguration은 가장 기본적인 Batch 환경을 구성하는 클래스이며, 모든 Batch 구성 요소를 메모리 내 데이터 저장소를 사용하여 구성합니다. 이러한 메모리 내 데이터 저장소는 단순한 Batch 작업을 테스트하거나, 개발 단계에서 사용하기 적합합니다. 하지만, 실제 운영 환경에서는 데이터베이스를 사용하여 Batch 작업을 구성하는 것이 좋습니다. JpaBatchConfiguration JpaBatchConfiguration은 JPA 기반의 데이터베이스 연동을 처리 JpaBatchConfiguration 은 Spring Batch에서 JPA 기반의 데이터베이스 연동을 위해 사용됩니다. 이 클래스는 JobRepository, TransactionManager, EntityManagerFactory, JobLauncher 등을 설정합니다. JpaBatchConfiguration 은 Hibernate JPA 구현체를 사용하여 EntityManagerFactory 를 생성합니다. 따라서 개발자가 다른 JPA 구현체를 사용하려면, JpaBatchConfiguration 클래스를 상속받아 새로운 설정 클래스를 작성해야 합니다. JpaBatchConfiguration 는 JpaBatchConfigurer 객체를 생성하고 Bean 으로 등록한다. JpaBatchConfigurerJpaBatchConfigurer 는 BasicBatchConfigurer 를 상속받아 구현한 클래스로 JPA 관련 객체를 설정하는 설정 클래스다. JpaBatchConfigurer는 Batch 환경을 구성하는 데 사용됩니다. 이를 위해, JpaBatchConfigurer는 EntityManagerFactory, JpaTransactionManager, JpaJobRepository 등의 구성 요소를 구성합니다. 또한, 데이터베이스 연결 정보와 JPA 설정을 구성하고, 필요한 빈을 등록합니다. JpaBatchConfigurer는 일반적으로 DefaultBatchConfigurer를 상속하여 구현됩니다. DefaultBatchConfigurer는 가장 기본적인 Batch 환경을 구성하는 클래스이며, 모든 Batch 구성 요소를 기본값으로 구성합니다. JpaBatchConfigurer는 이러한 DefaultBatchConfigurer를 상속하여, JPA를 사용하여 Batch 작업을 구성할 수 있도록 확장한 것입니다. JpaBatchConfigurer를 사용하면, 개발자는 JPA를 사용하여 Batch 작업을 쉽게 구성할 수 있습니다. 또한, JPA를 사용하므로서 데이터베이스와의 매핑 작업이 간단해지며, 유지보수성이 향상됩니다. BatchConfigurerConfiguration.java @ConditionalOnClass(PlatformTransactionManager.class)@ConditionalOnBean(DataSource.class)@ConditionalOnMissingBean(BatchConfigurer.class)@Configuration(proxyBeanMethods = false)class BatchConfigurerConfiguration &#123; @Configuration(proxyBeanMethods = false) @ConditionalOnMissingBean(name = &quot;entityManagerFactory&quot;) static class JdbcBatchConfiguration &#123; @Bean BasicBatchConfigurer batchConfigurer(BatchProperties properties, DataSource dataSource, @BatchDataSource ObjectProvider&lt;DataSource&gt; batchDataSource, ObjectProvider&lt;TransactionManagerCustomizers&gt; transactionManagerCustomizers) &#123; return new BasicBatchConfigurer(properties, batchDataSource.getIfAvailable(() -&gt; dataSource), transactionManagerCustomizers.getIfAvailable()); &#125; &#125; @Configuration(proxyBeanMethods = false) @ConditionalOnClass(EntityManagerFactory.class) @ConditionalOnBean(name = &quot;entityManagerFactory&quot;) static class JpaBatchConfiguration &#123; @Bean JpaBatchConfigurer batchConfigurer(BatchProperties properties, DataSource dataSource, @BatchDataSource ObjectProvider&lt;DataSource&gt; batchDataSource, ObjectProvider&lt;TransactionManagerCustomizers&gt; transactionManagerCustomizers, EntityManagerFactory entityManagerFactory) &#123; return new JpaBatchConfigurer(properties, batchDataSource.getIfAvailable(() -&gt; dataSource), transactionManagerCustomizers.getIfAvailable(), entityManagerFactory); &#125; &#125;&#125; BatchAutoConfiguration 스프링 배치가 초기화 될때 자동으로 실행되는 설정 클래스 Job 을 실행하는 JobLauncherApplicationRunner Bean 을 생성한다. BatchConfigurationSelector BatchConfigurationSelector 클래스를 @EnableBatchProcessing 에 의해 Bean 으로 등록을 한다. BatchConfigurationSelector 클래스 내부에서는 modular Key 여부에 따라 ModularBatchConfiguration 혹은 SimpleBatchConfiguration 를 스프링 빈으로 등록한다. BatchConfigurationSelector.java public class BatchConfigurationSelector implements ImportSelector &#123; public BatchConfigurationSelector() &#123; &#125; public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; Class&lt;?&gt; annotationType = EnableBatchProcessing.class; AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(annotationType.getName(), false)); Assert.notNull(attributes, String.format(&quot;@%s is not present on importing class &#x27;%s&#x27; as expected&quot;, annotationType.getSimpleName(), importingClassMetadata.getClassName())); String[] imports; // modular Key 여부에 따라 ModularBatchConfiguration 혹은 SimpleBatchConfiguration 를 스프링 빈으로 등록 if (attributes.containsKey(&quot;modular&quot;) &amp;&amp; attributes.getBoolean(&quot;modular&quot;)) &#123; imports = new String[]&#123;ModularBatchConfiguration.class.getName()&#125;; &#125; else &#123; imports = new String[]&#123;SimpleBatchConfiguration.class.getName()&#125;; &#125; return imports; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"}],"tags":[]},{"title":"Spring Data JPA - Convertor","slug":"spring/spring-data-jpa/11-spring-data-jpa-convertor","date":"2022-04-05T10:39:59.000Z","updated":"2024-02-26T15:37:34.221Z","comments":true,"path":"2022/04/05/spring/spring-data-jpa/11-spring-data-jpa-convertor/","link":"","permalink":"https://ckck803.github.io/2022/04/05/spring/spring-data-jpa/11-spring-data-jpa-convertor/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 BooleanToYNConverterBoolean 으로 저장 되는 값을 True, false 로 변경해 값을 저장하기 위한 Convertor @Converterpublic class BooleanToYNConverter implements AttributeConverter&lt;Boolean, String&gt; &#123; @Override public String convertToDatabaseColumn(Boolean attribute)&#123; return (attribute != null &amp;&amp; attribute) ? &quot;Y&quot; : &quot;N&quot;; &#125; @Override public Boolean convertToEntityAttribute(String dbData)&#123; return &quot;Y&quot;.equals(dbData); &#125;&#125; @Entity@Getter@Builder@NoArgsConstructor@AllArgsConstructor@EntityListeners(AuditingEntityListener.class)public class Post extends BaseEntity&#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column private Long id; @Column(name = &quot;POST_TITLE&quot;, length = 100, nullable = false) private String title; @Column(name = &quot;POST_SUBTITLE&quot;) private String subTitle; @Lob private String content; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;username&quot;, nullable = false, referencedColumnName = &quot;username&quot;) @CreatedBy private UserInfo author; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;CATEGORY&quot;, nullable = true, referencedColumnName = &quot;CATEGORY_NAME&quot;) private Category category; @Column(name = &quot;isDeleted&quot;) @ColumnDefault(&quot;false&quot;) @Convert(converter = BooleanToYNConverter.class) private boolean isDeleted; // ==== 연관관계 편의 메서드 ==== // public void changeCategory(Category category)&#123; this.category = category; // 새로운 카테고리에 해당 포스트 추가 category.getPosts().add(this); &#125; public void setAuthor(UserInfo author)&#123; this.author = author; author.getPosts().add(this); &#125; public Post updatePost(Post post) &#123; this.title = post.title; this.subTitle = post.subTitle; this.content = post.content; changeCategory(post.getCategory()); return this; &#125;&#125;","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 BooleanToYNConverterBoolean 으로 저장 되는 값을 True, false 로 변경해 값을 저장하기 위한 Convertor @Converterpublic class BooleanToYNConverter implements AttributeConverter&lt;Boolean, String&gt; &#123; @Override public String convertToDatabaseColumn(Boolean attribute)&#123; return (attribute != null &amp;&amp; attribute) ? &quot;Y&quot; : &quot;N&quot;; &#125; @Override public Boolean convertToEntityAttribute(String dbData)&#123; return &quot;Y&quot;.equals(dbData); &#125;&#125; @Entity@Getter@Builder@NoArgsConstructor@AllArgsConstructor@EntityListeners(AuditingEntityListener.class)public class Post extends BaseEntity&#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column private Long id; @Column(name = &quot;POST_TITLE&quot;, length = 100, nullable = false) private String title; @Column(name = &quot;POST_SUBTITLE&quot;) private String subTitle; @Lob private String content; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;username&quot;, nullable = false, referencedColumnName = &quot;username&quot;) @CreatedBy private UserInfo author; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;CATEGORY&quot;, nullable = true, referencedColumnName = &quot;CATEGORY_NAME&quot;) private Category category; @Column(name = &quot;isDeleted&quot;) @ColumnDefault(&quot;false&quot;) @Convert(converter = BooleanToYNConverter.class) private boolean isDeleted; // ==== 연관관계 편의 메서드 ==== // public void changeCategory(Category category)&#123; this.category = category; // 새로운 카테고리에 해당 포스트 추가 category.getPosts().add(this); &#125; public void setAuthor(UserInfo author)&#123; this.author = author; author.getPosts().add(this); &#125; public Post updatePost(Post post) &#123; this.title = post.title; this.subTitle = post.subTitle; this.content = post.content; changeCategory(post.getCategory()); return this; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"Spring boot - 메시지 국제화 MessageSource","slug":"spring/spring-framework/springboot-messageresource","date":"2022-03-30T19:31:46.000Z","updated":"2024-02-26T16:06:34.799Z","comments":true,"path":"2022/03/31/spring/spring-framework/springboot-messageresource/","link":"","permalink":"https://ckck803.github.io/2022/03/31/spring/spring-framework/springboot-messageresource/","excerpt":"목차 Post not found: spring-boot/spring-framework/springboot-actuator Post not found: spring-boot/spring-framework/springboot-messageresource Post not found: spring-boot/spring-framework/configuration/springboot-WebMvcConfigurer Post not found: spring-boot/spring-framework/configuration/springboot-autoconfiguration 참고 https://gist.github.com/dlxotn216/cb9fe1e40c7961da9d7147d9ebc876d6 메시지 관리를 위한 MessageSource어플리케이션 개발을 진행하다가 보면 메시지를 보낼때 하드 코딩으로 넣다 보면 같은 맥략으로 쓰인 메시지들이 서로 상이하게 관리되는 것을 느낄 수 있었고 무엇보다 가장 큰 문제는 메시지를 변경하게 될 경우 해당 메시지가 사용된 소스를 전부 찾아 변경해 줘야 하는 문제점이 있다. 이런 메시지 파편화를 막고 한 곳에서 모든 메시지를 관리할 수 있도록 Spring 에서는 MessageSource 를 제공한다. MessageSource 메시지를 한 파일 message.properties 에서 관리할 수 있다. 경로 : main&#x2F;resource&#x2F;message.properties 메시지에 대한 다국어 처리 를 지원한다. 사용법 : message_[언어코드].properties 영어 : message_en.properties 한국어 : message_ko.properties 메시지 등록 경로 : main&#x2F;resource&#x2F;message.properties","text":"목차 Post not found: spring-boot/spring-framework/springboot-actuator Post not found: spring-boot/spring-framework/springboot-messageresource Post not found: spring-boot/spring-framework/configuration/springboot-WebMvcConfigurer Post not found: spring-boot/spring-framework/configuration/springboot-autoconfiguration 참고 https://gist.github.com/dlxotn216/cb9fe1e40c7961da9d7147d9ebc876d6 메시지 관리를 위한 MessageSource어플리케이션 개발을 진행하다가 보면 메시지를 보낼때 하드 코딩으로 넣다 보면 같은 맥략으로 쓰인 메시지들이 서로 상이하게 관리되는 것을 느낄 수 있었고 무엇보다 가장 큰 문제는 메시지를 변경하게 될 경우 해당 메시지가 사용된 소스를 전부 찾아 변경해 줘야 하는 문제점이 있다. 이런 메시지 파편화를 막고 한 곳에서 모든 메시지를 관리할 수 있도록 Spring 에서는 MessageSource 를 제공한다. MessageSource 메시지를 한 파일 message.properties 에서 관리할 수 있다. 경로 : main&#x2F;resource&#x2F;message.properties 메시지에 대한 다국어 처리 를 지원한다. 사용법 : message_[언어코드].properties 영어 : message_en.properties 한국어 : message_ko.properties 메시지 등록 경로 : main&#x2F;resource&#x2F;message.properties Key, Value 형식으로 메시지를 등록해 사용할 수 있다. 값을 동적으로 받아 Message 를 띄우고 싶을 경우 {0}, {1} 형식으로 argument 를 받을 수 있다. created.message=Successfully &#123;0&#125; is created MessageSource 인터페이스MessageSource 객체를 사용해 message.properties 에 저장된 Message 를 읽어올 수 있다. public interface MessageSource &#123; @Nullable String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale); String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException; String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException;&#125; MessageSource Bean 생성ResourceBundleMessageSource 를 이용해 Resource 에 저장된 message.properties 파일을 읽어온 후 MessageSource Bean 을 만들어준다. @Beanpublic MessageSource messageSource()&#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename(&quot;messages&quot;); // 메시지 리소스 번들 지정 messageSource.setDefaultEncoding(&quot;UTF-8&quot;); // 문자 Encoding 설정 return messageSource;&#125; application.properties 를 이용한 등록Java Code 를 이용해 MessageSource Bean 을 등록할 수 있지만 Spring Boot 의 경우 MessageSource 빈을 자동으로 등록해준다.(default name &#x3D; messages) 또한, Application.properties 를 이용해 추가적인 설정을 해줄 수 있다. spring.messages.basename=messages,config.i18n.messages MessageSource 를 이용해 메시지 사용하기 MessageSource 객체내 getMessage 메소드를 이용해 등록된 메시지를 사용할 수 있다. getMessage 첫번째 값은 등록된 key 값, 두번째 값은 전달하고자 하는 argument 값, 세번째 값은 다국어 처리를 위한 Locale 정보다. @RequestMapping(&quot;/api/auth&quot;)@RestController@RequiredArgsConstructorpublic class AuthController &#123; private final UserInfoService userInfoService; private final MessageSource messageSource; @PostMapping(&quot;/signup&quot;) public ResponseEntity registerUser(@RequestBody RequestRegisterUser registerUser) &#123; registerUser.setPassword(registerUser.getPassword()); UserInfo userinfo = userInfoService.saveUser(registerUser); return new ResponseEntity(messageSource.getMessage(&quot;created.message&quot;, new String[]&#123;&quot;User Account&quot;&#125;, null), HttpStatus.OK); &#125; @GetMapping(&quot;/logout&quot;) public void logout() &#123; &#125;&#125; MessageSource ErrorMessageSource 에 등록되지 않은 메시지를 조회하게 될 경우 NoSuchMessageException 예외가 발생한다. @Testpublic void MessageFailTest()&#123; assertThatThrownBy(() -&gt; &#123; messageSource.getMessage(&quot;code&quot;, null, null); &#125;).isInstanceOf(NoSuchMessageException.class);&#125; LocaleResolver 인터페이스 Spring 은 Locale 정보를 읽어올 수 있게 LocalResolver 라는 인터페이스를 제공한다. LocalResolver 객체를 이용해 Locale 객체가 만들어 지면 해당 객체를 이용해 LocaleContext 객체가 만들어지고 LocaleContextHolder 라는 저장소에 저장된다. LocaleContextHolder 은 LocaleContext 를 ThreadLocal 을 이용해 관리하기 때문에 Thread Safe 하게 Locale 정보를 저장할 수 있다. public interface LocaleResolver &#123; Locale resolveLocale(HttpServletRequest request); void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale);&#125; AcceptHeaderLocaleResolver Accept Header 기반으로 Locale 정보를 읽어오는 Resolver LocaleResolver 의 대표적인 구현체는 Request Header 로부터 Locale 정보를 읽어오는 AcceptHeaderLocaleResolver 가 있다. AcceptHeaderLocaleResolver 객체는 LocaleContextHolder 에 Locale 정보를 저장하지 않는다. @Overridepublic Locale resolveLocale(HttpServletRequest request) &#123; Locale defaultLocale = getDefaultLocale(); if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) &#123; return defaultLocale; &#125; Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = getSupportedLocales(); if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) &#123; return requestLocale; &#125; Locale supportedLocale = findSupportedLocale(request, supportedLocales); if (supportedLocale != null) &#123; return supportedLocale; &#125; return (defaultLocale != null ? defaultLocale : requestLocale);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring/Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/Spring-Framework/"}],"tags":[]},{"title":"Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기","slug":"spring/spring-security/oauth2/oauth2-04-authenticate","date":"2022-03-20T04:26:33.000Z","updated":"2024-02-26T16:23:52.095Z","comments":true,"path":"2022/03/20/spring/spring-security/oauth2/oauth2-04-authenticate/","link":"","permalink":"https://ckck803.github.io/2022/03/20/spring/spring-security/oauth2/oauth2-04-authenticate/","excerpt":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 참고 https://www.baeldung.com/spring-security-5-oauth2-login https://www.docs4dev.com/docs/en/spring-security/5.1.2.RELEASE/reference/jc.html#oauth2client OAuth2LoginAuthenticationFilter OAuth2 인증을 진행하기 위한 Filter OAuth2 인증 방식도 UsernamePassword 인증과 같이 인증을 진행하기 위한 Filter 가 존재한다. OAuth2LoginAuthenticationFilter 에서는 Authentication Server 로부터 Authorization Code 를 받은 후 Acess Token 과 Reflesh Token 을 받기 위한 과정을 진행한다. ClientRegistrationRepository ClientRegistration 정보를 저장 및 가져오기 위한 Class OAuth2AuthorizedClient 인증된 Client 정보를 관리하기 위한 Class Access Token, Reflesh Token, ClientRegistration 정보를 관리하는 Class OAuth2AuthorizedClientRepository OAuth2AuthorizedClient 정보를 저장 및 가져오기 위한 Class 인증이 진행중인 Client 정보를 가져온다. 기본 구현체는 HttpSessionOAuth2AuthorizedClientRepository OAuth2AuthorizedClientService Application Level 에서 OAuth2AuthorizedClient 정보를 가져오기 위한 Class 인증이 완료된 Client 정보를 저장소 에서 가져올 때 사용한다. 메모리에 OAuth2AuthorizedClient 객체를 저장하는 InMemoryOAuth2AuthorizedClientService 데이터 베이스에 OAuth2AuthorizedClient 객체를 저장하는 JdbcOAuth2AuthorizedClientService AuthorizationRequestRepository 인증 요청에서 인증 응답을 받을때 까지 OAuth2AuthorizationRequest 의 지속성을 보장하기 위한 Class 기본 구현체는 Session 에 저장하는 HttpSessionOAuth2AuthorizationRequestRepository OAuth2AuthorizationRequestResolver registrationId 와 HttpServletRequest 를 OAuth2AuthorizationRequest 객체를 생성하기 위한 Class 기본 구현체는 DefaultOAuth2AuthorizationRequestResolver OAuth2AccessTokenResponseClient Authorization Code 를 Access Token 으로 교환하는데 사용하는 Class 기본 구현체는 DefaultAuthorizationCodeTokenResponseClient 인증 과정","text":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 참고 https://www.baeldung.com/spring-security-5-oauth2-login https://www.docs4dev.com/docs/en/spring-security/5.1.2.RELEASE/reference/jc.html#oauth2client OAuth2LoginAuthenticationFilter OAuth2 인증을 진행하기 위한 Filter OAuth2 인증 방식도 UsernamePassword 인증과 같이 인증을 진행하기 위한 Filter 가 존재한다. OAuth2LoginAuthenticationFilter 에서는 Authentication Server 로부터 Authorization Code 를 받은 후 Acess Token 과 Reflesh Token 을 받기 위한 과정을 진행한다. ClientRegistrationRepository ClientRegistration 정보를 저장 및 가져오기 위한 Class OAuth2AuthorizedClient 인증된 Client 정보를 관리하기 위한 Class Access Token, Reflesh Token, ClientRegistration 정보를 관리하는 Class OAuth2AuthorizedClientRepository OAuth2AuthorizedClient 정보를 저장 및 가져오기 위한 Class 인증이 진행중인 Client 정보를 가져온다. 기본 구현체는 HttpSessionOAuth2AuthorizedClientRepository OAuth2AuthorizedClientService Application Level 에서 OAuth2AuthorizedClient 정보를 가져오기 위한 Class 인증이 완료된 Client 정보를 저장소 에서 가져올 때 사용한다. 메모리에 OAuth2AuthorizedClient 객체를 저장하는 InMemoryOAuth2AuthorizedClientService 데이터 베이스에 OAuth2AuthorizedClient 객체를 저장하는 JdbcOAuth2AuthorizedClientService AuthorizationRequestRepository 인증 요청에서 인증 응답을 받을때 까지 OAuth2AuthorizationRequest 의 지속성을 보장하기 위한 Class 기본 구현체는 Session 에 저장하는 HttpSessionOAuth2AuthorizationRequestRepository OAuth2AuthorizationRequestResolver registrationId 와 HttpServletRequest 를 OAuth2AuthorizationRequest 객체를 생성하기 위한 Class 기본 구현체는 DefaultOAuth2AuthorizationRequestResolver OAuth2AccessTokenResponseClient Authorization Code 를 Access Token 으로 교환하는데 사용하는 Class 기본 구현체는 DefaultAuthorizationCodeTokenResponseClient 인증 과정 AuthorizationRequestRepository 객체에서 OAuth2AuthorizationRequest 정보를 가져온 후 해당 객체를 지운다. ClientRegistration, OAuth2AuthorizationRequest, OAuth2AuthorizationResponse 객체를 이용해 OAuth2LoginAuthenticationToken 객체를 생성한다. AuthenticationProvider 객체를 이용해 인증을 진행한 후 새로운 OAuth2LoginAuthenticationToken 객체를 반환 받는다. Access Token 정보와 Reflesh Token 정보 ClientRegistration 정보를 담는 OAuth2AuthorizedClient 객체를 생성 OAuth2AuthorizedClientRepository 에 성성된 OAuth2AuthorizedClient 객체를 저장한다. @Overridepublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; // Request 객체로부터 Parameter 를 가져온다. MultiValueMap&lt;String, String&gt; params = OAuth2AuthorizationResponseUtils .toMultiMap(request.getParameterMap()); // Request Parameter 에 code, state 가 있는지 확인한다. if (!OAuth2AuthorizationResponseUtils.isAuthorizationResponse(params)) &#123; OAuth2Error oauth2Error = new OAuth2Error(OAuth2ErrorCodes.INVALID_REQUEST); throw new OAuth2AuthenticationException(oauth2Error, oauth2Error.toString()); &#125; // AuthorizationRequestRepository 객체에서 state 정보에 해당하는 OAuth2AuthorizationRequest 객체를 가져온후 해당 값을 AuthorizationRequestRepository 에서 지운다. // AuthorizationRequestRepository 객체 기본 구현체는 HttpSessionOAuth2AuthorizationRequestRepository OAuth2AuthorizationRequest authorizationRequest = this.authorizationRequestRepository .removeAuthorizationRequest(request, response); if (authorizationRequest == null) &#123; OAuth2Error oauth2Error = new OAuth2Error(AUTHORIZATION_REQUEST_NOT_FOUND_ERROR_CODE); throw new OAuth2AuthenticationException(oauth2Error, oauth2Error.toString()); &#125; // Registration 정보를 가져온다. ex) google, github, facebook, ... String registrationId = authorizationRequest.getAttribute(OAuth2ParameterNames.REGISTRATION_ID); // Registration 에 맞는 client_id 와 client_secret 정보를 가져와 ClientRegistration 객체를 생성한다. ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId); if (clientRegistration == null) &#123; OAuth2Error oauth2Error = new OAuth2Error(CLIENT_REGISTRATION_NOT_FOUND_ERROR_CODE, &quot;Client Registration not found with Id: &quot; + registrationId, null); throw new OAuth2AuthenticationException(oauth2Error, oauth2Error.toString()); &#125; // @formatter:off String redirectUri = UriComponentsBuilder.fromHttpUrl(UrlUtils.buildFullRequestUrl(request)) .replaceQuery(null) .build() .toUriString(); // @formatter:on // Request Parameter 로부터 code, state, redirectUri 을 가져와 OAuth2AuthorizationResponse 객체를 생성한다. OAuth2AuthorizationResponse authorizationResponse = OAuth2AuthorizationResponseUtils.convert(params, redirectUri); Object authenticationDetails = this.authenticationDetailsSource.buildDetails(request); // ClientRegistration 객체와 OAuth2AuthorizationRequest 객체와 OAuth2AuthorizationResponse 객체를 이용해 OAuth2LoginAuthenticationToken 객체를 만든다. OAuth2LoginAuthenticationToken authenticationRequest = new OAuth2LoginAuthenticationToken(clientRegistration, new OAuth2AuthorizationExchange(authorizationRequest, authorizationResponse)); authenticationRequest.setDetails(authenticationDetails); // AuthenticationProvider 객체를 이용해 인증을 진행한다. 인증시 ClientRegistration 정보와 Authorization_code 정보를 사용한다. // 인증을 진행한 후 Acess Token, Refresh Token 정보가 담긴 Authentication(Token) 객체를 가져온다. OAuth2LoginAuthenticationToken authenticationResult = (OAuth2LoginAuthenticationToken) this .getAuthenticationManager() .authenticate(authenticationRequest); // OAuth2LoginAuthenticationToken 객체를 OAuth2AuthenticationToken 객체로 변경한다. OAuth2AuthenticationToken oauth2Authentication = this.authenticationResultConverter .convert(authenticationResult); Assert.notNull(oauth2Authentication, &quot;authentication result cannot be null&quot;); oauth2Authentication.setDetails(authenticationDetails); // Access Token 정보와 Reflesh Token 정보 ClientRegistration 정보를 담는 OAuth2AuthorizedClient 객체를 생성한다. OAuth2AuthorizedClient authorizedClient = new OAuth2AuthorizedClient( authenticationResult.getClientRegistration(), oauth2Authentication.getName(), authenticationResult.getAccessToken(), authenticationResult.getRefreshToken()); // OAuth2AuthorizedClientRepository 에 성성된 OAuth2AuthorizedClient 객체를 저장한다. this.authorizedClientRepository.saveAuthorizedClient(authorizedClient, oauth2Authentication, request, response); return oauth2Authentication;&#125; OAuth2LoginAuthenticationProvider OAuth 방식을 이용해 인증을 진행하고 Authentication(인증) 객체를 생성하는 Provider OAuth2AuthorizationExchange OAuth2AuthorizationRequest 객체와 OAuth2AuthorizationResponse 객체를 관리하는 객체 ClientRegistration client_id, client_secret, scope 정보를 관리하는 객체 OAuth2LoginAuthenticationToken OAuth2 인증시 사용하는 Authentication 객체 OAuth2AuthorizationCodeAuthenticationProvider Authorization Code 를 이용해 인증을 진행하는 Provider Authorization Code 를 이용해 Access Token 을 가져오는 OAuth2AccessTokenResponseClient 객체를 갖고 있다. 인증에 성공하면 Access Token 과 Refresh Token 을 Resource Server 로부터 받게 된다. OAuth2AuthorizationCodeAuthenticationToken Authorization Code 를 이용한 인증 후 생성되는 Authentication 객체 OAuth2AccessToken(accessToken) 과 OAuth2RefreshToken(refreshToken) 을 관리한다. OAuth2AccessToken OAuth2 에서 사용하는 Access Token 을 관리하는 객체 OAuth2RefreshToken OAuth2 에서 사용하는 Reflesh Token 을 관리하는 객체 OAuth2User 사용자 Principal 를 관리하는 객체 OAuth2User 인터페이스의 구현 인스턴스는 OAuth2AuthenticatedPrincipal 인터페이스로 표현할 수 있다. Authentication.getPrincipal() 를 이용해 값을 얻어올 수 있다. 인증 절차 Authorization Code 를 이용해 Resource Server 로부터 Access Token 과 Refresh Token 을 발급 받는다. Access Token 을 이용해 Resource Server 로부터 사용자 정보를 가져온후 OAuth2User 객체를 반환 받는다. 반환 받은 OAuth2User 객체와 Access Token 과 Refresh Token, Client Registration 정보를 이용해 새로운 AuthenticationToken(OAuth2LoginAuthenticationToken) 객체를 생성 후 반환한다. @Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; // Oauth2 인증을 통해 생성되는 Authentication 객체 OAuth2LoginAuthenticationToken loginAuthenticationToken = (OAuth2LoginAuthenticationToken) authentication; if (loginAuthenticationToken.getAuthorizationExchange().getAuthorizationRequest().getScopes().contains(&quot;openid&quot;)) &#123; return null; &#125; OAuth2AuthorizationCodeAuthenticationToken authorizationCodeAuthenticationToken; try &#123; // Authorization Code 를 이용해 인증 진행 후 Acces Token 정보를 가져온다. authorizationCodeAuthenticationToken = (OAuth2AuthorizationCodeAuthenticationToken) this.authorizationCodeAuthenticationProvider .authenticate(new OAuth2AuthorizationCodeAuthenticationToken( loginAuthenticationToken.getClientRegistration(), loginAuthenticationToken.getAuthorizationExchange())); &#125; catch (OAuth2AuthorizationException ex) &#123; OAuth2Error oauth2Error = ex.getError(); throw new OAuth2AuthenticationException(oauth2Error, oauth2Error.toString(), ex); &#125; OAuth2AccessToken accessToken = authorizationCodeAuthenticationToken.getAccessToken(); Map&lt;String, Object&gt; additionalParameters = authorizationCodeAuthenticationToken.getAdditionalParameters(); // Resource Server 로부터 사용자 정보를 조회한 후 OAuth2User 객체를 생성한다. OAuth2User oauth2User = this.userService .loadUser(new OAuth2UserRequest(loginAuthenticationToken.getClientRegistration(), accessToken, additionalParameters)); Collection&lt;? extends GrantedAuthority&gt; mappedAuthorities = this.authoritiesMapper.mapAuthorities(oauth2User.getAuthorities()); OAuth2LoginAuthenticationToken authenticationResult = new OAuth2LoginAuthenticationToken( loginAuthenticationToken.getClientRegistration(), loginAuthenticationToken.getAuthorizationExchange(), oauth2User, mappedAuthorities, accessToken, authorizationCodeAuthenticationToken.getRefreshToken()); authenticationResult.setDetails(loginAuthenticationToken.getDetails()); return authenticationResult;&#125; DefaultOAuth2UserService DefaultOAuth2UserService 주 역할은 Access Token 을 이용해 Resource Server 로부터 사용자 정보를 가져와 OAuth2User 객체를 생성하는 역할이다. userNameAttributeName 정보가 있는지 확인 Resource Server 에서 사용자 정보를 식별하기 위한 Id 역할을 하는 정보 Resource Server 로부터 사용자 정보를 가져온다. 가져온 사용자 정보를 이용해 OAuth2User 객체를 생성한다. 현재 코드는 예외 코드를 제외한 로직만 있다. @Overridepublic OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException &#123; // userNameAttributeName 정보가 있는지 확인 String userNameAttributeName = userRequest.getClientRegistration() .getProviderDetails() .getUserInfoEndpoint() .getUserNameAttributeName(); // Resource Server 로부터 사용자 정보를 가져온다. RequestEntity&lt;?&gt; request = this.requestEntityConverter.convert(userRequest); ResponseEntity&lt;Map&lt;String, Object&gt;&gt; response = getResponse(userRequest, request); Map&lt;String, Object&gt; userAttributes = response.getBody(); Set&lt;GrantedAuthority&gt; authorities = new LinkedHashSet&lt;&gt;(); authorities.add(new OAuth2UserAuthority(userAttributes)); OAuth2AccessToken token = userRequest.getAccessToken(); for (String authority : token.getScopes()) &#123; authorities.add(new SimpleGrantedAuthority(&quot;SCOPE_&quot; + authority)); &#125; // Resource Server 로부터 가져온 사용자 정보를 이용해 OAuth2User 객체를 만든다. return new DefaultOAuth2User(authorities, userAttributes, userNameAttributeName);&#125;// RestOperations 을 이용해 Resource Server 로 요청을 보낸다.private ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getResponse(OAuth2UserRequest userRequest, RequestEntity&lt;?&gt; request) &#123; try &#123; return this.restOperations.exchange(request, PARAMETERIZED_RESPONSE_TYPE); &#125; ....&#125; OAuth2LoginAuthenticationToken OAuth 인증시 사용하는 Authentication 객체 Principal, Client Registration, Access Token, Refresh Token 등의 정보를 관리한다. public class OAuth2LoginAuthenticationToken extends AbstractAuthenticationToken &#123; private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; private OAuth2User principal; private ClientRegistration clientRegistration; private OAuth2AuthorizationExchange authorizationExchange; private OAuth2AccessToken accessToken; private OAuth2RefreshToken refreshToken; public OAuth2LoginAuthenticationToken( ClientRegistration clientRegistration, OAuth2AuthorizationExchange authorizationExchange) &#123; super(Collections.emptyList()); this.clientRegistration = clientRegistration; this.authorizationExchange = authorizationExchange; this.setAuthenticated(false); &#125; public OAuth2LoginAuthenticationToken( ClientRegistration clientRegistration, OAuth2AuthorizationExchange authorizationExchange, OAuth2User principal, Collection&lt;? extends GrantedAuthority&gt; authorities, OAuth2AccessToken accessToken) &#123; this(clientRegistration, authorizationExchange, principal, authorities, accessToken, null); &#125; public OAuth2LoginAuthenticationToken( ClientRegistration clientRegistration, OAuth2AuthorizationExchange authorizationExchange, OAuth2User principal, Collection&lt;? extends GrantedAuthority&gt; authorities, OAuth2AccessToken accessToken, @Nullable OAuth2RefreshToken refreshToken) &#123; super(authorities); this.clientRegistration = clientRegistration; this.authorizationExchange = authorizationExchange; this.principal = principal; this.accessToken = accessToken; this.refreshToken = refreshToken; this.setAuthenticated(true); &#125; ...&#125; DefaultOAuth2User OAuth 인증 후 전달 받은 사용자 정보를 관리하는 Principal 객체 public class DefaultOAuth2User implements OAuth2User, Serializable &#123; private static final long serialVersionUID = 560L; private final Set&lt;GrantedAuthority&gt; authorities; private final Map&lt;String, Object&gt; attributes; private final String nameAttributeKey; public DefaultOAuth2User( Collection&lt;? extends GrantedAuthority&gt; authorities, Map&lt;String, Object&gt; attributes, String nameAttributeKey ) &#123; if (!attributes.containsKey(nameAttributeKey)) &#123; throw new IllegalArgumentException(&quot;Missing attribute &#x27;&quot; + nameAttributeKey + &quot;&#x27; in attributes&quot;); &#125; else &#123; this.authorities = authorities != null ? Collections.unmodifiableSet(new LinkedHashSet(this.sortAuthorities(authorities))) : Collections.unmodifiableSet(new LinkedHashSet(AuthorityUtils.NO_AUTHORITIES)); this.attributes = Collections.unmodifiableMap(new LinkedHashMap(attributes)); this.nameAttributeKey = nameAttributeKey; &#125; &#125; ....&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Oauth2","slug":"Spring/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Oauth2/"}],"tags":[]},{"title":"컴퓨터 구조 - 메모리 관리 Paging 기법","slug":"computer-science/computer-structure/paging","date":"2022-03-19T20:31:07.000Z","updated":"2024-02-18T16:19:54.517Z","comments":true,"path":"2022/03/20/computer-science/computer-structure/paging/","link":"","permalink":"https://ckck803.github.io/2022/03/20/computer-science/computer-structure/paging/","excerpt":"Paging 기법 프로세스가 사용하는 메모리를 일정한 크기로 잘라 메모리에 할당 하는 방식, 기존 논리 주소 공간이 하나의 연속된 물리 주소 공간에 들어가야 하는 제약을 해소하기 위해 생긴 방식 프로세스의 주소 공간을 나누는 단위는 page, 메모리를 나누는 단위는 frame 이라 한다. page 와 frame 의 크기는 항상 같다. 메모리에 프로세스 주소 공간 전체를 올릴 필요가 사라졌다. 연속된 메모리로 관리하지 않기 때문에 Page Table 을 이용해 여러개로 나뉜 Page 정보를 관리한다. 외부 단편화 가 발생하지 않지만 내부 단편화 가 발생하게 된다. Page Table Virtual Page Number 를 Physical Frame Number 로 변환 시켜주는 Mapping 정보와 현재 Memory 적재 여부를 확인할 수 있는 Table MMU(Memory Management Unit) 는 Page Table 정보를 이용해 논리 주소를 물리 주소로 변환시킨다. Page Table 을 프로세스 마다 하나씩 존재하고 메모리에 올라가 있다. 실행된고 있는 프로세스가 많을 수록 메모리에 올라가 있는 Page Table 정보도 많게 된다. Page Fault Page Fault 란 프로세스가 요청하는 Page 정보가 현재 Memory 에 없는 경우를 뜻한다.","text":"Paging 기법 프로세스가 사용하는 메모리를 일정한 크기로 잘라 메모리에 할당 하는 방식, 기존 논리 주소 공간이 하나의 연속된 물리 주소 공간에 들어가야 하는 제약을 해소하기 위해 생긴 방식 프로세스의 주소 공간을 나누는 단위는 page, 메모리를 나누는 단위는 frame 이라 한다. page 와 frame 의 크기는 항상 같다. 메모리에 프로세스 주소 공간 전체를 올릴 필요가 사라졌다. 연속된 메모리로 관리하지 않기 때문에 Page Table 을 이용해 여러개로 나뉜 Page 정보를 관리한다. 외부 단편화 가 발생하지 않지만 내부 단편화 가 발생하게 된다. Page Table Virtual Page Number 를 Physical Frame Number 로 변환 시켜주는 Mapping 정보와 현재 Memory 적재 여부를 확인할 수 있는 Table MMU(Memory Management Unit) 는 Page Table 정보를 이용해 논리 주소를 물리 주소로 변환시킨다. Page Table 을 프로세스 마다 하나씩 존재하고 메모리에 올라가 있다. 실행된고 있는 프로세스가 많을 수록 메모리에 올라가 있는 Page Table 정보도 많게 된다. Page Fault Page Fault 란 프로세스가 요청하는 Page 정보가 현재 Memory 에 없는 경우를 뜻한다. Virtual Memory 가 Mapping 돼 있지 않을 상태일 때 CPU 에게 Trap 을 발생시켜 OS가 인지하게 한다. Page 가 Mapping 돼 있지 않은 Page Replacement Algorithm (페이지 교체 알고리즘) Memory 에 새로운 Page 올릴 공간이 없을 경우 기존 Memory 에서 점유하는 Page 를 내리기 위한 알고리즘 FIFO(First In First Out) 가장 먼저 올라간 Page 를 가장 먼저 내리는 알고리즘 LRU (Least Recently Used) 가장 오랫동안 사용되지 않는 Page 를 내리는 알고리즘 많은 운영체제에서 사용하는 Page 교체 알고리즘이다. 계수-기반(Counting-Based) 페이지 교체 NFU (Not Frequently Used) 참조 횟수가 가장 적은 Page 를 교체하는 알고리즘 만약 Page 교체 대상이 여러개일 경우 LRU 알고리즘을 이용해 가장 오랫동안 사용되지 않는 Page 를 내린다. MFU (Most Frequently Used) 참조 횟수가 가장 많은 Page 를 교체하는 알고리즘 참조 횟수가 적은 Page 는 가장 최근에 참조된 것으로 보고 앞으로 사용할 가능성이 높다고 판단한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"컴퓨터 구조","slug":"CS/컴퓨터-구조","permalink":"https://ckck803.github.io/categories/CS/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0/"},{"name":"메모리 관리","slug":"CS/컴퓨터-구조/메모리-관리","permalink":"https://ckck803.github.io/categories/CS/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC/"}],"tags":[]},{"title":"컴퓨터 구조 - 메모리 관리 Segmentation 기법","slug":"computer-science/computer-structure/segmentation","date":"2022-03-19T20:31:07.000Z","updated":"2024-02-18T16:19:54.517Z","comments":true,"path":"2022/03/20/computer-science/computer-structure/segmentation/","link":"","permalink":"https://ckck803.github.io/2022/03/20/computer-science/computer-structure/segmentation/","excerpt":"Segmentation 기법 Paging 기법과 달리 프로세스가 사용하는 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할 하고 메모리에 할당하는 기법 Segmentation 은 프로세스를 세그먼트(code, data, stack)의 집합으로 보고 의미가 같은 논리적 내용 단위로 자른다. 자르는 방식에서의 차이가 있고, 메모리에 할당하는 방식은 Paging 과 같다. Segmentation 은 Segmentation Table 을 이용해 여러개로 나뉜 Segment 들을 관리 한다. Paging Table 과의 차이는 Segmentation Table 은 서로 다른 크기로 나뉘었기 때문에 Limit 정보도 같이 관리된다.","text":"Segmentation 기법 Paging 기법과 달리 프로세스가 사용하는 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할 하고 메모리에 할당하는 기법 Segmentation 은 프로세스를 세그먼트(code, data, stack)의 집합으로 보고 의미가 같은 논리적 내용 단위로 자른다. 자르는 방식에서의 차이가 있고, 메모리에 할당하는 방식은 Paging 과 같다. Segmentation 은 Segmentation Table 을 이용해 여러개로 나뉜 Segment 들을 관리 한다. Paging Table 과의 차이는 Segmentation Table 은 서로 다른 크기로 나뉘었기 때문에 Limit 정보도 같이 관리된다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"컴퓨터 구조","slug":"CS/컴퓨터-구조","permalink":"https://ckck803.github.io/categories/CS/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0/"},{"name":"메모리 관리","slug":"CS/컴퓨터-구조/메모리-관리","permalink":"https://ckck803.github.io/categories/CS/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC/"}],"tags":[]},{"title":"Spring Security OAuth2 - Handler","slug":"spring/spring-security/oauth2/oauth2-07-handler","date":"2022-03-18T06:56:10.000Z","updated":"2024-02-26T16:24:05.719Z","comments":true,"path":"2022/03/18/spring/spring-security/oauth2/oauth2-07-handler/","link":"","permalink":"https://ckck803.github.io/2022/03/18/spring/spring-security/oauth2/oauth2-07-handler/","excerpt":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 참고Success Handler 만들기Oauth2 인증 후 특정 작업을 진행하기 위해서는 SuccessHandler 가 필요하다. AuthenticationSuccessHandler 를 구현해 인증 후 사용자 정보를 로그로 출력하는 Handler 를 만들어 보려고 한다. 인증 후 Authentication 객체 내 Principal 에는 OAuth2User 객체 정보가 들어가게 된다. (OAuth2LoginAuthenticationProvider 에서 확인) @Slf4jpublic class Oauth2AuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal(); log.info(&quot;oAuth2User name = &#123;&#125;&quot;, (String) oAuth2User.getAttribute(&quot;email&quot;)); log.info(&quot;oAuth2User name = &#123;&#125;&quot;, (String) oAuth2User.getAttribute(&quot;name&quot;)); &#125;&#125; Security Config 추가oauth2AuthenticationSuccessHandler Bean 을 생성 후 successHandler 에 추가한다.","text":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 참고Success Handler 만들기Oauth2 인증 후 특정 작업을 진행하기 위해서는 SuccessHandler 가 필요하다. AuthenticationSuccessHandler 를 구현해 인증 후 사용자 정보를 로그로 출력하는 Handler 를 만들어 보려고 한다. 인증 후 Authentication 객체 내 Principal 에는 OAuth2User 객체 정보가 들어가게 된다. (OAuth2LoginAuthenticationProvider 에서 확인) @Slf4jpublic class Oauth2AuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal(); log.info(&quot;oAuth2User name = &#123;&#125;&quot;, (String) oAuth2User.getAttribute(&quot;email&quot;)); log.info(&quot;oAuth2User name = &#123;&#125;&quot;, (String) oAuth2User.getAttribute(&quot;name&quot;)); &#125;&#125; Security Config 추가oauth2AuthenticationSuccessHandler Bean 을 생성 후 successHandler 에 추가한다. @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/oauth_login&quot;) .permitAll() .anyRequest() .authenticated() .and() .oauth2Login() .loginPage(&quot;/oauth_login&quot;) .successHandler(oauth2AuthenticationSuccessHandler());&#125;@Beanpublic AuthenticationSuccessHandler oauth2AuthenticationSuccessHandler() &#123; return new Oauth2AuthenticationSuccessHandler();&#125; Failure Handler 만들기Success Handler 와 마찬가지로 인증 실패시 특정 작업을 실행하기 위해 Failure Handler 가 필요하다. AuthenticationFailureHandler 를 구현해 실패 후 실패 Log 와 response 객체에 인증 실패 메시지를 보내도록 한다. @Slf4j@RequiredArgsConstructorpublic class Oauth2AuthenticationFailureHandler implements AuthenticationFailureHandler &#123; private final ObjectMapper objectMapper; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; response.setStatus(HttpStatus.UNAUTHORIZED.value()); response.setContentType(MediaType.APPLICATION_JSON_VALUE); log.info(&quot;Authentication failed&quot;); objectMapper.writeValue(response.getWriter(), &quot;Authentication failed&quot;); &#125;&#125; Security Config 추가oauth2AuthenticationFailureHandler Bean 을 생성 후 failureHandler 에 넣어준다. @EnableWebSecurity@Slf4j@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final OAuth2AuthorizedClientService oAuth2AuthorizedClientService; private final ObjectMapper objectMapper; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/oauth_login&quot;) .permitAll() .anyRequest() .authenticated() .and() .oauth2Login() .loginPage(&quot;/oauth_login&quot;) .successHandler(oauth2AuthenticationSuccessHandler()) .failureHandler(oauth2AuthenticationFailureHandler()); &#125; @Bean public AuthenticationSuccessHandler oauth2AuthenticationSuccessHandler() &#123; return new Oauth2AuthenticationSuccessHandler(); &#125; @Bean public AuthenticationFailureHandler oauth2AuthenticationFailureHandler()&#123; return new Oauth2AuthenticationFailureHandler(objectMapper); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Oauth2","slug":"Spring/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Oauth2/"}],"tags":[]},{"title":"Spring Security OAuth2 - Login 페이지 Customizing 하기","slug":"spring/spring-security/oauth2/oauth2-06","date":"2022-03-18T04:56:10.000Z","updated":"2024-02-26T16:24:00.450Z","comments":true,"path":"2022/03/18/spring/spring-security/oauth2/oauth2-06/","link":"","permalink":"https://ckck803.github.io/2022/03/18/spring/spring-security/oauth2/oauth2-06/","excerpt":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 참고 https://www.baeldung.com/spring-security-5-oauth2-login Security Config@EnableWebSecurity@Slf4jpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/oauth_login&quot;) .permitAll() .anyRequest() .authenticated() .and() .oauth2Login() .loginPage(&quot;/oauth_login&quot;); &#125;&#125; Controller@Controllerpublic class LoginController &#123; private static String authorizationRequestBaseUri = &quot;oauth2/authorization&quot;; Map&lt;String, String&gt; oauth2AuthenticationUrls = new HashMap&lt;&gt;(); @Autowired private ClientRegistrationRepository clientRegistrationRepository; @GetMapping(&quot;/oauth_login&quot;) public String getLoginPage(Model model) &#123; Iterable&lt;ClientRegistration&gt; clientRegistrations = null; ResolvableType type = ResolvableType.forInstance(clientRegistrationRepository) .as(Iterable.class); if (type != ResolvableType.NONE &amp;&amp; ClientRegistration.class.isAssignableFrom(type.resolveGenerics()[0])) &#123; clientRegistrations = (Iterable&lt;ClientRegistration&gt;) clientRegistrationRepository; &#125; clientRegistrations .forEach(registration -&gt; oauth2AuthenticationUrls .put(registration.getClientName(), authorizationRequestBaseUri + &quot;/&quot; + registration.getRegistrationId()) ); model.addAttribute(&quot;urls&quot;, oauth2AuthenticationUrls); return &quot;oauth_login&quot;; &#125;&#125; 로그인 페이지","text":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 참고 https://www.baeldung.com/spring-security-5-oauth2-login Security Config@EnableWebSecurity@Slf4jpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/oauth_login&quot;) .permitAll() .anyRequest() .authenticated() .and() .oauth2Login() .loginPage(&quot;/oauth_login&quot;); &#125;&#125; Controller@Controllerpublic class LoginController &#123; private static String authorizationRequestBaseUri = &quot;oauth2/authorization&quot;; Map&lt;String, String&gt; oauth2AuthenticationUrls = new HashMap&lt;&gt;(); @Autowired private ClientRegistrationRepository clientRegistrationRepository; @GetMapping(&quot;/oauth_login&quot;) public String getLoginPage(Model model) &#123; Iterable&lt;ClientRegistration&gt; clientRegistrations = null; ResolvableType type = ResolvableType.forInstance(clientRegistrationRepository) .as(Iterable.class); if (type != ResolvableType.NONE &amp;&amp; ClientRegistration.class.isAssignableFrom(type.resolveGenerics()[0])) &#123; clientRegistrations = (Iterable&lt;ClientRegistration&gt;) clientRegistrationRepository; &#125; clientRegistrations .forEach(registration -&gt; oauth2AuthenticationUrls .put(registration.getClientName(), authorizationRequestBaseUri + &quot;/&quot; + registration.getRegistrationId()) ); model.addAttribute(&quot;urls&quot;, oauth2AuthenticationUrls); return &quot;oauth_login&quot;; &#125;&#125; 로그인 페이지&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;Oauth2 Login&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;col-sm-3 well&quot;&gt; &lt;h3&gt;Login with:&lt;/h3&gt; &lt;div class=&quot;list-group&quot;&gt; &lt;p th:each=&quot;url : $&#123;urls&#125;&quot;&gt; &lt;a th:text=&quot;$&#123;url.key&#125;&quot; th:href=&quot;$&#123;url.value&#125;&quot; class=&quot;list-group-item active&quot;&gt;Client&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Oauth2","slug":"Spring/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Oauth2/"}],"tags":[]},{"title":"Spring Test - @WithMockUser, @WithAnonymousUser","slug":"spring/spring-test/with-mock-user","date":"2022-03-15T14:25:35.000Z","updated":"2024-02-26T16:20:04.905Z","comments":true,"path":"2022/03/15/spring/spring-test/with-mock-user/","link":"","permalink":"https://ckck803.github.io/2022/03/15/spring/spring-test/with-mock-user/","excerpt":"목차 Spring Test - @WebMvcTest Spring Test - @DataJpaTest Spring Test - @WithMockUser, @WithAnonymousUser Controller@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return new String(&quot;hello&quot;); &#125;&#125; @WithMockUser@WithMockUser 는 Security Test 를 진행할 때 인증된 Authentication 객체를 만들어 인증된 상태로 Test 를 진행할 수 있게 도와준다. 속성 username : Authentication 객체에서 사용할 username 을 설정 password : Authentication 객체에서 사용할 password 을 설정 roles : Authentication 객체에서 사용할 role 을 설정 authorities : Authentication 객체에서 사용할 authorities 을 설정 @WebMvcTest@AutoConfigureMockMvcclass HelloControllerTest &#123; @Autowired MockMvc mockMvc; @Test @WithMockUser(username = &quot;user&quot;, password = &quot;1234&quot;) void mockUserTest() throws Exception &#123; mockMvc.perform(get(&quot;/hello&quot;)) .andDo(print()) .andExpect(status().isOk()); &#125;&#125; @WithMockUser 권한 사용 하기","text":"목차 Spring Test - @WebMvcTest Spring Test - @DataJpaTest Spring Test - @WithMockUser, @WithAnonymousUser Controller@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return new String(&quot;hello&quot;); &#125;&#125; @WithMockUser@WithMockUser 는 Security Test 를 진행할 때 인증된 Authentication 객체를 만들어 인증된 상태로 Test 를 진행할 수 있게 도와준다. 속성 username : Authentication 객체에서 사용할 username 을 설정 password : Authentication 객체에서 사용할 password 을 설정 roles : Authentication 객체에서 사용할 role 을 설정 authorities : Authentication 객체에서 사용할 authorities 을 설정 @WebMvcTest@AutoConfigureMockMvcclass HelloControllerTest &#123; @Autowired MockMvc mockMvc; @Test @WithMockUser(username = &quot;user&quot;, password = &quot;1234&quot;) void mockUserTest() throws Exception &#123; mockMvc.perform(get(&quot;/hello&quot;)) .andDo(print()) .andExpect(status().isOk()); &#125;&#125; @WithMockUser 권한 사용 하기Security Config 추가하기Resource 에 각각 다른 권한 별로 접근이 가능하도록 설정한다. @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/hello&quot;).hasRole(&quot;USER&quot;) .antMatchers(&quot;/manager&quot;).hasRole(&quot;MANAGER&quot;) .anyRequest() .authenticated();&#125; Controller 추가@GetMapping(&quot;/manager&quot;)public String manager()&#123; return &quot;Hello Manager&quot;;&#125; 테스트 코드 작성@WithMockUser 를 통해 생성된 Authentication 객체는 role 이 USER 기 때문에 MANAGER 권한이 필요한 resource 에는 접근할 수 없다. @Test@WithMockUser(username = &quot;user&quot;, password = &quot;1234&quot;, roles = &quot;USER&quot;)void mockManagerTest() throws Exception &#123; mockMvc.perform(get(&quot;/manager&quot;)) .andDo(print()) .andExpect(status().isForbidden());&#125; @WithAnonymousUser@WithAnonymousUser 는 anonymous 사용자로 테스트를 진행한다. @Test@WithAnonymousUservoid mockAnonymousUserTest() throws Exception &#123; mockMvc.perform(get(&quot;/hello&quot;)) .andDo(print()) .andExpect(status().isForbidden());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Test","slug":"Spring/Spring-Test","permalink":"https://ckck803.github.io/categories/Spring/Spring-Test/"}],"tags":[]},{"title":"프로그래머스 - 양과 늑대 Cpp","slug":"algorithm/programmers/그래프탐색/92343-양과늑대-cpp","date":"2022-03-15T11:10:40.000Z","updated":"2024-02-18T16:19:54.515Z","comments":true,"path":"2022/03/15/algorithm/programmers/그래프탐색/92343-양과늑대-cpp/","link":"","permalink":"https://ckck803.github.io/2022/03/15/algorithm/programmers/%EA%B7%B8%EB%9E%98%ED%94%84%ED%83%90%EC%83%89/92343-%EC%96%91%EA%B3%BC%EB%8A%91%EB%8C%80-cpp/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92343 프로그래머스 - 양과 늑대 Cpp 문제 풀이이 문제의 가장 어려운 점은 한번 방문한 노드를 여러번 방문할 수 있다는 것이다. 중복을 허용한 탐색을 진행하면 탐색이 끝나지 않으므로, 최대한 중복 방문을 제거하기 위해 비트마스크 를 이용해 방문한 노드들을 관리하면서 같은 상태에서 같은 노드 방문을 못하게 하는게 이 문제의 핵심이다.그 다음으로 어려웠던 부분은 이 탐색의 끝은 항상 루트 노드에서 끝나야 한다는 점이고, 반대로 생각하면 루트 노드에서 탐색 가능한 범위만 정답이 될 수 있는 것이다. 처음에 이 부분을 염두하지 않아서 계속 틀렸다. 이 두 부분만 잘 염두 하면 이 문제를 해결하는데 큰 어려움은 없다. 전체 소스 코드#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int maxValue = 0;void dfs(int sheep, int woof, int start, int state, vector&lt;int&gt; info, vector&lt;vector&lt;int&gt;&gt;&amp; grape, vector&lt;vector&lt;bool&gt;&gt;&amp; check) &#123; if (woof &gt;= sheep) &#123; return; &#125; maxValue = max(maxValue, sheep); for (int i = 0; i &lt; info.size(); i++) &#123; int node = 1 &lt;&lt; i; int isVisited = state &amp; node; int nextState = state | node; if (grape[start][i] == 0) &#123; continue; &#125; if (check[nextState][i] == true) &#123; continue; &#125; check[nextState][i] = true; if (isVisited) &#123; dfs(sheep, woof, i, nextState, info, grape, check); &#125; else &#123; if (info[i] == 0) &#123; dfs(sheep + 1, woof, i, nextState, info, grape, check); &#125; else &#123; dfs(sheep, woof + 1, i, nextState, info, grape, check); &#125; &#125; check[nextState][i] = false; &#125;&#125;int solution(vector&lt;int&gt; info, vector&lt;vector&lt;int&gt;&gt; edges) &#123; int answer = 0; vector&lt;vector&lt;int&gt;&gt; grape = vector&lt;vector&lt;int&gt;&gt;(info.size() + 1, vector&lt;int&gt;(info.size() + 1, 0)); vector&lt;vector&lt;bool&gt;&gt; check = vector&lt;vector&lt;bool&gt;&gt;((1 &lt;&lt; 18) - 1, vector&lt;bool&gt;(17 + 1, false)); for (vector&lt;int&gt; edge : edges) &#123; int from, to; from = edge[0]; to = edge[1]; grape[from][to] = 1; grape[to][from] = 1; &#125; maxValue = 0; int state = 1 &lt;&lt; 0; check[state][0] = true; dfs(1, 0, 0, state, info, grape, check); answer = max(maxValue, answer); return answer;&#125;","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92343 프로그래머스 - 양과 늑대 Cpp 문제 풀이이 문제의 가장 어려운 점은 한번 방문한 노드를 여러번 방문할 수 있다는 것이다. 중복을 허용한 탐색을 진행하면 탐색이 끝나지 않으므로, 최대한 중복 방문을 제거하기 위해 비트마스크 를 이용해 방문한 노드들을 관리하면서 같은 상태에서 같은 노드 방문을 못하게 하는게 이 문제의 핵심이다.그 다음으로 어려웠던 부분은 이 탐색의 끝은 항상 루트 노드에서 끝나야 한다는 점이고, 반대로 생각하면 루트 노드에서 탐색 가능한 범위만 정답이 될 수 있는 것이다. 처음에 이 부분을 염두하지 않아서 계속 틀렸다. 이 두 부분만 잘 염두 하면 이 문제를 해결하는데 큰 어려움은 없다. 전체 소스 코드#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int maxValue = 0;void dfs(int sheep, int woof, int start, int state, vector&lt;int&gt; info, vector&lt;vector&lt;int&gt;&gt;&amp; grape, vector&lt;vector&lt;bool&gt;&gt;&amp; check) &#123; if (woof &gt;= sheep) &#123; return; &#125; maxValue = max(maxValue, sheep); for (int i = 0; i &lt; info.size(); i++) &#123; int node = 1 &lt;&lt; i; int isVisited = state &amp; node; int nextState = state | node; if (grape[start][i] == 0) &#123; continue; &#125; if (check[nextState][i] == true) &#123; continue; &#125; check[nextState][i] = true; if (isVisited) &#123; dfs(sheep, woof, i, nextState, info, grape, check); &#125; else &#123; if (info[i] == 0) &#123; dfs(sheep + 1, woof, i, nextState, info, grape, check); &#125; else &#123; dfs(sheep, woof + 1, i, nextState, info, grape, check); &#125; &#125; check[nextState][i] = false; &#125;&#125;int solution(vector&lt;int&gt; info, vector&lt;vector&lt;int&gt;&gt; edges) &#123; int answer = 0; vector&lt;vector&lt;int&gt;&gt; grape = vector&lt;vector&lt;int&gt;&gt;(info.size() + 1, vector&lt;int&gt;(info.size() + 1, 0)); vector&lt;vector&lt;bool&gt;&gt; check = vector&lt;vector&lt;bool&gt;&gt;((1 &lt;&lt; 18) - 1, vector&lt;bool&gt;(17 + 1, false)); for (vector&lt;int&gt; edge : edges) &#123; int from, to; from = edge[0]; to = edge[1]; grape[from][to] = 1; grape[to][from] = 1; &#125; maxValue = 0; int state = 1 &lt;&lt; 0; check[state][0] = true; dfs(1, 0, 0, state, info, grape, check); answer = max(maxValue, answer); return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"정규 표현식","slug":"Programming/프로그래머스/문자열/정규-표현식","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/"}],"tags":[]},{"title":"Spring Test - @DataJpaTest","slug":"spring/spring-test/DataJpaTest","date":"2022-03-15T05:25:35.000Z","updated":"2024-02-26T16:20:04.904Z","comments":true,"path":"2022/03/15/spring/spring-test/DataJpaTest/","link":"","permalink":"https://ckck803.github.io/2022/03/15/spring/spring-test/DataJpaTest/","excerpt":"목차 Spring Test - @WebMvcTest Spring Test - @DataJpaTest Spring Test - @WithMockUser, @WithAnonymousUser @DataJpaTest JPA 테스트를 진행하기 위해 사용하는 어노테이션, JPA component 들만 관리하기 때문에 JPA test 시 관련된 Configuration 들만이 적용된다. 각 Test 를 진행할때마다 하나의 Transaction 에서 수행되고 Test 가 끝나면 Roll-back 을 진행한다. @Transactional 기능이 필요하지 않으면 @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED) 설정 Test 진행시 Embedded In Memory Database 로 진행한다. @AutoConfigureTestDatabase 을 이용하면 Test 시 특정 Database 를 사용할 수 있다. @DataJpaTest 를 이용한 Test 코드 작성@DataJpaTestclass PostTest &#123; @Autowired private PostRepository postRepository; @Test void createPostTest()&#123; String title = &quot;title&quot;; String subTitle = &quot;subTitle&quot;; String categoryName = &quot;test&quot;; String content = &quot;content&quot;; Category category = Category.builder() .name(categoryName) .build(); Post post = Post.builder() .title(title) .subTitle(subTitle) .category(category) .content(content) .build(); Post savedPost = postRepository.save(post); assertThat(savedPost.getTitle()).isEqualTo(title); assertThat(savedPost.getSubTitle()).isEqualTo(subTitle); assertThat(savedPost.getContent()).isEqualTo(content); &#125;&#125;","text":"목차 Spring Test - @WebMvcTest Spring Test - @DataJpaTest Spring Test - @WithMockUser, @WithAnonymousUser @DataJpaTest JPA 테스트를 진행하기 위해 사용하는 어노테이션, JPA component 들만 관리하기 때문에 JPA test 시 관련된 Configuration 들만이 적용된다. 각 Test 를 진행할때마다 하나의 Transaction 에서 수행되고 Test 가 끝나면 Roll-back 을 진행한다. @Transactional 기능이 필요하지 않으면 @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED) 설정 Test 진행시 Embedded In Memory Database 로 진행한다. @AutoConfigureTestDatabase 을 이용하면 Test 시 특정 Database 를 사용할 수 있다. @DataJpaTest 를 이용한 Test 코드 작성@DataJpaTestclass PostTest &#123; @Autowired private PostRepository postRepository; @Test void createPostTest()&#123; String title = &quot;title&quot;; String subTitle = &quot;subTitle&quot;; String categoryName = &quot;test&quot;; String content = &quot;content&quot;; Category category = Category.builder() .name(categoryName) .build(); Post post = Post.builder() .title(title) .subTitle(subTitle) .category(category) .content(content) .build(); Post savedPost = postRepository.save(post); assertThat(savedPost.getTitle()).isEqualTo(title); assertThat(savedPost.getSubTitle()).isEqualTo(subTitle); assertThat(savedPost.getContent()).isEqualTo(content); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Test","slug":"Spring/Spring-Test","permalink":"https://ckck803.github.io/categories/Spring/Spring-Test/"}],"tags":[]},{"title":"Spring Test - @WebMvcTest","slug":"spring/spring-test/WebMvcTest","date":"2022-03-14T14:25:35.000Z","updated":"2024-02-26T16:20:04.904Z","comments":true,"path":"2022/03/14/spring/spring-test/WebMvcTest/","link":"","permalink":"https://ckck803.github.io/2022/03/14/spring/spring-test/WebMvcTest/","excerpt":"목차 Spring Test - @WebMvcTest Spring Test - @DataJpaTest Spring Test - @WithMockUser, @WithAnonymousUser @WebMvcTest Spring MVC 를 테스트하기 위해 사용되는 어노테이션, MVC 테스트와 관련된 Configuration 이 적용된다. @Controller, @ControllerAdvice, @JsonComponent, Converter&#x2F;GenericConverter, Filter, HandlerMethodArgumentResolver, WebMvcConfigurer 를 Scan 한다. @Component, @Service, @Repository Bean은 적용되지 않는다. MVC 테스트시 Spring Security 설정도 자동적으로 추가해준다. controllers 속성을 이용해 특정 Controller 를 지정함으로써 해당 Controller 만 테스트 진행할 수 있다. includeFilters 속성과 excludeFilters 속성을 이용해 특정 Filter 를 추가하거나 제외할 수 있다. 장점 @SpringBootTest 에 비해 MVC 에 필요한 구성만 불러옴으로 훨씬 가볍고 빠르다. 단점 Mock 기반 테스트를 진행하기 때문에 운영에서는 제대로 동작하지 않을 수 있다.","text":"목차 Spring Test - @WebMvcTest Spring Test - @DataJpaTest Spring Test - @WithMockUser, @WithAnonymousUser @WebMvcTest Spring MVC 를 테스트하기 위해 사용되는 어노테이션, MVC 테스트와 관련된 Configuration 이 적용된다. @Controller, @ControllerAdvice, @JsonComponent, Converter&#x2F;GenericConverter, Filter, HandlerMethodArgumentResolver, WebMvcConfigurer 를 Scan 한다. @Component, @Service, @Repository Bean은 적용되지 않는다. MVC 테스트시 Spring Security 설정도 자동적으로 추가해준다. controllers 속성을 이용해 특정 Controller 를 지정함으로써 해당 Controller 만 테스트 진행할 수 있다. includeFilters 속성과 excludeFilters 속성을 이용해 특정 Filter 를 추가하거나 제외할 수 있다. 장점 @SpringBootTest 에 비해 MVC 에 필요한 구성만 불러옴으로 훨씬 가볍고 빠르다. 단점 Mock 기반 테스트를 진행하기 때문에 운영에서는 제대로 동작하지 않을 수 있다. @WebMvcTest 를 이용한 Test 코드@WebMvcTest( value = PostController.class , excludeFilters = &#123; @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = JsonSecurityConfig.class), @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = JwtSecurityConfig.class)&#125;)@ActiveProfiles(&quot;local&quot;)class PostControllerTest &#123; @MockBean private JwtUtils jwtUtils; @Autowired private MockMvc mockMvc; @MockBean private PostService postService; @MockBean private CategoryService categoryService; @Autowired private ObjectMapper objectMapper; @MockBean(name = &quot;userDetailsService&quot;) private UserInfoUserDetailsService userInfoUserDetailsService; @PostConstruct public void setup() &#123; given(userInfoUserDetailsService.loadUserByUsername(anyString())) .willReturn(new User(&quot;test&quot;, &quot;password&quot;, AuthorityUtils.createAuthorityList(&quot;ROLE_WRITE&quot;))); &#125; @Test @WithMockUser void getAllTest() throws Exception &#123; List&lt;Page&gt; posts = new ArrayList&lt;&gt;(); given(postService.getAllPosts(PageRequest.of(0, 3))).willReturn(new PageImpl(posts)); ResultActions resultActions = mockMvc.perform(get(&quot;/api/post&quot;)); resultActions .andExpect(status().isOk()); &#125; @Test @WithUserDetails void saveTest() throws Exception &#123; String title = new String(&quot;Title&quot;); String subTitle = new String(&quot;subTitle&quot;); String content = new String(&quot;content&quot;); String beforeCategoryName = new String(&quot;beforeCategory&quot;); String afterCategoryName = new String(&quot;afterCategory&quot;); RequestPostDto requestPostDto = new RequestPostDto(); requestPostDto.setTitle(title); requestPostDto.setSubTitle(subTitle); requestPostDto.setContent(content); requestPostDto.setCategory(afterCategoryName); Category beforeCategory = Category.builder() .name(beforeCategoryName) .posts(new ArrayList&lt;&gt;()) .build(); Category afterCategory = Category.builder() .name(afterCategoryName) .posts(new ArrayList&lt;&gt;()) .build(); Post post = Post.builder() .id(1L) .title(title) .subTitle(subTitle) .content(content) .category(beforeCategory) .build(); given(categoryService.saveOrFindCategory(afterCategoryName)).willReturn(afterCategory); given(postService.savePost(any(Post.class))).willReturn(post); String requestBody = objectMapper.writeValueAsString(requestPostDto); ResultActions resultActions = mockMvc.perform(post(&quot;/api/post/new&quot;) .with(csrf()) .content(requestBody) .contentType(MediaType.APPLICATION_JSON) ); resultActions .andExpect(status().isCreated()) .andDo(print()); verify(postService).savePost(any(Post.class)); &#125; @Test @WithUserDetails void saveFailTest() throws Exception &#123; String title = new String(&quot;Title&quot;); String subTitle = new String(&quot;subTitle&quot;); String content = new String(&quot;content&quot;); String afterCategoryName = new String(&quot;afterCategory&quot;); RequestPostDto requestPostDto = new RequestPostDto(); requestPostDto.setTitle(title); requestPostDto.setSubTitle(subTitle); requestPostDto.setContent(content); requestPostDto.setCategory(afterCategoryName); Category afterCategory = Category.builder() .name(afterCategoryName) .posts(new ArrayList&lt;&gt;()) .build(); given(categoryService.saveOrFindCategory(afterCategoryName)).willReturn(afterCategory); given(postService.savePost(any(Post.class))).willThrow(PostSaveFailException.class); String requestBody = objectMapper.writeValueAsString(requestPostDto); ResultActions resultActions = mockMvc.perform(post(&quot;/api/post/new&quot;) .content(requestBody) .with(csrf()) .contentType(MediaType.APPLICATION_JSON) ); resultActions .andExpect(status().isBadRequest()) .andDo(print()); verify(postService).savePost(any(Post.class)); &#125; @Test @WithUserDetails void deletePostTest() throws Exception &#123; Long id = 1L; ResultActions resultActions = mockMvc.perform(delete(&quot;/api/post/delete/&quot; + id) .with(csrf())); resultActions .andExpect(status().isOk()) .andDo(print()); verify(postService).deletePost(1L); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Test","slug":"Spring/Spring-Test","permalink":"https://ckck803.github.io/categories/Spring/Spring-Test/"}],"tags":[]},{"title":"Oracle 12c - Docker 로 시작하기","slug":"oracle/oracle-02-12c","date":"2022-03-13T02:10:40.000Z","updated":"2024-02-18T16:19:54.543Z","comments":true,"path":"2022/03/13/oracle/oracle-02-12c/","link":"","permalink":"https://ckck803.github.io/2022/03/13/oracle/oracle-02-12c/","excerpt":"목차 Oracle - Docker 로 시작하기 Oracle 12c - Docker 로 시작하기 11g 제한사항Oracle 11g 의 경우 11G 제한이 걸려 있어서 부득이 하게 12c 로 변경 했다. 11g 가 11G 까지라서 11g 인건가….. SQL Error [12953] [72000]: ORA-12953: The request exceeds the maximum allowed database size of 11 GB 이미지 다운로드 Image : absolutapps&#x2F;oracle-12c-ee docker pull absolutapps/oracle-12c-ee 이미지 실행하기","text":"목차 Oracle - Docker 로 시작하기 Oracle 12c - Docker 로 시작하기 11g 제한사항Oracle 11g 의 경우 11G 제한이 걸려 있어서 부득이 하게 12c 로 변경 했다. 11g 가 11G 까지라서 11g 인건가….. SQL Error [12953] [72000]: ORA-12953: The request exceeds the maximum allowed database size of 11 GB 이미지 다운로드 Image : absolutapps&#x2F;oracle-12c-ee docker pull absolutapps/oracle-12c-ee 이미지 실행하기docker run --name oracle12c -d -p 1521:1521 -v ~/docker/oracle-12c:/u01/app/oracle absolutapps/oracle-12c-ee 로그 확인하기docker logs -f oracle12c ls: cannot access /u01/app/oracle/oradata/orcl: No such file or directoryNo databases found in /u01/app/oracle/oradata/orcl. About to create a new database instanceStarting database listenerLSNRCTL for Linux: Version 12.1.0.2.0 - Production on 13-MAR-2022 05:03:22Copyright (c) 1991, 2014, Oracle. All rights reserved.Starting /u01/app/oracle/product/12.1.0.2/dbhome_1/bin/tnslsnr: please wait...TNSLSNR for Linux: Version 12.1.0.2.0 - ProductionSystem parameter file is /u01/app/oracle/product/12.1.0.2/dbhome_1/network/admin/listener.oraLog messages written to /u01/app/oracle/diag/tnslsnr/96af22c647e9/listener/alert/log.xmlListening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=96af22c647e9)(PORT=1521)))Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=96af22c647e9)(PORT=1521)))STATUS of the LISTENER------------------------Alias LISTENERVersion TNSLSNR for Linux: Version 12.1.0.2.0 - ProductionStart Date 13-MAR-2022 05:03:23Uptime 0 days 0 hr. 0 min. 0 secTrace Level offSecurity ON: Local OS AuthenticationSNMP OFFListener Parameter File /u01/app/oracle/product/12.1.0.2/dbhome_1/network/admin/listener.oraListener Log File /u01/app/oracle/diag/tnslsnr/96af22c647e9/listener/alert/log.xmlListening Endpoints Summary... (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=96af22c647e9)(PORT=1521)))The listener supports no servicesThe command completed successfullyCopying database files1% complete3% complete11% complete18% complete26% complete37% completeCreating and starting Oracle instance40% complete45% complete50% complete55% complete56% complete60% complete62% completeCompleting Database Creation66% complete70% complete73% complete85% complete96% complete100% completeLook at the log file &quot;/u01/app/oracle/cfgtoollogs/dbca/orcl/orcl.log&quot; for further details.LSNRCTL for Linux: Version 12.1.0.2.0 - Production on 13-MAR-2022 05:11:44Copyright (c) 1991, 2014, Oracle. All rights reserved.Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=96af22c647e9)(PORT=1521)))The command completed successfullyDatabase has been created in /u01/app/oracle/oradata/orclSYS and SYSTEM passwords are set to [oracle]Setting HTTP port to 8080PL/SQL procedure successfully completed.Please login to http://&lt;ip_address&gt;:8080/em to use enterprise managerUser: sys; Password oracle; Sysdba: trueFixing permissions...Running init scripts...Init scripts in /oracle.init.d/: Ignoring /oracle.init.d/*Done with scripts we are ready to go","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Oracle","slug":"Programming/Oracle","permalink":"https://ckck803.github.io/categories/Programming/Oracle/"}],"tags":[]},{"title":"Oracle - Docker 로 시작하기","slug":"oracle/oracle-01","date":"2022-03-13T01:10:40.000Z","updated":"2024-02-18T16:19:54.542Z","comments":true,"path":"2022/03/13/oracle/oracle-01/","link":"","permalink":"https://ckck803.github.io/2022/03/13/oracle/oracle-01/","excerpt":"목차 Oracle - Docker 로 시작하기 Oracle 12c - Docker 로 시작하기 이미지 다운로드Oracle 의 경우 Mac 버전 데이터 베이스를 지원하지 않기 때문에 Docker 를 이용해 Oracle 를 이용해보려고 한다. Image : jaspeen&#x2F;oracle-xe-11g docker pull jaspeen/oracle-xe-11g 이미지 실행하기docker run --name oracle11g -d -p 1521:1521 jaspeen/oracle-xe-11g# Docker Volumn 과 외부 Volumn 연결docker run --name oracle11g -d -p 1521:1521 -v ~/docker/oracle:/u01/app/oracle jaspeen/oracle-xe-11g Sqlplus 실행","text":"목차 Oracle - Docker 로 시작하기 Oracle 12c - Docker 로 시작하기 이미지 다운로드Oracle 의 경우 Mac 버전 데이터 베이스를 지원하지 않기 때문에 Docker 를 이용해 Oracle 를 이용해보려고 한다. Image : jaspeen&#x2F;oracle-xe-11g docker pull jaspeen/oracle-xe-11g 이미지 실행하기docker run --name oracle11g -d -p 1521:1521 jaspeen/oracle-xe-11g# Docker Volumn 과 외부 Volumn 연결docker run --name oracle11g -d -p 1521:1521 -v ~/docker/oracle:/u01/app/oracle jaspeen/oracle-xe-11g Sqlplus 실행docker exec -it oracle11g sqlplusSQL*Plus: Release 11.2.0.2.0 Production on Sun Mar 13 03:33:24 2022Copyright (c) 1982, 2011, Oracle. All rights reserved.Enter user-name: systemEnter password: oracle Service 확인SQL&gt; show parameter service_names;NAME TYPE VALUE------------------------------------ ----------- ------------------------------service_names string XE DBeaver 연결하기 Host : Oracle 이 설치 돼 있는 서버 IP 주소 Port : Oracle 서비스를 이용하기 위한 Port Number Database : Service Name 을 명시 Username : Oracle 접속을 위한 username Passowrd : Oracle 접속을 위한 Password","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Oracle","slug":"Programming/Oracle","permalink":"https://ckck803.github.io/categories/Programming/Oracle/"}],"tags":[]},{"title":"프로그래머스 - 양궁 대회 (Python)","slug":"algorithm/programmers/경우의수/92342-양궁대회-python","date":"2022-03-12T11:10:40.000Z","updated":"2024-02-18T16:19:54.515Z","comments":true,"path":"2022/03/12/algorithm/programmers/경우의수/92342-양궁대회-python/","link":"","permalink":"https://ckck803.github.io/2022/03/12/algorithm/programmers/%EA%B2%BD%EC%9A%B0%EC%9D%98%EC%88%98/92342-%EC%96%91%EA%B6%81%EB%8C%80%ED%9A%8C-python/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/92342 프로그래머스 - 키패드누르기 Cpp 프로그래머스 - 키패드누르기 Python 유의 사항 화살을 맞춘 개수를 저장하고 정렬하는데 있어서 주의해야 한다. 정렬에 대한 가중치가 앞자리가 아닌 뒷자리 에 있으므로 값을 저장할 때 뒤집어서 저장한 후 내림 차순으로 정렬해 가장 큰 값을 가져와 해당 값을 뒤집으면 가장 낮은 점수를 많이 맞춘 순서대로 정렬된 값을 가져올 수 있다. cases = []maxDiff: int = 0results = []def getScore(index: int): return 10 - indexdef calScores(ryan: list, apeech: list) -&gt; None: diff: int = 0 apeech_score: int = 0 ryan_score: int = 0 global maxDiff for i in range(11): if apeech[i] == 0 and ryan[i] == 0: continue if ryan[i] &gt; apeech[i]: ryan_score += getScore(i) else: apeech_score += getScore(i) diff = ryan_score - apeech_score if diff &lt;= 0: return if diff &gt;= maxDiff: oneCase: str = &#x27;&#x27;.join(list(map(str, ryan[::-1]))) if(diff &gt; maxDiff): results.clear() maxDiff = diff results.append(oneCase)def makeAllCase(start: int, choice: int, n: int, ryan: list) -&gt; None: if(choice &gt;= n): cases.append(ryan.copy()) return for i in range(start, 11): ryan[i] += 1 makeAllCase(i, choice+1, n, ryan) ryan[i] -= 1def solution(n, info): answer = [] ryan = [0] * 11 makeAllCase(0, 0, n, ryan) for case in cases: calScores(case, info) if len(results) &gt; 0: results.sort(reverse=True) answer = list(map(int, results[0][::-1])) # print(answer) else: answer.append(-1) return answer","text":"https://programmers.co.kr/learn/courses/30/lessons/92342 프로그래머스 - 키패드누르기 Cpp 프로그래머스 - 키패드누르기 Python 유의 사항 화살을 맞춘 개수를 저장하고 정렬하는데 있어서 주의해야 한다. 정렬에 대한 가중치가 앞자리가 아닌 뒷자리 에 있으므로 값을 저장할 때 뒤집어서 저장한 후 내림 차순으로 정렬해 가장 큰 값을 가져와 해당 값을 뒤집으면 가장 낮은 점수를 많이 맞춘 순서대로 정렬된 값을 가져올 수 있다. cases = []maxDiff: int = 0results = []def getScore(index: int): return 10 - indexdef calScores(ryan: list, apeech: list) -&gt; None: diff: int = 0 apeech_score: int = 0 ryan_score: int = 0 global maxDiff for i in range(11): if apeech[i] == 0 and ryan[i] == 0: continue if ryan[i] &gt; apeech[i]: ryan_score += getScore(i) else: apeech_score += getScore(i) diff = ryan_score - apeech_score if diff &lt;= 0: return if diff &gt;= maxDiff: oneCase: str = &#x27;&#x27;.join(list(map(str, ryan[::-1]))) if(diff &gt; maxDiff): results.clear() maxDiff = diff results.append(oneCase)def makeAllCase(start: int, choice: int, n: int, ryan: list) -&gt; None: if(choice &gt;= n): cases.append(ryan.copy()) return for i in range(start, 11): ryan[i] += 1 makeAllCase(i, choice+1, n, ryan) ryan[i] -= 1def solution(n, info): answer = [] ryan = [0] * 11 makeAllCase(0, 0, n, ryan) for case in cases: calScores(case, info) if len(results) &gt; 0: results.sort(reverse=True) answer = list(map(int, results[0][::-1])) # print(answer) else: answer.append(-1) return answer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"경우의 수","slug":"Programming/프로그래머스/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"},{"name":"중복 순열","slug":"Programming/프로그래머스/경우의-수/중복-순열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/%EC%A4%91%EB%B3%B5-%EC%88%9C%EC%97%B4/"}],"tags":[]},{"title":"백준 1197 - 최소 스패닝 트리 (Cpp)","slug":"algorithm/baekjoon/최소스패닝트리/1197-최소스패닝트리-cpp","date":"2022-03-09T01:47:05.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2022/03/09/algorithm/baekjoon/최소스패닝트리/1197-최소스패닝트리-cpp/","link":"","permalink":"https://ckck803.github.io/2022/03/09/algorithm/baekjoon/%EC%B5%9C%EC%86%8C%EC%8A%A4%ED%8C%A8%EB%8B%9D%ED%8A%B8%EB%A6%AC/1197-%EC%B5%9C%EC%86%8C%EC%8A%A4%ED%8C%A8%EB%8B%9D%ED%8A%B8%EB%A6%AC-cpp/","excerpt":"링크 https://www.acmicpc.net/problem/1197 전체 소스 코드#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#define endl &#x27;\\n&#x27;;using namespace std;int find(int node, vector&lt;int&gt;&amp; v) &#123; if (node == v[node]) &#123; return node; &#125; return v[node] = find(v[node], v);&#125;void merge(int a, int b, vector&lt;int&gt;&amp; v) &#123; if (a != b) &#123; v[a] = b; &#125;&#125;int main(void) &#123; int vertex, edge; int totalWeight = 0; cin &gt;&gt; vertex &gt;&gt; edge; vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edges = vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;(vertex + 1); vector&lt;int&gt; v = vector&lt;int&gt;(vertex + 1); for (int i = 0; i &lt; v.size(); i++) &#123; v[i] = i; &#125; for (int i = 0; i &lt; edge; i++) &#123; int from, to, weight; cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight; edges.push_back(&#123;weight, &#123;from, to&#125;&#125;); &#125; sort(edges.begin(), edges.end()); for (auto we : edges) &#123; int weight = we.first; pair&lt;int, int&gt; e = we.second; int from = e.first; int to = e.second; int setA = find(from, v); int setB = find(to, v); if (setA != setB) &#123; totalWeight += weight; merge(setA, setB, v); &#125; &#125; cout &lt;&lt; totalWeight &lt;&lt; endl; return 0;&#125;","text":"링크 https://www.acmicpc.net/problem/1197 전체 소스 코드#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#define endl &#x27;\\n&#x27;;using namespace std;int find(int node, vector&lt;int&gt;&amp; v) &#123; if (node == v[node]) &#123; return node; &#125; return v[node] = find(v[node], v);&#125;void merge(int a, int b, vector&lt;int&gt;&amp; v) &#123; if (a != b) &#123; v[a] = b; &#125;&#125;int main(void) &#123; int vertex, edge; int totalWeight = 0; cin &gt;&gt; vertex &gt;&gt; edge; vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edges = vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;(vertex + 1); vector&lt;int&gt; v = vector&lt;int&gt;(vertex + 1); for (int i = 0; i &lt; v.size(); i++) &#123; v[i] = i; &#125; for (int i = 0; i &lt; edge; i++) &#123; int from, to, weight; cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight; edges.push_back(&#123;weight, &#123;from, to&#125;&#125;); &#125; sort(edges.begin(), edges.end()); for (auto we : edges) &#123; int weight = we.first; pair&lt;int, int&gt; e = we.second; int from = e.first; int to = e.second; int setA = find(from, v); int setB = find(to, v); if (setA != setB) &#123; totalWeight += weight; merge(setA, setB, v); &#125; &#125; cout &lt;&lt; totalWeight &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"그래프","slug":"Programming/Beakjoon/그래프","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EA%B7%B8%EB%9E%98%ED%94%84/"}],"tags":[]},{"title":"Spring - Embedded Kafka 사용하기","slug":"spring/spring-kafka/spring-kafka-embedded","date":"2022-03-08T14:47:05.000Z","updated":"2024-02-26T16:10:59.043Z","comments":true,"path":"2022/03/08/spring/spring-kafka/spring-kafka-embedded/","link":"","permalink":"https://ckck803.github.io/2022/03/08/spring/spring-kafka/spring-kafka-embedded/","excerpt":"목자 Spring - Kafka Spring - Kafka Java Config 사용하기 Spring - Embedded Kafka 사용하기 스프링 부트 카프카 사용하기참고https://www.baeldung.com/spring-boot-kafka-testing 의존성testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27;testImplementation &#x27;org.springframework.kafka:spring-kafka-test&#x27;// https://mvnrepository.com/artifact/org.testcontainers/kafkatestImplementation group: &#x27;org.testcontainers&#x27;, name: &#x27;kafka&#x27;, version: &#x27;1.16.3&#x27; Spring Propertiesspring: kafka: consumer: auto-offset-reset: earliest group-id: baeldungtest: topic: embedded-test-topic","text":"목자 Spring - Kafka Spring - Kafka Java Config 사용하기 Spring - Embedded Kafka 사용하기 스프링 부트 카프카 사용하기참고https://www.baeldung.com/spring-boot-kafka-testing 의존성testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27;testImplementation &#x27;org.springframework.kafka:spring-kafka-test&#x27;// https://mvnrepository.com/artifact/org.testcontainers/kafkatestImplementation group: &#x27;org.testcontainers&#x27;, name: &#x27;kafka&#x27;, version: &#x27;1.16.3&#x27; Spring Propertiesspring: kafka: consumer: auto-offset-reset: earliest group-id: baeldungtest: topic: embedded-test-topic Producer@Componentpublic class KafkaProducer &#123; private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProducer.class); @Autowired private KafkaTemplate&lt;String, String&gt; kafkaTemplate; public void send(String topic, String payload) &#123; LOGGER.info(&quot;sending payload=&#x27;&#123;&#125;&#x27; to topic=&#x27;&#123;&#125;&#x27;&quot;, payload, topic); kafkaTemplate.send(topic, payload); &#125;&#125; Consumer@Componentpublic class KafkaConsumer &#123; private static final Logger LOGGER = LoggerFactory.getLogger(KafkaConsumer.class); private CountDownLatch latch = new CountDownLatch(1); private String payload = null; @KafkaListener(topics = &quot;$&#123;test.topic&#125;&quot;) public void receive(ConsumerRecord&lt;?, ?&gt; consumerRecord) &#123; LOGGER.info(&quot;received payload=&#x27;&#123;&#125;&#x27;&quot;, consumerRecord.toString()); setPayload(consumerRecord.toString()); latch.countDown(); &#125; public CountDownLatch getLatch() &#123; return latch; &#125; public String getPayload() &#123; return payload; &#125; private void setPayload(String payload) &#123; this.payload = payload; &#125;&#125; EmbeddedKafka 를 이용한 Test 코드 작성 @EmbeddedKafka 어노테이션을 사용하면 테스트 실행시 필요한 EmbeddedKafkaBroker 를 설정할 수 있다. partitions : EmbeddedKafka 내 Partition 개수를 설정한다. brokerProperties : EmbeddedKafka Broker 설정을 한다. @SpringBootTest@DirtiesContext@EmbeddedKafka(partitions = 1, brokerProperties = &#123; &quot;listeners=PLAINTEXT://localhost:9092&quot;, &quot;port=9092&quot; &#125;)class EmbeddedKafkaApplicationTests &#123; @Autowired public KafkaTemplate&lt;String, String&gt; template; @Autowired private KafkaConsumer consumer; @Autowired private KafkaProducer producer; @Value(&quot;$&#123;test.topic&#125;&quot;) private String topic; @Test public void givenEmbeddedKafkaBroker_whenSendingtoDefaultTemplate_thenMessageReceived() throws Exception &#123; template.send(topic, &quot;Sending with default template&quot;); consumer.getLatch().await(10000, TimeUnit.MILLISECONDS); assertThat(consumer.getLatch().getCount(), equalTo(0L)); assertThat(consumer.getPayload(), containsString(&quot;embedded-test-topic&quot;)); &#125; @Test public void givenEmbeddedKafkaBroker_whenSendingtoSimpleProducer_thenMessageReceived() throws Exception &#123; producer.send(topic, &quot;Sending with our own simple KafkaProducer&quot;); consumer.getLatch().await(10000, TimeUnit.MILLISECONDS); assertThat(consumer.getLatch().getCount(), equalTo(0L)); assertThat(consumer.getPayload(), containsString(&quot;embedded-test-topic&quot;)); &#125;&#125; Test Container 를 이용한 Kafka Test 코드 작성 KafkaContainer 객체를 이용해 Test 시 사용할 Kafka Container 를 가져올 수 있다. @RunWith(SpringRunner.class)@Import(KafkaTestContainersLiveTest.KafkaTestContainersConfiguration.class)@SpringBootTest(classes = EmbeddedKafkaApplication.class)@DirtiesContextpublic class KafkaTestContainersLiveTest &#123; @ClassRule public static KafkaContainer kafka = new KafkaContainer(DockerImageName.parse(&quot;confluentinc/cp-kafka:5.4.3&quot;)); @Autowired public KafkaTemplate&lt;String, String&gt; template; @Autowired private KafkaConsumer consumer; @Autowired private KafkaProducer producer; @Value(&quot;$&#123;test.topic&#125;&quot;) private String topic; @Test public void givenKafkaDockerContainer_whenSendingtoDefaultTemplate_thenMessageReceived() throws Exception &#123; template.send(topic, &quot;Sending with default template&quot;); consumer.getLatch().await(10000, TimeUnit.MILLISECONDS); assertThat(consumer.getLatch().getCount(), CoreMatchers.equalTo(0L)); assertThat(consumer.getPayload(), CoreMatchers.containsString(&quot;embedded-test-topic&quot;)); &#125; @Test public void givenKafkaDockerContainer_whenSendingtoSimpleProducer_thenMessageReceived() throws Exception &#123; producer.send(topic, &quot;Sending with own controller&quot;); consumer.getLatch().await(10000, TimeUnit.MILLISECONDS); assertThat(consumer.getLatch().getCount(), CoreMatchers.equalTo(0L)); assertThat(consumer.getPayload(), CoreMatchers.containsString(&quot;embedded-test-topic&quot;)); &#125; @TestConfiguration static class KafkaTestContainersConfiguration &#123; @Bean ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; kafkaListenerContainerFactory() &#123; ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); return factory; &#125; @Bean public ConsumerFactory&lt;Integer, String&gt; consumerFactory() &#123; return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); &#125; @Bean public Map&lt;String, Object&gt; consumerConfigs() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()); props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;); props.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;baeldung&quot;); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return props; &#125; @Bean public ProducerFactory&lt;String, String&gt; producerFactory() &#123; Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;(); configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()); configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); return new DefaultKafkaProducerFactory&lt;&gt;(configProps); &#125; @Bean public KafkaTemplate&lt;String, String&gt; kafkaTemplate() &#123; return new KafkaTemplate&lt;&gt;(producerFactory()); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Kafka","slug":"Spring/Kafka","permalink":"https://ckck803.github.io/categories/Spring/Kafka/"}],"tags":[]},{"title":"Spring - Kafka Java Config 사용하기","slug":"spring/spring-kafka/springboot-kafka-javaconfig","date":"2022-03-07T14:47:05.000Z","updated":"2024-02-26T16:10:53.099Z","comments":true,"path":"2022/03/07/spring/spring-kafka/springboot-kafka-javaconfig/","link":"","permalink":"https://ckck803.github.io/2022/03/07/spring/spring-kafka/springboot-kafka-javaconfig/","excerpt":"목자 Spring - Kafka Spring - Kafka Java Config 사용하기 Spring - Embedded Kafka 사용하기 스프링 부트 카프카 사용하기참고https://www.baeldung.com/spring-kafka 목자 Post not found: spring-boot/spring-kafka/springboot-kafka Post not found: spring-boot/spring-kafka/springboot-kafka-javaconfig 의존성 추가implementation &#x27;org.springframework.kafka:spring-kafka&#x27;testImplementation &#x27;org.springframework.kafka:spring-kafka-test&#x27;","text":"목자 Spring - Kafka Spring - Kafka Java Config 사용하기 Spring - Embedded Kafka 사용하기 스프링 부트 카프카 사용하기참고https://www.baeldung.com/spring-kafka 목자 Post not found: spring-boot/spring-kafka/springboot-kafka Post not found: spring-boot/spring-kafka/springboot-kafka-javaconfig 의존성 추가implementation &#x27;org.springframework.kafka:spring-kafka&#x27;testImplementation &#x27;org.springframework.kafka:spring-kafka-test&#x27; 카프카에 접속하기 위한 설정kafka: bootstrapAddress: localhost:9092 message: topic: test consumer: group-id: foo Topic 설정KafkaAdmin 는 Kafka 에 해당 Topic 이 없을 경우 자동으로 Topic 을 생성해준다. @Configurationpublic class KafkaTopicConfig &#123; @Value(&quot;$&#123;kafka.bootstrapAddress&#125;&quot;) private String bootstrapAddress; @Bean public KafkaAdmin kafkaAdmin()&#123; Map&lt;String, Object&gt; configs = new HashMap&lt;&gt;(); configs.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress); return new KafkaAdmin(configs); &#125; @Bean public NewTopic topic()&#123; // 1. Topic 명, 2. Partition 개수, 3. Replication 수 return new NewTopic(&quot;test&quot;, 1, (short) 1); &#125;&#125; Producer 설정ProducerConfig 를 이용해 Producer 를 사용하기 위해 필요한 값들을 설정해준다. BOOTSTRAP_SERVERS_CONFIG 연결하기 위한 Kafka Server 주소 정보를 설정 KEY_SERIALIZER_CLASS_CONFIG 카프카로 Key 값을 보내기 위해 직렬화 하기 위한 정보를 설정 VALUE_SERIALIZER_CLASS_CONFIG 카프카로 Value 값을 보내기 위해 직렬화 하기 위한 정보를 설정 MAX_REQUEST_SIZE_CONFIG Producer 가 카프카로 보낼 수 있는 Message 최대 크기를 설정 @Configurationpublic class KafkaProducerConfig &#123; @Value(value = &quot;$&#123;kafka.bootstrapAddress&#125;&quot;) private String bootstrapAddress; @Bean public ProducerFactory&lt;String, String&gt; producerFactory()&#123; Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;(); configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress); configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); configProps.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, &quot;20971520&quot;); return new DefaultKafkaProducerFactory&lt;&gt;(configProps); &#125; @Bean public KafkaTemplate&lt;String, String&gt; kafkaTemplate()&#123; return new KafkaTemplate&lt;&gt;(producerFactory()); &#125;&#125; Consummer 설정ConsumerConfig 를 이용해 Consumer 를 사용하기 위해 필요한 값들을 설정해준다. BOOTSTRAP_SERVERS_CONFIG 연결하기 위한 Kafka Server 주소를 설정 KEY_DESERIALIZER_CLASS_CONFIG 카프카에서 전달 받은 Key 값을 역질렬화 하기 위한 정보를 설정 VALUE_DESERIALIZER_CLASS_CONFIG 카프카에서 전달 받은 Value 값을 역질렬화 하기 위한 정보를 설정 GROUP_ID_CONFIG 카프카 Consumer Group 정보를 설정 @Configuration@EnableKafkapublic class KafkaConsumerConfig &#123; @Value(value = &quot;$&#123;kafka.bootstrapAddress&#125;&quot;) private String bootstrapAddress; @Value(value = &quot;$&#123;kafka.consumer.group-id&#125;&quot;) private String consumerGroupId; @Bean public ConsumerFactory&lt;String, String&gt; consumerFactory()&#123; Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;(); configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress); configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); configProps.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId); return new DefaultKafkaConsumerFactory&lt;&gt;(configProps); &#125; @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory()&#123; ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); return factory; &#125;&#125; Producer@Service@RequiredArgsConstructor@Slf4jpublic class KafkaProducer &#123; private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; @Value(value = &quot;$&#123;kafka.message.topic&#125;&quot;) private String topicName; public void sendMessage(String message) &#123; ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; future = kafkaTemplate.send(topicName, message); future.addCallback(new ListenableFutureCallback&lt;&gt;() &#123; @Override public void onSuccess(SendResult&lt;String, String&gt; result) &#123; log.info(&quot;Sent message=[&quot; + message + &quot;] with offset=[&quot; + result.getRecordMetadata() .offset() + &quot;]&quot;); &#125; @Override public void onFailure(Throwable ex) &#123; log.info(&quot;Unable to send message=[&quot; + message + &quot;] due to : &quot; + ex.getMessage()); &#125; &#125;); &#125;&#125; Consumer@Servicepublic class KafkaConsumer &#123; private CountDownLatch latch = new CountDownLatch(3); @KafkaListener(topics = &quot;$&#123;kafka.message.topic&#125;&quot;, groupId = &quot;foo&quot;) public void listenGroupFoo(String message) &#123; System.out.println(&quot;Received Message in group &#x27;foo&#x27;: &quot; + message); latch.countDown(); &#125;&#125; Controller@RestController@RequestMapping(&quot;/kafka&quot;)@RequiredArgsConstructor@Slf4jpublic class KafkaController &#123; private final KafkaProducer kafkaProducer; @PostMapping public String sendMessage(@RequestParam(&quot;message&quot;) String message) &#123; this.kafkaProducer.sendMessage(message); log.info(&quot;Request Success = &#123;&#125;&quot;, message); return &quot;success&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Kafka","slug":"Spring/Kafka","permalink":"https://ckck803.github.io/categories/Spring/Kafka/"}],"tags":[]},{"title":"네트워크 - STOMP","slug":"computer-science/network/http/stomp","date":"2022-03-07T05:16:32.000Z","updated":"2024-02-18T16:19:54.519Z","comments":true,"path":"2022/03/07/computer-science/network/http/stomp/","link":"","permalink":"https://ckck803.github.io/2022/03/07/computer-science/network/http/stomp/","excerpt":"STOMP (Simple Text Oriented Messaging Protocol)WebSocket 프로토콜은 두 가지 유형의 메세지를 정의하고 있지만 그 메세지의 내용까지는 정의하고 있지 않는다. STOMP (Simple Text Oriented Messaging Protocol) 은 메세징 전송을 효율적으로 하기 위해 탄생한 프로토콜 기본적으로 pub/sub 구조로 되어있어 메세지를 전송하고 메세지를 받아 처리하는 부분이 확실히 정해져 있기 때문에 개발자 입장에서 명확하게 인지하고 개발할 수 있는 이점이 있다. 한 줄로 정의하자면, STOMP 프로토콜은 WebSocket 위에서 동작하는 프로토콜로써 클라이언트와 서버가 전송할 메세지의 유형, 형식, 내용들을 정의하는 매커니즘 이다. 또한 STOMP를 이용하면 메세지의 헤더에 값을 줄 수 있어 헤더 값을 기반으로 통신 시 인증 처리를 구현하는 것도 가능하며 STOMP 스펙에 정의한 규칙만 잘 지키면 여러 언어 및 플랫폼 간 메세지를 상호 운영할 수 있다.","text":"STOMP (Simple Text Oriented Messaging Protocol)WebSocket 프로토콜은 두 가지 유형의 메세지를 정의하고 있지만 그 메세지의 내용까지는 정의하고 있지 않는다. STOMP (Simple Text Oriented Messaging Protocol) 은 메세징 전송을 효율적으로 하기 위해 탄생한 프로토콜 기본적으로 pub/sub 구조로 되어있어 메세지를 전송하고 메세지를 받아 처리하는 부분이 확실히 정해져 있기 때문에 개발자 입장에서 명확하게 인지하고 개발할 수 있는 이점이 있다. 한 줄로 정의하자면, STOMP 프로토콜은 WebSocket 위에서 동작하는 프로토콜로써 클라이언트와 서버가 전송할 메세지의 유형, 형식, 내용들을 정의하는 매커니즘 이다. 또한 STOMP를 이용하면 메세지의 헤더에 값을 줄 수 있어 헤더 값을 기반으로 통신 시 인증 처리를 구현하는 것도 가능하며 STOMP 스펙에 정의한 규칙만 잘 지키면 여러 언어 및 플랫폼 간 메세지를 상호 운영할 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"}],"tags":[]},{"title":"네트워크 - Web Socket","slug":"computer-science/network/http/websocket","date":"2022-03-06T14:16:32.000Z","updated":"2024-02-18T16:19:54.519Z","comments":true,"path":"2022/03/06/computer-science/network/http/websocket/","link":"","permalink":"https://ckck803.github.io/2022/03/06/computer-science/network/http/websocket/","excerpt":"웹 소켓 Web Socket 웹 소켓이란 두 프로그램 간의 메시지를 교환하기 위한 통신 방법 중 하나, 현재 HTML5 에서 많이 사용하는 방식이다. WebSocket 프로토콜은 Text, Binary 두 가지 유형의 메세지를 정의하고 있지만 그 메세지의 내용까지는 정의하고 있지 않는다. 특징 양방향 통신 (Full-Duplex) 데이터 송수신을 동시에 처리할 수 있는 통신 방법 클라이언트와 서버가 서로에게 원할 때 데이터를 주고 받을 수 있다. Http 통신은 Client 가 요청을 보내고 Server 가 요청에 대해 응답을 보내주는 단방향 통신 실시간 네트워킹 웹 환경에서 연속된 데이터를 빠르게 노출할 수 있다. Web Socket 이전 기술 위 기술들은 HTTP 위에서 동작하므로 Request, Response 둘다 Header 가 불필요하게 크다. Polling 서버로 일정 주기로 요청을 송신하는 방식이다. Real-time 통신에서는 언제 통신이 발생할지 예측이 불가능 하므로 주기적으로 Request 와 Connection을 생성한다. 불필요한 Request 와 Connection 을 위한 자원 Loss 가 발생 Long Polling 서버에서 요청을 보내고 이벤트가 생겨 응답 받을 때 까지 연결을 종료하지 않는다. 응답을 받으면 귾고 다시 재요청을 한다. 많은 양의 메시지가 쏟아질 경우 Polling 과 같다. Streaming 서버에 요청을 보내고 끊기지 않는 연결 상태에서 끊임 없이 데이터를 수신한다. 클라이언트에서 서버로의 데이터 송신이 어렵다.","text":"웹 소켓 Web Socket 웹 소켓이란 두 프로그램 간의 메시지를 교환하기 위한 통신 방법 중 하나, 현재 HTML5 에서 많이 사용하는 방식이다. WebSocket 프로토콜은 Text, Binary 두 가지 유형의 메세지를 정의하고 있지만 그 메세지의 내용까지는 정의하고 있지 않는다. 특징 양방향 통신 (Full-Duplex) 데이터 송수신을 동시에 처리할 수 있는 통신 방법 클라이언트와 서버가 서로에게 원할 때 데이터를 주고 받을 수 있다. Http 통신은 Client 가 요청을 보내고 Server 가 요청에 대해 응답을 보내주는 단방향 통신 실시간 네트워킹 웹 환경에서 연속된 데이터를 빠르게 노출할 수 있다. Web Socket 이전 기술 위 기술들은 HTTP 위에서 동작하므로 Request, Response 둘다 Header 가 불필요하게 크다. Polling 서버로 일정 주기로 요청을 송신하는 방식이다. Real-time 통신에서는 언제 통신이 발생할지 예측이 불가능 하므로 주기적으로 Request 와 Connection을 생성한다. 불필요한 Request 와 Connection 을 위한 자원 Loss 가 발생 Long Polling 서버에서 요청을 보내고 이벤트가 생겨 응답 받을 때 까지 연결을 종료하지 않는다. 응답을 받으면 귾고 다시 재요청을 한다. 많은 양의 메시지가 쏟아질 경우 Polling 과 같다. Streaming 서버에 요청을 보내고 끊기지 않는 연결 상태에서 끊임 없이 데이터를 수신한다. 클라이언트에서 서버로의 데이터 송신이 어렵다. Web Socket 핸드 쉐이킹 HTTP, HTTPS 를 이용해 HandShaking 이 일어난다. 핸드 쉐이킹이 완료 되면 HTTP, HTTPS 에서 ws, wss 로 프로토콜이 변경된다. Close Frame 을 받게 되면 Connection 이 종료된다. 한계 HTML5 이전에 구현된 서비스에서는 Web Socket 을 사용할 수 없다. Socket.io, SockJS 와 같은 기술을 통해 웹 소켓 처럼 사용할 수 있다. 문자열들을 주고 받을 수 있게만 하는 역할 문자열의 해독은 온전히 어플리케이션에서 처리해야 한다. HTTP 는 형식을 정해 뒀기 때문에 형식에 맞춰 해석할 수 있다. Web Socket은 형식이 정해져 있지 않아 어플리케이션에서 쉽게 해석하기 힘들다. sub-protocols 을 이용해 주고 받는 메시지 형태를 약속한다.(ex. STOMP) 채팅 통신을 위한 형식을 정의 HTTP 와 유사하게 간단히 정의 돼 해석하기 편한 프로토콜 Web Socket 위에서 사용된다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"}],"tags":[]},{"title":"Database - 서브 쿼리","slug":"database/subquery","date":"2022-03-05T16:15:42.000Z","updated":"2024-02-18T16:19:54.525Z","comments":true,"path":"2022/03/06/database/subquery/","link":"","permalink":"https://ckck803.github.io/2022/03/06/database/subquery/","excerpt":"서브 쿼리 서브쿼리란 쿼리안의 보조 쿼리를 가르키는 용어다. 서브 쿼리가 어느 위치에 있는지에 따라서 불리는 용어가 살짝씩 다르다. 스칼라 서브 쿼리 인라인 뷰 중첩 서브 쿼리 스칼라 서브 쿼리SELECT 절에 서브쿼리가 있을 경우 스칼라 서브쿼리 라고 불린다. 스칼라 서브 쿼리는 반환되는 데이터 값이 1행 1열의 구조로 출력 돼야 한다. 인라인 뷰FROM 절에 서브쿼리가 있는 경우 인라인 뷰 라고 불린다. FROM 절 냅에 일시적으로 뷰를 생성하는 방식이라 인라인 뷰라고 불린다. 인라인 뷰의 결과는 내부적으로 메모리 또는 디스크에 임시 테이블을 생성해 활용한다. 중첩 서브쿼리WHERE 절에 서브쿼리가 있는 경우 중첩 서브쿼리 라고 불린다.","text":"서브 쿼리 서브쿼리란 쿼리안의 보조 쿼리를 가르키는 용어다. 서브 쿼리가 어느 위치에 있는지에 따라서 불리는 용어가 살짝씩 다르다. 스칼라 서브 쿼리 인라인 뷰 중첩 서브 쿼리 스칼라 서브 쿼리SELECT 절에 서브쿼리가 있을 경우 스칼라 서브쿼리 라고 불린다. 스칼라 서브 쿼리는 반환되는 데이터 값이 1행 1열의 구조로 출력 돼야 한다. 인라인 뷰FROM 절에 서브쿼리가 있는 경우 인라인 뷰 라고 불린다. FROM 절 냅에 일시적으로 뷰를 생성하는 방식이라 인라인 뷰라고 불린다. 인라인 뷰의 결과는 내부적으로 메모리 또는 디스크에 임시 테이블을 생성해 활용한다. 중첩 서브쿼리WHERE 절에 서브쿼리가 있는 경우 중첩 서브쿼리 라고 불린다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"}],"tags":[]},{"title":"Oracle - Clustering Factor","slug":"database/oracle/clustering-factor","date":"2022-03-05T16:15:42.000Z","updated":"2024-02-18T16:19:54.523Z","comments":true,"path":"2022/03/06/database/oracle/clustering-factor/","link":"","permalink":"https://ckck803.github.io/2022/03/06/database/oracle/clustering-factor/","excerpt":"Oracle - Clustering Factor 데이터베이스에서는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다. 인덱스 클러스터링 팩터가 좋다. 고 하면 인덱스 정렬 순서 와 테이블 정렬 순서 가 서로 비슷하다는 것을 말한다. Index Scan의 Cost에 큰 영향을 준다. Index Lookup을 통해 Data를 읽는 일량을 결정한다.","text":"Oracle - Clustering Factor 데이터베이스에서는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다. 인덱스 클러스터링 팩터가 좋다. 고 하면 인덱스 정렬 순서 와 테이블 정렬 순서 가 서로 비슷하다는 것을 말한다. Index Scan의 Cost에 큰 영향을 준다. Index Lookup을 통해 Data를 읽는 일량을 결정한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Oracle","slug":"Programming/Oracle","permalink":"https://ckck803.github.io/categories/Programming/Oracle/"}],"tags":[]},{"title":"Kafka Consumer","slug":"kafka/kafka-consumer","date":"2022-03-02T13:25:35.000Z","updated":"2024-03-18T15:29:11.271Z","comments":true,"path":"2022/03/02/kafka/kafka-consumer/","link":"","permalink":"https://ckck803.github.io/2022/03/02/kafka/kafka-consumer/","excerpt":"Kafka Consumer카프카에서는 Consumer 가 데이터를 가져가도 데이터가 사라지지 않는다. Kafka Consumer 는 기본적으로 Topic 의 데이터를 가져온다. 데이터를 가져오는 것을 Polling 이라고 한다. Partition Offset 위치 기록(Commit) Consumer Group 을 통해 병렬 처리 offset 메시지가 파티션 내에서 가지는 고유의 번호 offset 은 토픽 별로 파티션 별로 별개로 지정된다. Consumer 가 데이터를 어느지점까지 읽었는지 확인하는 용도로 사용한다. Consumer 가 데이터를 읽어가면 offset 을 Commit 한다. Consumer 가 Partition 의 읽은 위치(offset) 은 Kafka 의 __Consumer_offset 토픽에 저장된다. Consumer 가 중지가 되더라도 시작 위치를 알고 있으므로 다시 복구하여 데이터를 처리할 수 있다. Multiple Consumer Consumer 개수는 Partition 개수보다 적거나 같아야 한다. 여러 Partition 을 가진 Topic 에 대해 Consumer 가 병렬 처리하게 하기 위해서는 Consumer 가 Partition의 개수보다 작아야 한다. 다른 Consumer Group","text":"Kafka Consumer카프카에서는 Consumer 가 데이터를 가져가도 데이터가 사라지지 않는다. Kafka Consumer 는 기본적으로 Topic 의 데이터를 가져온다. 데이터를 가져오는 것을 Polling 이라고 한다. Partition Offset 위치 기록(Commit) Consumer Group 을 통해 병렬 처리 offset 메시지가 파티션 내에서 가지는 고유의 번호 offset 은 토픽 별로 파티션 별로 별개로 지정된다. Consumer 가 데이터를 어느지점까지 읽었는지 확인하는 용도로 사용한다. Consumer 가 데이터를 읽어가면 offset 을 Commit 한다. Consumer 가 Partition 의 읽은 위치(offset) 은 Kafka 의 __Consumer_offset 토픽에 저장된다. Consumer 가 중지가 되더라도 시작 위치를 알고 있으므로 다시 복구하여 데이터를 처리할 수 있다. Multiple Consumer Consumer 개수는 Partition 개수보다 적거나 같아야 한다. 여러 Partition 을 가진 Topic 에 대해 Consumer 가 병렬 처리하게 하기 위해서는 Consumer 가 Partition의 개수보다 작아야 한다. 다른 Consumer Group 각기 다른 Consumber Group 은 다른 Consumer Group 에 영향을 미치지 않는다. Consumer Group 별로 Topic 별로 offset 을 나누어 저장하기 때문이다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"Kafka","slug":"Develop/Kafka","permalink":"https://ckck803.github.io/categories/Develop/Kafka/"}],"tags":[]},{"title":"Kafka Partitioner","slug":"kafka/kafka-partitioner","date":"2022-03-02T13:25:35.000Z","updated":"2024-03-18T13:49:39.446Z","comments":true,"path":"2022/03/02/kafka/kafka-partitioner/","link":"","permalink":"https://ckck803.github.io/2022/03/02/kafka/kafka-partitioner/","excerpt":"Kafka Partitioner Producer 가 데이터를 보내면 무조건 Partitioner 를 통해 Broker 로 데이터를 보낸다. Recode 에 포함된 Message Key 혹은 Message 값에 따라서 Partition 의 위치가 결정된다. Producer 를 사용할때 Partitiooner 를 설정하지 않는다면 UniformStickyPartitioner 로 설정된다. Key 가 있는 Message Message Key 를 가진 레코드는 Partitioner 에 의해서 특정한 Hash 값이 생성된다. 해당 Hash 값을 이용해 어느 Partition 에 저장될지 결정된다. 동일한 Message Key 를 가진 Record 는 동일한 Hash 값을 만들기 때문에 항상 동일한 Partition 에 들어가는 것을 보장한다. 순서를 지켜서 데이터를 처리할 수 있는 장점이 있다. Partition 내부에서는 Queue 처럼 동작하기 때문에 순서를 지킬 수 있다. Key 가 없는 MessageRound Robin 형태로 데이터가 들어가게 된다. UniformStickyPartitioner 는 프로듀서에서 배치로 모을 수 있는 최대한의 Record 를 모아서 Partition 으로 데이터를 보내게 된다. Message Key 가 없는 Record 들은 Partition 에 적절히 분배된다.","text":"Kafka Partitioner Producer 가 데이터를 보내면 무조건 Partitioner 를 통해 Broker 로 데이터를 보낸다. Recode 에 포함된 Message Key 혹은 Message 값에 따라서 Partition 의 위치가 결정된다. Producer 를 사용할때 Partitiooner 를 설정하지 않는다면 UniformStickyPartitioner 로 설정된다. Key 가 있는 Message Message Key 를 가진 레코드는 Partitioner 에 의해서 특정한 Hash 값이 생성된다. 해당 Hash 값을 이용해 어느 Partition 에 저장될지 결정된다. 동일한 Message Key 를 가진 Record 는 동일한 Hash 값을 만들기 때문에 항상 동일한 Partition 에 들어가는 것을 보장한다. 순서를 지켜서 데이터를 처리할 수 있는 장점이 있다. Partition 내부에서는 Queue 처럼 동작하기 때문에 순서를 지킬 수 있다. Key 가 없는 MessageRound Robin 형태로 데이터가 들어가게 된다. UniformStickyPartitioner 는 프로듀서에서 배치로 모을 수 있는 최대한의 Record 를 모아서 Partition 으로 데이터를 보내게 된다. Message Key 가 없는 Record 들은 Partition 에 적절히 분배된다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"Kafka","slug":"Develop/Kafka","permalink":"https://ckck803.github.io/categories/Develop/Kafka/"}],"tags":[]},{"title":"Kafka Replication","slug":"kafka/kafka-replication","date":"2022-03-02T13:25:35.000Z","updated":"2024-03-18T13:49:39.470Z","comments":true,"path":"2022/03/02/kafka/kafka-replication/","link":"","permalink":"https://ckck803.github.io/2022/03/02/kafka/kafka-replication/","excerpt":"Kafka Broker카프카가 설치 돼 있는 서버 단위를 말한다. 보통 3개 이상의 Broker 로 구성해 사용하는 것을 권장 Replication 데이터의 복제를 의미한다 Replication 은 Partition 의 고가용성 을 위해 사용된다. 3개 이상의 Broker 를 사용할 때 Replication 은 3으로 설정하는 것이 좋다 Replication 이 1인 경우 Partition 이 원본 1개만 존재한다는 것이다. Replication 이 2인 경우 Partition 이 원본 1개와 복재본 1개 총 2개가 존재함을 의미한다. Replication 이 3인 경우 Partition 이 원본 1개와 복재본 2개 총 3개가 존재함을 의미한다. Broker 개수에 따라서 Replication 개수가 제한된다. Replication 의 개수는 Broker의 개수를 넘어설 수 없다. 원본 Partition 은 Leader Partition 이라 부르고, 복재본 Partition 은 Follower Partition 이라 부른다. Leader Partition 과 Follower Partition 을 합쳐서 ISR (In Sync Replica) 라고 부른다. Producer 가 Topic 의 Partition 에 데이터를 전달할 때 전달받는 주체가 Leader Partition 이된다. Replication 이 1인 경우 Partition 이 한개고 Replication 이 1인 Topic 이 존재하고 Broker 가 3대라면 Broker 3대 중 1대에 해당 Topic 정보가 저장된다.","text":"Kafka Broker카프카가 설치 돼 있는 서버 단위를 말한다. 보통 3개 이상의 Broker 로 구성해 사용하는 것을 권장 Replication 데이터의 복제를 의미한다 Replication 은 Partition 의 고가용성 을 위해 사용된다. 3개 이상의 Broker 를 사용할 때 Replication 은 3으로 설정하는 것이 좋다 Replication 이 1인 경우 Partition 이 원본 1개만 존재한다는 것이다. Replication 이 2인 경우 Partition 이 원본 1개와 복재본 1개 총 2개가 존재함을 의미한다. Replication 이 3인 경우 Partition 이 원본 1개와 복재본 2개 총 3개가 존재함을 의미한다. Broker 개수에 따라서 Replication 개수가 제한된다. Replication 의 개수는 Broker의 개수를 넘어설 수 없다. 원본 Partition 은 Leader Partition 이라 부르고, 복재본 Partition 은 Follower Partition 이라 부른다. Leader Partition 과 Follower Partition 을 합쳐서 ISR (In Sync Replica) 라고 부른다. Producer 가 Topic 의 Partition 에 데이터를 전달할 때 전달받는 주체가 Leader Partition 이된다. Replication 이 1인 경우 Partition 이 한개고 Replication 이 1인 Topic 이 존재하고 Broker 가 3대라면 Broker 3대 중 1대에 해당 Topic 정보가 저장된다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"Kafka","slug":"Develop/Kafka","permalink":"https://ckck803.github.io/categories/Develop/Kafka/"}],"tags":[]},{"title":"Kafka Producer","slug":"kafka/kafka-producer","date":"2022-03-02T13:25:35.000Z","updated":"2024-03-21T00:40:17.129Z","comments":true,"path":"2022/03/02/kafka/kafka-producer/","link":"","permalink":"https://ckck803.github.io/2022/03/02/kafka/kafka-producer/","excerpt":"카프카 프로듀서카프카 프로듀서는 브로커에 존재하는 토픽에 메시지를 전달하는 역할을 담당합니다. Topic 에 해당하는 메시지를 생성 후 해당 Topic으로 데이터를 publish 한다. 또한, 메시지 전송이 실패할 경우, 재전송을 한다. 카프카 프로듀서는 브로커로 메시지를 보낼때 파티션 Key 도 함께 보낼 수 있습니다. 브로커는 파티션 Key 의 유무에 따라 데이터를 저장하는 방식이 달라집니다. 파티션 Key 가 null 인 데이터 전송Topic 에 Partition 이 한개인 경우는 데이터들이 순차적으로 쌓이게 된다. Topic 에 Partition 이 여러개인 경우 Round Robin 형식으로 데이터가 쌓이게 된다. 파티션 Key 를 전송할 경우Kafka 는 Key 를 특정한 Hash 값으로 변형 시켜 Partition 과 1:1 매칭을 시킵니다. 각 파티션에 동일 Key 의 Value 만 쌓이게 된다. Partition 의 개수와 Key 의 개수가 일치하지 않는 경우 Key 와 Partition 의 매칭이 깨지게 돼 Key 와 Partition 연결은 보장되지 않습니다.","text":"카프카 프로듀서카프카 프로듀서는 브로커에 존재하는 토픽에 메시지를 전달하는 역할을 담당합니다. Topic 에 해당하는 메시지를 생성 후 해당 Topic으로 데이터를 publish 한다. 또한, 메시지 전송이 실패할 경우, 재전송을 한다. 카프카 프로듀서는 브로커로 메시지를 보낼때 파티션 Key 도 함께 보낼 수 있습니다. 브로커는 파티션 Key 의 유무에 따라 데이터를 저장하는 방식이 달라집니다. 파티션 Key 가 null 인 데이터 전송Topic 에 Partition 이 한개인 경우는 데이터들이 순차적으로 쌓이게 된다. Topic 에 Partition 이 여러개인 경우 Round Robin 형식으로 데이터가 쌓이게 된다. 파티션 Key 를 전송할 경우Kafka 는 Key 를 특정한 Hash 값으로 변형 시켜 Partition 과 1:1 매칭을 시킵니다. 각 파티션에 동일 Key 의 Value 만 쌓이게 된다. Partition 의 개수와 Key 의 개수가 일치하지 않는 경우 Key 와 Partition 의 매칭이 깨지게 돼 Key 와 Partition 연결은 보장되지 않습니다. Ack 옵션카프카 Producer 에는 Ack 라는 상세 옵션이 있고 Partition 의 Replication 과 관련이 있다. Ack 는 0, 1, All 옵션 3개중 하나를 선택할 수 있습니다. Ack 가 0일 경우 Producer 는 Leader Partition 에 데이터를 전송하고 응답값은 받지 않습니다. Leader Partition 에 데이터가 정상적으로 전송 됐는지, 나머지 Partition 에 정상적으로 복제 됐는지 알 수 없고 보장할 수 없습니다. 속도는 빠르지만 데이터가 유실 될 가능성이 있습니다. Ack 가 1일 경우 Leader Partition 에 데이터를 전송하고 응답값을 받는다. 나머지 Partition 에 데이터가 복제 됐는지는 알 수 없다. Leader Partition 이 데이터를 받은 즉시 Broker 가 장애가 난다면 나머지 Partition 에 데이터 Ack 가 All 일 경우 Follow Partition 에 복제가 잘 일어났는지 응답 값을 받는다. 확인하는 부분이 많아 속도가 현저히 느리다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"Kafka","slug":"Develop/Kafka","permalink":"https://ckck803.github.io/categories/Develop/Kafka/"}],"tags":[]},{"title":"Kafka 구조","slug":"kafka/kafka","date":"2022-03-01T13:25:35.000Z","updated":"2024-02-18T16:19:54.542Z","comments":true,"path":"2022/03/01/kafka/kafka/","link":"","permalink":"https://ckck803.github.io/2022/03/01/kafka/kafka/","excerpt":"Kafka 구조 Topic 데이터를 구분하기 위해 사용하는 논리적인 단위 (데이터 베이스의 테이블 명과 유사하다고 생각하면 된다.) Topic은 한개 이상의 partition으로 구성된다. 카프카에서는 데이터를 주고 받을 때 Topic 을 이용해 pub&#x2F;sub 형태로 데이터를 주고 받는다. Partition 토픽에 속한 Record 를 실제 저장소에 저장하는 가장 작은 물리적인 단위 Consumer 가 Record 를 가져가더라도 Record 는 삭제되지 않는다. 파티션은 늘리는 것은 가능하지만 줄이는 것은 불가능하므로 파티션을 늘릴때는 주의 해야 한다. Record 파티션에 저장되는 데이터 Kafka Pub&#x2F;Sub 모델 Kafka 를 사용하기 위해서는 Message 를 발행하는 Producer 와 Message 를 구독하는 Consumer 로 구성한다. Kafka 에서는 메시지를 발행하는 Publisher 를 Producer 로 메시지를 구독하는 Subscriber 를 Consumer 라고 부른다. Kafka 에서는 Consumer 가 데이터를 가져가도 데이터가 사라지지 않는다. Kafka Producer Kafka Producer 는 데이터를 Kafka 로 보내는 역할을 한다.","text":"Kafka 구조 Topic 데이터를 구분하기 위해 사용하는 논리적인 단위 (데이터 베이스의 테이블 명과 유사하다고 생각하면 된다.) Topic은 한개 이상의 partition으로 구성된다. 카프카에서는 데이터를 주고 받을 때 Topic 을 이용해 pub&#x2F;sub 형태로 데이터를 주고 받는다. Partition 토픽에 속한 Record 를 실제 저장소에 저장하는 가장 작은 물리적인 단위 Consumer 가 Record 를 가져가더라도 Record 는 삭제되지 않는다. 파티션은 늘리는 것은 가능하지만 줄이는 것은 불가능하므로 파티션을 늘릴때는 주의 해야 한다. Record 파티션에 저장되는 데이터 Kafka Pub&#x2F;Sub 모델 Kafka 를 사용하기 위해서는 Message 를 발행하는 Producer 와 Message 를 구독하는 Consumer 로 구성한다. Kafka 에서는 메시지를 발행하는 Publisher 를 Producer 로 메시지를 구독하는 Subscriber 를 Consumer 라고 부른다. Kafka 에서는 Consumer 가 데이터를 가져가도 데이터가 사라지지 않는다. Kafka Producer Kafka Producer 는 데이터를 Kafka 로 보내는 역할을 한다. Topic 에 해당하는 메시지를 생성 후 해당 Topic 으로 데이터를 publish 한다 Kafka Consumer Kafka Consumer 는 Topic 의 데이터를 가져오는 역할을 한다. 카프카에서 데이터를 가져오는 것을 Polling 이라고 한다. Consumer 가 읽은 위치는 offset 을 이용해 기록한다. Kafka Consumer Group Kafka Consumer 는 Consumer Group 에 속한다. Consumer Group 은 같은 Topic 을 구독하고 공통된 작업을 처리하는 Consumer 들의 모음이다. Kafka 로그를 처리하고 사용자에게 전파하는 Consumer Group Kafka 로그를 Elastic Search 에 저장하는 Consumer Group Consumer Group 에 여러개의 Consumer 를 생성해 특정 Topic 내 Message 병렬 처리 가 가능하다. 여러 Partition 을 가진 Topic 에 대해 Consumer 가 병렬 처리하게 하기 위해서는 Consumer 가 Partition의 개수보다 작아야 한다. 서로 다른 Consumber Group 은 다른 Consumer Group 에 영향을 미치지 않는다. Consumer Group 별로 Topic 별로 offset 을 나누어 저장하기 때문이다. offset 메시지가 파티션 내에서 가지는 고유의 번호, Consumer 가 Partition 내 Message 를 읽은 위치를 알려준다. offset 은 Topic 별로 Partition 별로 별개로 지정된다. Consumer 가 데이터를 어느지점까지 읽었는지 확인하는 용도로 사용한다. Consumer 가 데이터를 읽어가면 offset 을 Commit 한다. Consumer 가 Partition 의 읽은 위치 (offset) 은 Kafka 의 __Consumer_offset 토픽에 저장된다. Consumer 가 중지가 되더라도 시작 위치를 알고 있으므로 다시 복구하여 데이터를 처리할 수 있다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"Kafka","slug":"Develop/Kafka","permalink":"https://ckck803.github.io/categories/Develop/Kafka/"}],"tags":[]},{"title":"Spring Web Socket - Chat 프로그램 만들기 1","slug":"spring/spring-websocket/chatting/chatting-01","date":"2022-03-01T13:25:35.000Z","updated":"2024-02-26T16:11:58.318Z","comments":true,"path":"2022/03/01/spring/spring-websocket/chatting/chatting-01/","link":"","permalink":"https://ckck803.github.io/2022/03/01/spring/spring-websocket/chatting/chatting-01/","excerpt":"Spring boot Web Socket - Chat 프로그램 만들기 1참고 https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html https://daddyprogrammer.org/post/4731/spring-websocket-chatting-server-redis-pub-sub/ Message BrokerMessage Broker 는 Publisher 로부터 전달 받은 Message 를 Subscriber 로 전달하는 중간 역할을 하며 응용 소프트웨어 간에 메시지를 교환할 수 있게 한다. 이때, 메시지가 적재되는 공간은 Message Queue 라고 하며 메시지 그룹을 Topic 이라고 한다. Message Broker 는 데이터를 보내고 처리하고 삭제한다. Message Interceptor 정의하기 ChannelInterceptor 는 Message 를 MessageChannel 로 보내기 전과 Message 가 MessageChannel 로 보낸 후 추가적일 로직을 수행할 수 있게 도와주는 Interface 다. ChannelInterceptor 인터페이스를 구현해 Socket 통신 상태를 로그로 찍어 확인한다.","text":"Spring boot Web Socket - Chat 프로그램 만들기 1참고 https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html https://daddyprogrammer.org/post/4731/spring-websocket-chatting-server-redis-pub-sub/ Message BrokerMessage Broker 는 Publisher 로부터 전달 받은 Message 를 Subscriber 로 전달하는 중간 역할을 하며 응용 소프트웨어 간에 메시지를 교환할 수 있게 한다. 이때, 메시지가 적재되는 공간은 Message Queue 라고 하며 메시지 그룹을 Topic 이라고 한다. Message Broker 는 데이터를 보내고 처리하고 삭제한다. Message Interceptor 정의하기 ChannelInterceptor 는 Message 를 MessageChannel 로 보내기 전과 Message 가 MessageChannel 로 보낸 후 추가적일 로직을 수행할 수 있게 도와주는 Interface 다. ChannelInterceptor 인터페이스를 구현해 Socket 통신 상태를 로그로 찍어 확인한다. @Slf4j@Component@RequiredArgsConstructorpublic class StompHandler implements ChannelInterceptor &#123; @Override public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123; StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message); if(StompCommand.CONNECT.equals(accessor.getCommand()))&#123; log.info(&quot;CONNECT&quot;); &#125;else if(StompCommand.SUBSCRIBE.equals(accessor.getCommand()))&#123; log.info(&quot;SUBSCRIBE&quot;); &#125;else if(StompCommand.DISCONNECT.equals(accessor.getCommand()))&#123; log.info(&quot;DISCONNECT&quot;); &#125; return message; &#125;&#125; Web Socket 설정 STOMP 를 사용하기 위한 설정은 WebSocketMessageBrokerConfigurer 와 @EnableWebSocketMessageBroker 를 이용해 진행한다. MessageBrokerRegistry 객체를 이용해 Message Broker 설정 setApplicationDestinationPrefixes 메소드를 이용해 Client 가 보내는 요청을 처리하기 위한 Prefix 를 설정한다. enableSimpleBroker 메소드를 이용해 SimpleBroker 설정을 한다. SimpleBroker 는 설정된 Prefix 를 subscribe 하는 Client 에게 메시지를 전달하는 역할을 한다. StompEndpointRegistry 객체를 이용해 End Point 설정 addEndpoint 메소드를 이용해 STOMP 를 사용하기 위한 End Point 를 설정한다. ChannelRegistration 객체를 이용해 Message Channel 에 Interceptor 를 추가한다. @Configuration@EnableWebSocketMessageBroker@RequiredArgsConstructorpublic class WebsocketConfig implements WebSocketMessageBrokerConfigurer &#123; private final StompHandler stompHandler; @Override public void configureMessageBroker(MessageBrokerRegistry brokerRegistry) &#123; brokerRegistry.setApplicationDestinationPrefixes(&quot;/pub&quot;); brokerRegistry.enableSimpleBroker(&quot;/sub&quot;); &#125; @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint(&quot;/ws-stomp&quot;) .setAllowedOriginPatterns(&quot;*&quot;) .withSockJS(); &#125; @Override public void configureClientInboundChannel(ChannelRegistration registration) &#123; registration.interceptors(stompHandler); &#125;&#125; Chat Room 관련 요청을 처리하기 위한 Controller@RequiredArgsConstructor@RestController@RequestMapping(&quot;/api/chat&quot;)public class ChatRoomController &#123; private final ChatRoomRepository chatRoomRepository; @GetMapping(&quot;/room&quot;) public String rooms() &#123; return &quot;/chat/room&quot;; &#125; @GetMapping(&quot;/rooms&quot;) @ResponseBody public List&lt;ChatRoom&gt; room() &#123; List&lt;ChatRoom&gt; chatRooms = chatRoomRepository.findAllRoom(); chatRooms.stream() .forEach(room -&gt; room.setUserCount(chatRoomRepository.getUserCount(room.getRoomId()))); return chatRooms; &#125; @PostMapping(&quot;/room&quot;) @ResponseBody public ChatRoom createRoom(@RequestParam String name) &#123; return chatRoomRepository.createChatRoom(name); &#125; @GetMapping(&quot;/room/enter/&#123;roomId&#125;&quot;) public String roomDetail(Model model, @PathVariable String roomId) &#123; model.addAttribute(&quot;roomId&quot;, roomId); return &quot;/chat/roomdetail&quot;; &#125; @GetMapping(&quot;/room/&#123;roomId&#125;&quot;) @ResponseBody public ChatRoom roomInfo(@PathVariable String roomId) &#123; return chatRoomRepository.findRoomById(roomId); &#125;&#125; @Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class ChatMessage &#123; private Message Type; private String roomId; private String sender; private String message; private Long userCount; public enum Message&#123; ENTER, QUIT, TALK; &#125;&#125; @Data@NoArgsConstructorpublic class ChatRoom implements Serializable &#123; private static final long serialVersionUID = 6494678977089006639L; private String roomId; private String name; private long userCount; public static ChatRoom create(String name) &#123; ChatRoom chatRoom = new ChatRoom(); chatRoom.roomId = UUID.randomUUID().toString(); chatRoom.name = name; return chatRoom; &#125;&#125; Redis Pub&#x2F;Sub 모델 사용하기Message 를 처리하기 위한 ListenrListner 에서는 전달 받은 Message 를 SimpMessageSendingOperations 를 이용해 현재 소켓에 연결돼 있는 사용자에게 메시지를 전파한다. @Service@Slf4j@RequiredArgsConstructorpublic class RedisSubscriber &#123; private final ObjectMapper objectMapper; private final SimpMessageSendingOperations messagingTemplate; public void sendMessage(String publishMessage) &#123; try &#123; ChatMessage chatMessage = objectMapper.readValue(publishMessage, ChatMessage.class); messagingTemplate.convertAndSend(&quot;/sub/api/chat/room/&quot; + chatMessage.getRoomId(), chatMessage); &#125; catch (Exception e) &#123; log.error(&quot;Exception &#123;&#125;&quot;, e); &#125; &#125;&#125; MessageListenerAdapter 객체를 이용해 Message 를 처리할 Listner 를 설정해준다. RedisMessageListenerContainer 객체를 이용해 Topic 과 Listner 를 연결해준다. Topic 에 Message 가 생성되면 MessageListner 가 해당 Message 를 처리한다. Redis 설정 하기@Configuration@EnableRedisRepositoriespublic class RedisConfig &#123; @Bean public ChannelTopic channelTopic()&#123; return new ChannelTopic(&quot;chatroom&quot;); &#125; @Bean public MessageListenerAdapter messageListenerAdapter(RedisSubscriber redisSubscriber)&#123; return new MessageListenerAdapter(redisSubscriber, &quot;sendMessage&quot;); &#125; @Bean public RedisMessageListenerContainer redisMessageListener(RedisConnectionFactory redisConnectionFactory, MessageListenerAdapter messageListenerAdapter, ChannelTopic channelTopic)&#123; RedisMessageListenerContainer container = new RedisMessageListenerContainer(); container.setConnectionFactory(redisConnectionFactory); container.addMessageListener(messageListenerAdapter, channelTopic); return container; &#125; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(String.class)); return redisTemplate; &#125;&#125; Redis 에 저장 및 불러오기 위한 Repository 정의 HashOperations Redis 에 Map 형태 (Key, Value) 로 데이터에 접근 및 저장을 하기 위한 객체 ValueOperations Redis 에 String 데이터를 접근 및 저장을 위한 객체 @Repository@RequiredArgsConstructorpublic class ChatRoomRepository &#123; private static final String CHAT_ROOM = &quot;CHAT_ROOM&quot;; private static final String USER_COUNT = &quot;USER_COUNT&quot;; private static final String ENTER_INFO = &quot;ENTER_INFO&quot;; @Resource(name = &quot;redisTemplate&quot;) private HashOperations&lt;String, String, ChatRoom&gt; hashOpsChatRoom; @Resource(name = &quot;redisTemplate&quot;) private HashOperations&lt;String, String, String&gt; hashOpsEnterInfo; @Resource(name = &quot;redisTemplate&quot;) private ValueOperations&lt;String, String&gt; valueOps; public List&lt;ChatRoom&gt; findAllRoom() &#123; return hashOpsChatRoom.values(CHAT_ROOM); &#125; public ChatRoom findRoomById(String id) &#123; return hashOpsChatRoom.get(CHAT_ROOM, id); &#125; public ChatRoom createChatRoom(String name) &#123; ChatRoom chatRoom = ChatRoom.create(name); hashOpsChatRoom.put(CHAT_ROOM, chatRoom.getRoomId(), chatRoom); return chatRoom; &#125; public void setUserEnterInfo(String userSessionId, String roomId)&#123; hashOpsEnterInfo.put(ENTER_INFO, userSessionId, roomId); &#125; public String getUserEnterRoomId(String userSessionId)&#123; return hashOpsEnterInfo.get(ENTER_INFO, userSessionId); &#125; public void removeUserEnterRoomId(String userSessionId)&#123; hashOpsEnterInfo.delete(ENTER_INFO, userSessionId); &#125; public Long getUserCount(String roomId)&#123; return Long.valueOf(Optional.ofNullable(valueOps.get(USER_COUNT+ &quot;_&quot; + roomId)).orElse(&quot;0&quot;)); &#125; public Long plusUserCount(String roomId)&#123; return Optional.ofNullable(valueOps.increment(USER_COUNT+&quot;_&quot;+roomId)).orElse(0L); &#125; public Long minusUserCount(String roomId)&#123; return Optional.ofNullable(valueOps.decrement(USER_COUNT+&quot;_&quot;+roomId)).filter(count -&gt; count &gt; 0).orElse(0L); &#125;&#125; 전달 받은 Message 를 Redis 로 보내기@RequiredArgsConstructor@Servicepublic class ChatService &#123; private final ChannelTopic channelTopic; private final RedisTemplate redisTemplate; private final ChatRoomRepository chatRoomRepository; public String getRoomId(String destination) &#123; int lastIndex = destination.lastIndexOf(&quot;/&quot;); if (lastIndex != -1) &#123; return destination.substring(lastIndex + 1); &#125; else &#123; return &quot;&quot;; &#125; &#125; public void sendChatMessage(ChatMessage message)&#123; String roomId = getRoomId(message.getMessage()); Long userCount = chatRoomRepository.getUserCount(roomId); message.setUserCount(userCount); redisTemplate.convertAndSend(channelTopic.getTopic(), message); &#125;&#125; Message 요청 처리하기 @MessageMapping 를 이용해 메시지 요청을 받기 위한 경로를 설정한다. /api/chat/message 경로로 들어온 Message 를 처리한다. @RestController@RequiredArgsConstructor@Slf4jpublic class ChatController &#123; private final ChatService chatService; @MessageMapping(&quot;/api/chat/message&quot;) public void message(ChatMessage message) &#123; chatService.sendChatMessage(message); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring WebSocket","slug":"Spring/Spring-WebSocket","permalink":"https://ckck803.github.io/categories/Spring/Spring-WebSocket/"}],"tags":[]},{"title":"Kafka 설치","slug":"kafka/kafka-install","date":"2022-03-01T13:25:35.000Z","updated":"2024-03-18T13:49:39.432Z","comments":true,"path":"2022/03/01/kafka/kafka-install/","link":"","permalink":"https://ckck803.github.io/2022/03/01/kafka/kafka-install/","excerpt":"카프카 설치http://kafka.apache.org/ 주키퍼 실행bin/zookeeper-server-start.sh config/zookeeper.properties Properties 변경server.properties에서 Listner 설정을 추가해 줘야 한다. listeners=PLAINTEXT://127.0.0.1:9092 kafka 실행bin/kafka-server-start.sh config/server.properties","text":"카프카 설치http://kafka.apache.org/ 주키퍼 실행bin/zookeeper-server-start.sh config/zookeeper.properties Properties 변경server.properties에서 Listner 설정을 추가해 줘야 한다. listeners=PLAINTEXT://127.0.0.1:9092 kafka 실행bin/kafka-server-start.sh config/server.properties Topic 생성bin/kafka-topics.sh --create --topic quickstart-events --bootstrap-server localhost:9092 Producerbin/kafka-console-producer.sh --topic quickstart-events --bootstrap-server localhost:9092 Consumerbin/kafka-console-consumer.sh --topic quickstart-events --from-beginning --bootstrap-server localhost:9092 Kafka Producer Kafka Producer 는 데이터를 Kafka 로 보내는 역할을 한다. Topic 에 해당하는 메시지를 생성 후 해당 Topic 으로 데이터를 publish 한다 처리 실패시 재시도한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"Kafka","slug":"Develop/Kafka","permalink":"https://ckck803.github.io/categories/Develop/Kafka/"}],"tags":[]},{"title":"Spring - Kafka","slug":"spring/spring-kafka/springboot-kafka","date":"2022-02-23T14:47:05.000Z","updated":"2024-02-26T16:10:47.372Z","comments":true,"path":"2022/02/23/spring/spring-kafka/springboot-kafka/","link":"","permalink":"https://ckck803.github.io/2022/02/23/spring/spring-kafka/springboot-kafka/","excerpt":"스프링 부트 카프카 사용하기목자 Spring - Kafka Spring - Kafka Java Config 사용하기 Spring - Embedded Kafka 사용하기 의존성 추가implementation &#x27;org.springframework.kafka:spring-kafka&#x27;testImplementation &#x27;org.springframework.kafka:spring-kafka-test&#x27; 카프카에 접속하기 위한 설정Consumer 설정 spring.kafka.consumer.bootstrap-servers 카프카에 연결을 하기 위한 접속 주소 spring.kafka.consumer.group-id kafka Consumer 그룹에 대한 정보 spring.kafka.consumer.auto-offset-reset topic에 붙은 consumer의 offset 정보가 존재하지 않거나 오류가 발생해 offset을 사용할 수 없는 경우 처리하기 위한 옵션 latest : 가장 마지막 offset부터 earliest : 가장 처음 offset부터 none : offset 정보가 없으면 Exception 발생 spring.kafka.consumer.key-deserializer 카프카에서 전달받은 key 를 역질렬화 할때 사용하는 역질렬화 클래스 StringDeserializer 는 문자열 데이터만 사용 가능한 역직렬화 도구 spring.kafka.consumer.value-deserializer 카프카에서 전달받은 value 를 역질렬화 할때 사용하는 역질렬화 클래스 StringDeserializer 는 문자열 데이터만 사용 가능한 역직렬화 도구 Producer 설정","text":"스프링 부트 카프카 사용하기목자 Spring - Kafka Spring - Kafka Java Config 사용하기 Spring - Embedded Kafka 사용하기 의존성 추가implementation &#x27;org.springframework.kafka:spring-kafka&#x27;testImplementation &#x27;org.springframework.kafka:spring-kafka-test&#x27; 카프카에 접속하기 위한 설정Consumer 설정 spring.kafka.consumer.bootstrap-servers 카프카에 연결을 하기 위한 접속 주소 spring.kafka.consumer.group-id kafka Consumer 그룹에 대한 정보 spring.kafka.consumer.auto-offset-reset topic에 붙은 consumer의 offset 정보가 존재하지 않거나 오류가 발생해 offset을 사용할 수 없는 경우 처리하기 위한 옵션 latest : 가장 마지막 offset부터 earliest : 가장 처음 offset부터 none : offset 정보가 없으면 Exception 발생 spring.kafka.consumer.key-deserializer 카프카에서 전달받은 key 를 역질렬화 할때 사용하는 역질렬화 클래스 StringDeserializer 는 문자열 데이터만 사용 가능한 역직렬화 도구 spring.kafka.consumer.value-deserializer 카프카에서 전달받은 value 를 역질렬화 할때 사용하는 역질렬화 클래스 StringDeserializer 는 문자열 데이터만 사용 가능한 역직렬화 도구 Producer 설정 spring.kafka.producer.bootstrap-servers 카프카에 연결을 하기 위한 접속 주소 spring.kafka.producer.key-serializer Message 를 카프카 브로커에 전송할 때 사용하는 Serializer 어떤 직렬화 클래스가 key 값을 바이트 배열로 변환했을 때 사용됐는지 알려준다. StringSerializer 는 문자열 데이터만 사용 가능한 직렬화 도구 spring.kafka.producer.value-serializer Message 를 카프카 브로커에 전송할 때 사용하는 Serializer 어떤 직렬화 클래스가 value 값을 바이트 배열로 변환했을 때 사용됐는지 알려준다. StringSerializer 는 문자열 데이터만 사용 가능한 직렬화 도구 application.yml spring: kafka: consumer: bootstrap-servers: localhost:9092 group-id: foo auto-offset-reset: earliest key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer producer: bootstrap-servers: localhost:9092 key-serializer: org.apache.kafka.common.serialization.StringSerializer value-serializer: org.apache.kafka.common.serialization.StringSerializer Kafka Producer Producer 에서는 KafkaTemplate 을 이용해 Kafka 내 특정 Topic 으로 메시지를 전송한다. KafkaProducer.java @Service@RequiredArgsConstructorpublic class KafkaProducer &#123; private static final String TOPIC = &quot;exam&quot;; private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; public void sendMessage(String message)&#123; System.out.println(String.format(&quot;Produce message : %s&quot;, message)); this.kafkaTemplate.send(TOPIC, message); &#125;&#125; KafkaController.java @RestController@RequestMapping(&quot;/kafka&quot;)public class KafkaController &#123; private final KafkaProducer producer; @Autowired KafkaController(KafkaProducer producer) &#123; this.producer = producer; &#125; @PostMapping public String sendMessage(@RequestParam(&quot;message&quot;) String message) &#123; this.producer.sendMessage(message); return &quot;success&quot;; &#125;&#125; Kafka Consumer @KafkaListener 어노테이션을 이용해 Consumer 설정을 해준다. groupId : 해당 Consumer 가 속한 Consumer Group topics : 해당 Consumer 가 구독하는 Topic KafkaConsumer.java @Servicepublic class KafkaConsumer &#123; @KafkaListener(topics = &quot;exam&quot;, groupId = &quot;foo&quot;) public void consume(String message) throws IOException&#123; System.out.println(String.format(&quot;Consumed message : %s&quot;, message)); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Kafka","slug":"Spring/Kafka","permalink":"https://ckck803.github.io/categories/Spring/Kafka/"}],"tags":[]},{"title":"백준 15650 - N 과 M (2) - 순열","slug":"algorithm/baekjoon/경우의수/15650-N과M-cpp","date":"2022-02-13T12:10:40.000Z","updated":"2024-02-18T16:19:54.510Z","comments":true,"path":"2022/02/13/algorithm/baekjoon/경우의수/15650-N과M-cpp/","link":"","permalink":"https://ckck803.github.io/2022/02/13/algorithm/baekjoon/%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%AE%E1%84%8B%E1%85%B4%E1%84%89%E1%85%AE/15650-N%EA%B3%BCM-cpp/","excerpt":"백준 15650 - N 과 M (2) - 순열 Post not found: algorithm/baekjoon/경우의수/15649-N과M-cpp Post not found: algorithm/baekjoon/경우의수/15650-N과M-cpp 링크https://www.acmicpc.net/problem/2606 문제 풀이 주어진 N 개에서 M 개를 뽑는 경우의 수를 다루는 조합 문제 백트레킹 을 이용해 만들 수 있는 모든 경우의 수를 만들어 줬다. 다만, 조합은 순서와 상관 없이 뽑은 상태가 같으면 같은 Case 로 분류가 된다. 때문에 현재 뽑은 위치(idx) 에서 앞에 있는 것들만 뽑게 하면 같은 경우의 수가 나오는 것을 방지할 수 있다. 전체 소스 코드#include &lt;iostream&gt;#include &lt;vector&gt;#define endl &#x27;\\n&#x27;using namespace std;vector&lt;int&gt; v;vector&lt;bool&gt; check;// idx : 수열 탐색 현재 시작 위치를 알려주기 위한 변수// depth : 재귀 문이 몇번 호출 됐는지 확인하기 위한 변수// n : 수열 탐색의 마지막 위치를 확인하기 위한 값// m : 재귀 문을 최대 호출할 수 있는 횟수void nCr(int idx, int depth, int n, int m) &#123; if (depth == m) &#123; for (int value : v) &#123; cout &lt;&lt; value &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; for (int i = idx; i &lt; n; i++) &#123; if (check[i] == true) &#123; continue; &#125; check[i] = true; v[depth] = i + 1; nCr(i + 1, depth + 1, n, m); check[i] = false; &#125;&#125;int main(void) &#123; cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false); int n, m; cin &gt;&gt; n &gt;&gt; m; v = vector&lt;int&gt;(m); check = vector&lt;bool&gt;(n); nCr(0, 0, n, m); return 0;&#125;","text":"백준 15650 - N 과 M (2) - 순열 Post not found: algorithm/baekjoon/경우의수/15649-N과M-cpp Post not found: algorithm/baekjoon/경우의수/15650-N과M-cpp 링크https://www.acmicpc.net/problem/2606 문제 풀이 주어진 N 개에서 M 개를 뽑는 경우의 수를 다루는 조합 문제 백트레킹 을 이용해 만들 수 있는 모든 경우의 수를 만들어 줬다. 다만, 조합은 순서와 상관 없이 뽑은 상태가 같으면 같은 Case 로 분류가 된다. 때문에 현재 뽑은 위치(idx) 에서 앞에 있는 것들만 뽑게 하면 같은 경우의 수가 나오는 것을 방지할 수 있다. 전체 소스 코드#include &lt;iostream&gt;#include &lt;vector&gt;#define endl &#x27;\\n&#x27;using namespace std;vector&lt;int&gt; v;vector&lt;bool&gt; check;// idx : 수열 탐색 현재 시작 위치를 알려주기 위한 변수// depth : 재귀 문이 몇번 호출 됐는지 확인하기 위한 변수// n : 수열 탐색의 마지막 위치를 확인하기 위한 값// m : 재귀 문을 최대 호출할 수 있는 횟수void nCr(int idx, int depth, int n, int m) &#123; if (depth == m) &#123; for (int value : v) &#123; cout &lt;&lt; value &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; for (int i = idx; i &lt; n; i++) &#123; if (check[i] == true) &#123; continue; &#125; check[i] = true; v[depth] = i + 1; nCr(i + 1, depth + 1, n, m); check[i] = false; &#125;&#125;int main(void) &#123; cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false); int n, m; cin &gt;&gt; n &gt;&gt; m; v = vector&lt;int&gt;(m); check = vector&lt;bool&gt;(n); nCr(0, 0, n, m); return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"경우의 수","slug":"Programming/Beakjoon/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"}],"tags":[]},{"title":"백준 15649 - N 과 M (1) - 순열","slug":"algorithm/baekjoon/경우의수/15649-N과M-cpp","date":"2022-02-13T11:10:40.000Z","updated":"2024-02-18T16:19:54.510Z","comments":true,"path":"2022/02/13/algorithm/baekjoon/경우의수/15649-N과M-cpp/","link":"","permalink":"https://ckck803.github.io/2022/02/13/algorithm/baekjoon/%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%AE%E1%84%8B%E1%85%B4%E1%84%89%E1%85%AE/15649-N%EA%B3%BCM-cpp/","excerpt":"백준 15649 - N 과 M (1) Post not found: algorithm/baekjoon/경우의수/15649-N과M-cpp Post not found: algorithm/baekjoon/경우의수/15650-N과M-cpp 링크https://www.acmicpc.net/problem/2606 문제 풀이 주어진 N 개에서 M 개를 뽑아 나열하는 순열 문제. 백트래킹 을 이용해 만들 수 있는 모든 수열의 경우의 수 를 만들어 준다. check 를 이용해 똑같은 숫자를 여러 번 뽑는 중복 행위를 판단하고 v 배열을 통해 한 수열이 만들어지면 출력하도록 한다. v : 뽑은 숫자를 저장하기 위한 배열 check : 해당 숫자가 뽑혔는지 판단하기 위한 배열 전체 소스 코드","text":"백준 15649 - N 과 M (1) Post not found: algorithm/baekjoon/경우의수/15649-N과M-cpp Post not found: algorithm/baekjoon/경우의수/15650-N과M-cpp 링크https://www.acmicpc.net/problem/2606 문제 풀이 주어진 N 개에서 M 개를 뽑아 나열하는 순열 문제. 백트래킹 을 이용해 만들 수 있는 모든 수열의 경우의 수 를 만들어 준다. check 를 이용해 똑같은 숫자를 여러 번 뽑는 중복 행위를 판단하고 v 배열을 통해 한 수열이 만들어지면 출력하도록 한다. v : 뽑은 숫자를 저장하기 위한 배열 check : 해당 숫자가 뽑혔는지 판단하기 위한 배열 전체 소스 코드#include &lt;iostream&gt;#include &lt;vector&gt;#define endl &#x27;\\n&#x27;using namespace std;vector&lt;int&gt; v;vector&lt;bool&gt; check;void dfs(int n, int m, int depth) &#123; if (m == depth) &#123; for (int value : v) &#123; cout &lt;&lt; value &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (check[i] == true) &#123; continue; &#125; check[i] = true; v[depth] = i + 1; dfs(n, m, depth + 1); check[i] = false; &#125;&#125;int main(void) &#123; cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false); int N, M; cin &gt;&gt; N &gt;&gt; M; v = vector&lt;int&gt;(M); check = vector&lt;bool&gt;(N); dfs(N, M, 0);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"경우의 수","slug":"Programming/Beakjoon/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"}],"tags":[]},{"title":"SQL injection","slug":"computer-science/network/security/sql-injection","date":"2022-02-12T16:16:32.000Z","updated":"2024-02-18T16:19:54.519Z","comments":true,"path":"2022/02/13/computer-science/network/security/sql-injection/","link":"","permalink":"https://ckck803.github.io/2022/02/13/computer-science/network/security/sql-injection/","excerpt":"SQL injection 이란 보안상의 허점을 이용해 사용자가 정의한 SQL 문외 조작된 SQL 을 주입하고 실행시켜 데이터베이스에 저장된 중요한 정보를 가져오는 공격 기법을 의미한다. Error Based SQL injection 논리적 에러를 이용한 SQL injection 잘못된 SQL 을 이용해 고의로 에러를 발생시는 공격 기법이다. 예외로 던저진 Message 를 통해 테이블 명과 컬럼과 같은 테이블 정보 를 얻어낼 수 있다. SQL 구문 정보를 변경해 사용자 인증을 우회해 접속할 수 있다. Union Based SQL injection Union 명령을 이용한 SQL injection 정상적으로 실행하는 쿼리와 정보를 탈취하기 위한 쿼리문을 Union 연산자를 통해 실행시킨다. 데이터 형식과 컬럼 수가 일치하면 Union 연산자를 이용해 데이터를 가져올 수 있다. SELECT uid FROM user_table WHERE uid=&#x27;&#x27; UNION SELECT upw FROM user_table WHERE uid=&#x27;admin&#x27; -- and...","text":"SQL injection 이란 보안상의 허점을 이용해 사용자가 정의한 SQL 문외 조작된 SQL 을 주입하고 실행시켜 데이터베이스에 저장된 중요한 정보를 가져오는 공격 기법을 의미한다. Error Based SQL injection 논리적 에러를 이용한 SQL injection 잘못된 SQL 을 이용해 고의로 에러를 발생시는 공격 기법이다. 예외로 던저진 Message 를 통해 테이블 명과 컬럼과 같은 테이블 정보 를 얻어낼 수 있다. SQL 구문 정보를 변경해 사용자 인증을 우회해 접속할 수 있다. Union Based SQL injection Union 명령을 이용한 SQL injection 정상적으로 실행하는 쿼리와 정보를 탈취하기 위한 쿼리문을 Union 연산자를 통해 실행시킨다. 데이터 형식과 컬럼 수가 일치하면 Union 연산자를 이용해 데이터를 가져올 수 있다. SELECT uid FROM user_table WHERE uid=&#x27;&#x27; UNION SELECT upw FROM user_table WHERE uid=&#x27;admin&#x27; -- and... 참고https://www.baeldung.com/sql-injection 방어하는 방법 Parameter Binding (preparestatement 사용) 순수한 Query String 을 사용하는 것이 아니라 Parameter Bindling 을 사용하면 피할 수 있다. mybatis에서 $를 사용하지 않고 #을 사용 SQL 관련 에러가 발생했으르 때 해당 에러 메시지를 표시하지 않도록 한다. Spring JPA 에서의 SQL injection 공격Request Parameter 에 &#39; or 1&#39;=&#39;1 을 덧 붙여 보내게 되면 서버에 저장된 모든 회원 정보를 가져올 수 있다. http://localhost:8080/accounts?customerId=abc%27%20or%20%271%27=%271 저장된 회원 정보@PostConstructpublic void init()&#123; Account account1 = Account.builder() .customerId(&quot;account1&quot;) .accNumber(&quot;010-1111-1111&quot;) .build(); Account account2 = Account.builder() .customerId(&quot;account2&quot;) .accNumber(&quot;010-2222-2222&quot;) .build(); Account account3 = Account.builder() .customerId(&quot;account3&quot;) .accNumber(&quot;010-3333-3333&quot;) .build(); accountRepository.saveAccount(account1); accountRepository.saveAccount(account2); accountRepository.saveAccount(account3);&#125; ControllercustomerId 파라미터로 넘어온 데이터를 이용해 데이터 베이스에 저장된 회원 정보를 불러 오도록 한다. @GetMapping(&quot;/accounts&quot;)public List&lt;AccountDTO&gt; retrieveAccount(@RequestParam(&quot;customerId&quot;) String param)&#123; log.info(&quot;Param = &#123;&#125;&quot;, param); List&lt;AccountDTO&gt; accountDTOS = accountRepository.unsafeJpaFindAccountsByCustomerId(param); return accountDTOS;&#125; Repository Controller 에서 넘겨준 customerId 를 이용해 SQL 을 작성하고 작성된 SQL 을 이용해 데이터베이스에 저장된 회원 정보를 가져온다. Parameter 를 바로 받아 SQL 을 생성하는 이 부분에서 SQL Injection 문제가 발생하게 된다. public List&lt;AccountDTO&gt; unsafeJpaFindAccountsByCustomerId(String customerId) &#123; // 직접 전달된 Parameter 를 이용해 생성하는 로직이 SQL Injection 의 원인이된다. String jql = &quot;select a from Account a where a.customerId = &#x27;&quot; + customerId + &quot;&#x27;&quot;; log.info(&quot;Query = &#123;&#125;&quot;, jql); TypedQuery&lt;Account&gt; q = em.createQuery(jql, Account.class); return q.getResultList() .stream() .map(a -&gt; AccountDTO.builder() .accNumber(a.getAccNumber()) .customerId(a.getCustomerId()) .build()) .collect(Collectors.toList());&#125; 로그로그를 확인해 보면 Parameter 로 같이 넘어온 &#39; or 1&#39;=&#39;1 이 붙어서 쿼리문이 생성된 것을 확인할 수 있다.생성된 쿼리가 수행될 경우 데이터 베이스에 저장된 모든 회원 정보를 가져오게 된다. 결과적으로 모든 회원 정보가 반환되는 것을 확인할 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"Security","slug":"CS/Network/Security","permalink":"https://ckck803.github.io/categories/CS/Network/Security/"}],"tags":[]},{"title":"백준 1012 - 유기농 배추 (Python)","slug":"algorithm/baekjoon/BFS/1012-유기농배추-python","date":"2022-02-12T11:10:40.000Z","updated":"2024-02-18T16:19:54.508Z","comments":true,"path":"2022/02/12/algorithm/baekjoon/BFS/1012-유기농배추-python/","link":"","permalink":"https://ckck803.github.io/2022/02/12/algorithm/baekjoon/BFS/1012-%EC%9C%A0%EA%B8%B0%EB%86%8D%EB%B0%B0%EC%B6%94-python/","excerpt":"백준 1012 - 유기농 배추 (Python)링크https://www.acmicpc.net/problem/2606 전체 소스 코드def bfs(y, x): q = [] q.append([y, x]) check[y][x] = True while q: cntY, cntX = q.pop() for i in range(4): ny = cntY + dy[i] nx = cntX + dx[i] if 0 &gt; ny or ny &gt;= col or 0 &gt; nx or nx &gt;= row: continue if check[ny][nx] == False and field[ny][nx] == 1: q.append([ny, nx]) check[ny][nx] = Truetest_case = int(input())row = 0col = 0k = 0field = []check = []dy = [1, -1, 0, 0]dx = [0, 0, 1, -1]for t in range(test_case): row, col, k = map(int, input().split()) field = [[0] * row for _ in range(col)] check = [[False] * row for _ in range(col)] count = 0 for i in range(k): x, y = map(int, input().split()) field[y][x] = 1 for i in range(col): for j in range(row): if check[i][j] == False and field[i][j] == 1: count += 1 bfs(i, j) print(count)","text":"백준 1012 - 유기농 배추 (Python)링크https://www.acmicpc.net/problem/2606 전체 소스 코드def bfs(y, x): q = [] q.append([y, x]) check[y][x] = True while q: cntY, cntX = q.pop() for i in range(4): ny = cntY + dy[i] nx = cntX + dx[i] if 0 &gt; ny or ny &gt;= col or 0 &gt; nx or nx &gt;= row: continue if check[ny][nx] == False and field[ny][nx] == 1: q.append([ny, nx]) check[ny][nx] = Truetest_case = int(input())row = 0col = 0k = 0field = []check = []dy = [1, -1, 0, 0]dx = [0, 0, 1, -1]for t in range(test_case): row, col, k = map(int, input().split()) field = [[0] * row for _ in range(col)] check = [[False] * row for _ in range(col)] count = 0 for i in range(k): x, y = map(int, input().split()) field[y][x] = 1 for i in range(col): for j in range(row): if check[i][j] == False and field[i][j] == 1: count += 1 bfs(i, j) print(count)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[]},{"title":"백준 2606 - 바이러스 (Python)","slug":"algorithm/baekjoon/BFS/2606-바이러스-python","date":"2022-02-12T11:10:40.000Z","updated":"2024-02-18T16:19:54.509Z","comments":true,"path":"2022/02/12/algorithm/baekjoon/BFS/2606-바이러스-python/","link":"","permalink":"https://ckck803.github.io/2022/02/12/algorithm/baekjoon/BFS/2606-%EB%B0%94%EC%9D%B4%EB%9F%AC%EC%8A%A4-python/","excerpt":"백준 2606 - 바이러스 (Python)링크https://www.acmicpc.net/problem/2606 전체 소스 코드def bfs(start_node): q = [] q.append(start_node) check[start_node] = True count = 0 while q: node = q.pop(0) for i in range(1, node_num+1): if check[i] == False and field[node][i] == 1: q.append(i) count += 1 check[i] = True return countnode_num = int(input())line_num = int(input())field = [[0]*(node_num+1)for i in range(node_num+1)]check = [False]*(node_num+1)for i in range(line_num): a, b = map(int, input().split()) field[a][b] = 1 field[b][a] = 1print(bfs(1))","text":"백준 2606 - 바이러스 (Python)링크https://www.acmicpc.net/problem/2606 전체 소스 코드def bfs(start_node): q = [] q.append(start_node) check[start_node] = True count = 0 while q: node = q.pop(0) for i in range(1, node_num+1): if check[i] == False and field[node][i] == 1: q.append(i) count += 1 check[i] = True return countnode_num = int(input())line_num = int(input())field = [[0]*(node_num+1)for i in range(node_num+1)]check = [False]*(node_num+1)for i in range(line_num): a, b = map(int, input().split()) field[a][b] = 1 field[b][a] = 1print(bfs(1))","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[]},{"title":"백준 2606 - 단지번호 붙이기 (Python)","slug":"algorithm/baekjoon/BFS/2667-단지번호붙이기-python","date":"2022-02-12T11:10:40.000Z","updated":"2024-02-18T16:19:54.510Z","comments":true,"path":"2022/02/12/algorithm/baekjoon/BFS/2667-단지번호붙이기-python/","link":"","permalink":"https://ckck803.github.io/2022/02/12/algorithm/baekjoon/BFS/2667-%EB%8B%A8%EC%A7%80%EB%B2%88%ED%98%B8%EB%B6%99%EC%9D%B4%EA%B8%B0-python/","excerpt":"백준 2667 - 단지번호 붙이기 (Python)링크https://www.acmicpc.net/problem/2667 전체 소스 코드def bfs(y, x): q = [] q.append([y, x]) check[y][x] = True count = 0 while len(q) &gt; 0: count += 1 cntY = q[0][0] cntX = q[0][1] q.pop(0) for i in range(4): ny = cntY + dy[i] nx = cntX + dx[i] if 0 &gt; ny or ny &gt;= n or 0 &gt; nx or nx &gt;= n: continue if check[ny][nx] == False and field[ny][nx] != 0: check[ny][nx] = True q.append([ny, nx]) values.append(count)dy = [1, -1, 0, 0]dx = [0, 0, 1, -1]n = int(input())color = 0values = []check = [[False] * n for i in range(n)]field = [[0] * n for i in range(n)]for i in range(n): line = input() for j in range(len(line)): field[i][j] = int(line[j])for i in range(n): for j in range(n): if check[i][j] == False and field[i][j] != 0: color += 1 bfs(i, j)values.sort()print(color)for i in values: print(i)","text":"백준 2667 - 단지번호 붙이기 (Python)링크https://www.acmicpc.net/problem/2667 전체 소스 코드def bfs(y, x): q = [] q.append([y, x]) check[y][x] = True count = 0 while len(q) &gt; 0: count += 1 cntY = q[0][0] cntX = q[0][1] q.pop(0) for i in range(4): ny = cntY + dy[i] nx = cntX + dx[i] if 0 &gt; ny or ny &gt;= n or 0 &gt; nx or nx &gt;= n: continue if check[ny][nx] == False and field[ny][nx] != 0: check[ny][nx] = True q.append([ny, nx]) values.append(count)dy = [1, -1, 0, 0]dx = [0, 0, 1, -1]n = int(input())color = 0values = []check = [[False] * n for i in range(n)]field = [[0] * n for i in range(n)]for i in range(n): line = input() for j in range(len(line)): field[i][j] = int(line[j])for i in range(n): for j in range(n): if check[i][j] == False and field[i][j] != 0: color += 1 bfs(i, j)values.sort()print(color)for i in values: print(i)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[]},{"title":"MySQL - 사용자 생성","slug":"database/mysql/create-user","date":"2022-01-26T11:10:40.000Z","updated":"2024-02-18T16:19:54.523Z","comments":true,"path":"2022/01/26/database/mysql/create-user/","link":"","permalink":"https://ckck803.github.io/2022/01/26/database/mysql/create-user/","excerpt":"MySQL - 사용자 생성show databases; use mysql; 계정 생성 쿼리-- 내부에서만 사용할 계정 생성CREATE USER &#x27;계정 아이디&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;비밀번호&#x27;;-- 외부에서 사용할 계정 생성CREATE USER &#x27;계정 아이디&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;비밀번호&#x27;; 권한 부여-- GRANT ALL PRIVILEGES ON *.* TO &#x27;계정 아이디&#x27;@&#x27;%&#x27;;flush privileges;quit$$ CREATE DATABASE study_db default CHARACTER SET UTF8;","text":"MySQL - 사용자 생성show databases; use mysql; 계정 생성 쿼리-- 내부에서만 사용할 계정 생성CREATE USER &#x27;계정 아이디&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;비밀번호&#x27;;-- 외부에서 사용할 계정 생성CREATE USER &#x27;계정 아이디&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;비밀번호&#x27;; 권한 부여-- GRANT ALL PRIVILEGES ON *.* TO &#x27;계정 아이디&#x27;@&#x27;%&#x27;;flush privileges;quit$$ CREATE DATABASE study_db default CHARACTER SET UTF8;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"MySQL","slug":"Programming/MySQL","permalink":"https://ckck803.github.io/categories/Programming/MySQL/"}],"tags":[]},{"title":"프로그래머스 - 양궁 대회 (Cpp)","slug":"algorithm/programmers/경우의수/92342-양궁대회-cpp","date":"2022-01-21T11:10:40.000Z","updated":"2024-02-18T16:19:54.514Z","comments":true,"path":"2022/01/21/algorithm/programmers/경우의수/92342-양궁대회-cpp/","link":"","permalink":"https://ckck803.github.io/2022/01/21/algorithm/programmers/%EA%B2%BD%EC%9A%B0%EC%9D%98%EC%88%98/92342-%EC%96%91%EA%B6%81%EB%8C%80%ED%9A%8C-cpp/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/92342 프로그래머스 - 키패드누르기 Cpp 프로그래머스 - 키패드누르기 Python 유의 사항 화살을 맞춘 개수를 저장하고 정렬하는데 있어서 주의해야 한다. 정렬에 대한 가중치가 앞자리가 아닌 뒷자리 에 있으므로 값을 저장할 때 뒤집어서 저장한 후 내림 차순으로 정렬해 가장 큰 값을 가져와 해당 값을 뒤집으면 가장 낮은 점수를 많이 맞춘 순서대로 정렬된 값을 가져올 수 있다. #include &lt;bits/stdc++.h&gt;using namespace std;int max_diff = -1;vector&lt;string&gt; scores;int getValue(int idx) &#123; return 10 - idx;&#125;void calScore(vector&lt;int&gt; apeach, vector&lt;int&gt; ryan) &#123; int diff = 0; int total_apeach = 0; int total_ryan = 0; for (int i = 0; i &lt; 11; i++) &#123; if (apeach[i] == 0 &amp;&amp; ryan[i] == 0) &#123; continue; &#125; if (apeach[i] &gt;= ryan[i]) &#123; total_apeach += getValue(i); &#125; else &#123; total_ryan += getValue(i); &#125; &#125; if (total_ryan &gt; total_apeach) &#123; diff = total_ryan - total_apeach; &#125; else &#123; return; &#125; string str; for (int i : ryan) &#123; str += i + &#x27;0&#x27;; &#125; reverse(str.begin(), str.end()); if (diff &gt; max_diff) &#123; max_diff = diff; scores.clear(); scores.push_back(str); &#125; else if (diff == max_diff) &#123; scores.push_back(str); &#125;&#125;void back_tracking(int depth, int idx, int n, vector&lt;int&gt;&amp; apeach, vector&lt;int&gt;&amp; ryan) &#123; if (idx &gt; 10) &#123; return; &#125; if (depth == n) &#123; calScore(apeach, ryan); return; &#125; ryan[idx] += 1; back_tracking(depth + 1, idx, n, apeach, ryan); ryan[idx] -= 1; back_tracking(depth, idx + 1, n, apeach, ryan);&#125;vector&lt;int&gt; solution(int n, vector&lt;int&gt; info) &#123; vector&lt;int&gt; answer; vector&lt;int&gt; ryan = vector&lt;int&gt;(11, 0); back_tracking(0, 0, n, info, ryan); if (max_diff == -1) &#123; answer.push_back(-1); &#125; else &#123; sort(scores.begin(), scores.end(), greater&lt;string&gt;()); string str = scores[0]; reverse(str.begin(), str.end()); for (int i = 0; i &lt; str.size(); i++) &#123; answer.push_back(str[i] - &#x27;0&#x27;); &#125; &#125; return answer;&#125;","text":"https://programmers.co.kr/learn/courses/30/lessons/92342 프로그래머스 - 키패드누르기 Cpp 프로그래머스 - 키패드누르기 Python 유의 사항 화살을 맞춘 개수를 저장하고 정렬하는데 있어서 주의해야 한다. 정렬에 대한 가중치가 앞자리가 아닌 뒷자리 에 있으므로 값을 저장할 때 뒤집어서 저장한 후 내림 차순으로 정렬해 가장 큰 값을 가져와 해당 값을 뒤집으면 가장 낮은 점수를 많이 맞춘 순서대로 정렬된 값을 가져올 수 있다. #include &lt;bits/stdc++.h&gt;using namespace std;int max_diff = -1;vector&lt;string&gt; scores;int getValue(int idx) &#123; return 10 - idx;&#125;void calScore(vector&lt;int&gt; apeach, vector&lt;int&gt; ryan) &#123; int diff = 0; int total_apeach = 0; int total_ryan = 0; for (int i = 0; i &lt; 11; i++) &#123; if (apeach[i] == 0 &amp;&amp; ryan[i] == 0) &#123; continue; &#125; if (apeach[i] &gt;= ryan[i]) &#123; total_apeach += getValue(i); &#125; else &#123; total_ryan += getValue(i); &#125; &#125; if (total_ryan &gt; total_apeach) &#123; diff = total_ryan - total_apeach; &#125; else &#123; return; &#125; string str; for (int i : ryan) &#123; str += i + &#x27;0&#x27;; &#125; reverse(str.begin(), str.end()); if (diff &gt; max_diff) &#123; max_diff = diff; scores.clear(); scores.push_back(str); &#125; else if (diff == max_diff) &#123; scores.push_back(str); &#125;&#125;void back_tracking(int depth, int idx, int n, vector&lt;int&gt;&amp; apeach, vector&lt;int&gt;&amp; ryan) &#123; if (idx &gt; 10) &#123; return; &#125; if (depth == n) &#123; calScore(apeach, ryan); return; &#125; ryan[idx] += 1; back_tracking(depth + 1, idx, n, apeach, ryan); ryan[idx] -= 1; back_tracking(depth, idx + 1, n, apeach, ryan);&#125;vector&lt;int&gt; solution(int n, vector&lt;int&gt; info) &#123; vector&lt;int&gt; answer; vector&lt;int&gt; ryan = vector&lt;int&gt;(11, 0); back_tracking(0, 0, n, info, ryan); if (max_diff == -1) &#123; answer.push_back(-1); &#125; else &#123; sort(scores.begin(), scores.end(), greater&lt;string&gt;()); string str = scores[0]; reverse(str.begin(), str.end()); for (int i = 0; i &lt; str.size(); i++) &#123; answer.push_back(str[i] - &#x27;0&#x27;); &#125; &#125; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"경우의 수","slug":"Programming/프로그래머스/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"},{"name":"중복 순열","slug":"Programming/프로그래머스/경우의-수/중복-순열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/%EC%A4%91%EB%B3%B5-%EC%88%9C%EC%97%B4/"}],"tags":[]},{"title":"프로그래머스 - 주차 요금 계산","slug":"algorithm/programmers/string/92341-주차요금계산-python","date":"2022-01-19T11:10:40.000Z","updated":"2024-02-18T16:19:54.514Z","comments":true,"path":"2022/01/19/algorithm/programmers/string/92341-주차요금계산-python/","link":"","permalink":"https://ckck803.github.io/2022/01/19/algorithm/programmers/string/92341-%EC%A3%BC%EC%B0%A8%EC%9A%94%EA%B8%88%EA%B3%84%EC%82%B0-python/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92341 프로그래머스 - 주차 요금 계산 import mathlimit = 23*60 + 59def time_to_minute(time): times = list(map(int, time.split(&#x27;:&#x27;))) return times[0] * 60 + times[1]def calCost(base_time, base_fee, per_time, per_fee, interval): if base_time &gt; interval: return base_fee return base_fee + math.ceil((interval-base_time)/per_time)*per_feedef solution(fees, records): answer = [] fees = list(map(int, fees)) base_time = fees[0] base_fee = fees[1] per_time = fees[2] per_fee = fees[3] dict = &#123;&#125; time_dict = &#123;&#125; fee_dict = &#123;&#125; for line in records: words = line.split(&#x27; &#x27;) time = time_to_minute(words[0]) car_number = words[1] in_out = words[2] if in_out == &#x27;IN&#x27;: dict[car_number] = [time] else: dict[car_number].append(time) in_out_times = dict[car_number] if car_number in time_dict: time_dict[car_number] += (in_out_times[1] - in_out_times[0]) else: time_dict[car_number] = (in_out_times[1] - in_out_times[0]) for key, value in dict.items(): if len(value) == 1: if key in time_dict: time_dict[key] += (limit - value[0]) else: time_dict[key] = (limit - value[0]) for key, value in time_dict.items(): fee = calCost(base_time, base_fee, per_time, per_fee, value) if key in fee_dict: fee_dict[key] += fee else: fee_dict[key] = fee soredDict = sorted(fee_dict.items()) for value in soredDict: answer.append(value[1]) return answer","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92341 프로그래머스 - 주차 요금 계산 import mathlimit = 23*60 + 59def time_to_minute(time): times = list(map(int, time.split(&#x27;:&#x27;))) return times[0] * 60 + times[1]def calCost(base_time, base_fee, per_time, per_fee, interval): if base_time &gt; interval: return base_fee return base_fee + math.ceil((interval-base_time)/per_time)*per_feedef solution(fees, records): answer = [] fees = list(map(int, fees)) base_time = fees[0] base_fee = fees[1] per_time = fees[2] per_fee = fees[3] dict = &#123;&#125; time_dict = &#123;&#125; fee_dict = &#123;&#125; for line in records: words = line.split(&#x27; &#x27;) time = time_to_minute(words[0]) car_number = words[1] in_out = words[2] if in_out == &#x27;IN&#x27;: dict[car_number] = [time] else: dict[car_number].append(time) in_out_times = dict[car_number] if car_number in time_dict: time_dict[car_number] += (in_out_times[1] - in_out_times[0]) else: time_dict[car_number] = (in_out_times[1] - in_out_times[0]) for key, value in dict.items(): if len(value) == 1: if key in time_dict: time_dict[key] += (limit - value[0]) else: time_dict[key] = (limit - value[0]) for key, value in time_dict.items(): fee = calCost(base_time, base_fee, per_time, per_fee, value) if key in fee_dict: fee_dict[key] += fee else: fee_dict[key] = fee soredDict = sorted(fee_dict.items()) for value in soredDict: answer.append(value[1]) return answer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}],"tags":[]},{"title":"프로그래머스 - K진수에서 소수 구하기 Python","slug":"algorithm/programmers/string/92335-k진수에서소수구하기-python","date":"2022-01-19T11:10:40.000Z","updated":"2024-02-18T16:19:54.514Z","comments":true,"path":"2022/01/19/algorithm/programmers/string/92335-k진수에서소수구하기-python/","link":"","permalink":"https://ckck803.github.io/2022/01/19/algorithm/programmers/string/92335-k%EC%A7%84%EC%88%98%EC%97%90%EC%84%9C%EC%86%8C%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0-python/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92335 프로그래머스 - K진수에서 소수 구하기 Python def is_prime(value): if value &lt;= 1: return False for i in range(2, int(value**0.5)+1): if value % i == 0: return False return Truedef solution(n, k): answer = 0 str_value = &#x27;&#x27; stack = [] while n &gt; 0: stack.append(n % k) n = n//k while len(stack) &gt; 0: str_value += str(stack.pop()) sub_strs = str_value.split(&#x27;0&#x27;) for i in sub_strs: if i == &#x27;&#x27;: continue if is_prime(int(i)): answer += 1 return answer","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92335 프로그래머스 - K진수에서 소수 구하기 Python def is_prime(value): if value &lt;= 1: return False for i in range(2, int(value**0.5)+1): if value % i == 0: return False return Truedef solution(n, k): answer = 0 str_value = &#x27;&#x27; stack = [] while n &gt; 0: stack.append(n % k) n = n//k while len(stack) &gt; 0: str_value += str(stack.pop()) sub_strs = str_value.split(&#x27;0&#x27;) for i in sub_strs: if i == &#x27;&#x27;: continue if is_prime(int(i)): answer += 1 return answer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"}],"tags":[]},{"title":"프로그래머스 - 신고 결과 받기 Cpp","slug":"algorithm/programmers/string/92334-신고결과받기-cpp","date":"2022-01-17T11:10:40.000Z","updated":"2024-02-18T16:19:54.514Z","comments":true,"path":"2022/01/17/algorithm/programmers/string/92334-신고결과받기-cpp/","link":"","permalink":"https://ckck803.github.io/2022/01/17/algorithm/programmers/string/92334-%EC%8B%A0%EA%B3%A0%EA%B2%B0%EA%B3%BC%EB%B0%9B%EA%B8%B0-cpp/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92334 프로그래머스 - 신고 결과 받기 Cpp 프로그래머스 - 신고 결과 받기 Python #include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;string&gt; split(string line) &#123; vector&lt;string&gt; v; int point = 0; for (int i = 0; i &lt; line.size(); i++) &#123; if (line[i] == &#x27; &#x27;) &#123; point = i; break; &#125; &#125; v.push_back(line.substr(0, point)); v.push_back(line.substr(point + 1)); return v;&#125;vector&lt;int&gt; solution(vector&lt;string&gt; id_list, vector&lt;string&gt; report, int k) &#123; vector&lt;int&gt; answer = vector&lt;int&gt;(id_list.size(), 0); map&lt;string, set&lt;string&gt;&gt; m; for (string line : report) &#123; vector&lt;string&gt; v = split(line); string id = v[0]; string report_id = v[1]; m[v[1]].insert(v[0]); &#125; for (auto iter = m.begin(); iter != m.end(); iter++) &#123; if (iter-&gt;second.size() &gt;= k) &#123; set&lt;string&gt;&amp; s = iter-&gt;second; for (auto s_iter = s.begin(); s_iter != s.end(); s_iter++) &#123; int index = find(id_list.begin(), id_list.end(), *s_iter) - id_list.begin(); answer[index]++; &#125; &#125; &#125; return answer;&#125;","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92334 프로그래머스 - 신고 결과 받기 Cpp 프로그래머스 - 신고 결과 받기 Python #include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;string&gt; split(string line) &#123; vector&lt;string&gt; v; int point = 0; for (int i = 0; i &lt; line.size(); i++) &#123; if (line[i] == &#x27; &#x27;) &#123; point = i; break; &#125; &#125; v.push_back(line.substr(0, point)); v.push_back(line.substr(point + 1)); return v;&#125;vector&lt;int&gt; solution(vector&lt;string&gt; id_list, vector&lt;string&gt; report, int k) &#123; vector&lt;int&gt; answer = vector&lt;int&gt;(id_list.size(), 0); map&lt;string, set&lt;string&gt;&gt; m; for (string line : report) &#123; vector&lt;string&gt; v = split(line); string id = v[0]; string report_id = v[1]; m[v[1]].insert(v[0]); &#125; for (auto iter = m.begin(); iter != m.end(); iter++) &#123; if (iter-&gt;second.size() &gt;= k) &#123; set&lt;string&gt;&amp; s = iter-&gt;second; for (auto s_iter = s.begin(); s_iter != s.end(); s_iter++) &#123; int index = find(id_list.begin(), id_list.end(), *s_iter) - id_list.begin(); answer[index]++; &#125; &#125; &#125; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"}],"tags":[]},{"title":"프로그래머스 - 신고 결과 받기 Python","slug":"algorithm/programmers/string/92334-신고결과받기-python","date":"2022-01-17T11:10:40.000Z","updated":"2024-02-18T16:19:54.514Z","comments":true,"path":"2022/01/17/algorithm/programmers/string/92334-신고결과받기-python/","link":"","permalink":"https://ckck803.github.io/2022/01/17/algorithm/programmers/string/92334-%EC%8B%A0%EA%B3%A0%EA%B2%B0%EA%B3%BC%EB%B0%9B%EA%B8%B0-python/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92334 프로그래머스 - 신고 결과 받기 Cpp 프로그래머스 - 신고 결과 받기 Python def solution(id_list, report, k): answer = [0] * len(id_list) dict = &#123;id: set() for id in id_list&#125; for line in set(report): args = line.split(&#x27; &#x27;) dict[args[1]].add(args[0]) print(dict) for key, value in dict.items(): if len(value) &gt;= k: for i in value: answer[id_list.index(i)] += 1 return answer","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/92334 프로그래머스 - 신고 결과 받기 Cpp 프로그래머스 - 신고 결과 받기 Python def solution(id_list, report, k): answer = [0] * len(id_list) dict = &#123;id: set() for id in id_list&#125; for line in set(report): args = line.split(&#x27; &#x27;) dict[args[1]].add(args[0]) print(dict) for key, value in dict.items(): if len(value) &gt;= k: for i in value: answer[id_list.index(i)] += 1 return answer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"}],"tags":[]},{"title":"네트워크 - CORS (Corss Site Resource Sharing)","slug":"computer-science/network/security/cors","date":"2022-01-16T16:16:32.000Z","updated":"2024-02-18T16:19:54.519Z","comments":true,"path":"2022/01/17/computer-science/network/security/cors/","link":"","permalink":"https://ckck803.github.io/2022/01/17/computer-science/network/security/cors/","excerpt":"SOP (Same Origin Policy)다른 출처의 리소스를 사용 못하도록 제한하는 보안 방식 CORS (Cross Origin Resource Sharing) 하나의 Origin 에서 실행 중인 웹 애플리케이션이 다른 Origin 내 리소스를 사용하는 것을 의미한다. 추가 HTTP 헤더를 이용해 한 출처에서 실행중인 웹 어플리케이션이 다른 출처의 선택된 자원에 접근할 수 있는 권한을 부여하도록 브라우저에게 알려주는 체제 Request 내 Origin 헤더와 Response 내 Access-Control-Allow-Origin 헤더가 같으면 브라우저는 같은 출처로 인식한다. 해결 방법서버에서 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에 보내는 방식으로 CORS 에러를 해결할 수 있습니다. 프론트엔드 개발자가 CORS 에러를 확인했다면, 서버에 Access-Control-Allow-Origin 등 CORS를 해결하기 위한 몇 가지 응답 헤더를 포함해 달라고 요청해야 합니다. 출처 URL의 Protocol, Host, Port 를 합친 것을 의미한다.","text":"SOP (Same Origin Policy)다른 출처의 리소스를 사용 못하도록 제한하는 보안 방식 CORS (Cross Origin Resource Sharing) 하나의 Origin 에서 실행 중인 웹 애플리케이션이 다른 Origin 내 리소스를 사용하는 것을 의미한다. 추가 HTTP 헤더를 이용해 한 출처에서 실행중인 웹 어플리케이션이 다른 출처의 선택된 자원에 접근할 수 있는 권한을 부여하도록 브라우저에게 알려주는 체제 Request 내 Origin 헤더와 Response 내 Access-Control-Allow-Origin 헤더가 같으면 브라우저는 같은 출처로 인식한다. 해결 방법서버에서 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에 보내는 방식으로 CORS 에러를 해결할 수 있습니다. 프론트엔드 개발자가 CORS 에러를 확인했다면, 서버에 Access-Control-Allow-Origin 등 CORS를 해결하기 위한 몇 가지 응답 헤더를 포함해 달라고 요청해야 합니다. 출처 URL의 Protocol, Host, Port 를 합친 것을 의미한다. CORS 접근 제어 시나리오 Simple Request Preflight Requst Credential Request Simple Request Preflight 요청 없이 바로 요청을 보낸다. 사용할 수 있는 메서드는 GET, POST, HEAD 메서드 사용할 수 있는 Content-Type application&#x2F;x-www-form-urlencoded multipart&#x2F;form-data text&#x2F;plain 사용할 수 있는 헤더 Accept Accept-Language Content-Language Content-type 만 허용 가능 Preflight Requst Option 메서드를 이용해 다른 도메인의 리소스에 요청이 가능한지 확인 Request 내 Origin 과 응답의 Access-Control-Allow-Origin 을 브라우저가 비교해 판단한다. 요청이 가능하면 실제 요청을 보낸다. Request Header Origin : 요청 출처 Access-Control-Request-Method : 실제 요청의 메서드 Access-Control-Request-Headers : 실제 요청의 추가 헤더 Response Header Access-Control-Allow-Origin : 서버측 허가 출처 Access-Control-Allow-Methods : 서버 측 허가 메서드 Access-Control-Allow-Headers : 서버 측 허가 헤더 Access-Control-Max-Age : Preflight 응답 캐시 시간","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"Security","slug":"CS/Network/Security","permalink":"https://ckck803.github.io/categories/CS/Network/Security/"}],"tags":[]},{"title":"네트워크 - CSRF (Corss Site Request For Forgery)","slug":"computer-science/network/security/csrf","date":"2022-01-16T16:16:32.000Z","updated":"2024-02-18T16:19:54.519Z","comments":true,"path":"2022/01/17/computer-science/network/security/csrf/","link":"","permalink":"https://ckck803.github.io/2022/01/17/computer-science/network/security/csrf/","excerpt":"CSRF (Corss Site Request Forgery) CSRF 란 사이트 간 요청 위조의 의미로, 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 해 특정 웹페이지를 보안에 취약하게 하거나 수정, 삭제 들의 작업을 하게 만드는 공격 방법공격자가 특정 사용자의 권한을 탈취해 특정 행위 (수정, 삭제, 등록 등) 를 사이트에 요청하게 만드는 공격 CSRF 를 위한 조건 권한이 있는 사용자가 사이트(서비스) 에 접속해야 한다. 사용자가 공격자가 만든 피싱 사이트에 접속하게 되면 CSRF 공격이 성립된다. 2008년에 발생했던 옥션의 개인정보 유출 사건에서도 관리자 계정을 탈취하는데 이 CSRF 방법을 이용 옥션 관리자가 메일을 조회하면서 CSRF 공격할 수 있는 테그가 들어간 이메일을 열어 해커가 관리자 권한을 취득하게 됨 &lt;img src=&quot;http://auction.com/changeUserAcoount?id=admin&amp;password=admin&quot; width=&quot;0&quot; height=&quot;0&quot;&gt; 방어 방법1. Referrer 검증","text":"CSRF (Corss Site Request Forgery) CSRF 란 사이트 간 요청 위조의 의미로, 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 해 특정 웹페이지를 보안에 취약하게 하거나 수정, 삭제 들의 작업을 하게 만드는 공격 방법공격자가 특정 사용자의 권한을 탈취해 특정 행위 (수정, 삭제, 등록 등) 를 사이트에 요청하게 만드는 공격 CSRF 를 위한 조건 권한이 있는 사용자가 사이트(서비스) 에 접속해야 한다. 사용자가 공격자가 만든 피싱 사이트에 접속하게 되면 CSRF 공격이 성립된다. 2008년에 발생했던 옥션의 개인정보 유출 사건에서도 관리자 계정을 탈취하는데 이 CSRF 방법을 이용 옥션 관리자가 메일을 조회하면서 CSRF 공격할 수 있는 테그가 들어간 이메일을 열어 해커가 관리자 권한을 취득하게 됨 &lt;img src=&quot;http://auction.com/changeUserAcoount?id=admin&amp;password=admin&quot; width=&quot;0&quot; height=&quot;0&quot;&gt; 방어 방법1. Referrer 검증 Reqeust Header 에 있는 Referrer 속성을 검증해 차단하는 방식, 이 방법만으로도 대부분 방어가 가능하다. 같은 도메인 내 페이지에 XSS 취약점이 있다면 CSRF 공격에 취약해 질 수 있다. Referer 란 현재 요청을 보낸 페이지의 절대 혹은 부분 주소 정보를 갖고 있는 헤더 특정 링크를 통해 사이트를 방문하게 되면 해당 사이트 주소를 갖고 있다. 다른 도메인에 리소스 요청을 하는 경우라면 해당 리소스를 사용하는 페이지 주소를 갖고 있다. 2. CSRF Token 사용 난수를 사용자 세션에 저장해 사용자의 모든 요청에 값을 포함해 전송한다. 요청이 들어올 때 마다 세션에 저장된 값과 전송된 값이 일치하는지 검증 XSS 를 통한 CSRF 공격에 취약하다. 3. CAPCHA 사용 이미지는 매번 바뀌어 인증 값을 미리 획득 할 수 없게 구성돼 있음 인증 값을 미리 획득 할 수 없어서 가장 안전한 방법","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"Security","slug":"CS/Network/Security","permalink":"https://ckck803.github.io/categories/CS/Network/Security/"}],"tags":[]},{"title":"네트워크 - XSS (Cross-Site Scripting)","slug":"computer-science/network/security/xss","date":"2022-01-16T16:16:32.000Z","updated":"2024-02-18T16:19:54.520Z","comments":true,"path":"2022/01/17/computer-science/network/security/xss/","link":"","permalink":"https://ckck803.github.io/2022/01/17/computer-science/network/security/xss/","excerpt":"![]&#x2F;images&#x2F;computer-science&#x2F;network&#x2F;http&#x2F;xss.png) XSS (Cross-Site Scripting) 공격자가 보안이 취약한 웹 사이트에 악성 스크립트를 삽입하는 공격 기법 XSS 를 통해 C&amp;C (좀비 PC에 명령을 내리거나 악성 코드를 제어하는 서버) 로 리다이렉하거나 사용자의 쿠키를 탈취해 Session 하이재킹 공격을 할 수 있다. Persistent XSS 공격자가 심어놓은 특정 스크립트가 서버에 저장돼 지속적으로 서비스를 제공하는 정상 페이지에서 공격자에게 스크립트가 노출되는 기법 Relected XSS 웹 어플리케이션의 파라미터를 사용할 때 발생하는 취약점을 이용한 공격 기법 쿼리 파라미터로 특정 스크립트를 보냈을 때 서버가 필터링을 거치지 않고 파라미터로 포함된 스크립트를 응답 페이지에 담아 전송할 때 문제가 발생","text":"![]&#x2F;images&#x2F;computer-science&#x2F;network&#x2F;http&#x2F;xss.png) XSS (Cross-Site Scripting) 공격자가 보안이 취약한 웹 사이트에 악성 스크립트를 삽입하는 공격 기법 XSS 를 통해 C&amp;C (좀비 PC에 명령을 내리거나 악성 코드를 제어하는 서버) 로 리다이렉하거나 사용자의 쿠키를 탈취해 Session 하이재킹 공격을 할 수 있다. Persistent XSS 공격자가 심어놓은 특정 스크립트가 서버에 저장돼 지속적으로 서비스를 제공하는 정상 페이지에서 공격자에게 스크립트가 노출되는 기법 Relected XSS 웹 어플리케이션의 파라미터를 사용할 때 발생하는 취약점을 이용한 공격 기법 쿼리 파라미터로 특정 스크립트를 보냈을 때 서버가 필터링을 거치지 않고 파라미터로 포함된 스크립트를 응답 페이지에 담아 전송할 때 문제가 발생 XSS 의 위험성 쿠키 정보 및 Session ID 획득 시스템 관리자 권한 획득 악성코드 다운로드 거짓 페이지 노출 XSS 방지법 HTML 5 에서는 innerHTML 을 통해 주입한 스크립트는 실행되지 않는다. Cookie 에 HttpOnly 옵션을 활성화 한다. document.cookie 를 이용해 Cookie 정보를 가져오는 것을 차단한다. 단 localStorage 에 저장된 정보에 대한 접근은 막을 수 없다. Script 문자 필터링 htmlentity 사용 특수문자를 HTML Entity 로 변환한다. &lt; : &lt; 로 변환 &gt; : &gt; 로 변환","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"Security","slug":"CS/Network/Security","permalink":"https://ckck803.github.io/categories/CS/Network/Security/"}],"tags":[]},{"title":"프로그래머스 - 문자열 압축 Python","slug":"algorithm/programmers/string/60057-문자열압축-python","date":"2022-01-09T11:10:40.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2022/01/09/algorithm/programmers/string/60057-문자열압축-python/","link":"","permalink":"https://ckck803.github.io/2022/01/09/algorithm/programmers/string/60057-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%95%95%EC%B6%95-python/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/60057 프로그래머스 - 문자열 압축 Cpp 프로그래머스 - 문자열 압축 Python 문제 풀이간단한 구현 문제다. 주어진 문자열을 substr 해서 문자열 비교를 통해 같은 문자열의 개수를 찾아내 압축된 문자열 형태로 만들어준 다음 압축된 문자열의 길이를 반환해주면 되는 문제다. 문제 전체 소스def solution(s): answer = &#x27;&#x27; if len(s) == 1: return len(s) for i in range(1, len(s)//2 + 1): sentence = &#x27;&#x27; count = 0 word = s[:i] for j in range(0, len(s), i): if s[j:j+i] == word: count += 1 else: if count &gt; 1: sentence += (str(count) + word) else: sentence += (word) word = s[j:j+i] count = 1 if count &gt; 1: sentence += (str(count) + word) else: sentence += (word) if len(answer) == 0: answer = sentence elif len(answer) &gt; len(sentence): answer = sentence print(answer) return len(answer)","text":"https://programmers.co.kr/learn/courses/30/lessons/60057 프로그래머스 - 문자열 압축 Cpp 프로그래머스 - 문자열 압축 Python 문제 풀이간단한 구현 문제다. 주어진 문자열을 substr 해서 문자열 비교를 통해 같은 문자열의 개수를 찾아내 압축된 문자열 형태로 만들어준 다음 압축된 문자열의 길이를 반환해주면 되는 문제다. 문제 전체 소스def solution(s): answer = &#x27;&#x27; if len(s) == 1: return len(s) for i in range(1, len(s)//2 + 1): sentence = &#x27;&#x27; count = 0 word = s[:i] for j in range(0, len(s), i): if s[j:j+i] == word: count += 1 else: if count &gt; 1: sentence += (str(count) + word) else: sentence += (word) word = s[j:j+i] count = 1 if count &gt; 1: sentence += (str(count) + word) else: sentence += (word) if len(answer) == 0: answer = sentence elif len(answer) &gt; len(sentence): answer = sentence print(answer) return len(answer)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://ckck803.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"Cpp","slug":"Cpp","permalink":"https://ckck803.github.io/tags/Cpp/"}]},{"title":"프로그래머스 - 문자열 압축 Cpp","slug":"algorithm/programmers/string/60057-문자열압축-cpp","date":"2022-01-09T11:10:40.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2022/01/09/algorithm/programmers/string/60057-문자열압축-cpp/","link":"","permalink":"https://ckck803.github.io/2022/01/09/algorithm/programmers/string/60057-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%95%95%EC%B6%95-cpp/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/60057 프로그래머스 - 문자열 압축 Cpp 프로그래머스 - 문자열 압축 Python 문제 풀이간단한 구현 문제다. 주어진 문자열을 substr 해서 문자열 비교를 통해 같은 문자열의 개수를 찾아내 압축된 문자열 형태로 만들어준 다음 압축된 문자열의 길이를 반환해주면 되는 문제다. 문자열 압축하기주어진 문자열을 스캔하면서 고려해야 하는 조건이 첫번째는 substr 하려는 범위가 주어진 문자열의 범위를 넘어서면 안된다는 것이다. 두번째는 substr 범위가 주어진 문자열의 범위를 넘어선 경우 압축된 문자열에 그대로 추가해줘야 한다는 것이다. int divideString(int length, string s) &#123; string zipString = &quot;&quot;; int i = 0; // 문자열을 스캔하면서 substr 범위가 주어진 문자열을 넘는지 확인한다. for (i = 0; i &lt; s.length() &amp;&amp; i + length &lt; s.length(); i = i + length) &#123; int count = 0; bool isErase = false; string substr = s.substr(i, length); string cmpstr = s.substr(i, length); while (substr == cmpstr &amp;&amp; s.length() &gt; i) &#123; count++; i += length; isErase = true; substr = s.substr(i, length); &#125; if (isErase == true) &#123; i -= length; &#125; if (count == 1) &#123; zipString += cmpstr; &#125; else &#123; zipString += to_string(count); zipString += cmpstr; &#125; &#125; // 남겨진 문자열을 압축된 문자열에 그대로 추가한다. for (int idx = i; idx &lt; s.length(); idx++) &#123; zipString += s[i]; &#125; return zipString.length();&#125; 문제 전체 소스#include &lt;bits/stdc++.h&gt;using namespace std;int divideString(int length, string s) &#123; string zipString = &quot;&quot;; int count = 0; int i = 0; for (i = 0; i &lt; s.length() &amp;&amp; i + length &lt; s.length(); i = i + length) &#123; bool isErase = false; string substr = s.substr(i, length); string cmpstr = s.substr(i, length); while (substr == cmpstr &amp;&amp; s.length() &gt; i) &#123; count++; i += length; isErase = true; substr = s.substr(i, length); &#125; if (isErase == true) &#123; i -= length; &#125; if (count == 1) &#123; zipString += cmpstr; &#125; else &#123; zipString += to_string(count); zipString += cmpstr; &#125; count = 0; cmpstr = &quot;&quot;; &#125; for (int idx = i; idx &lt; s.length(); idx++) &#123; zipString += s[i]; &#125; return zipString.length();&#125;int solution(string s) &#123; int answer = 0; int minValue = s.length(); for (int i = 1; i &lt;= s.length() / 2; i++) &#123; int zipLength = divideString(i, s); minValue = min(zipLength, minValue); &#125; answer = minValue; return answer;&#125;","text":"https://programmers.co.kr/learn/courses/30/lessons/60057 프로그래머스 - 문자열 압축 Cpp 프로그래머스 - 문자열 압축 Python 문제 풀이간단한 구현 문제다. 주어진 문자열을 substr 해서 문자열 비교를 통해 같은 문자열의 개수를 찾아내 압축된 문자열 형태로 만들어준 다음 압축된 문자열의 길이를 반환해주면 되는 문제다. 문자열 압축하기주어진 문자열을 스캔하면서 고려해야 하는 조건이 첫번째는 substr 하려는 범위가 주어진 문자열의 범위를 넘어서면 안된다는 것이다. 두번째는 substr 범위가 주어진 문자열의 범위를 넘어선 경우 압축된 문자열에 그대로 추가해줘야 한다는 것이다. int divideString(int length, string s) &#123; string zipString = &quot;&quot;; int i = 0; // 문자열을 스캔하면서 substr 범위가 주어진 문자열을 넘는지 확인한다. for (i = 0; i &lt; s.length() &amp;&amp; i + length &lt; s.length(); i = i + length) &#123; int count = 0; bool isErase = false; string substr = s.substr(i, length); string cmpstr = s.substr(i, length); while (substr == cmpstr &amp;&amp; s.length() &gt; i) &#123; count++; i += length; isErase = true; substr = s.substr(i, length); &#125; if (isErase == true) &#123; i -= length; &#125; if (count == 1) &#123; zipString += cmpstr; &#125; else &#123; zipString += to_string(count); zipString += cmpstr; &#125; &#125; // 남겨진 문자열을 압축된 문자열에 그대로 추가한다. for (int idx = i; idx &lt; s.length(); idx++) &#123; zipString += s[i]; &#125; return zipString.length();&#125; 문제 전체 소스#include &lt;bits/stdc++.h&gt;using namespace std;int divideString(int length, string s) &#123; string zipString = &quot;&quot;; int count = 0; int i = 0; for (i = 0; i &lt; s.length() &amp;&amp; i + length &lt; s.length(); i = i + length) &#123; bool isErase = false; string substr = s.substr(i, length); string cmpstr = s.substr(i, length); while (substr == cmpstr &amp;&amp; s.length() &gt; i) &#123; count++; i += length; isErase = true; substr = s.substr(i, length); &#125; if (isErase == true) &#123; i -= length; &#125; if (count == 1) &#123; zipString += cmpstr; &#125; else &#123; zipString += to_string(count); zipString += cmpstr; &#125; count = 0; cmpstr = &quot;&quot;; &#125; for (int idx = i; idx &lt; s.length(); idx++) &#123; zipString += s[i]; &#125; return zipString.length();&#125;int solution(string s) &#123; int answer = 0; int minValue = s.length(); for (int i = 1; i &lt;= s.length() / 2; i++) &#123; int zipLength = divideString(i, s); minValue = min(zipLength, minValue); &#125; answer = minValue; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}],"tags":[]},{"title":"백준 13460 - 구슬 탈출 2","slug":"algorithm/baekjoon/samsung/13460-구슬탈출2","date":"2022-01-09T06:16:03.000Z","updated":"2024-02-18T16:19:54.510Z","comments":true,"path":"2022/01/09/algorithm/baekjoon/samsung/13460-구슬탈출2/","link":"","permalink":"https://ckck803.github.io/2022/01/09/algorithm/baekjoon/samsung/13460-%EA%B5%AC%EC%8A%AC%ED%83%88%EC%B6%9C2/","excerpt":"https://www.acmicpc.net/problem/13460 백준 13460 - 구슬 탈출 2 백준 13460 - 구슬 탈출 2문제스타트링크에서 판매하는 어린이용 장난감 중에서 가장 인기가 많은 제품은 구슬 탈출이다. 구슬 탈출은 직사각형 보드에 빨간 구슬과 파란 구슬을 하나씩 넣은 다음, 빨간 구슬을 구멍을 통해 빼내는 게임이다. 보드의 세로 크기는 N, 가로 크기는 M이고, 편의상 1×1크기의 칸으로 나누어져 있다. 가장 바깥 행과 열은 모두 막혀져 있고, 보드에는 구멍이 하나 있다. 빨간 구슬과 파란 구슬의 크기는 보드에서 1×1크기의 칸을 가득 채우는 사이즈이고, 각각 하나씩 들어가 있다. 게임의 목표는 빨간 구슬을 구멍을 통해서 빼내는 것이다. 이때, 파란 구슬이 구멍에 들어가면 안 된다. 이때, 구슬을 손으로 건드릴 수는 없고, 중력을 이용해서 이리 저리 굴려야 한다. 왼쪽으로 기울이기, 오른쪽으로 기울이기, 위쪽으로 기울이기, 아래쪽으로 기울이기와 같은 네 가지 동작이 가능하다. 각각의 동작에서 공은 동시에 움직인다. 빨간 구슬이 구멍에 빠지면 성공이지만, 파란 구슬이 구멍에 빠지면 실패이다. 빨간 구슬과 파란 구슬이 동시에 구멍에 빠져도 실패이다. 빨간 구슬과 파란 구슬은 동시에 같은 칸에 있을 수 없다. 또, 빨간 구슬과 파란 구슬의 크기는 한 칸을 모두 차지한다. 기울이는 동작을 그만하는 것은 더 이상 구슬이 움직이지 않을 때 까지이다. 보드의 상태가 주어졌을 때, 최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 구하는 프로그램을 작성하시오.","text":"https://www.acmicpc.net/problem/13460 백준 13460 - 구슬 탈출 2 백준 13460 - 구슬 탈출 2문제스타트링크에서 판매하는 어린이용 장난감 중에서 가장 인기가 많은 제품은 구슬 탈출이다. 구슬 탈출은 직사각형 보드에 빨간 구슬과 파란 구슬을 하나씩 넣은 다음, 빨간 구슬을 구멍을 통해 빼내는 게임이다. 보드의 세로 크기는 N, 가로 크기는 M이고, 편의상 1×1크기의 칸으로 나누어져 있다. 가장 바깥 행과 열은 모두 막혀져 있고, 보드에는 구멍이 하나 있다. 빨간 구슬과 파란 구슬의 크기는 보드에서 1×1크기의 칸을 가득 채우는 사이즈이고, 각각 하나씩 들어가 있다. 게임의 목표는 빨간 구슬을 구멍을 통해서 빼내는 것이다. 이때, 파란 구슬이 구멍에 들어가면 안 된다. 이때, 구슬을 손으로 건드릴 수는 없고, 중력을 이용해서 이리 저리 굴려야 한다. 왼쪽으로 기울이기, 오른쪽으로 기울이기, 위쪽으로 기울이기, 아래쪽으로 기울이기와 같은 네 가지 동작이 가능하다. 각각의 동작에서 공은 동시에 움직인다. 빨간 구슬이 구멍에 빠지면 성공이지만, 파란 구슬이 구멍에 빠지면 실패이다. 빨간 구슬과 파란 구슬이 동시에 구멍에 빠져도 실패이다. 빨간 구슬과 파란 구슬은 동시에 같은 칸에 있을 수 없다. 또, 빨간 구슬과 파란 구슬의 크기는 한 칸을 모두 차지한다. 기울이는 동작을 그만하는 것은 더 이상 구슬이 움직이지 않을 때 까지이다. 보드의 상태가 주어졌을 때, 최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 구하는 프로그램을 작성하시오. 입력첫 번째 줄에는 보드의 세로, 가로 크기를 의미하는 두 정수 N, M (3 ≤ N, M ≤ 10)이 주어진다. 다음 N개의 줄에 보드의 모양을 나타내는 길이 M의 문자열이 주어진다. 이 문자열은 ‘.’, ‘#’, ‘O’, ‘R’, ‘B’ 로 이루어져 있다. ‘.’은 빈 칸을 의미하고, ‘#’은 공이 이동할 수 없는 장애물 또는 벽을 의미하며, ‘O’는 구멍의 위치를 의미한다. ‘R’은 빨간 구슬의 위치, ‘B’는 파란 구슬의 위치이다. 입력되는 모든 보드의 가장자리에는 모두 ‘#’이 있다. 구멍의 개수는 한 개 이며, 빨간 구슬과 파란 구슬은 항상 1개가 주어진다. 출력최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 출력한다. 만약, 10번 이하로 움직여서 빨간 구슬을 구멍을 통해 빼낼 수 없으면 -1을 출력한다. 전체 소스#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\\n&#x27;char board[11][11];bool check[11][11][11][11];// 왼쪽, 오른쪽, 위쪽, 아랫쪽int dy[4] = &#123;0, 0, -1, 1&#125;;int dx[4] = &#123;-1, 1, 0, 0&#125;;pair&lt;int, int&gt; moveBall(pair&lt;int, int&gt; ball, int dir) &#123; while (board[ball.first + dy[dir]][ball.second + dx[dir]] != &#x27;#&#x27;) &#123; if (board[ball.first][ball.second] == &#x27;O&#x27;) &#123; break; &#125; ball.first += dy[dir]; ball.second += dx[dir]; &#125; return ball;&#125;bool isBlueExit(pair&lt;int, int&gt; next_blue) &#123; if (board[next_blue.first][next_blue.second] == &#x27;O&#x27;) &#123; return true; &#125; return false;&#125;bool isRedExit(pair&lt;int, int&gt; next_red) &#123; if (board[next_red.first][next_red.second] == &#x27;O&#x27;) &#123; return true; &#125; return false;&#125;bool isSame(pair&lt;int, int&gt; next_red, pair&lt;int, int&gt; next_blue) &#123; if (next_red.first == next_blue.first &amp;&amp; next_red.second == next_blue.second) &#123; return true; &#125; return false;&#125;void moveBack(pair&lt;int, int&gt; cnt_red, pair&lt;int, int&gt; cnt_blue, pair&lt;int, int&gt;&amp; next_red, pair&lt;int, int&gt;&amp; next_blue, int dir) &#123; // move left if (dir == 0) &#123; if (cnt_red.second &lt; cnt_blue.second) &#123; next_blue.second++; &#125; else &#123; next_red.second++; &#125; &#125; // move right if (dir == 1) &#123; if (cnt_red.second &gt; cnt_blue.second) &#123; next_blue.second--; &#125; else &#123; next_red.second--; &#125; &#125; // move up if (dir == 2) &#123; if (cnt_red.first &lt; cnt_blue.first) &#123; next_blue.first++; &#125; else &#123; next_red.first++; &#125; &#125; // move down if (dir == 3) &#123; if (cnt_red.first &gt; cnt_blue.first) &#123; next_blue.first--; &#125; else &#123; next_red.first--; &#125; &#125;&#125;int bfs(pair&lt;int, int&gt; redBall, pair&lt;int, int&gt; blueBall, pair&lt;int, int&gt; exit) &#123; queue&lt;pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt;&gt;&gt; q; q.push(&#123;redBall, blueBall&#125;); check[redBall.first][redBall.second][blueBall.first][blueBall.second] = true; int count = 0; while (!q.empty()) &#123; count++; int q_size = q.size(); if (count &gt; 10) &#123; break; &#125; while (q_size--) &#123; pair&lt;int, int&gt; cnt_red = q.front().first; pair&lt;int, int&gt; cnt_blue = q.front().second; q.pop(); for (int i = 0; i &lt; 4; i++) &#123; pair&lt;int, int&gt; next_red = moveBall(cnt_red, i); pair&lt;int, int&gt; next_blue = moveBall(cnt_blue, i); if (isBlueExit(next_blue)) &#123; continue; &#125; if (isRedExit(next_red)) &#123; return count; &#125; if (isSame(next_red, next_blue)) &#123; moveBack(cnt_red, cnt_blue, next_red, next_blue, i); &#125; if (check[next_red.first][next_red.second][next_blue.first][next_blue.second] == false) &#123; q.push(&#123;next_red, next_blue&#125;); check[next_red.first][next_red.second][next_blue.first][next_blue.second] = true; &#125; &#125; &#125; &#125; return -1;&#125;int main(void) &#123; int row, col; cin &gt;&gt; row &gt;&gt; col; pair&lt;int, int&gt; redBall; pair&lt;int, int&gt; blueBall; pair&lt;int, int&gt; exit; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; cin &gt;&gt; board[i][j]; if (board[i][j] == &#x27;R&#x27;) &#123; redBall = &#123;i, j&#125;; board[i][j] = &#x27;.&#x27;; &#125; if (board[i][j] == &#x27;B&#x27;) &#123; blueBall = &#123;i, j&#125;; board[i][j] = &#x27;.&#x27;; &#125; if (board[i][j] == &#x27;O&#x27;) &#123; exit = &#123;i, j&#125;; &#125; &#125; &#125; cout &lt;&lt; bfs(redBall, blueBall, exit) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"SAMSUNG","slug":"Programming/Beakjoon/SAMSUNG","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/SAMSUNG/"},{"name":"시뮬레이션","slug":"Programming/Beakjoon/SAMSUNG/시뮬레이션","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/SAMSUNG/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"}],"tags":[]},{"title":"프로그래머스 - 신규 아이디 추천 (Java)","slug":"algorithm/programmers/string/72410-신규아이디추천-java","date":"2022-01-05T11:10:40.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2022/01/05/algorithm/programmers/string/72410-신규아이디추천-java/","link":"","permalink":"https://ckck803.github.io/2022/01/05/algorithm/programmers/string/72410-%EC%8B%A0%EA%B7%9C%EC%95%84%EC%9D%B4%EB%94%94%EC%B6%94%EC%B2%9C-java/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/72410 프로그래머스 - 신규 아이디 추천 (Java) 프로그래머스 - 신규 아이디 추천 (Python) 문제 풀이주어진 조건에 맞춰 하나하나씩 구현하면 되는 문제다. 문자열 관련 정규 표현식을 이용하면 더욱 깔끔하게 문제를 해결 할 수 있다. 전체 소스class Solution &#123; public String solution(String new_id) &#123; String id = new_id.toLowerCase(); id = id.replaceAll(&quot;[^-_.a-z0-9]&quot;, &quot;&quot;); id = id.replaceAll(&quot;[.]&#123;2,&#125;&quot;, &quot;.&quot;); id = id.replaceAll(&quot;^[.]|[.]$&quot;, &quot;&quot;); if (id.equals(&quot;&quot;)) &#123; id += &quot;a&quot;; &#125; if (id.length() &gt;= 16) &#123; id = id.substring(0, 15); id = id.replaceAll(&quot;[.]$&quot;, &quot;&quot;); &#125; while (id.length() &lt;= 2) &#123; id += id.charAt(id.length() - 1); &#125; return id; &#125;&#125;","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/72410 프로그래머스 - 신규 아이디 추천 (Java) 프로그래머스 - 신규 아이디 추천 (Python) 문제 풀이주어진 조건에 맞춰 하나하나씩 구현하면 되는 문제다. 문자열 관련 정규 표현식을 이용하면 더욱 깔끔하게 문제를 해결 할 수 있다. 전체 소스class Solution &#123; public String solution(String new_id) &#123; String id = new_id.toLowerCase(); id = id.replaceAll(&quot;[^-_.a-z0-9]&quot;, &quot;&quot;); id = id.replaceAll(&quot;[.]&#123;2,&#125;&quot;, &quot;.&quot;); id = id.replaceAll(&quot;^[.]|[.]$&quot;, &quot;&quot;); if (id.equals(&quot;&quot;)) &#123; id += &quot;a&quot;; &#125; if (id.length() &gt;= 16) &#123; id = id.substring(0, 15); id = id.replaceAll(&quot;[.]$&quot;, &quot;&quot;); &#125; while (id.length() &lt;= 2) &#123; id += id.charAt(id.length() - 1); &#125; return id; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"정규 표현식","slug":"Programming/프로그래머스/문자열/정규-표현식","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/"}],"tags":[]},{"title":"프로그래머스 - 키패드누르기 Python","slug":"algorithm/programmers/string/67256-키패드누르기-python","date":"2022-01-05T11:10:40.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2022/01/05/algorithm/programmers/string/67256-키패드누르기-python/","link":"","permalink":"https://ckck803.github.io/2022/01/05/algorithm/programmers/string/67256-%ED%82%A4%ED%8C%A8%EB%93%9C%EB%88%84%EB%A5%B4%EA%B8%B0-python/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 키패드누르기 Cpp 프로그래머스 - 키패드누르기 Python def solution(numbers, hand): answer = &#x27;&#x27; left_hands = [1, 4, 7] right_hands = [3, 6, 9] middle = [2, 5, 8, 0] key_pad = &#123; 1: [0, 0], 2: [0, 1], 3: [0, 2], 4: [1, 0], 5: [1, 1], 6: [1, 2], 7: [2, 0], 8: [2, 1], 9: [2, 2], 0: [3, 1], &#125; left_position = [3, 0] right_position = [3, 2] for key in numbers: if key in left_hands: left_position = key_pad[key] answer += &#x27;L&#x27; elif key in right_hands: right_position = key_pad[key] answer += &#x27;R&#x27; else: # print(key_pad[key][0]) left_dist = abs( left_position[0] - key_pad[key][0]) + abs(left_position[1] - key_pad[key][1]) right_dist = abs( right_position[0] - key_pad[key][0]) + abs(right_position[1] - key_pad[key][1]) if left_dist == right_dist: if hand == &#x27;right&#x27;: right_position = key_pad[key] answer += &quot;R&quot; else: left_position = key_pad[key] answer += &quot;L&quot; elif left_dist &lt; right_dist: left_position = key_pad[key] answer += &#x27;L&#x27; else: right_position = key_pad[key] answer += &#x27;R&#x27; return answer","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 키패드누르기 Cpp 프로그래머스 - 키패드누르기 Python def solution(numbers, hand): answer = &#x27;&#x27; left_hands = [1, 4, 7] right_hands = [3, 6, 9] middle = [2, 5, 8, 0] key_pad = &#123; 1: [0, 0], 2: [0, 1], 3: [0, 2], 4: [1, 0], 5: [1, 1], 6: [1, 2], 7: [2, 0], 8: [2, 1], 9: [2, 2], 0: [3, 1], &#125; left_position = [3, 0] right_position = [3, 2] for key in numbers: if key in left_hands: left_position = key_pad[key] answer += &#x27;L&#x27; elif key in right_hands: right_position = key_pad[key] answer += &#x27;R&#x27; else: # print(key_pad[key][0]) left_dist = abs( left_position[0] - key_pad[key][0]) + abs(left_position[1] - key_pad[key][1]) right_dist = abs( right_position[0] - key_pad[key][0]) + abs(right_position[1] - key_pad[key][1]) if left_dist == right_dist: if hand == &#x27;right&#x27;: right_position = key_pad[key] answer += &quot;R&quot; else: left_position = key_pad[key] answer += &quot;L&quot; elif left_dist &lt; right_dist: left_position = key_pad[key] answer += &#x27;L&#x27; else: right_position = key_pad[key] answer += &#x27;R&#x27; return answer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}],"tags":[]},{"title":"프로그래머스 - 로또의 최고 순위와 최저 순위 Python","slug":"algorithm/programmers/string/77484-로또의최고순위와최저순위-python","date":"2022-01-04T11:10:40.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2022/01/04/algorithm/programmers/string/77484-로또의최고순위와최저순위-python/","link":"","permalink":"https://ckck803.github.io/2022/01/04/algorithm/programmers/string/77484-%EB%A1%9C%EB%98%90%EC%9D%98%EC%B5%9C%EA%B3%A0%EC%88%9C%EC%9C%84%EC%99%80%EC%B5%9C%EC%A0%80%EC%88%9C%EC%9C%84-python/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 로또의 최고 순위와 최저 순위 Cpp 프로그래머스 - 로또의 최고 순위와 최저 순위 Java 프로그래머스 - 로또의 최고 순위와 최저 순위 Python def ranking(cnt): if cnt == 6: return 1 elif cnt == 5: return 2 elif cnt == 4: return 3 elif cnt == 3: return 4 elif cnt == 2: return 5 else: return 6def cmp(lottos, win_nums): answer = [] cnt = 0 zeros = 0 for i in lottos: if i == 0: zeros += 1 elif i in win_nums: cnt += 1 answer.append(ranking(cnt+zeros)) answer.append(ranking(cnt)) return answerdef solution(lottos, win_nums): answer = cmp(lottos, win_nums) return answer","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 로또의 최고 순위와 최저 순위 Cpp 프로그래머스 - 로또의 최고 순위와 최저 순위 Java 프로그래머스 - 로또의 최고 순위와 최저 순위 Python def ranking(cnt): if cnt == 6: return 1 elif cnt == 5: return 2 elif cnt == 4: return 3 elif cnt == 3: return 4 elif cnt == 2: return 5 else: return 6def cmp(lottos, win_nums): answer = [] cnt = 0 zeros = 0 for i in lottos: if i == 0: zeros += 1 elif i in win_nums: cnt += 1 answer.append(ranking(cnt+zeros)) answer.append(ranking(cnt)) return answerdef solution(lottos, win_nums): answer = cmp(lottos, win_nums) return answer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"정규 표현식","slug":"Programming/프로그래머스/문자열/정규-표현식","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/"}],"tags":[]},{"title":"프로그래머스 - 로또의 최고 순위와 최저 순위 Java","slug":"algorithm/programmers/string/77484-로또의최고순위와최저순위-java","date":"2022-01-04T10:10:40.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2022/01/04/algorithm/programmers/string/77484-로또의최고순위와최저순위-java/","link":"","permalink":"https://ckck803.github.io/2022/01/04/algorithm/programmers/string/77484-%EB%A1%9C%EB%98%90%EC%9D%98%EC%B5%9C%EA%B3%A0%EC%88%9C%EC%9C%84%EC%99%80%EC%B5%9C%EC%A0%80%EC%88%9C%EC%9C%84-java/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 로또의 최고 순위와 최저 순위 Cpp 프로그래머스 - 로또의 최고 순위와 최저 순위 Java 프로그래머스 - 로또의 최고 순위와 최저 순위 Python class Solution &#123; private int findScore(int value) &#123; if (value == 6) &#123; return 1; &#125; else if (value == 5) &#123; return 2; &#125; else if (value == 4) &#123; return 3; &#125; else if (value == 3) &#123; return 4; &#125; else if (value == 2) &#123; return 5; &#125; else &#123; return 6; &#125; &#125; private int[] cmpStrings(int[] lottos, int[] win_nums) &#123; int[] result = new int[2]; int length = lottos.length; int zeroCnt = 0; int sameCnt = 0; for (int i = 0; i &lt; length; i++) &#123; if (lottos[i] == 0) &#123; zeroCnt++; continue; &#125; for (int j = 0; j &lt; length; j++) &#123; if (lottos[i] == win_nums[j]) &#123; sameCnt++; &#125; &#125; &#125; result[0] = findScore(sameCnt + zeroCnt); result[1] = findScore(sameCnt); return result; &#125; public int[] solution(int[] lottos, int[] win_nums) &#123; int[] answer = new int[2]; answer = cmpStrings(lottos, win_nums); return answer; &#125;&#125;","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 로또의 최고 순위와 최저 순위 Cpp 프로그래머스 - 로또의 최고 순위와 최저 순위 Java 프로그래머스 - 로또의 최고 순위와 최저 순위 Python class Solution &#123; private int findScore(int value) &#123; if (value == 6) &#123; return 1; &#125; else if (value == 5) &#123; return 2; &#125; else if (value == 4) &#123; return 3; &#125; else if (value == 3) &#123; return 4; &#125; else if (value == 2) &#123; return 5; &#125; else &#123; return 6; &#125; &#125; private int[] cmpStrings(int[] lottos, int[] win_nums) &#123; int[] result = new int[2]; int length = lottos.length; int zeroCnt = 0; int sameCnt = 0; for (int i = 0; i &lt; length; i++) &#123; if (lottos[i] == 0) &#123; zeroCnt++; continue; &#125; for (int j = 0; j &lt; length; j++) &#123; if (lottos[i] == win_nums[j]) &#123; sameCnt++; &#125; &#125; &#125; result[0] = findScore(sameCnt + zeroCnt); result[1] = findScore(sameCnt); return result; &#125; public int[] solution(int[] lottos, int[] win_nums) &#123; int[] answer = new int[2]; answer = cmpStrings(lottos, win_nums); return answer; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"정규 표현식","slug":"Programming/프로그래머스/문자열/정규-표현식","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/"}],"tags":[]},{"title":"프로그래머스 - 로또의 최고 순위와 최저 순위 Cpp","slug":"algorithm/programmers/string/77484-로또의최고순위와최저순위-cpp","date":"2022-01-04T09:10:40.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2022/01/04/algorithm/programmers/string/77484-로또의최고순위와최저순위-cpp/","link":"","permalink":"https://ckck803.github.io/2022/01/04/algorithm/programmers/string/77484-%EB%A1%9C%EB%98%90%EC%9D%98%EC%B5%9C%EA%B3%A0%EC%88%9C%EC%9C%84%EC%99%80%EC%B5%9C%EC%A0%80%EC%88%9C%EC%9C%84-cpp/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 로또의 최고 순위와 최저 순위 Cpp 프로그래머스 - 로또의 최고 순위와 최저 순위 Java 프로그래머스 - 로또의 최고 순위와 최저 순위 Python #include &lt;bits/stdc++.h&gt;using namespace std;int findScore(int value) &#123; if (value == 6) &#123; return 1; &#125; else if (value == 5) &#123; return 2; &#125; else if (value == 4) &#123; return 3; &#125; else if (value == 3) &#123; return 4; &#125; else if (value == 2) &#123; return 5; &#125; else &#123; return 6; &#125;&#125;vector&lt;int&gt; cmpString(vector&lt;int&gt;&amp; lottos, vector&lt;int&gt;&amp; win_nums) &#123; vector&lt;int&gt; result; int zeroCnt = 0; int sameCnt = 0; for (int i = 0; i &lt; 6; i++) &#123; if (lottos[i] == 0) &#123; zeroCnt++; continue; &#125; for (int j = 0; j &lt; 6; j++) &#123; if (lottos[i] == win_nums[j]) &#123; sameCnt++; &#125; &#125; &#125; result.push_back(findScore(sameCnt + zeroCnt)); result.push_back(findScore(sameCnt)); return result;&#125;vector&lt;int&gt; solution(vector&lt;int&gt; lottos, vector&lt;int&gt; win_nums) &#123; vector&lt;int&gt; answer; answer = cmpString(lottos, win_nums); return answer;&#125;","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 로또의 최고 순위와 최저 순위 Cpp 프로그래머스 - 로또의 최고 순위와 최저 순위 Java 프로그래머스 - 로또의 최고 순위와 최저 순위 Python #include &lt;bits/stdc++.h&gt;using namespace std;int findScore(int value) &#123; if (value == 6) &#123; return 1; &#125; else if (value == 5) &#123; return 2; &#125; else if (value == 4) &#123; return 3; &#125; else if (value == 3) &#123; return 4; &#125; else if (value == 2) &#123; return 5; &#125; else &#123; return 6; &#125;&#125;vector&lt;int&gt; cmpString(vector&lt;int&gt;&amp; lottos, vector&lt;int&gt;&amp; win_nums) &#123; vector&lt;int&gt; result; int zeroCnt = 0; int sameCnt = 0; for (int i = 0; i &lt; 6; i++) &#123; if (lottos[i] == 0) &#123; zeroCnt++; continue; &#125; for (int j = 0; j &lt; 6; j++) &#123; if (lottos[i] == win_nums[j]) &#123; sameCnt++; &#125; &#125; &#125; result.push_back(findScore(sameCnt + zeroCnt)); result.push_back(findScore(sameCnt)); return result;&#125;vector&lt;int&gt; solution(vector&lt;int&gt; lottos, vector&lt;int&gt; win_nums) &#123; vector&lt;int&gt; answer; answer = cmpString(lottos, win_nums); return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"정규 표현식","slug":"Programming/프로그래머스/문자열/정규-표현식","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/"}],"tags":[]},{"title":"프로그래머스 - 키패드누르기 Cpp","slug":"algorithm/programmers/string/67256-키패드누르기-cpp","date":"2022-01-03T11:10:40.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2022/01/03/algorithm/programmers/string/67256-키패드누르기-cpp/","link":"","permalink":"https://ckck803.github.io/2022/01/03/algorithm/programmers/string/67256-%ED%82%A4%ED%8C%A8%EB%93%9C%EB%88%84%EB%A5%B4%EA%B8%B0-cpp/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 키패드누르기 Cpp 프로그래머스 - 키패드누르기 Python #include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;bool isLeft(int number) &#123; if (number == 1 || number == 4 || number == 7) &#123; return true; &#125; return false;&#125;bool isRight(int number) &#123; if (number == 3 || number == 6 || number == 9) &#123; return true; &#125; return false;&#125;bool isMiddle(int number) &#123; if (number == 2 || number == 5 || number == 8 || number == 0) &#123; return true; &#125; return false;&#125;string solution(vector&lt;int&gt; numbers, string hand) &#123; string answer = &quot;&quot;; map&lt;int, pair&lt;int, int&gt;&gt; keypad; keypad[1] = &#123;0, 0&#125;, keypad[2] = &#123;0, 1&#125;, keypad[3] = &#123;0, 2&#125;; keypad[4] = &#123;1, 0&#125;, keypad[5] = &#123;1, 1&#125;, keypad[6] = &#123;1, 2&#125;; keypad[7] = &#123;2, 0&#125;, keypad[8] = &#123;2, 1&#125;, keypad[9] = &#123;2, 2&#125;; keypad[0] = &#123;3, 1&#125;; pair&lt;int, int&gt; left_point = &#123;3, 0&#125;; pair&lt;int, int&gt; right_point = &#123;3, 2&#125;; cout &lt;&lt; keypad[2].first &lt;&lt; &quot; &quot; &lt;&lt; keypad[2].second &lt;&lt; endl; for (int number : numbers) &#123; if (isLeft(number)) &#123; left_point = keypad[number]; answer.append(&quot;L&quot;); &#125; if (isRight(number)) &#123; right_point = keypad[number]; answer.append(&quot;R&quot;); &#125; if (isMiddle(number)) &#123; pair&lt;int, int&gt; key_point = keypad[number]; int left_dist = abs(key_point.first - left_point.first) + abs(key_point.second - left_point.second); int right_dist = abs(key_point.first - right_point.first) + abs(key_point.second - right_point.second); if (left_dist == right_dist) &#123; if (hand == &quot;right&quot;) &#123; right_point = keypad[number]; answer.append(&quot;R&quot;); &#125; else &#123; left_point = keypad[number]; answer.append(&quot;L&quot;); &#125; &#125; else if (left_dist &lt; right_dist) &#123; left_point = keypad[number]; answer.append(&quot;L&quot;); &#125; else &#123; right_point = keypad[number]; answer.append(&quot;R&quot;); &#125; &#125; &#125; return answer;&#125;","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/77484 프로그래머스 - 키패드누르기 Cpp 프로그래머스 - 키패드누르기 Python #include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;bool isLeft(int number) &#123; if (number == 1 || number == 4 || number == 7) &#123; return true; &#125; return false;&#125;bool isRight(int number) &#123; if (number == 3 || number == 6 || number == 9) &#123; return true; &#125; return false;&#125;bool isMiddle(int number) &#123; if (number == 2 || number == 5 || number == 8 || number == 0) &#123; return true; &#125; return false;&#125;string solution(vector&lt;int&gt; numbers, string hand) &#123; string answer = &quot;&quot;; map&lt;int, pair&lt;int, int&gt;&gt; keypad; keypad[1] = &#123;0, 0&#125;, keypad[2] = &#123;0, 1&#125;, keypad[3] = &#123;0, 2&#125;; keypad[4] = &#123;1, 0&#125;, keypad[5] = &#123;1, 1&#125;, keypad[6] = &#123;1, 2&#125;; keypad[7] = &#123;2, 0&#125;, keypad[8] = &#123;2, 1&#125;, keypad[9] = &#123;2, 2&#125;; keypad[0] = &#123;3, 1&#125;; pair&lt;int, int&gt; left_point = &#123;3, 0&#125;; pair&lt;int, int&gt; right_point = &#123;3, 2&#125;; cout &lt;&lt; keypad[2].first &lt;&lt; &quot; &quot; &lt;&lt; keypad[2].second &lt;&lt; endl; for (int number : numbers) &#123; if (isLeft(number)) &#123; left_point = keypad[number]; answer.append(&quot;L&quot;); &#125; if (isRight(number)) &#123; right_point = keypad[number]; answer.append(&quot;R&quot;); &#125; if (isMiddle(number)) &#123; pair&lt;int, int&gt; key_point = keypad[number]; int left_dist = abs(key_point.first - left_point.first) + abs(key_point.second - left_point.second); int right_dist = abs(key_point.first - right_point.first) + abs(key_point.second - right_point.second); if (left_dist == right_dist) &#123; if (hand == &quot;right&quot;) &#123; right_point = keypad[number]; answer.append(&quot;R&quot;); &#125; else &#123; left_point = keypad[number]; answer.append(&quot;L&quot;); &#125; &#125; else if (left_dist &lt; right_dist) &#123; left_point = keypad[number]; answer.append(&quot;L&quot;); &#125; else &#123; right_point = keypad[number]; answer.append(&quot;R&quot;); &#125; &#125; &#125; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}],"tags":[]},{"title":"Redux Saga","slug":"react/redux/redux-04-saga","date":"2022-01-01T05:31:46.000Z","updated":"2024-11-23T16:46:05.284Z","comments":true,"path":"2022/01/01/react/redux/redux-04-saga/","link":"","permalink":"https://ckck803.github.io/2022/01/01/react/redux/redux-04-saga/","excerpt":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 Redux Saga 액션을 모니터링하고 있다가 특정 Action 이 발생하면 특정 작업을 진행한다. 비동기 작업을 진행할 때 기존 요청을 취소 할 수 있다. 특정 Action 이 발생했을 때 다른 액션을 디스패치 하거나 자바스크립트 코드를 실행할 수 있다. Generator 에 기반한 미들웨어 Generator 함수의 흐름을 특정 구간에 멈춰 놨다가 다시 실행 할 수 있다.return 값을 여러번 보낼 수 있다. import &#123; delay, put, takeEvery, takeLatest &#125; from &quot;redux-saga/effects&quot;;const SET_DIFF = &quot;counter/SET_DIFF&quot;;const INCREASE = &quot;counter/INCREASE&quot;;const DECREASE = &quot;counter/DECREASE&quot;;const INCREASE_ASYNC = &quot;NCREASE_ASYNC&quot;;const DECREASE_ASYNC = &quot;DECREASE_ASYNC&quot;;export const setDiff = (diff) =&gt; (&#123; type: SET_DIFF, diff &#125;);export const increase = () =&gt; (&#123; type: INCREASE &#125;);export const decrease = () =&gt; (&#123; type: DECREASE &#125;);export const increaseAsync = () =&gt; (&#123; type: INCREASE_ASYNC &#125;);export const decreaseAsync = () =&gt; (&#123; type: DECREASE_ASYNC &#125;);function* increaseSaga() &#123; yield delay(1000); yield put(increase()); // put 은 dispatch 와 비슷한 개념&#125;function* decreaseSaga() &#123; yield delay(1000); yield put(decrease());&#125;export function* counterSaga() &#123; yield takeEvery(INCREASE_ASYNC, increaseSaga); yield takeLatest(DECREASE_ASYNC, decreaseSaga);&#125;const initialState = &#123; number: 0, diff: 1,&#125;;export default function counter(state = initialState, action) &#123; switch (action.type) &#123; case SET_DIFF: return &#123; ...state, diff: action.diff, &#125;; case INCREASE: return &#123; ...state, number: state.number + state.diff, &#125;; case DECREASE: return &#123; ...state, number: state.number - state.diff, &#125;; default: return state; &#125;&#125; import React from &quot;react&quot;;import &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import Counter from &quot;./Counter&quot;;import &#123; increase, decrease, setDiff, increaseAsync, decreaseAsync,&#125; from &quot;../modules/counter&quot;;const CounterContainer = () =&gt; &#123; const &#123; number, diff &#125; = useSelector((state) =&gt; (&#123; number: state.counter.number, &#125;)); const dispatch = useDispatch(); // const onIncrease = () =&gt; dispatch(increase()); // const onDecrease = () =&gt; dispatch(decrease()); const onIncrease = () =&gt; dispatch(increaseAsync()); const onDecrease = () =&gt; dispatch(decreaseAsync()); const onSetDiff = (diff) =&gt; dispatch(setDiff(diff)); return ( &lt;Counter number=&#123;number&#125; diff=&#123;diff&#125; onIncrease=&#123;onIncrease&#125; onDecrease=&#123;onDecrease&#125; onSetDiff=&#123;onSetDiff&#125; /&gt; );&#125;;export default CounterContainer;","text":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 Redux Saga 액션을 모니터링하고 있다가 특정 Action 이 발생하면 특정 작업을 진행한다. 비동기 작업을 진행할 때 기존 요청을 취소 할 수 있다. 특정 Action 이 발생했을 때 다른 액션을 디스패치 하거나 자바스크립트 코드를 실행할 수 있다. Generator 에 기반한 미들웨어 Generator 함수의 흐름을 특정 구간에 멈춰 놨다가 다시 실행 할 수 있다.return 값을 여러번 보낼 수 있다. import &#123; delay, put, takeEvery, takeLatest &#125; from &quot;redux-saga/effects&quot;;const SET_DIFF = &quot;counter/SET_DIFF&quot;;const INCREASE = &quot;counter/INCREASE&quot;;const DECREASE = &quot;counter/DECREASE&quot;;const INCREASE_ASYNC = &quot;NCREASE_ASYNC&quot;;const DECREASE_ASYNC = &quot;DECREASE_ASYNC&quot;;export const setDiff = (diff) =&gt; (&#123; type: SET_DIFF, diff &#125;);export const increase = () =&gt; (&#123; type: INCREASE &#125;);export const decrease = () =&gt; (&#123; type: DECREASE &#125;);export const increaseAsync = () =&gt; (&#123; type: INCREASE_ASYNC &#125;);export const decreaseAsync = () =&gt; (&#123; type: DECREASE_ASYNC &#125;);function* increaseSaga() &#123; yield delay(1000); yield put(increase()); // put 은 dispatch 와 비슷한 개념&#125;function* decreaseSaga() &#123; yield delay(1000); yield put(decrease());&#125;export function* counterSaga() &#123; yield takeEvery(INCREASE_ASYNC, increaseSaga); yield takeLatest(DECREASE_ASYNC, decreaseSaga);&#125;const initialState = &#123; number: 0, diff: 1,&#125;;export default function counter(state = initialState, action) &#123; switch (action.type) &#123; case SET_DIFF: return &#123; ...state, diff: action.diff, &#125;; case INCREASE: return &#123; ...state, number: state.number + state.diff, &#125;; case DECREASE: return &#123; ...state, number: state.number - state.diff, &#125;; default: return state; &#125;&#125; import React from &quot;react&quot;;import &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import Counter from &quot;./Counter&quot;;import &#123; increase, decrease, setDiff, increaseAsync, decreaseAsync,&#125; from &quot;../modules/counter&quot;;const CounterContainer = () =&gt; &#123; const &#123; number, diff &#125; = useSelector((state) =&gt; (&#123; number: state.counter.number, &#125;)); const dispatch = useDispatch(); // const onIncrease = () =&gt; dispatch(increase()); // const onDecrease = () =&gt; dispatch(decrease()); const onIncrease = () =&gt; dispatch(increaseAsync()); const onDecrease = () =&gt; dispatch(decreaseAsync()); const onSetDiff = (diff) =&gt; dispatch(setDiff(diff)); return ( &lt;Counter number=&#123;number&#125; diff=&#123;diff&#125; onIncrease=&#123;onIncrease&#125; onDecrease=&#123;onDecrease&#125; onSetDiff=&#123;onSetDiff&#125; /&gt; );&#125;;export default CounterContainer; import &#123; combineReducers &#125; from &quot;redux&quot;;import counter, &#123; counterSaga &#125; from &quot;./counter&quot;;import todos from &quot;./todos&quot;;import &#123; all &#125; from &quot;redux-saga/effects&quot;;const rootReducer = combineReducers(&#123; counter, todos,&#125;);export function* rootSaga() &#123; yield all([counterSaga()]); // all 은 배열 안의 여러 사가를 동시에 실행시켜줍니다.&#125;export default rootReducer; import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import rootReducer, &#123; rootSaga &#125; from &#x27;./modules&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;import myLogger from &#x27;./middlewares/myLogger&#x27;;import createSagaMiddleware from &#x27;redux-saga&#x27;;const sagaMiddleware = createSagaMiddleware();const store = createStore(rootReducer, applyMiddleware(sagaMiddleware, myLogger));sagaMiddleware.run(rootSaga);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&#x27;root&#x27;));reportWebVitals();","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Redux","slug":"Frontend/Redux","permalink":"https://ckck803.github.io/categories/Frontend/Redux/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"Redux Middleware 만들기","slug":"react/redux/redux-03-middleware","date":"2021-12-31T21:31:46.000Z","updated":"2024-11-23T16:46:05.211Z","comments":true,"path":"2022/01/01/react/redux/redux-03-middleware/","link":"","permalink":"https://ckck803.github.io/2022/01/01/react/redux/redux-03-middleware/","excerpt":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 Redux Middleware 만들기Middleware 생성Dispatch 되는 이력을 콘솔로 찍는 로거를 만든다. const myLogger = store =&gt; next =&gt; action =&gt; &#123; console.log(action); const result = next(action); // 반환하는 result 는 Container 에서 Disaptch 됐을 때 결과 물이 result return result;&#125;export default myLogger; Middleware 적용applyMiddleware 함수를 이용해 Redux 에 미들웨어를 적용한다. import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import rootReducer from &#x27;./modules&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;import myLogger from &#x27;./middlewares/myLogger&#x27;;const store = createStore(rootReducer, applyMiddleware(myLogger));ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&#x27;root&#x27;));reportWebVitals();","text":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 Redux Middleware 만들기Middleware 생성Dispatch 되는 이력을 콘솔로 찍는 로거를 만든다. const myLogger = store =&gt; next =&gt; action =&gt; &#123; console.log(action); const result = next(action); // 반환하는 result 는 Container 에서 Disaptch 됐을 때 결과 물이 result return result;&#125;export default myLogger; Middleware 적용applyMiddleware 함수를 이용해 Redux 에 미들웨어를 적용한다. import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import rootReducer from &#x27;./modules&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;import myLogger from &#x27;./middlewares/myLogger&#x27;;const store = createStore(rootReducer, applyMiddleware(myLogger));ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&#x27;root&#x27;));reportWebVitals();","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Redux","slug":"Frontend/Redux","permalink":"https://ckck803.github.io/categories/Frontend/Redux/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"네트워크 - HTTP 메시지 구조","slug":"computer-science/network/http/http-message","date":"2021-12-27T14:16:32.000Z","updated":"2024-02-18T16:19:54.518Z","comments":true,"path":"2021/12/27/computer-science/network/http/http-message/","link":"","permalink":"https://ckck803.github.io/2021/12/27/computer-science/network/http/http-message/","excerpt":"네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp HTTP 메시지 구조 HyperText Transfer Protocol 의 약자로 HTML 문서를 전송하기 위해 만들어진 규약조건이다.HTTP는 TCP&#x2F;IP 기반으로 되어있다. HTTP 통신 방식HTTP는 기본적으로 요청&#x2F;응답 구조 Client 요청 MessageJson 데이터 curl –http1.1 http://localhost:8888/greeting -v -H “Content-Type: application&#x2F;json” -d ‘{“hello”:”json”}’ POST /greeting HTTP/1.1Host: localhost:8888Accept: */*Content-Length: 16Content-Type: application/jsonUser-Agent: curl/7.71.1&#123;&quot;hello&quot;:&quot;json&quot;&#125;","text":"네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp HTTP 메시지 구조 HyperText Transfer Protocol 의 약자로 HTML 문서를 전송하기 위해 만들어진 규약조건이다.HTTP는 TCP&#x2F;IP 기반으로 되어있다. HTTP 통신 방식HTTP는 기본적으로 요청&#x2F;응답 구조 Client 요청 MessageJson 데이터 curl –http1.1 http://localhost:8888/greeting -v -H “Content-Type: application&#x2F;json” -d ‘{“hello”:”json”}’ POST /greeting HTTP/1.1Host: localhost:8888Accept: */*Content-Length: 16Content-Type: application/jsonUser-Agent: curl/7.71.1&#123;&quot;hello&quot;:&quot;json&quot;&#125; Multipart Form 데이터 curl –http1.1 http://localhost:8888/greeting -v -F ‘file&#x3D;&#x2F;Users&#x2F;dongwoo-yang&#x2F;Desktop&#x2F;alliance-point.png’ POST /greeting HTTP/1.1Host: localhost:8888Accept: */*Content-Length: 185Content-Type: multipart/form-data; boundary=------------------------d3aa01d8dc675444User-Agent: curl/7.71.1--------------------------d3aa01d8dc675444Content-Disposition: form-data; name=&quot;file&quot;/Users/dongwoo-yang/Desktop/alliance-point.png--------------------------d3aa01d8dc675444-- Server 응답 messageHTTP/1.1 200 OKDate: Wed, 05 Jan 2022 03:04:44 GMTContent-Length: 32Content-Type: text/html; charset=utf-8&lt;html&gt;&lt;body&gt;Hello&lt;/body&gt;&lt;/html&gt; HTTP Request 구조 Start Line Header Body Start LinePOST /greeting HTTP/1.1 Http Method request가 의도한 action을 정의하는 부분 Http Method 종류는 GET , POST , PUT , DELETE , PATCH , OPTIONS 등등이 있다. Request Target Http 요청이 전송되는 주소(URI) Controller (Handler) 주소라고 생각하면 된다. HTTP Version HTTP Version을 명시한다. 1.1을 가장 많이 사용하고 1.0 , 1.1 , 2.0 , 3.0 이 있다. Header Key:Value 형태로 구성돼 있다. Host: localhost:8888Accept: */*Content-Length: 16Content-Type: application/jsonUser-Agent: curl/7.71.1 Content-Type 파일의 종류를 지정 보통은 MIME 타입(전자 메일을 위해 만들어진 식별자)이라는 식별자를 기술 Content-Length 바디의 크기 압축이 이루어지는 경우는 압축 후의 크기 Content-Encoding 압축이 이루어진 경우 압축 형식을 설명한다. User-Agent 클라이언트가 자신의 애플리케이션 이름을 넣는 곳 브라우저의 종류나 버전을 구분할 수 있다. Body 헤더 끝에 빈 줄 을 넣으면 그 이후는 모두 바디가 된다. Host: localhost:8888Accept: */*Content-Length: 185Content-Type: multipart/form-data; boundary=------------------------d3aa01d8dc675444User-Agent: curl/7.71.1 --------------------------d3aa01d8dc675444Content-Disposition: form-data; name=&quot;file&quot;/Users/dongwoo-yang/Desktop/alliance-point.png--------------------------d3aa01d8dc675444--","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"HTTP","slug":"CS/Network/HTTP","permalink":"https://ckck803.github.io/categories/CS/Network/HTTP/"}],"tags":[]},{"title":"네트워크 - HTTP Version","slug":"computer-science/network/http/http-version","date":"2021-12-27T14:16:32.000Z","updated":"2024-02-18T16:19:54.518Z","comments":true,"path":"2021/12/27/computer-science/network/http/http-version/","link":"","permalink":"https://ckck803.github.io/2021/12/27/computer-science/network/http/http-version/","excerpt":"HTTP Version 네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp HTTP&#x2F;0.9 간단하게 HTML 객체 를 받아오기 위해 만들어진 프로토콜이다. 때문에 GET메서드 만을 지원한다. 멀티미디어 콘텐츠에 대한 MIME 타입이나, HTTP 해더, 버전 번호는 지원하지 않는다. HTTP&#x2F;1.0 버전 번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리를 추가했다. 웹페이지와 상호작용하는 폼을 실현 하나의 커넥션에 하나의 요청과 하나의 응답만 가능 요청GET /greeting HTTP/1.0Host: localhost:18888Connection: closeAccept: */*User-Agent: curl/7.71.1 응답","text":"HTTP Version 네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp HTTP&#x2F;0.9 간단하게 HTML 객체 를 받아오기 위해 만들어진 프로토콜이다. 때문에 GET메서드 만을 지원한다. 멀티미디어 콘텐츠에 대한 MIME 타입이나, HTTP 해더, 버전 번호는 지원하지 않는다. HTTP&#x2F;1.0 버전 번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리를 추가했다. 웹페이지와 상호작용하는 폼을 실현 하나의 커넥션에 하나의 요청과 하나의 응답만 가능 요청GET /greeting HTTP/1.0Host: localhost:18888Connection: closeAccept: */*User-Agent: curl/7.71.1 응답HTTP/1.0 200 OKDate: Tue, 04 Jan 2022 16:48:00 GMTContent-Length: 32Content-Type: text/html; charset=utf-8 HTTP&#x2F;1.0+ keep-alive 커넥션 가상 호스팅 지원 프록시 연결 요청마다 connection을 해줘야 한다. HTTP&#x2F;1.1 HTTP 의 첫번째 표준 버전 HTTP&#x2F;1.1은 HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화 잘못된 기능제거에 집중 Persistent Connection 도입 파이프 라이닝 기법 도입 Head Of Line Blocking 문제가 있음 domain sharing 방식 PipeLining 기법 하나의 커넥션에 다수의 Request 와 Response 를 받을 수 있는 기법 Head Of Line Blocking 앞선 요청에 대한 처리가 늦어지면 다음 요청들에 대한 처리들도 다 늦어진다. HTTP&#x2F;2.0 기존 HTTP 를 개선 및 성능 향상에 초점을 맞춘 프로토콜 HTTP&#x2F;1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행중인 프로토콜 멀티플렉싱 을 통해 latency를 줄이고 해더 압축을 통해 중복된 해더 값을 없애 Overhead를 최소화 (허프만 인코딩 사용) 서버 푸시 기능을 지원한다. Client 가 요청하지 않은 자원을 서버에서 보내준다. HTTP&#x2F;2.0 프로토콜과 HTTP&#x2F;1.1의 차이점 HTTP&#x2F;1.1은 기본적으로 Connection당 하나의 요청을 처리하도록 설계 동시 전송이 불가능하고 요청과 응답이 순차적으로 이루어진다. HTTP 문서 안에 포함된 다수의 리소스를 처리하려면 요청할 리소스 개수에 비래해 레이턴시가 길어진다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"HTTP","slug":"CS/Network/HTTP","permalink":"https://ckck803.github.io/categories/CS/Network/HTTP/"}],"tags":[]},{"title":"네트워크 - HTTPS","slug":"computer-science/network/http/https","date":"2021-12-27T14:16:32.000Z","updated":"2024-02-18T16:19:54.518Z","comments":true,"path":"2021/12/27/computer-science/network/http/https/","link":"","permalink":"https://ckck803.github.io/2021/12/27/computer-science/network/http/https/","excerpt":"네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp 네트워크 - HTTPSHTTPS의 마지막 S는 Over Secure Socket Layer의 약자로 보안이 강화된 HTTP라는 것을 알 수 있다. SSL&#x2F;TLS 에서 HTTP 가 작동할 경우 HTTPS 라고 부른다. HTTPS 와 SSL 이 같은 것이 아닌 SSL 위에 올라가는 프로토콜 중 하나가 바로 HTTPS 다. 암호화 이점 기밀성의 원칙 에서 보면 통신 내용이 공격자에게 노출(snipping) 되는 것을 막을 수 있다. 무결성의 원칙 에서 보면 통신 내용을 타인이 함부로 변경 하는 것을 막을 수 있다. 기밀성의 원칙과 무결성의 원칙을 통해 서버와 클라이언트는 서로 신뢰를 할 수 있다. SSL (Secure Socket Layer)-","text":"네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp 네트워크 - HTTPSHTTPS의 마지막 S는 Over Secure Socket Layer의 약자로 보안이 강화된 HTTP라는 것을 알 수 있다. SSL&#x2F;TLS 에서 HTTP 가 작동할 경우 HTTPS 라고 부른다. HTTPS 와 SSL 이 같은 것이 아닌 SSL 위에 올라가는 프로토콜 중 하나가 바로 HTTPS 다. 암호화 이점 기밀성의 원칙 에서 보면 통신 내용이 공격자에게 노출(snipping) 되는 것을 막을 수 있다. 무결성의 원칙 에서 보면 통신 내용을 타인이 함부로 변경 하는 것을 막을 수 있다. 기밀성의 원칙과 무결성의 원칙을 통해 서버와 클라이언트는 서로 신뢰를 할 수 있다. SSL (Secure Socket Layer)- SSL은 원래 Netscape에서 웹 서버와 브라우저 사이의 보안을 위해 만들어진 프로토콜이다. 인증서를 이용해 사용자와 서버를 인증하는데 사용한다. TLS (Transport Layer Secure)네스케이프사에서 발명된 SSL이 국제 인터넷 표준화 기구인 IETF의 관리로 변경되면서 TLS(Transport Layer Secure)로 이름이 바뀌었다. 때문에 SSL 3.0은 TLS 1.0을 계승한다. SSL의 암호화 방식 대칭키 공개키 대칭키 문서를 암호화 복호화 할 때 같은 키를 사용한다. 공개키 문서를 암호화 복호화 하는데 다른키를 사용한다. Private Key 로 암호화된 문서는 Public Key 로만 복호화할 수 있다. 반대로 Public Key 로 암호화된 문서는 Private Key 로만 복호화할 수 있다. 인증서의 역할 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다. SSL 통신에 사용할 공개키를 클라이언트에게 제공한다. CA(인증서)CA안에는 서비스의 정보와 서버 측 공개키가 들어가 있다.서비스 정보를 통해 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지에 대한 내용을 담고 있고, 서버 측 공개키를 통해 서버와 통신을 할 때 사용할 공개키와 그 공개키의 암호화 방법들의 정보를 담고 있다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"HTTP","slug":"CS/Network/HTTP","permalink":"https://ckck803.github.io/categories/CS/Network/HTTP/"}],"tags":[]},{"title":"네트워크 - HTTP","slug":"computer-science/network/http/http","date":"2021-12-27T03:16:32.000Z","updated":"2024-02-18T16:19:54.518Z","comments":true,"path":"2021/12/27/computer-science/network/http/http/","link":"","permalink":"https://ckck803.github.io/2021/12/27/computer-science/network/http/http/","excerpt":"네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp HTTP란 HyperText Transfer Protocol 의 약자로 HTML 문서를 전송하기 위해 만들어진 규약조건이다.HTTP는 TCP&#x2F;IP 기반으로 되어있다. Client - Server 구조 Stateless (무상태) 프로토콜 비 연결성 Client - Server 구조 클라이언트는 서버에 요청을 보내고 서버로부터 응답을 기다리는 단방향 통신 구조 Request Response 구조 Stateless (무상태) 프로토콜","text":"네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp HTTP란 HyperText Transfer Protocol 의 약자로 HTML 문서를 전송하기 위해 만들어진 규약조건이다.HTTP는 TCP&#x2F;IP 기반으로 되어있다. Client - Server 구조 Stateless (무상태) 프로토콜 비 연결성 Client - Server 구조 클라이언트는 서버에 요청을 보내고 서버로부터 응답을 기다리는 단방향 통신 구조 Request Response 구조 Stateless (무상태) 프로토콜 Server 에서 Client 의 상태 를 관리하지 않는다. 상태를 유지하는 방법으로 쿠키 , 세션 , 토큰 을 사용하는 방법들이 있다. 쿠키 : Client Side 에 상태를 저장 세션 : Server Side 에 상태를 저장 Token : Client Side 에 상태를 저장, 저장하는 데이터는 암호화 를 통해 안전하게 저장되고 서명 을 이용해 유효성을 입증한다. 비 연결성 클라이언트와 서버가 연결을 맺은 후, 요청에 대한 응답을 완료하면 연결을 끊는 성질 연결&#x2F;해제하는 오버해드 가 발생한다. HTTP Keep-Alive 속성을 이용해 해결할 수 있다. Keep Alive Connection: Keep-AliveKeep-Alive: max&#x3D;5, timeout&#x3D;120 HTTP&#x2F;1.1 부터 지원하는 기능 요청에 Connection: Keep-Alive 헤더를 포함시킨다. 지정된 시간 동안 클라이언트와 서버간의 Connection 을 유지한다. timeout : Connection 을 유지할 시간을 명시 max : Connection 을 유지할 HTTP 요청을 개수를 명시","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"HTTP","slug":"CS/Network/HTTP","permalink":"https://ckck803.github.io/categories/CS/Network/HTTP/"}],"tags":[]},{"title":"네트워크 - OSI 7 계층과 TCP/IP 5계층","slug":"computer-science/network/http/oci7-tcpip5","date":"2021-12-27T03:16:32.000Z","updated":"2024-02-18T16:19:54.519Z","comments":true,"path":"2021/12/27/computer-science/network/http/oci7-tcpip5/","link":"","permalink":"https://ckck803.github.io/2021/12/27/computer-science/network/http/oci7-tcpip5/","excerpt":"네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp 네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 OCI 7 계층 다양한 컴퓨터 시스템이 표준 프로토콜을 사용하여 통신할 수 있도록 국제 표준화 기구(ISO) 에서 만든 개념 모델이다. OSI 표준 모형은 7계층으로 이루어져 있다. 계층별로 역할을 분리해서 각 계층이 독립적으로 기능을 수행하고, 계층 간 통신을 통해 전체 통신 프로세스를 가능하게 한다. TCP&#x2F;IP 5 계층 프로토콜 프로토콜 : source와 target간의 데이터를 어떻게 주고 받을 지에 대한 규약(방법)이다. 크게는 동기식 과 비동기식 으로 나뉘게 된다.","text":"네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 네트워크 - HTTP 네트워크 - HTTP Version 네트워크 - HTTP 메시지 구조 네트워크 - HTTPS Post not found: computer-science/network/tcp 네트워크 - OSI 7 계층과 TCP&#x2F;IP 5계층 OCI 7 계층 다양한 컴퓨터 시스템이 표준 프로토콜을 사용하여 통신할 수 있도록 국제 표준화 기구(ISO) 에서 만든 개념 모델이다. OSI 표준 모형은 7계층으로 이루어져 있다. 계층별로 역할을 분리해서 각 계층이 독립적으로 기능을 수행하고, 계층 간 통신을 통해 전체 통신 프로세스를 가능하게 한다. TCP&#x2F;IP 5 계층 프로토콜 프로토콜 : source와 target간의 데이터를 어떻게 주고 받을 지에 대한 규약(방법)이다. 크게는 동기식 과 비동기식 으로 나뉘게 된다. L1 - Physical Layer (물리 계층) 데이터 단위 : Bit 물리적인 통신채널 을 통해 bit 신호를 주고 받는다. 대표적인 장비 : 리피터 L2 - Data Link Layer (데이터 링크 계층) MAC (Media Access Control) 주소 사용 LAN (Local Area Network) 통신에 사용되는 주소 스위치간 통신을 위해 사용되는 주소 데이터 단위 : Frame (프레임) 대표 장비 : Switch (스위치) 네트워크에 연결된 컴퓨터들 간 충돌없이 통신하기 위한 방법 을 정의한다. Forwarding&#x2F;Filtering 방식으로 통신해 목적지로만 데이터를 보낸다. Forwarding : MAC 테이블에 일치하는 주소로 데이터를 보낸다. Filtering : 일치하지 않는 주소로는 데이터를 보내지 않는다. L3 - Network Layer (네트워크 계층) Routing 테이블을 이용해 Packet 을 출발지에서 목적지로의 경로를 설정한다. IP (Internet Protocol) 를 이용해 통신한다. WAN (Wide Area Network) 통신에 사용되는 주소 서로 다른 LAN 에 속한 장비들끼리 통신할 수 있게 해준다. 현재는 IPv4, IPv6 의 두가지 주소 체계를 가지고 있다. 데이터 단위 : Packet (패킷) 대표 장비 : Router Routing 과 Forwarding 을 이용해 Packet 을 목적지 IP 까지 전송한다. Routing : 출발지에서 목적지까지 경로를 설정하는 것 Forwarding : Router 의 입력포트에서 출력포트로 Packet 을 이동시키는 것 L4 - Transport Layer (전송 계층) Port Number 를 이용해 통신한다 (1 ~ 65535) 범위의 값을 갖는다. 해당 Port 번호를 이용해 목적지 프로세스 까지 데이터를 전달한다. 종단간 전송 (End To End) 을 보장한다. TCP&#x2F;UDP 통신이 있다. 대표 장비 : Firewall, Load Balancer TCP UDP 데이터 단위 Segment Datagram 연결 방식 연결 지향 서비스 비연결 흐름 제어 &amp; 혼잡 제어 지원 미지원 속도 느리다 빠르다 통신 방식 1:1 통신 1:1, 1:N, N:M 통신 지원 L5 - Application Layer (응용 계층) 데이터 단위 : Message 프로토콜 : HTTP, FTP, SMTP, SSH","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"HTTP","slug":"CS/Network/HTTP","permalink":"https://ckck803.github.io/categories/CS/Network/HTTP/"}],"tags":[]},{"title":"Spring - Embeded Redis 사용하기","slug":"spring/spring-redis/springboot-redis","date":"2021-12-23T14:47:05.000Z","updated":"2024-02-26T16:10:27.519Z","comments":true,"path":"2021/12/23/spring/spring-redis/springboot-redis/","link":"","permalink":"https://ckck803.github.io/2021/12/23/spring/spring-redis/springboot-redis/","excerpt":"Spring Boot - Embeded Redis 사용하기보통 Redis를 사용하는 스프링 프로젝트를 Local에서 프로젝트 실행시 Redis를 선행적으로 설치해줘야 한다. 이 문제를 Embedded Redis를 사용해 프로젝트가 Local 환경에 의존적이지 않고 프로젝트 만으로 구동할 수 있도록 한다. 의존build.gradle implementation &#x27;org.springframework.boot:spring-boot-starter-data-redis&#x27;//embedded-rediscompile group: &#x27;it.ozimov&#x27;, name: &#x27;embedded-redis&#x27;, version: &#x27;0.7.2&#x27;&#125; application.yml spring: redis: host: localhost port: 6379 profiles: active: local local에서 프로젝트를 진행하기 위한 설정이다. Profile 어노테이션을 통해 -Dspring.profiles.active&#x3D;local 옵션이 주어졌을 때 해당 설정을 사용할 수 있다 EmbeddedRedisConfig","text":"Spring Boot - Embeded Redis 사용하기보통 Redis를 사용하는 스프링 프로젝트를 Local에서 프로젝트 실행시 Redis를 선행적으로 설치해줘야 한다. 이 문제를 Embedded Redis를 사용해 프로젝트가 Local 환경에 의존적이지 않고 프로젝트 만으로 구동할 수 있도록 한다. 의존build.gradle implementation &#x27;org.springframework.boot:spring-boot-starter-data-redis&#x27;//embedded-rediscompile group: &#x27;it.ozimov&#x27;, name: &#x27;embedded-redis&#x27;, version: &#x27;0.7.2&#x27;&#125; application.yml spring: redis: host: localhost port: 6379 profiles: active: local local에서 프로젝트를 진행하기 위한 설정이다. Profile 어노테이션을 통해 -Dspring.profiles.active&#x3D;local 옵션이 주어졌을 때 해당 설정을 사용할 수 있다 EmbeddedRedisConfig @Slf4j@Profile(&quot;local&quot;)@Configurationpublic class EmbeddedRedisConfig &#123; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private int redisPort; private RedisServer redisServer; @PostConstruct public void redisServer() throws IOException &#123; redisServer = new RedisServer(redisPort); redisServer.start(); &#125; @PreDestroy public void stopRedis()&#123; if(redisServer != null)&#123; redisServer.stop(); &#125; &#125;&#125; Redis 사용 설정하기RedisConnectionFactory 를 구현한 LettuceConnectionFactory 를 이용해 Redis와 연결을 위한 설정 정보를 기입한다. RedisTemplate 객체와 Redis에 저장된 Binary데이터사이에 Serialize, Deserialize 해주는 Helper Class RedisRepositoryConfig @Configuration@EnableRedisRepositoriespublic class RedisRepositoryConfig &#123; @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String redisHost; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private int redisPort; @Bean public RedisConnectionFactory redisConnectionFactory()&#123; return new LettuceConnectionFactory(redisHost, redisPort); &#125; @Bean public RedisTemplate&lt;?, ?&gt; redisTemplate()&#123; RedisTemplate&lt;byte[], byte[]&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory()); return redisTemplate; &#125;&#125; @SpringBootTestpublic class RedisTest &#123; @Autowired private PointRedisRepository pointRedisRepository; @AfterEach public void tearDown() throws Exception &#123; pointRedisRepository.deleteAll(); &#125; @Test @DisplayName(&quot;기본 등록 조회 기능&quot;) public void retrieve()&#123; String id = &quot;dongwoo&quot;; LocalDateTime refreshTime = LocalDateTime.of(2021,3,16,0,0); Point point = Point.builder() .id(id) .amount(1000L) .refreshTime(refreshTime) .build(); pointRedisRepository.save(point); Point savedPoint = pointRedisRepository.findById(id).get(); assertThat(savedPoint.getAmount()).isEqualTo(1000L); assertThat(savedPoint.getRefreshTime()).isEqualTo(refreshTime); &#125; @Test @DisplayName(&quot;수정 기능&quot;) public void revise()&#123; String id = &quot;dongwoo&quot;; LocalDateTime refreshTime = LocalDateTime.of(2021,3,16,0,0); pointRedisRepository.save(Point.builder() .id(id) .amount(1000L) .refreshTime(refreshTime) .build()); Point savedPoint = pointRedisRepository.findById(id).get(); savedPoint.refresh(2000L, LocalDateTime.of(2021,3,17,0,0)); pointRedisRepository.save(savedPoint); Point refreshPoint = pointRedisRepository.findById(id).get(); assertThat(refreshPoint.getAmount()).isEqualTo(2000L); &#125;&#125; @Slf4j@Profile(&quot;local&quot;)@Configurationpublic class EmbeddedRedisConfig &#123; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private int redisPort; private RedisServer redisServer; @PostConstruct public void redisServer() throws IOException &#123; int port = isRedisRunning() ? findAvailablePort() : redisPort; redisServer = new RedisServer(port); redisServer.start(); &#125; @PreDestroy public void stopRedis() &#123; if (redisServer != null) &#123; redisServer.stop(); &#125; &#125; private boolean isRedisRunning() throws IOException&#123; return isRedisRunning(); &#125; public int findAvailablePort() throws IOException&#123; for(int port = 10000; port &lt;= 65535; port++ )&#123; Process process = executeGrepProcessCommand(port); if(!isRunning(process))&#123; return port; &#125; &#125; throw new IllegalArgumentException(&quot;Not Found Available port: 10000 ~ 65535&quot;); &#125; private Process executeGrepProcessCommand(int port) throws IOException&#123; String command = String.format(&quot;netstat -nat | grep LISTEN|grep %d&quot;, port); String[] shell = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, command&#125;; return Runtime.getRuntime().exec(shell); &#125; private boolean isRunning(Process process)&#123; String line; StringBuilder pidInfo = new StringBuilder(); try(BufferedReader input = new BufferedReader(new InputStreamReader(process.getInputStream())))&#123; while((line = input.readLine()) != null) &#123; pidInfo.append(line); &#125; &#125;catch (Exception e) &#123; &#125; return !StringUtils.isEmpty(pidInfo.toString()); &#125;&#125; 참고https://www.baeldung.com/spring-embedded-redis","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Redis","slug":"Spring/Redis","permalink":"https://ckck803.github.io/categories/Spring/Redis/"}],"tags":[]},{"title":"Spring AOP Pointcut 표현식 - this, target","slug":"spring/spring-aop/pointcut/pointcut-09","date":"2021-12-20T06:31:07.000Z","updated":"2024-02-26T15:25:12.650Z","comments":true,"path":"2021/12/20/spring/spring-aop/pointcut/pointcut-09/","link":"","permalink":"https://ckck803.github.io/2021/12/20/spring/spring-aop/pointcut/pointcut-09/","excerpt":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut Spring 핵심원리 고급편 - this, target","text":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut Spring 핵심원리 고급편 - this, target","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"포인트 컷","slug":"Spring/Spring-AOP/포인트-컷","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%BB%B7/"}],"tags":[]},{"title":"Spring AOP Pointcut 표현식 - 매게변수 전달","slug":"spring/spring-aop/pointcut/pointcut-08","date":"2021-12-20T05:31:07.000Z","updated":"2024-02-26T15:25:08.932Z","comments":true,"path":"2021/12/20/spring/spring-aop/pointcut/pointcut-08/","link":"","permalink":"https://ckck803.github.io/2021/12/20/spring/spring-aop/pointcut/pointcut-08/","excerpt":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut Spring 핵심원리 고급편 - 매게변수 전달","text":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut Spring 핵심원리 고급편 - 매게변수 전달","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"포인트 컷","slug":"Spring/Spring-AOP/포인트-컷","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%BB%B7/"}],"tags":[]},{"title":"Spring AOP Pointcut 표현식 - bean","slug":"spring/spring-aop/pointcut/pointcut-07","date":"2021-12-20T04:31:07.000Z","updated":"2024-02-26T15:25:04.907Z","comments":true,"path":"2021/12/20/spring/spring-aop/pointcut/pointcut-07/","link":"","permalink":"https://ckck803.github.io/2021/12/20/spring/spring-aop/pointcut/pointcut-07/","excerpt":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut @Slf4j@Import(BeanTest.BeanAspect.class)@SpringBootTestpublic class BeanTest &#123; @Autowired OrderService orderService; @Test void success()&#123; orderService.orderItem(&quot;itemA&quot;); &#125; @Aspect static class BeanAspect&#123; @Around(&quot;bean(orderService) || bean(*Repository)&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable &#123; log.info(&quot;[bean] &#123;&#125;&quot;, joinPoint.getSignature()); return joinPoint.proceed(); &#125; &#125;&#125; 2021-12-21 00:13:43.463 INFO 35836 --- [ Test worker] com.example.aop.pointcut.BeanTest : [bean] void com.example.aop.order.OrderService.orderItem(String)2021-12-21 00:13:43.474 INFO 35836 --- [ Test worker] com.example.aop.order.OrderService : [orderService] 실행2021-12-21 00:13:43.475 INFO 35836 --- [ Test worker] com.example.aop.pointcut.BeanTest : [bean] String com.example.aop.order.OrderRepository.save(String)2021-12-21 00:13:43.480 INFO 35836 --- [ Test worker] com.example.aop.order.OrderRepository : [orderRepository] 실행","text":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut @Slf4j@Import(BeanTest.BeanAspect.class)@SpringBootTestpublic class BeanTest &#123; @Autowired OrderService orderService; @Test void success()&#123; orderService.orderItem(&quot;itemA&quot;); &#125; @Aspect static class BeanAspect&#123; @Around(&quot;bean(orderService) || bean(*Repository)&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable &#123; log.info(&quot;[bean] &#123;&#125;&quot;, joinPoint.getSignature()); return joinPoint.proceed(); &#125; &#125;&#125; 2021-12-21 00:13:43.463 INFO 35836 --- [ Test worker] com.example.aop.pointcut.BeanTest : [bean] void com.example.aop.order.OrderService.orderItem(String)2021-12-21 00:13:43.474 INFO 35836 --- [ Test worker] com.example.aop.order.OrderService : [orderService] 실행2021-12-21 00:13:43.475 INFO 35836 --- [ Test worker] com.example.aop.pointcut.BeanTest : [bean] String com.example.aop.order.OrderRepository.save(String)2021-12-21 00:13:43.480 INFO 35836 --- [ Test worker] com.example.aop.order.OrderRepository : [orderRepository] 실행","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Pointcut","slug":"Spring/Spring-AOP/Pointcut","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Pointcut/"}],"tags":[]},{"title":"Spring AOP Pointcut 표현식 - @annotation, @args","slug":"spring/spring-aop/pointcut/pointcut-annotation","date":"2021-12-20T03:31:07.000Z","updated":"2024-02-26T15:25:17.942Z","comments":true,"path":"2021/12/20/spring/spring-aop/pointcut/pointcut-annotation/","link":"","permalink":"https://ckck803.github.io/2021/12/20/spring/spring-aop/pointcut/pointcut-annotation/","excerpt":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut @annotation 메서드가 주어진 어노테이션을 가지고 있는 조인 포인트를 매칭 Spring 에서는 특정 어노테이션이 적용된 메소드에 Advice 를 적용하기 위해 Pointcut 표현식 에서 @annotation 을 제공합니다. Custom Annotation 생성@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MethodAop &#123; String value();&#125; Advisor 생성어노테이션을 이용해 Advice 적용하기 위해 @annotation 에 어노테이션 패키지 경로를 지정합니다. @Slf4j@Aspectstatic class AtAnnotationAspect&#123; @Around(&quot;@annotation(com.example.aop.member.annotation.MethodAop)&quot;) public Object doAtAnnotation(ProceedingJoinPoint joinPoint) throws Throwable &#123; log.info(&quot;[@annotation] &#123;&#125;&quot;, joinPoint.getSignature()); return joinPoint.proceed(); &#125;&#125;","text":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut @annotation 메서드가 주어진 어노테이션을 가지고 있는 조인 포인트를 매칭 Spring 에서는 특정 어노테이션이 적용된 메소드에 Advice 를 적용하기 위해 Pointcut 표현식 에서 @annotation 을 제공합니다. Custom Annotation 생성@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MethodAop &#123; String value();&#125; Advisor 생성어노테이션을 이용해 Advice 적용하기 위해 @annotation 에 어노테이션 패키지 경로를 지정합니다. @Slf4j@Aspectstatic class AtAnnotationAspect&#123; @Around(&quot;@annotation(com.example.aop.member.annotation.MethodAop)&quot;) public Object doAtAnnotation(ProceedingJoinPoint joinPoint) throws Throwable &#123; log.info(&quot;[@annotation] &#123;&#125;&quot;, joinPoint.getSignature()); return joinPoint.proceed(); &#125;&#125; Custom Annotation 적용@MethodAop 를 메소드에 적용합니다. 해당 어노테이션이 적용된 메소드에 Advice 를 적용합니다. @ClassAop@Componentpublic class MemberServiceImpl implements MemberService &#123; @Override @MethodAop(&quot;test&quot;) public String hello(String param) &#123; return null; &#125; public String internal(String param)&#123; return &quot;ok&quot;; &#125;&#125; MemberService 객체가 프록시 객체로 생성된 것을 확인할 수 있습니다. 또한, @MethodAop 가 적용된 hello 메소드에 Advice 로직이 수행된 것을 확인할 수 있습니다. @Testvoid success()&#123; log.info(&quot;memberService Proxy = &#123;&#125;&quot;, memberService.getClass()); memberService.hello(&quot;helloA&quot;);&#125; 2021-12-21 00:06:40.720 INFO 35688 --- [ Test worker] c.example.aop.pointcut.AtAnnotationTest : memberService Proxy = class com.example.aop.member.MemberServiceImpl$$EnhancerBySpringCGLIB$$a8e518182021-12-21 00:06:40.727 INFO 35688 --- [ Test worker] .a.p.AtAnnotationTest$AtAnnotationAspect : [@annotation] String com.example.aop.member.MemberServiceImpl.hello(String)","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"포인트 컷","slug":"Spring/Spring-AOP/포인트-컷","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%BB%B7/"}],"tags":[]},{"title":"Spring AOP Pointcut 표현식 - @target, @within","slug":"spring/spring-aop/pointcut/pointcut-05","date":"2021-12-20T02:31:07.000Z","updated":"2024-02-26T15:24:52.961Z","comments":true,"path":"2021/12/20/spring/spring-aop/pointcut/pointcut-05/","link":"","permalink":"https://ckck803.github.io/2021/12/20/spring/spring-aop/pointcut/pointcut-05/","excerpt":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut @target 과 @within@target 은 부모 클래스의 메서드까지 Advice 를 다 적용하고, @within 은 정의된 클래스내 메서드에만 Advice 를 적용합니다. Custon Annotation 생성@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ClassAop &#123;&#125; Advisor 생성@Slf4j@Aspectstatic class AtTargetAtWithinAspect &#123; //@target: 인스턴스 기준으로 모든 메서드의 조인 포인트를 선정, 부모 타입의 메서드도 적용 @Around(&quot;execution(* com.example.aop..*(..)) &amp;&amp; @target(com.example.aop.member.annotation.ClassAop)&quot;) public Object atTarget(ProceedingJoinPoint joinPoint) throws Throwable &#123; log.info(&quot;[@target] &#123;&#125;&quot;, joinPoint.getSignature()); return joinPoint.proceed(); &#125; //@within: 선택된 클래스 내부에 있는 메서드만 조인 포인트로 선정, 부모 타입의 메서드는 적용되지 않음 @Around(&quot;execution(* com.example.aop..*(..)) &amp;&amp; @within(com.example.aop.member.annotation.ClassAop)&quot;) public Object atWithin(ProceedingJoinPoint joinPoint) throws Throwable &#123; log.info(&quot;[@within] &#123;&#125;&quot;, joinPoint.getSignature()); return joinPoint.proceed(); &#125;&#125; AOP 적용 확인","text":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut @target 과 @within@target 은 부모 클래스의 메서드까지 Advice 를 다 적용하고, @within 은 정의된 클래스내 메서드에만 Advice 를 적용합니다. Custon Annotation 생성@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ClassAop &#123;&#125; Advisor 생성@Slf4j@Aspectstatic class AtTargetAtWithinAspect &#123; //@target: 인스턴스 기준으로 모든 메서드의 조인 포인트를 선정, 부모 타입의 메서드도 적용 @Around(&quot;execution(* com.example.aop..*(..)) &amp;&amp; @target(com.example.aop.member.annotation.ClassAop)&quot;) public Object atTarget(ProceedingJoinPoint joinPoint) throws Throwable &#123; log.info(&quot;[@target] &#123;&#125;&quot;, joinPoint.getSignature()); return joinPoint.proceed(); &#125; //@within: 선택된 클래스 내부에 있는 메서드만 조인 포인트로 선정, 부모 타입의 메서드는 적용되지 않음 @Around(&quot;execution(* com.example.aop..*(..)) &amp;&amp; @within(com.example.aop.member.annotation.ClassAop)&quot;) public Object atWithin(ProceedingJoinPoint joinPoint) throws Throwable &#123; log.info(&quot;[@within] &#123;&#125;&quot;, joinPoint.getSignature()); return joinPoint.proceed(); &#125;&#125; AOP 적용 확인@Testvoid success() &#123; log.info(&quot;child Proxy=&#123;&#125;&quot;, child.getClass()); child.childMethod(); //부모, 자식 모두 있는 메서드 child.parentMethod(); //부모 클래스만 있는 메서드&#125;static class Config &#123; @Bean public Parent parent() &#123; return new Parent(); &#125; @Bean public Child child() &#123; return new Child(); &#125; @Bean public AtTargetAtWithinAspect atTargetAtWithinAspect() &#123; return new AtTargetAtWithinAspect(); &#125;&#125;static class Parent &#123; public void parentMethod()&#123;&#125; //부모에만 있는 메서드&#125;@ClassAopstatic class Child extends Parent &#123; public void childMethod()&#123;&#125;&#125; 2021-12-20 20:45:37.947 INFO 34481 --- [ Test worker] c.e.aop.pointcut.AtTargetAtWithinTest : child Proxy=class com.example.aop.pointcut.AtTargetAtWithinTest$Child$$EnhancerBySpringCGLIB$$6f94df272021-12-20 20:45:37.951 INFO 34481 --- [ Test worker] argetAtWithinTest$AtTargetAtWithinAspect : [@target] void com.example.aop.pointcut.AtTargetAtWithinTest$Child.childMethod()2021-12-20 20:45:37.951 INFO 34481 --- [ Test worker] argetAtWithinTest$AtTargetAtWithinAspect : [@within] void com.example.aop.pointcut.AtTargetAtWithinTest$Child.childMethod()2021-12-20 20:45:37.955 INFO 34481 --- [ Test worker] argetAtWithinTest$AtTargetAtWithinAspect : [@target] void com.example.aop.pointcut.AtTargetAtWithinTest$Parent.parentMethod()","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"포인트 컷","slug":"Spring/Spring-AOP/포인트-컷","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%BB%B7/"}],"tags":[]},{"title":"Spring AOP Pointcut 표현식 - args","slug":"spring/spring-aop/pointcut/pointcut-args","date":"2021-12-20T01:31:07.000Z","updated":"2024-02-26T15:25:22.477Z","comments":true,"path":"2021/12/20/spring/spring-aop/pointcut/pointcut-args/","link":"","permalink":"https://ckck803.github.io/2021/12/20/spring/spring-aop/pointcut/pointcut-args/","excerpt":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut Spring 핵심원리 고급편 - args execution 은 파라미터 타입이 정확하게 일치돼야 한다. execution 은 클래스에 선언된 정보를 기반으로 판단한다. args 는 부모타입을 허용한다. args 는 실제로 넘어온 파라미터 객체 인스턴스를 보고 판단한다. private AspectJExpressionPointcut pointcut(String expression) &#123; AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(expression); return pointcut;&#125;@Testvoid args() &#123; //hello(String)과 매칭 assertThat(pointcut(&quot;args(String)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(Object)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args()&quot;) .matches(helloMethod, MemberServiceImpl.class)).isFalse(); assertThat(pointcut(&quot;args(..)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(*)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(String,..)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue();&#125; /** * execution(* *(java.io.Serializable)): 메서드의 시그니처로 판단 (정적) * args(java.io.Serializable): 런타임에 전달된 인수로 판단 (동적) */@Testvoid argsVsExecution() &#123; // Args // args 는 상위 타입도 허용한다. assertThat(pointcut(&quot;args(String)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(java.io.Serializable)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(Object)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); // Execution // execution 은 정확하게 매칭돼야 한다. assertThat(pointcut(&quot;execution(* *(String))&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;execution(* *(java.io.Serializable))&quot;) //매칭 실패 .matches(helloMethod, MemberServiceImpl.class)).isFalse(); assertThat(pointcut(&quot;execution(* *(Object))&quot;) //매칭 실패 .matches(helloMethod, MemberServiceImpl.class)).isFalse();&#125;","text":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut Spring 핵심원리 고급편 - args execution 은 파라미터 타입이 정확하게 일치돼야 한다. execution 은 클래스에 선언된 정보를 기반으로 판단한다. args 는 부모타입을 허용한다. args 는 실제로 넘어온 파라미터 객체 인스턴스를 보고 판단한다. private AspectJExpressionPointcut pointcut(String expression) &#123; AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(expression); return pointcut;&#125;@Testvoid args() &#123; //hello(String)과 매칭 assertThat(pointcut(&quot;args(String)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(Object)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args()&quot;) .matches(helloMethod, MemberServiceImpl.class)).isFalse(); assertThat(pointcut(&quot;args(..)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(*)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(String,..)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue();&#125; /** * execution(* *(java.io.Serializable)): 메서드의 시그니처로 판단 (정적) * args(java.io.Serializable): 런타임에 전달된 인수로 판단 (동적) */@Testvoid argsVsExecution() &#123; // Args // args 는 상위 타입도 허용한다. assertThat(pointcut(&quot;args(String)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(java.io.Serializable)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;args(Object)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); // Execution // execution 은 정확하게 매칭돼야 한다. assertThat(pointcut(&quot;execution(* *(String))&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); assertThat(pointcut(&quot;execution(* *(java.io.Serializable))&quot;) //매칭 실패 .matches(helloMethod, MemberServiceImpl.class)).isFalse(); assertThat(pointcut(&quot;execution(* *(Object))&quot;) //매칭 실패 .matches(helloMethod, MemberServiceImpl.class)).isFalse();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Pointcut","slug":"Spring/Spring-AOP/Pointcut","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Pointcut/"}],"tags":[]},{"title":"Spring AOP Pointcut 표현식 - within","slug":"spring/spring-aop/pointcut/pointcut-within","date":"2021-12-20T00:31:07.000Z","updated":"2024-02-26T15:25:31.511Z","comments":true,"path":"2021/12/20/spring/spring-aop/pointcut/pointcut-within/","link":"","permalink":"https://ckck803.github.io/2021/12/20/spring/spring-aop/pointcut/pointcut-within/","excerpt":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut within within 은 특정 타입 에 대해 Advice 를 적용합니다. 특정 타입이 within 을 만족 하면 해당 타입내 모든 메소드는 Advice 가 적용됩니다. // com.example.aop.member.MemberServiceImpl 타입을 대상으로 Advice 를 적용합니다.within(com.example.aop.member.MemberServiceImpl)// com.example.aop.member 패키지내 타입 이름에 Service 가 들어가면 Advice 를 적욯합니다.within(com.example.aop.member.*Service*)// com.example.aop 패키지와 하위 패키지내 모든 타입에 Advice 를 적용합니다.within(com.example.aop..*) execution 과 within 의 차이within 은 표현식은 execution 과 다르게 부모 타입을 지정했을 경우 자식 타입에는 Advice 가 적용되지 않습니다. 즉, 상속이나 구현을 통해 생성된 객체에는 Advice 가 적용되지 않고 정확하게 지정된 타입에만 적용되는 점에서 execution 과 차이가 있습니다. @Test@DisplayName(&quot;타겟의 타입에만 직접 적용, 인터페이스를 선정하면 안된다.&quot;)void withinSuperTypeFalse() &#123; pointcut.setExpression(&quot;within(com.example.aop.member.MemberService)&quot;); assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();&#125;@Test@DisplayName(&quot;execution은 타입 기반, 인터페이스 선정 가능&quot;)void executionSuperTypeTrue() &#123; pointcut.setExpression(&quot;execution(* com.example.aop.member.MemberService.*(..))&quot;); assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();&#125;","text":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut within within 은 특정 타입 에 대해 Advice 를 적용합니다. 특정 타입이 within 을 만족 하면 해당 타입내 모든 메소드는 Advice 가 적용됩니다. // com.example.aop.member.MemberServiceImpl 타입을 대상으로 Advice 를 적용합니다.within(com.example.aop.member.MemberServiceImpl)// com.example.aop.member 패키지내 타입 이름에 Service 가 들어가면 Advice 를 적욯합니다.within(com.example.aop.member.*Service*)// com.example.aop 패키지와 하위 패키지내 모든 타입에 Advice 를 적용합니다.within(com.example.aop..*) execution 과 within 의 차이within 은 표현식은 execution 과 다르게 부모 타입을 지정했을 경우 자식 타입에는 Advice 가 적용되지 않습니다. 즉, 상속이나 구현을 통해 생성된 객체에는 Advice 가 적용되지 않고 정확하게 지정된 타입에만 적용되는 점에서 execution 과 차이가 있습니다. @Test@DisplayName(&quot;타겟의 타입에만 직접 적용, 인터페이스를 선정하면 안된다.&quot;)void withinSuperTypeFalse() &#123; pointcut.setExpression(&quot;within(com.example.aop.member.MemberService)&quot;); assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();&#125;@Test@DisplayName(&quot;execution은 타입 기반, 인터페이스 선정 가능&quot;)void executionSuperTypeTrue() &#123; pointcut.setExpression(&quot;execution(* com.example.aop.member.MemberService.*(..))&quot;); assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"포인트 컷","slug":"Spring/Spring-AOP/포인트-컷","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%BB%B7/"}],"tags":[]},{"title":"Spring AOP - Pointcut 표현식 execution","slug":"spring/spring-aop/pointcut/pointcut-execution","date":"2021-12-19T23:31:07.000Z","updated":"2024-02-26T15:25:26.836Z","comments":true,"path":"2021/12/20/spring/spring-aop/pointcut/pointcut-execution/","link":"","permalink":"https://ckck803.github.io/2021/12/20/spring/spring-aop/pointcut/pointcut-execution/","excerpt":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut execution execution( [접근제어자] 리턴타입 [선언타입] 메서드이름 (파라미터) [예외] ) execution 는 Pointcut 표현식에서 가장 많이 사용되는 명시자 입니다. execution 는 메소드의 접근 제어자, 리턴 타입, 메소드가 선언된 패키지, 클래스 정보, 메소드 파라미터, 예외처리 정보를 이용해 다양한 조건으로 Pointcut 을 적용할 수 있도록 제공합니다. execution(public String com.example.aop.member.MemberServiceImpl.hello(String)) 접근 제어자 : public 인 메소드 리턴 타입 : String 선언 타입 : com.example.aop.member.MemberServiceImpl 메서드 이름 : hello 파라미터 : String 예외 : 생략 @Testvoid exactMatch()&#123; // public java.lang.String com.example.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(public String com.example.aop.member.MemberServiceImpl.hello(String))&quot;); assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();&#125;","text":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut execution execution( [접근제어자] 리턴타입 [선언타입] 메서드이름 (파라미터) [예외] ) execution 는 Pointcut 표현식에서 가장 많이 사용되는 명시자 입니다. execution 는 메소드의 접근 제어자, 리턴 타입, 메소드가 선언된 패키지, 클래스 정보, 메소드 파라미터, 예외처리 정보를 이용해 다양한 조건으로 Pointcut 을 적용할 수 있도록 제공합니다. execution(public String com.example.aop.member.MemberServiceImpl.hello(String)) 접근 제어자 : public 인 메소드 리턴 타입 : String 선언 타입 : com.example.aop.member.MemberServiceImpl 메서드 이름 : hello 파라미터 : String 예외 : 생략 @Testvoid exactMatch()&#123; // public java.lang.String com.example.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(public String com.example.aop.member.MemberServiceImpl.hello(String))&quot;); assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();&#125; 모든 메소드를 대상으로 한 포인트 컷 - execution(* *(..)) 접근 제어자 : 생략 리턴 타입 : * 선언 타입 : 생략 메서드 이름 : * 파라미터 : (..) 예외 : 없음 pointcut.setExpression(&quot;execution(* *(..))&quot;); Method 지정 execution( [접근제어자] 리턴타입 [선언타입] 메서드이름 (파라미터) [예외] ) execution 에 특정 메소드 정보를 기입할 경우 해당되는 메소드에 Advice 가 적용됩니다. 메소드 이름에 * 를 넣은 경우 모든 대상으로 Advice 가 적용되고 특정이름으로 시작하거나 포함하거나 끝나는 경우에는 이름 정보와 * 를 조합하면 조건에 맞는 메소드만 Advice 를 적용할 수 있습니다. // hello 인 메소드에 Advice 를 적용합니다.execution(* hello(..))// hel 로 시작하는 메소드에 Advice 를 적용합니다.execution(* hel*(..))// 메소드 이름에 el 이 들어가는 메소드에 Advice 를 적용합니다.execution(* *el*(..)) 선언 타입 지정 execution( [접근제어자] 리턴타입 [선언타입] 메서드이름 (파라미터) [예외] ) 선언 타임의 경우 패키지와 클래스 정보로 구성됩니다. 패키지와 클래스를 이용한 지정, 특정 패키지만 지정, 하위 패키지까지 지정, 구현 클래스 지정, 인터페이스 혹은 상위 클래스 지정, 특정 패키지 정보와 클래스를 지정하는 방법등을 통해 Advice 를 적용할 수 있습니다. 특정 Package 내 Class 를 지정패키지와 클래스를 명시하면 해당 패키지내 클래스 메소드를 대상으로 Advice 를 적용할 수 있습니다. execution(* com.example.aop.member.MemberServiceImpl.hello(..)) Package 내 모든 클래스에 적용패키지에 속한 모든 클래스를 대상으로 Advice 를 적용하고 싶다면 패지키 정보 만 명시하고 클래스 정보 에 * 를 넣으면 해당 패키지 내 모든 클래스 메소드에 AOP 를 적용합니다. 다만, 하위 패키지 클래스에는 적용되지 않습니다. // com.example.aop.member 패키지 내 클래스에 Advice 가 적용execution(* com.example.aop.member.*.*(..)) // com.example.aop.member 패키지 내 클래스에는 Advice 가 적용되지 않습니다.execution(* com.example.aop.*.*(..)) 하위 Package 내 클래스에 AOP 적용패키지를 명시할 경우 해당 패키지내 객체를 대상으로만 Advice 가 적용됩니다. 만일 하위 패키지까지 적용하고 싶다면 .. 를 넣어주면 하위 패키지내 객체들까지 Advice 적용할 수 있습니다. // com.example.aop.member 하위 패키지 클래스까지 AOP 를 적용합니다.execution(* com.example.aop.member..*.*(..))// com.example.aop 하위 패키지 클래스까지 AOP 를 적용합니다.execution(* com.example.aop..*.*(..)) 부모 타입 지정 - 자식 타입에 적용부모 타입을 대상으로 하는 Pointcut 은 자식 타입을 대상으로도 동일하게 적용됩니다. 따라서, 구현 혹은 상속을 통해 자식 타입에도 Advice 를 적용할 수 있습니다. 부모 타입을 지정하면 Pointcut 의 대상은 부모 타입에 정의된 메소드에만 적용할 수 있습니다 즉, 자식 타입에서 선언한 메서드는 Pointcut 대상이 될 수 없습니다. // 부모 타입을 지정하면 자식 타입에도 적용됩니다.pointcut.setExpression(&quot;execution(* com.example.aop.member.MemberService.*.*(..))&quot;);assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();// 자식 타입에서 선언한 메소드는 AOP 가 적용되지 않습니다.// internal 메소드는 MemberServiceImpl 클래스에서 선언한 메소드라 AOP 적용대상이 아닙니다.pointcut.setExpression(&quot;execution(* com.example.aop.member.MemberService.*.*(..))&quot;);Method internalMethod = MemberServiceImpl.class.getMethod(&quot;internal&quot;, String.class);assertThat(pointcut.matches(internalMethod, MemberServiceImpl.class)).isFalse(); Parameter 지정 execution( [접근제어자] 리턴타입 [선언타입] 메서드이름 (파라미터) [예외] ) 메소드에서 사용하는 Paramater 를 대상으로 Advice 를 적용할 수 있습니다. 표현식을 이용해 단일, 한개 이상, 모든 파라미터를 대상으로 적용할 수 있습니다. // String 파라미터를 사용하는 메소드에 Advice 적용execution(* *(String))// 파라미터가 없는 메소드만 Advice 적용execution(* *())// 하나의 파라미터만 가진 메소드에 Advice 적용execution(* *(*))// 모든 파라미터형식의 모든 메소드에 Advice 적용execution(* *(..))// 특정 파라미터로 시작하고 모든 파라미터형식의 메소드에 허용execution(* *(String, ..))","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"포인트 컷","slug":"Spring/Spring-AOP/포인트-컷","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%BB%B7/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Pointcut","slug":"spring/spring-aop/pointcut/pointcut-01","date":"2021-12-19T22:31:07.000Z","updated":"2024-02-26T15:24:37.631Z","comments":true,"path":"2021/12/20/spring/spring-aop/pointcut/pointcut-01/","link":"","permalink":"https://ckck803.github.io/2021/12/20/spring/spring-aop/pointcut/pointcut-01/","excerpt":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut @Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ClassAop &#123;&#125; @Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MethodAop &#123; String value();&#125; public interface MemberService &#123; String hello(String param);&#125; @ClassAop@Componentpublic class MemberServiceImpl implements MemberService &#123; @Override @MethodAop(&quot;test&quot;) public String hello(String param) &#123; return null; &#125; public String internal(String param)&#123; return &quot;ok&quot;; &#125;&#125; AspectJExpressionPointcut 이 포인트 컷 표현식을 처리해주는 클래스 @Slf4jpublic class ExecutionTest &#123; AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); Method helloMethod; @BeforeEach public void init() throws NoSuchMethodException &#123; helloMethod = MemberServiceImpl.class.getMethod(&quot;hello&quot;, String.class); &#125; @Test void printMethod()&#123; log.info(&quot;helloMethod = &#123;&#125;&quot;, helloMethod); &#125;&#125;","text":"목차 Spring AOP Pointcut 표현식 - this, target Spring AOP Pointcut 표현식 - 매게변수 전달 Spring AOP Pointcut 표현식 - bean Spring AOP Pointcut 표현식 - @annotation, @args Spring AOP Pointcut 표현식 - @target, @within Spring AOP Pointcut 표현식 - args Spring AOP Pointcut 표현식 - within Spring AOP - Pointcut 표현식 execution Spring 핵심원리 고급편 - Pointcut @Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ClassAop &#123;&#125; @Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MethodAop &#123; String value();&#125; public interface MemberService &#123; String hello(String param);&#125; @ClassAop@Componentpublic class MemberServiceImpl implements MemberService &#123; @Override @MethodAop(&quot;test&quot;) public String hello(String param) &#123; return null; &#125; public String internal(String param)&#123; return &quot;ok&quot;; &#125;&#125; AspectJExpressionPointcut 이 포인트 컷 표현식을 처리해주는 클래스 @Slf4jpublic class ExecutionTest &#123; AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); Method helloMethod; @BeforeEach public void init() throws NoSuchMethodException &#123; helloMethod = MemberServiceImpl.class.getMethod(&quot;hello&quot;, String.class); &#125; @Test void printMethod()&#123; log.info(&quot;helloMethod = &#123;&#125;&quot;, helloMethod); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Pointcut","slug":"Spring/Spring-AOP/Pointcut","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Pointcut/"}],"tags":[]},{"title":"Java - Collection Framework","slug":"java/collection-framework/collection-framework-01","date":"2021-12-14T19:31:46.000Z","updated":"2024-02-18T16:19:54.527Z","comments":true,"path":"2021/12/15/java/collection-framework/collection-framework-01/","link":"","permalink":"https://ckck803.github.io/2021/12/15/java/collection-framework/collection-framework-01/","excerpt":"Java - Collection FrameworkList 컬랙션 List 컬랙션은 객체를 일렬로 늘여 놓은 구조 를 가지고 있다. 객체를 인덱스로 관리하기 때문에 객체를 저장하면 인덱스가 부여되고 해당 인덱스를 이용해 검색, 삭제를 할 수 있다. List 컬랙션에서는 객체 자체를 저장하는 게 아니라 객체의 번지를 참조한다. 동일한 객체를 중복 저장할 수 있다. 대표적인 구현체로는 ArrayList, Vector, LinkedList 등이 있다. 메서드 설명 boolean add(E e) List 맨 끝에 데이터를 추가한 후 정상적으로 저장되면 true 실패하면 false 를 반환한다. void add(int index, E element) 주어진 인덱스 위치에 데이터를 추가한다. set(int index, E element) 주어진 인덱스 위치에 저장된 데이터를 변경한다. boolean contains(Object o) 주어진 데이터가 List에 있는지 확인한다. E get(int index) 주어진 인덱스에 저장된 데이터를 반환한다. isEmpty() List 에 데이터가 있는지 확인한다. int size() List 에저장 돼 있는 데이터의 전체 크기를 반환한다. E remove(int index) 주어진 인덱스에 위치한 데이터를 삭제한다. void clear() List 에 저장돼 있는 모든 원소들을 삭제한다. boolean remove(Object o) List 에서 전달받은 데이터에 해당 하는 모든 원소를 삭제한다. Set 컬랙션 저장 순서가 유지되지 않기 때문에 Index 가 존재하지 않는다. 대신, Iterator 를 이용해 Set 에 저장된 데이터를 가져올 수 있다. 객체를 중복해서 저장할 수 없고, 하나의 null 만 저장할 수 있다. 대표적인 구현체로는 HashSet, TreeSet 이 있다. 메서드 설명 boolean add(E e) 데이터를 Set 에 저장한 후 정상적으로 저장되면 true를 중복 객체면 false 를 반환합니다. boolean contains(Object o) 객체가 저장돼 있는지 여부를 리턴합니다. Iterator iterator() 저장된 객체를 한번씩 가져오는 반복자를 반환한다. isEmpty() Set 이 비어있는지 조사합니다. int Size() Set 에 저장돼 있는 전체 객체수를 리턴합니다. void clear() Set 에 저장된 모든 객체를 삭제 boolean remove(Object o) Set 에 저장된 주어진 객체를 삭제합니다. Map 컬랙션 Key, Value 형식 으로 데이터를 관리하는 자료구조 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다. 기존에 저장된 키와 동일한 키로 값을 저장하면 새로운 값으로 대체된다. 대표적인 구현체로는 HashMap, HashTable, LinkedHashMap, TreeMap 등이 있다. 메서드 설명 V put(K Key, V value) Map 에 주어진 키와 값을 추가해 저장되면 해당 값을 리턴합니다. boolean containsKey(Object Key) Map 에 주어진 키 가 있는지 확인합니다. boolean containsValue(Object value) Map 에 주어진 값 이 있는지 확인합니다. Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 모든 Map.Entry 객체를 Set에 담아 리턴합니다. Set keySet() 모든 키를 Set 객체에 담아서 리턴합니다. V get(Object key) 주어진 키에 해당하는 값을 리턴합니다. boolean isEmpty() Map 이 비어있는지 조사합니다. int Size() Map 에 저장돼 있는 전체 객체의 수를 리턴합니다. Collection values() Map 에 저장된 모든 값을 Collection 객체에 담아서 리턴합니다. void clear() 저장된 모든 Map.Entry를 삭제합니다. V remove(Object Key) 주어진 키와 일치하는 Map.Entry를 삭제하고 값을 리턴합니다.","text":"Java - Collection FrameworkList 컬랙션 List 컬랙션은 객체를 일렬로 늘여 놓은 구조 를 가지고 있다. 객체를 인덱스로 관리하기 때문에 객체를 저장하면 인덱스가 부여되고 해당 인덱스를 이용해 검색, 삭제를 할 수 있다. List 컬랙션에서는 객체 자체를 저장하는 게 아니라 객체의 번지를 참조한다. 동일한 객체를 중복 저장할 수 있다. 대표적인 구현체로는 ArrayList, Vector, LinkedList 등이 있다. 메서드 설명 boolean add(E e) List 맨 끝에 데이터를 추가한 후 정상적으로 저장되면 true 실패하면 false 를 반환한다. void add(int index, E element) 주어진 인덱스 위치에 데이터를 추가한다. set(int index, E element) 주어진 인덱스 위치에 저장된 데이터를 변경한다. boolean contains(Object o) 주어진 데이터가 List에 있는지 확인한다. E get(int index) 주어진 인덱스에 저장된 데이터를 반환한다. isEmpty() List 에 데이터가 있는지 확인한다. int size() List 에저장 돼 있는 데이터의 전체 크기를 반환한다. E remove(int index) 주어진 인덱스에 위치한 데이터를 삭제한다. void clear() List 에 저장돼 있는 모든 원소들을 삭제한다. boolean remove(Object o) List 에서 전달받은 데이터에 해당 하는 모든 원소를 삭제한다. Set 컬랙션 저장 순서가 유지되지 않기 때문에 Index 가 존재하지 않는다. 대신, Iterator 를 이용해 Set 에 저장된 데이터를 가져올 수 있다. 객체를 중복해서 저장할 수 없고, 하나의 null 만 저장할 수 있다. 대표적인 구현체로는 HashSet, TreeSet 이 있다. 메서드 설명 boolean add(E e) 데이터를 Set 에 저장한 후 정상적으로 저장되면 true를 중복 객체면 false 를 반환합니다. boolean contains(Object o) 객체가 저장돼 있는지 여부를 리턴합니다. Iterator iterator() 저장된 객체를 한번씩 가져오는 반복자를 반환한다. isEmpty() Set 이 비어있는지 조사합니다. int Size() Set 에 저장돼 있는 전체 객체수를 리턴합니다. void clear() Set 에 저장된 모든 객체를 삭제 boolean remove(Object o) Set 에 저장된 주어진 객체를 삭제합니다. Map 컬랙션 Key, Value 형식 으로 데이터를 관리하는 자료구조 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다. 기존에 저장된 키와 동일한 키로 값을 저장하면 새로운 값으로 대체된다. 대표적인 구현체로는 HashMap, HashTable, LinkedHashMap, TreeMap 등이 있다. 메서드 설명 V put(K Key, V value) Map 에 주어진 키와 값을 추가해 저장되면 해당 값을 리턴합니다. boolean containsKey(Object Key) Map 에 주어진 키 가 있는지 확인합니다. boolean containsValue(Object value) Map 에 주어진 값 이 있는지 확인합니다. Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 모든 Map.Entry 객체를 Set에 담아 리턴합니다. Set keySet() 모든 키를 Set 객체에 담아서 리턴합니다. V get(Object key) 주어진 키에 해당하는 값을 리턴합니다. boolean isEmpty() Map 이 비어있는지 조사합니다. int Size() Map 에 저장돼 있는 전체 객체의 수를 리턴합니다. Collection values() Map 에 저장된 모든 값을 Collection 객체에 담아서 리턴합니다. void clear() 저장된 모든 Map.Entry를 삭제합니다. V remove(Object Key) 주어진 키와 일치하는 Map.Entry를 삭제하고 값을 리턴합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"},{"name":"Collection","slug":"Programming/JAVA/Collection","permalink":"https://ckck803.github.io/categories/Programming/JAVA/Collection/"}],"tags":[]},{"title":"Java - Collection Framework","slug":"java/collection-framework/collection-framework-02","date":"2021-12-14T19:31:46.000Z","updated":"2024-02-18T16:19:54.527Z","comments":true,"path":"2021/12/15/java/collection-framework/collection-framework-02/","link":"","permalink":"https://ckck803.github.io/2021/12/15/java/collection-framework/collection-framework-02/","excerpt":"Java - Collection FrameworkStack 먼저 들어간 데이터가 가장 마지막에 나오는 구조 (First In First Out) 메서드 설명 void push(E e) stack 최상단에 데이터를 추가한다. Element pop() stack 최상단 데이터를 반환한 후 스택 최상단 데이터를 삭제한다. Element peek() stack 최상단 데이터를 반환한다. boolean isEmpty() stack 이 비어있는지 확인한다. int size() stack 의 크기를 반환한다. Queue 메서드 설명 boolean add(E e) Queue 맨 뒤에 데이터를 추가한 후 정상적으로 수행했으면 True, 데이터 삽입에 실패하면 False 를 반환한다. Queue 에 여유 공간이 없어 실패한 경우 IllegalStateException 예외를 발생 시킨다. boolean offer(E e) Queue 맨 뒤에 데이터를 추가한 후 정상적으로 수행했으면 True, 데이터 삽입에 실패하면 False 를 반환한다. E element() Queue 맨 앞의 원소를 반환한다. E peek( ) Queue 맨 앞의 원소를 반환한다. Queue 가 비어있을 경우 null 을 반환한다. E poll( ) Queue 맨 앞의 원소를 반환한 후 삭제한다. Queue 가 비어있을 경우 null 을 반환한다. E remove() Queue 맨 앞의 원소를 삭제한다.","text":"Java - Collection FrameworkStack 먼저 들어간 데이터가 가장 마지막에 나오는 구조 (First In First Out) 메서드 설명 void push(E e) stack 최상단에 데이터를 추가한다. Element pop() stack 최상단 데이터를 반환한 후 스택 최상단 데이터를 삭제한다. Element peek() stack 최상단 데이터를 반환한다. boolean isEmpty() stack 이 비어있는지 확인한다. int size() stack 의 크기를 반환한다. Queue 메서드 설명 boolean add(E e) Queue 맨 뒤에 데이터를 추가한 후 정상적으로 수행했으면 True, 데이터 삽입에 실패하면 False 를 반환한다. Queue 에 여유 공간이 없어 실패한 경우 IllegalStateException 예외를 발생 시킨다. boolean offer(E e) Queue 맨 뒤에 데이터를 추가한 후 정상적으로 수행했으면 True, 데이터 삽입에 실패하면 False 를 반환한다. E element() Queue 맨 앞의 원소를 반환한다. E peek( ) Queue 맨 앞의 원소를 반환한다. Queue 가 비어있을 경우 null 을 반환한다. E poll( ) Queue 맨 앞의 원소를 반환한 후 삭제한다. Queue 가 비어있을 경우 null 을 반환한다. E remove() Queue 맨 앞의 원소를 삭제한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"},{"name":"Collection","slug":"Programming/JAVA/Collection","permalink":"https://ckck803.github.io/categories/Programming/JAVA/Collection/"}],"tags":[]},{"title":"Spring AOP - Advice 종류","slug":"spring/spring-aop/spring-aop/spring-aop-07","date":"2021-12-12T21:31:07.000Z","updated":"2024-02-26T15:25:53.074Z","comments":true,"path":"2021/12/13/spring/spring-aop/spring-aop/spring-aop-07/","link":"","permalink":"https://ckck803.github.io/2021/12/13/spring/spring-aop/spring-aop/spring-aop-07/","excerpt":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring 핵심원리 고급편 - 어드바이스 종류 종류 설명 @Around 메서드 호출 전 후에 실행, 가장 강력한 어드바이스, 조인 포인트 실행 여부 선택, 반환 값 변환, 예외 변환 등이 가능 @Before 조인 포인트 실행 이전에 실행 @AfterReturning 조인 포인트가 정상 완료 후 실행 @AftThrowing 메서드가 예외를 던지는 경우 실행 @After 조인 포인트가 정상 또는 예외에 관계 없이 실행 @Slf4j@Aspectpublic class AspectV6Advice &#123; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; // @Before log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); // @AfterReturning log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; // @AfterThrowing log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; // @After log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125;&#125; @Slf4j@Aspectpublic class AspectV6Advice &#123; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; // @Before log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); // @AfterReturning log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; // @AfterThrowing log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; // @After log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125; // @Before 은 그냥 실행해준다. @Before(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public void doBefore(JoinPoint joinPoint)&#123; log.info(&quot;[before] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; // return 값을 조작을 할 수는 있지만 바꿀 수 는 없다. @AfterReturning(value = &quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;, returning = &quot;result&quot;) public void doReturn(JoinPoint joinPoint, Object result)&#123; log.info(&quot;[return] &#123;&#125; return = &#123;&#125;&quot;, joinPoint.getSignature(), result); &#125; // 자동으로 throw ex 를 해준다. @AfterThrowing(value = &quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;, throwing = &quot;ex&quot;) public void doThrowing(JoinPoint joinPoint, Exception ex)&#123; log.info(&quot;[ex] &#123;&#125; message = &#123;&#125;&quot;, ex); &#125; @After(value = &quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public void doAfter(JoinPoint joinPoint)&#123; log.info(&quot;[after] &#123;&#125;&quot;, joinPoint.getSignature()); &#125;&#125; 모든 어드바이스는 JoinPoint 를 첫번째 파라미터에 사용할 수 있다. 단 @Around 는 ProceedingJoinPoint 를 사용해야 한다.ProceedingJoinPoint는 JoinPoint 의 하위 타입니다. JoinPoint 인터페이스의 주요 기능 Method 설명 getArgs 메서드 인수를 반환한다. getThis 프록시 객체를 반환한다. getTarget 대상 객체를 반환한다. getSignature 조언되는 메서드에 대한 설명을 반환한다. toString 조언되는 방법에 대한 유용한 설명을 인쇄한다.","text":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring 핵심원리 고급편 - 어드바이스 종류 종류 설명 @Around 메서드 호출 전 후에 실행, 가장 강력한 어드바이스, 조인 포인트 실행 여부 선택, 반환 값 변환, 예외 변환 등이 가능 @Before 조인 포인트 실행 이전에 실행 @AfterReturning 조인 포인트가 정상 완료 후 실행 @AftThrowing 메서드가 예외를 던지는 경우 실행 @After 조인 포인트가 정상 또는 예외에 관계 없이 실행 @Slf4j@Aspectpublic class AspectV6Advice &#123; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; // @Before log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); // @AfterReturning log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; // @AfterThrowing log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; // @After log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125;&#125; @Slf4j@Aspectpublic class AspectV6Advice &#123; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; // @Before log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); // @AfterReturning log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; // @AfterThrowing log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; // @After log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125; // @Before 은 그냥 실행해준다. @Before(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public void doBefore(JoinPoint joinPoint)&#123; log.info(&quot;[before] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; // return 값을 조작을 할 수는 있지만 바꿀 수 는 없다. @AfterReturning(value = &quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;, returning = &quot;result&quot;) public void doReturn(JoinPoint joinPoint, Object result)&#123; log.info(&quot;[return] &#123;&#125; return = &#123;&#125;&quot;, joinPoint.getSignature(), result); &#125; // 자동으로 throw ex 를 해준다. @AfterThrowing(value = &quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;, throwing = &quot;ex&quot;) public void doThrowing(JoinPoint joinPoint, Exception ex)&#123; log.info(&quot;[ex] &#123;&#125; message = &#123;&#125;&quot;, ex); &#125; @After(value = &quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public void doAfter(JoinPoint joinPoint)&#123; log.info(&quot;[after] &#123;&#125;&quot;, joinPoint.getSignature()); &#125;&#125; 모든 어드바이스는 JoinPoint 를 첫번째 파라미터에 사용할 수 있다. 단 @Around 는 ProceedingJoinPoint 를 사용해야 한다.ProceedingJoinPoint는 JoinPoint 의 하위 타입니다. JoinPoint 인터페이스의 주요 기능 Method 설명 getArgs 메서드 인수를 반환한다. getThis 프록시 객체를 반환한다. getTarget 대상 객체를 반환한다. getSignature 조언되는 메서드에 대한 설명을 반환한다. toString 조언되는 방법에 대한 유용한 설명을 인쇄한다. ProceedingJoinPoint 인터페이스의 주요 기능 proceed 다음 어드바이스나 타겟을 호출한다. 어드바이스 종류@Before 조인포인트 실행 전에 작동한다. @Around 와는 다르게 작업 흐름을 변경할 수 없다. @Around 는 ProceedingJoinPoint.proceed 를 호출해야 다음 대상이 호출된다. 만약 호출하지 않는다면 다음 대상이 호출 되지 않는다. @Before 는 ProceedingJoinPoint.proceed 메소드를 사용하지 않는다. 메서드 종료시 자동으로 다음 타켓이 호출된다. @AfterReturning 메서드 실행이 정상적으로 반화될 때 실행한다. returning 속성에 사용된 이름은 어드바이스 메서드의 매개변수 이름과 일치해야 한다. returnning 절에 지정된 타입의 값을 반환하는 메서드만 대상으로 실행한다. @Around 와 다르게 반환되는 객체를 변경할 수 없다. 반환 객체를 조작할 수는 있다. @AfterThrowing 메서드 실행이 예외를 던져서 종료될 때 실행한다. throwing 속성에 사용된 이름은 어드바이스 메서드의 매게변수 이름과 일치해야 한다. throwing 절에 지정된 타입과 맞은 예외를 대상으로 실행한다. 부모 타입을 지정하면 모든 자식 타입은 인정된다. @After 메서드 실행이 종료되면 실행된다. 정상 및 예외 반환 조건을 모두 처리한다. 일반적으로 리소스 및 유사한 목적을 해제하는데 사용한다. @Around 메서드의 실행의 주변에서 실행된다. 메서드 실행 전후에 작업을 수행한다. 가장 강력한 어드바이스 조인 포인트 실행 여부 선택 전달 값 변환 반환 값 변환 예외 변환 트랜잭션 처럼 try ~ catch ~ finally 모두 들어가는 구문 처리 가능 어드바이스의 첫 번째 파라미터는 ProceedingJoinPoint 를 사용해야 한다. proceed 메서드를 통해 대상을 실행한다. proceed 메서드를 여러번 실행할 수도 있다. @Around 외 다른 어드바이스가 존재하는 이유 @Around 는 항상 joinPoint.proceed 메소드를 호출해야 한다. 만약, 실수로 호출하지 않는다면 타겟이 호출되지 않는 치명적인 버그가 발생한다. @Slf4j@Aspectpublic class AspectV6Advice &#123; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; // @Before log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); @Before 는 joinPoint.proceed 메소드를 호출하는 고민을 하지 않아도 된다. // @Before 은 그냥 실행해준다.@Before(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;)public void doBefore(JoinPoint joinPoint)&#123; log.info(&quot;[before] &#123;&#125;&quot;, joinPoint.getSignature());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"}],"tags":[]},{"title":"Spring AOP - 트랜잭션 순서","slug":"spring/spring-aop/spring-aop/spring-aop-06","date":"2021-12-11T21:31:07.000Z","updated":"2024-02-26T15:25:48.825Z","comments":true,"path":"2021/12/12/spring/spring-aop/spring-aop/spring-aop-06/","link":"","permalink":"https://ckck803.github.io/2021/12/12/spring/spring-aop/spring-aop/spring-aop-06/","excerpt":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring 핵심원리 고급편 - 트랜잭션 순서@Slf4jpublic class AspectV5Order &#123; @Aspect @Order(2) public static class LogAspect&#123; @Around(&quot;com.example.aop.order.aop.Pointcuts.allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; log.info(&quot;[log] &#123;&#125;&quot;, joinPoint.getSignature()); // join point 시그니처 return joinPoint.proceed(); &#125; &#125; @Aspect @Order(1) public static class TxAspect&#123; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125; &#125;&#125;","text":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring 핵심원리 고급편 - 트랜잭션 순서@Slf4jpublic class AspectV5Order &#123; @Aspect @Order(2) public static class LogAspect&#123; @Around(&quot;com.example.aop.order.aop.Pointcuts.allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; log.info(&quot;[log] &#123;&#125;&quot;, joinPoint.getSignature()); // join point 시그니처 return joinPoint.proceed(); &#125; &#125; @Aspect @Order(1) public static class TxAspect&#123; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"}],"tags":[]},{"title":"Spring AOP - Pointcut 참조","slug":"spring/spring-aop/spring-aop/spring-aop-05","date":"2021-12-11T20:31:07.000Z","updated":"2024-02-26T15:25:45.167Z","comments":true,"path":"2021/12/12/spring/spring-aop/spring-aop/spring-aop-05/","link":"","permalink":"https://ckck803.github.io/2021/12/12/spring/spring-aop/spring-aop/spring-aop-05/","excerpt":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Pointcutpublic class Pointcuts &#123; @Pointcut(&quot;execution(* com.example.aop.order..*(..))&quot;) public void allOrder()&#123;&#125; // 클래스 이름 패턴이 *Service @Pointcut(&quot;execution(* *..*Service.*(..))&quot;) public void allService()&#123;&#125; // allOrder &amp;&amp; allService @Pointcut(&quot;allOrder() &amp;&amp; allService()&quot;) public void orderAndService()&#123;&#125;&#125; 외부 Pointcut 참조@Slf4j@Aspectpublic class AspectV4PointCut &#123; @Around(&quot;com.example.aop.order.aop.Pointcuts.allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; log.info(&quot;[log] &#123;&#125;&quot;, joinPoint.getSignature()); // join point 시그니처 return joinPoint.proceed(); &#125; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125;&#125; @Slf4j@SpringBootTest@Import(AspectV4PointCut.class)public class AopTest &#123; @Autowired OrderService orderService; @Autowired OrderRepository orderRepository; @Test public void aopTest()&#123; log.info(&quot;isAopProxy, orderService = &#123;&#125;&quot;, AopUtils.isAopProxy(orderService)); log.info(&quot;isAopProxy, orderRepository = &#123;&#125;&quot;, AopUtils.isAopProxy(orderRepository)); &#125; @Test public void success()&#123; orderService.orderItem(&quot;itemA&quot;); &#125; @Test public void exception()&#123; assertThatThrownBy(() -&gt; orderService.orderItem(&quot;ex&quot;)) .isInstanceOf(IllegalStateException.class); &#125;&#125;","text":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Pointcutpublic class Pointcuts &#123; @Pointcut(&quot;execution(* com.example.aop.order..*(..))&quot;) public void allOrder()&#123;&#125; // 클래스 이름 패턴이 *Service @Pointcut(&quot;execution(* *..*Service.*(..))&quot;) public void allService()&#123;&#125; // allOrder &amp;&amp; allService @Pointcut(&quot;allOrder() &amp;&amp; allService()&quot;) public void orderAndService()&#123;&#125;&#125; 외부 Pointcut 참조@Slf4j@Aspectpublic class AspectV4PointCut &#123; @Around(&quot;com.example.aop.order.aop.Pointcuts.allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; log.info(&quot;[log] &#123;&#125;&quot;, joinPoint.getSignature()); // join point 시그니처 return joinPoint.proceed(); &#125; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;com.example.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125;&#125; @Slf4j@SpringBootTest@Import(AspectV4PointCut.class)public class AopTest &#123; @Autowired OrderService orderService; @Autowired OrderRepository orderRepository; @Test public void aopTest()&#123; log.info(&quot;isAopProxy, orderService = &#123;&#125;&quot;, AopUtils.isAopProxy(orderService)); log.info(&quot;isAopProxy, orderRepository = &#123;&#125;&quot;, AopUtils.isAopProxy(orderRepository)); &#125; @Test public void success()&#123; orderService.orderItem(&quot;itemA&quot;); &#125; @Test public void exception()&#123; assertThatThrownBy(() -&gt; orderService.orderItem(&quot;ex&quot;)) .isInstanceOf(IllegalStateException.class); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"}],"tags":[]},{"title":"Spring AOP - 어드바이스 추가","slug":"spring/spring-aop/spring-aop/spring-aop-04","date":"2021-12-11T19:31:07.000Z","updated":"2024-02-26T15:25:41.215Z","comments":true,"path":"2021/12/12/spring/spring-aop/spring-aop/spring-aop-04/","link":"","permalink":"https://ckck803.github.io/2021/12/12/spring/spring-aop/spring-aop/spring-aop-04/","excerpt":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Advice 추가 기존에 로그를 찍은 기능에서 트랜잭션 기능 추가 allOrder com.example.aop.order 하위 패키지를 대상으로 포인트 컷 적용 allService 타입 이름 패턴이 *Service 를 대상으로 포인트 컷 적용 타입 이름 패턴 : 클래스, 인터페이스 모두 적용 @Around(“allOrder() &amp;&amp; allService()”) 포인트 컷은 조합이 가능하다 &amp;&amp; : AND || : OR ! : NOT @Slf4j@Aspectpublic class AspectV3 &#123; @Pointcut(&quot;execution(* com.example.aop.order..*(..))&quot;) private void allOrder()&#123;&#125; // 클래스 이름 패턴이 *Service @Pointcut(&quot;execution(* *..*Service.*(..))&quot;) private void allService()&#123;&#125; @Around(&quot;allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; log.info(&quot;[log] &#123;&#125;&quot;, joinPoint.getSignature()); // join point 시그니처 return joinPoint.proceed(); &#125; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;allOrder() &amp;&amp; allService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125;&#125;","text":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Advice 추가 기존에 로그를 찍은 기능에서 트랜잭션 기능 추가 allOrder com.example.aop.order 하위 패키지를 대상으로 포인트 컷 적용 allService 타입 이름 패턴이 *Service 를 대상으로 포인트 컷 적용 타입 이름 패턴 : 클래스, 인터페이스 모두 적용 @Around(“allOrder() &amp;&amp; allService()”) 포인트 컷은 조합이 가능하다 &amp;&amp; : AND || : OR ! : NOT @Slf4j@Aspectpublic class AspectV3 &#123; @Pointcut(&quot;execution(* com.example.aop.order..*(..))&quot;) private void allOrder()&#123;&#125; // 클래스 이름 패턴이 *Service @Pointcut(&quot;execution(* *..*Service.*(..))&quot;) private void allService()&#123;&#125; @Around(&quot;allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; log.info(&quot;[log] &#123;&#125;&quot;, joinPoint.getSignature()); // join point 시그니처 return joinPoint.proceed(); &#125; // com.example.aop.order 하위 패키지면서 클래스 이름 패턴이 *Service 인 것 @Around(&quot;allOrder() &amp;&amp; allService()&quot;) public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable&#123; try&#123; log.info(&quot;[트랜잭션 시작] &#123;&#125;&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); log.info(&quot;[트랜잭션 커밋] &#123;&#125;&quot;, joinPoint.getSignature()); return result; &#125;catch (Exception ex)&#123; log.info(&quot;[트랜잭션 롤백] &#123;&#125;&quot;, joinPoint.getSignature()); throw ex; &#125;finally &#123; log.info(&quot;[리소스 릴리즈] &#123;&#125;&quot;, joinPoint.getSignature()); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"}],"tags":[]},{"title":"Spring AOP - Pointcut 분리","slug":"spring/spring-aop/spring-aop/spring-aop-03","date":"2021-12-11T18:31:07.000Z","updated":"2024-02-26T15:25:35.702Z","comments":true,"path":"2021/12/12/spring/spring-aop/spring-aop/spring-aop-03/","link":"","permalink":"https://ckck803.github.io/2021/12/12/spring/spring-aop/spring-aop/spring-aop-03/","excerpt":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring 핵심원리 고급편 - Pointcut 분리 하나의 Pointcut 표현식을 여러 어드바이스에서 함께 사용하는 것이 가능하다. @Pointcut 에 포인트 컷 표현식을 사용한다. 메서드 이름과 파라미터를 합처서 Signature(시그니처) 라고 한다. 메서드의 반환 타입은 void 여야 한다. 코드 내용은 비워둔다. @Slf4j@Aspectpublic class AspectV2 &#123; @Pointcut(&quot;execution(* com.example.aop.order..*(..))&quot;) private void allOrder()&#123; &#125; @Around(&quot;allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; log.info(&quot;[log] &#123;&#125;&quot;, joinPoint.getSignature()); // join point 시그니처 return joinPoint.proceed(); &#125;&#125; @Slf4j@SpringBootTest//@Import(AspectV1.class) // Bean 등록@Import(AspectV2.class)public class AopTest &#123; @Autowired OrderService orderService; @Autowired OrderRepository orderRepository; @Test public void aopTest()&#123; log.info(&quot;isAopProxy, orderService = &#123;&#125;&quot;, AopUtils.isAopProxy(orderService)); log.info(&quot;isAopProxy, orderRepository = &#123;&#125;&quot;, AopUtils.isAopProxy(orderRepository)); &#125; @Test public void success()&#123; orderService.orderItem(&quot;itemA&quot;); &#125; @Test public void exception()&#123; assertThatThrownBy(() -&gt; orderService.orderItem(&quot;ex&quot;)) .isInstanceOf(IllegalStateException.class); &#125;&#125;","text":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring 핵심원리 고급편 - Pointcut 분리 하나의 Pointcut 표현식을 여러 어드바이스에서 함께 사용하는 것이 가능하다. @Pointcut 에 포인트 컷 표현식을 사용한다. 메서드 이름과 파라미터를 합처서 Signature(시그니처) 라고 한다. 메서드의 반환 타입은 void 여야 한다. 코드 내용은 비워둔다. @Slf4j@Aspectpublic class AspectV2 &#123; @Pointcut(&quot;execution(* com.example.aop.order..*(..))&quot;) private void allOrder()&#123; &#125; @Around(&quot;allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; log.info(&quot;[log] &#123;&#125;&quot;, joinPoint.getSignature()); // join point 시그니처 return joinPoint.proceed(); &#125;&#125; @Slf4j@SpringBootTest//@Import(AspectV1.class) // Bean 등록@Import(AspectV2.class)public class AopTest &#123; @Autowired OrderService orderService; @Autowired OrderRepository orderRepository; @Test public void aopTest()&#123; log.info(&quot;isAopProxy, orderService = &#123;&#125;&quot;, AopUtils.isAopProxy(orderService)); log.info(&quot;isAopProxy, orderRepository = &#123;&#125;&quot;, AopUtils.isAopProxy(orderRepository)); &#125; @Test public void success()&#123; orderService.orderItem(&quot;itemA&quot;); &#125; @Test public void exception()&#123; assertThatThrownBy(() -&gt; orderService.orderItem(&quot;ex&quot;)) .isInstanceOf(IllegalStateException.class); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"}],"tags":[]},{"title":"Spring AOP - @Aspect","slug":"spring/spring-aop/spring-aop/spring-aop-aspect","date":"2021-12-11T17:31:07.000Z","updated":"2024-02-26T15:25:57.334Z","comments":true,"path":"2021/12/12/spring/spring-aop/spring-aop/spring-aop-aspect/","link":"","permalink":"https://ckck803.github.io/2021/12/12/spring/spring-aop/spring-aop/spring-aop-aspect/","excerpt":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 @Aspect 작동방식 실행 스프링 어플리케이션 로딩 시점에 자동 프록시 생성기 를 호출한다. 모든 @Aspect Bean 조회 스프링 컨테이너에서 @Aspect Advisor 생성 @Aspect 어드바이저 빌더 를 통해 어드바이저를 생성한다. Aspect 기반 어드바이저 저장 생성한 어드바이저를 @Aspect 어드바이저 빌더 내부에 저장한다. 자동 프록시 생성기 역할@Aspect 가 적용된 Bean 들을 조회합니다. 해당 Bean 내 정의된 Advice 와 Pointcut 표현식을 이용해 Advisor 를 생성 후 저장합니다. Bean 객체 생성시 Bean 후처리기에서 Advisor 객체를 조회해 Pointcut 표현식에 해당되는 Bean 이 있을 경우 자동 프록시 생성기에서 Advice(부가기능) 가 적용된 프록시 객체를 생성합니다. @Aspect 사용하기","text":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 @Aspect 작동방식 실행 스프링 어플리케이션 로딩 시점에 자동 프록시 생성기 를 호출한다. 모든 @Aspect Bean 조회 스프링 컨테이너에서 @Aspect Advisor 생성 @Aspect 어드바이저 빌더 를 통해 어드바이저를 생성한다. Aspect 기반 어드바이저 저장 생성한 어드바이저를 @Aspect 어드바이저 빌더 내부에 저장한다. 자동 프록시 생성기 역할@Aspect 가 적용된 Bean 들을 조회합니다. 해당 Bean 내 정의된 Advice 와 Pointcut 표현식을 이용해 Advisor 를 생성 후 저장합니다. Bean 객체 생성시 Bean 후처리기에서 Advisor 객체를 조회해 Pointcut 표현식에 해당되는 Bean 이 있을 경우 자동 프록시 생성기에서 Advice(부가기능) 가 적용된 프록시 객체를 생성합니다. @Aspect 사용하기 스프링에서 AOP 를 사용하는 가장 간단한 방법은 @Aspect 를 이용하는 방식이다. 스프링은 프록시 방식의 AOP 만 사용하므로 프록시를 통하는 메서드 만 적용 대상이 된다. @Around 는 Pointcut 으로 어디에 AOP 로직을 넣을지 결정하고 @Around 의 메서드인 doLog 는 Advice 로 부가기능 로직을 정의합니다. @Slf4j@Aspectpublic class AspectV1 &#123; @Around(&quot;execution(* com.example.aop.order..*(..))&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; log.info(&quot;[log] &#123;&#125;&quot;, joinPoint.getSignature()); // join point 시그니처 return joinPoint.proceed(); &#125;&#125; @Slf4j@SpringBootTest@Import(AspectV1.class) // Bean 등록public class AopTest &#123; @Autowired OrderService orderService; @Autowired OrderRepository orderRepository; @Test public void aopTest()&#123; log.info(&quot;isAopProxy, orderService = &#123;&#125;&quot;, AopUtils.isAopProxy(orderService)); log.info(&quot;isAopProxy, orderRepository = &#123;&#125;&quot;, AopUtils.isAopProxy(orderRepository)); &#125; @Test public void success()&#123; orderService.orderItem(&quot;itemA&quot;); &#125; @Test public void exception()&#123; assertThatThrownBy(() -&gt; orderService.orderItem(&quot;ex&quot;)) .isInstanceOf(IllegalStateException.class); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"}],"tags":[]},{"title":"Redux 사용하기 - 계산기 만들기","slug":"react/redux/redux-02-typescript","date":"2021-12-06T22:31:46.000Z","updated":"2024-11-23T16:46:05.355Z","comments":true,"path":"2021/12/07/react/redux/redux-02-typescript/","link":"","permalink":"https://ckck803.github.io/2021/12/07/react/redux/redux-02-typescript/","excerpt":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 라이브러리 설치 yarn add react-redux Action Type 정의/* 액션 타입 만들기 */// Ducks 패턴을 따를땐 액션의 이름에 접두사를 넣어주세요.// 이렇게 하면 다른 모듈과 액션 이름이 중복되는 것을 방지 할 수 있습니다.const SET_DIFF = &quot;counter/SET_DIFF&quot;;const INCREASE = &quot;counter/INCREASE&quot;;const DECREASE = &quot;counter/DECREASE&quot;; Action 생성 함수/* 액션 생성함수 만들기 */// 액션 생성함수를 만들고 export 키워드를 사용해서 내보내주세요.export const setDiff = (diff) =&gt; (&#123; type: SET_DIFF, diff &#125;);export const increase = () =&gt; (&#123; type: INCREASE &#125;);export const decrease = () =&gt; (&#123; type: DECREASE &#125;); Reducer","text":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 라이브러리 설치 yarn add react-redux Action Type 정의/* 액션 타입 만들기 */// Ducks 패턴을 따를땐 액션의 이름에 접두사를 넣어주세요.// 이렇게 하면 다른 모듈과 액션 이름이 중복되는 것을 방지 할 수 있습니다.const SET_DIFF = &quot;counter/SET_DIFF&quot;;const INCREASE = &quot;counter/INCREASE&quot;;const DECREASE = &quot;counter/DECREASE&quot;; Action 생성 함수/* 액션 생성함수 만들기 */// 액션 생성함수를 만들고 export 키워드를 사용해서 내보내주세요.export const setDiff = (diff) =&gt; (&#123; type: SET_DIFF, diff &#125;);export const increase = () =&gt; (&#123; type: INCREASE &#125;);export const decrease = () =&gt; (&#123; type: DECREASE &#125;); Reducer/* 초기 상태 선언 */const initialState = &#123; number: 0, diff: 1,&#125;;/* 리듀서 선언 */// 리듀서는 export default 로 내보내주세요.export default function counter(state = initialState, action) &#123;$$ switch (action.type) &#123; case SET_DIFF: return &#123; ...state, diff: action.diff, &#125;; case INCREASE: return &#123; ...state, number: state.number + state.diff, &#125;; case DECREASE: return &#123; ...state, number: state.number - state.diff, &#125;; default: return state; &#125;&#125; import &#123; combineReducers &#125; from &quot;redux&quot;;import counter from &quot;./counter&quot;;import todos from &quot;./todos&quot;;const rootReducer = combineReducers(&#123; todos,&#125;);export default rootReducer; Store 생성import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;import rootReducer from &#x27;./modules&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(rootReducer); // 스토어를 만듭니다.console.log(store.getState()); // 스토어의 상태를 확인해봅시다.ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&#x27;root&#x27;));// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals(); import React from &quot;react&quot;;function Counter(&#123; number, diff, onIncrease, onDecrease, onSetDiff &#125;) &#123; const onChange = (e) =&gt; &#123; // e.target.value 의 타입은 문자열이기 때문에 숫자로 변환해주어야 합니다. onSetDiff(parseInt(e.target.value, 10)); &#125;; return ( &lt;div&gt; &lt;h1&gt;&#123;number&#125;&lt;/h1&gt; &lt;div&gt; &lt;input type=&quot;number&quot; value=&#123;diff&#125; min=&quot;1&quot; onChange=&#123;onChange&#125; /&gt; &lt;button onClick=&#123;onIncrease&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrease&#125;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;export default Counter; useDispatch 를 이용해 dispatch 를 만들 import React from &quot;react&quot;;import &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import Counter from &quot;./Counter&quot;;import &#123; increase, decrease, setDiff &#125; from &quot;../modules/counter&quot;;function CounterContainer() &#123; // useSelector는 리덕스 스토어의 상태를 조회하는 Hook입니다. // state의 값은 store.getState() 함수를 호출했을 때 나타나는 결과물과 동일합니다. const &#123; number, diff &#125; = useSelector((state) =&gt; (&#123; number: state.counter.number, diff: state.counter.diff, &#125;)); // useDispatch 는 리덕스 스토어의 dispatch 를 함수에서 사용 할 수 있게 해주는 Hook 입니다. const dispatch = useDispatch(); // 각 액션들을 디스패치하는 함수들을 만드세요 const onIncrease = () =&gt; dispatch(increase()); const onDecrease = () =&gt; dispatch(decrease()); const onSetDiff = (diff) =&gt; dispatch(setDiff(diff)); return ( &lt;Counter // 상태와 number=&#123;number&#125; diff=&#123;diff&#125; // 액션을 디스패치 하는 함수들을 props로 넣어줍니다. onIncrease=&#123;onIncrease&#125; onDecrease=&#123;onDecrease&#125; onSetDiff=&#123;onSetDiff&#125; /&gt; );&#125;export default CounterContainer; import React from &quot;react&quot;;import CounterContainer from &quot;./components/CounterContainer&quot;;function App() &#123; return ( &lt;div&gt; &lt;CounterContainer /&gt; &lt;/div&gt; );&#125;export default App;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Redux","slug":"Frontend/Redux","permalink":"https://ckck803.github.io/categories/Frontend/Redux/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"Redux 사용하기 - 계산기 만들기","slug":"react/redux/redux-02","date":"2021-12-06T22:31:46.000Z","updated":"2024-11-23T16:46:05.023Z","comments":true,"path":"2021/12/07/react/redux/redux-02/","link":"","permalink":"https://ckck803.github.io/2021/12/07/react/redux/redux-02/","excerpt":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 라이브러리 설치Action 정의하기export const INCREASE = &quot;counter/INCREASE&quot; as const;export const DECREASE = &quot;counter/DECREASE&quot; as const;interface increaseAction &#123; type: typeof INCREASE;&#125;interface decreaseAction &#123; type: typeof DECREASE;&#125;export type CounterType = increaseAction | decreaseAction; Action 생성 함수export const increase = (): increaseAction =&gt; (&#123; type: INCREASE,&#125;);export const decrease = (): decreaseAction =&gt; (&#123; type: DECREASE,&#125;); Stateinterface CounterState &#123; value: number;&#125;const initialState: CounterState = &#123; value: 0,&#125;;","text":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 라이브러리 설치Action 정의하기export const INCREASE = &quot;counter/INCREASE&quot; as const;export const DECREASE = &quot;counter/DECREASE&quot; as const;interface increaseAction &#123; type: typeof INCREASE;&#125;interface decreaseAction &#123; type: typeof DECREASE;&#125;export type CounterType = increaseAction | decreaseAction; Action 생성 함수export const increase = (): increaseAction =&gt; (&#123; type: INCREASE,&#125;);export const decrease = (): decreaseAction =&gt; (&#123; type: DECREASE,&#125;); Stateinterface CounterState &#123; value: number;&#125;const initialState: CounterState = &#123; value: 0,&#125;; Reducerconst CounterReducer = ( state = initialState, action: CounterType): CounterState =&gt; &#123; switch (action.type) &#123; case INCREASE: return &#123; ...state, value: state.value + 1, &#125;; case DECREASE: return &#123; ...state, value: state.value - 1, &#125;; default: return state; &#125;&#125;;export default CounterReducer;export type CounterReturnType = ReturnType&lt;typeof CounterReducer&gt;; Storeimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; applyMiddleware, createStore &#125; from &quot;redux&quot;;import CounterReducer from &quot;./redux/CounterReducer&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import &#123; logger &#125; from &quot;redux-logger&quot;;const store = createStore(CounterReducer, applyMiddleware(logger));const root = ReactDOM.createRoot( document.getElementById(&quot;root&quot;) as HTMLElement);root.render( &lt;React.StrictMode&gt; &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;);reportWebVitals(); Appimport React, &#123; useCallback, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; CounterReturnType, decrease, increase &#125; from &quot;./redux/CounterReducer&quot;;function App() &#123; const &#123; value &#125; = useSelector((state: CounterReturnType) =&gt; (&#123; value: state.value, &#125;)); const dispatch = useDispatch(); const onClickIncrease = useCallback(() =&gt; &#123; dispatch(increase()); &#125;, []); const onClickDecrease = useCallback(() =&gt; &#123; dispatch(decrease()); &#125;, []); return ( &lt;div className=&quot;App&quot;&gt; &lt;div&gt;&#123;value&#125;&lt;/div&gt; &lt;button onClick=&#123;onClickIncrease&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;onClickDecrease&#125;&gt;-1&lt;/button&gt; &lt;/div&gt; );&#125;export default App;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Redux","slug":"Frontend/Redux","permalink":"https://ckck803.github.io/categories/Frontend/Redux/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"Redux 사용하기","slug":"react/redux/redux-01-redux","date":"2021-12-06T21:31:46.000Z","updated":"2024-11-23T16:46:05.139Z","comments":true,"path":"2021/12/07/react/redux/redux-01-redux/","link":"","permalink":"https://ckck803.github.io/2021/12/07/react/redux/redux-01-redux/","excerpt":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 Redux 사용하기 하나의 애플리케이션 안에는 하나의 Store 가 존재 State 는 읽기 전용 불변성 을 지켜줘야 한다. 객체의 경우 Spread 연산자 를 사용해 기존 객체를 덮어써준다. 배열의 불변성을 지켜주는 내장함수를 사용해야 한다. 불변성을 지켜야만 Component 들이 제대로 Rerendering 된다. 변화를 일으키는 함수, Reducer 는 순수한 함수 여야 한다. Reducer 는 이전 상태 와 Action 객체 를 파라미터로 받는다. 이전 상태를 변경하지 않고 새로운 상태를 만들어 반환한다.(불변성 유지) 똑같은 파라미터로 호출된 리듀서는 언제나 똑같은 결과값을 반환해야 한다. Redux 모듈 설치yarn add react-redux Action 상태의 변화가 필요할 경우 Action 을 일으킨다.","text":"목차 Redux Saga Redux Middleware 만들기 Redux 사용하기 - 계산기 만들기 Redux 사용하기 Redux 사용하기 하나의 애플리케이션 안에는 하나의 Store 가 존재 State 는 읽기 전용 불변성 을 지켜줘야 한다. 객체의 경우 Spread 연산자 를 사용해 기존 객체를 덮어써준다. 배열의 불변성을 지켜주는 내장함수를 사용해야 한다. 불변성을 지켜야만 Component 들이 제대로 Rerendering 된다. 변화를 일으키는 함수, Reducer 는 순수한 함수 여야 한다. Reducer 는 이전 상태 와 Action 객체 를 파라미터로 받는다. 이전 상태를 변경하지 않고 새로운 상태를 만들어 반환한다.(불변성 유지) 똑같은 파라미터로 호출된 리듀서는 언제나 똑같은 결과값을 반환해야 한다. Redux 모듈 설치yarn add react-redux Action 상태의 변화가 필요할 경우 Action 을 일으킨다. type 이라는 값이 필수적 있어야 한다. type 외에도 다른 값을 넣어줄 수 있다. &#123; type: &quot;INCREASE&quot;, data: &#123; id: 0, text: &quot;값 증가&quot; &#125;&#125; Action 생성 함수 Action 을 만들어 반환 하는 함수 파라미터를 받아와 Action 을 생성해주는 함수 Action 생성함수를 만드는게 필수적이지는 않다. const increase = () =&gt; (&#123; type: INCREASE&#125;)// test 인수를 받아와 CHANGE_TEXT 라는 Action 을 생성해준다.const changeText = text =&gt; (&#123; type: CHANGE_TEXT, text&#125;); Reducer Action type 을 이용해 변화를 일으키는 함수 state 와 action 2가지 파라미터를 가져온다. action type 을 이용해 데이터 업데이트를 진행한 후 새로운 state 를 반환한다. reducer 에서는 불변성을 유지해야 하기 때문에 state 가 객체 상태로 넘어오면 spread 연산자를 활용한다. default에서는 기존의 state를 반환하는 형태로 작성한다.(여러개의 리덕스를 합처 Root Reducer를 만들 수 있기 때문에) function reducer(state = initialState, action) &#123; switch (action.type) &#123; case INCREASE: return &#123; ...state, counter: state.counter + 1 &#125; case DECREASE: return &#123; ...state, counter: state.counter - 1 &#125; case CHANGE_TEXT: return &#123; ...state, text: action.text &#125; case ADD_TO_LIST: return &#123; ...state, list: state.list.concat(action.item) &#125; default: return state; &#125;&#125; Store State 를 관리하는 저장소로 보통은 하나의 Application 당 하나의 Store 를 만든다.현재 앱의 상태 , Reducer , 내장 함수 들을 가지고 있다. dispatch (내장 함수) dispatch 는 action 을 발생시킨다. 발생 시킨 action 은 Reducer 로 전달돼 새로운 상태를 반환한다. subscribe (내장 함수) 파라미터로 함수를 넣어주면 action 이 dispatch 될 때마다 함수가 호출 된다. import &#123; createStore &#125; from &#x27;redux&#x27;;// createStore 를 이용해 store 를 생성한다.// reducer 를 인자로 받아 생성한다.const store = createStore(reducer); store.dispatch(increase());store.dispatch(decrease());store.dispatch(changeText(&#x27;안녕하세요&#x27;));store.dispatch(addToList(&#123; id: 1, text: &#x27;와우&#x27; &#125;)); React Redux 적용react-redux 패키지의 Provider 를 이용해 store 를 등록한 후 사용하면 된다. import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;import &#123; createStore &#125; from &#x27;redux&#x27;;import rootReducer from &#x27;./modules&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;const store = createStore(rootReducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&#x27;root&#x27;));reportWebVitals();","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Redux","slug":"Frontend/Redux","permalink":"https://ckck803.github.io/categories/Frontend/Redux/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"JPA Entity - 기본키 매핑","slug":"jpa/jpa-programming/entity/entity-primary-key","date":"2021-12-04T22:31:46.000Z","updated":"2024-02-18T16:19:54.528Z","comments":true,"path":"2021/12/05/jpa/jpa-programming/entity/entity-primary-key/","link":"","permalink":"https://ckck803.github.io/2021/12/05/jpa/jpa-programming/entity/entity-primary-key/","excerpt":"목차 JPA Entity - 테이블 매핑 JPA Entity - Column 매핑 JPA Entity - 기본키 매핑 기본키 매핑 방법 직접 매핑 : @Id 자동 생성 : @GeneratedValue strategy (전략) IDENTITY : 데이터 베이스에 위임 SEQUENCE : 데이터 베이스 스퀀스 오브젝트 사용 TABLE : 키 생성용 테이블 사용, 모든 DB 에서 사용 AUTO : 방언에 따라 자동 지정 IDENTITY 전략 기본키 생성을 데이터 베이스에 위임하는 전략 MySQL, PostgreSQL, SQL Server, DB2 에서 사용한다. IDENTITY 전략 - 문제점 DataBase 에 값이 들어가야 Id 값을 알 수 있다. 영속성 Context 에서 Entity 가 관리 되기 위해서는 PK 값이 반드시 있어야 한다. JPA 는 트랜잭션 COMMIT 시점에 INSERT SQL 실행하지만 IDENTITY 전략은 persist 시점에 실행 후 DB 에서 Id 조회","text":"목차 JPA Entity - 테이블 매핑 JPA Entity - Column 매핑 JPA Entity - 기본키 매핑 기본키 매핑 방법 직접 매핑 : @Id 자동 생성 : @GeneratedValue strategy (전략) IDENTITY : 데이터 베이스에 위임 SEQUENCE : 데이터 베이스 스퀀스 오브젝트 사용 TABLE : 키 생성용 테이블 사용, 모든 DB 에서 사용 AUTO : 방언에 따라 자동 지정 IDENTITY 전략 기본키 생성을 데이터 베이스에 위임하는 전략 MySQL, PostgreSQL, SQL Server, DB2 에서 사용한다. IDENTITY 전략 - 문제점 DataBase 에 값이 들어가야 Id 값을 알 수 있다. 영속성 Context 에서 Entity 가 관리 되기 위해서는 PK 값이 반드시 있어야 한다. JPA 는 트랜잭션 COMMIT 시점에 INSERT SQL 실행하지만 IDENTITY 전략은 persist 시점에 실행 후 DB 에서 Id 조회 SEQUENCE 전략 유일한 값을 순서대로 생성하는 특별한 DB 오브젝트 ORACLE, PostgreSQL, H2 데이터 베이스에서 사용 @SequenceGenerator 를 이용해 Sequence 를 관리할 수 있다. 속성 설명 기본 값 name 식별자 생성기 이름 sequenceName DataBase 에 등록된 시퀀스 이름 initialValue DDL 생성시에만 사용됨, Seqence DDL 을 생성할 때 처음 1 시작하는 수를 지정한다. 1 allocationSize 시퀀스 한번 호출에 증가하는 수 기본 값 50 category, scheme 데이터 베이스 category, scheme 이름 TABLE 전략 키 생성 전용 테이블 을 만들어 데이터 베이스 시퀀스를 흉내내는 전략 장점 : 모든 데이터 베이스에 적용 가능 단점 : 성능 @TableGenerator 를 이용해 Sequence 를 관리한다. 속성 설명 기본 값 name 식별자 생성기 이름 필수! table 키 생성 테이블 이름 pkColumnName 시퀀스 컬럼명 valueColumnNa 시퀀스 값 컬럼명 pkColumnValue 키로 사용할 값 이름 initailValue 초기 값, 마지막으로 생성된 값이 기준 allocationSize 시퀀스 한번에 증가하는 수 기본 값 50 category, scheme 데이터 베이스 category, scheme 이름 uniqueConstraints 유니크 제약 조건을 지정할 수 있다. 권장하는 식별자 전략 기본키 제약 조건 NULL 이 아니다. 값이 Unique 하다 변해서는 안된다. 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대체키를 사용하자 (비즈니스와 관련이 없는 값) 권장하는 대체키 : Long 형 + 대체키 + 키 생성 전략 사용","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"JPA Entity - Column 매핑","slug":"jpa/jpa-programming/entity/entity-column","date":"2021-12-04T20:31:46.000Z","updated":"2024-02-18T16:19:54.528Z","comments":true,"path":"2021/12/05/jpa/jpa-programming/entity/entity-column/","link":"","permalink":"https://ckck803.github.io/2021/12/05/jpa/jpa-programming/entity/entity-column/","excerpt":"목차 JPA Entity - 테이블 매핑 JPA Entity - Column 매핑 JPA Entity - 기본키 매핑 @Column| 이름 | 기능 | 기본 값 ||: ——————————— | :————————————————————————————————————————————————— |: ——- || name | 필드와 매핑할 테이블 컬럼 이름 | 객체의 필드 이름| insertable | 등록 가능 여부 (true : 등록 가능, false : 등록 불가) | True|updatable | 변경 가능 여부 (true : 변경 가능, false : 변경 불가)| nullable (DDL) | null 값 허용 여부를 설정한다. false 일 경우 not null 제약 조건 이 생성된다. || unique (DDL) | 한 컬럼에 대한 Unique 제약 조건 을 설정한다. || columnDefinition (DDL) | 데이터 베이스 컬럼 정보를 직접 줄 수 있다. | 필드의 자바 타입| length (DDL) | 문자열 길이 제약 조건을 생성한다. (String 에서만 사용 가능) | 255| precision (DDL) scale (DDL) | BigDecimal 타입에서 사용한다. precision 은 소수점을 포함한 자릿수를 scale 은 소수의 자릿수다. double 과 float 타입에는 적용되지 않는다. | @Enumerated 자바 Enum Type 을 매핑할 때 사용 value EnumType.ORIGINAL : enum 순서를 데이터 베이스에 저장 (Integer) EnumType.STRING : enum 이름을 데이터 베이스에 저장 (String) @Temporal value TemporalType.DATE : 날짜 정보, 데이터 베이스 date 타입과 Mapping TemporalType.TIME : 시간 정보, 데이터 베이스 time 타입과 Mapping TemporalType.TIMESTAMP : 날짜와 시간, 데이터 베이스 timestamp 와 Mapping","text":"목차 JPA Entity - 테이블 매핑 JPA Entity - Column 매핑 JPA Entity - 기본키 매핑 @Column| 이름 | 기능 | 기본 값 ||: ——————————— | :————————————————————————————————————————————————— |: ——- || name | 필드와 매핑할 테이블 컬럼 이름 | 객체의 필드 이름| insertable | 등록 가능 여부 (true : 등록 가능, false : 등록 불가) | True|updatable | 변경 가능 여부 (true : 변경 가능, false : 변경 불가)| nullable (DDL) | null 값 허용 여부를 설정한다. false 일 경우 not null 제약 조건 이 생성된다. || unique (DDL) | 한 컬럼에 대한 Unique 제약 조건 을 설정한다. || columnDefinition (DDL) | 데이터 베이스 컬럼 정보를 직접 줄 수 있다. | 필드의 자바 타입| length (DDL) | 문자열 길이 제약 조건을 생성한다. (String 에서만 사용 가능) | 255| precision (DDL) scale (DDL) | BigDecimal 타입에서 사용한다. precision 은 소수점을 포함한 자릿수를 scale 은 소수의 자릿수다. double 과 float 타입에는 적용되지 않는다. | @Enumerated 자바 Enum Type 을 매핑할 때 사용 value EnumType.ORIGINAL : enum 순서를 데이터 베이스에 저장 (Integer) EnumType.STRING : enum 이름을 데이터 베이스에 저장 (String) @Temporal value TemporalType.DATE : 날짜 정보, 데이터 베이스 date 타입과 Mapping TemporalType.TIME : 시간 정보, 데이터 베이스 time 타입과 Mapping TemporalType.TIMESTAMP : 날짜와 시간, 데이터 베이스 timestamp 와 Mapping @Lob 데이터 베이스의 BLOB, CLOB 타입과 매핑할 때 사용된다. 별도로 설정할 수 있는 속성이 없다. 매핑할 수 있는 타입에 따라 매핑 타입이 다르다. 매핑하는 컬럼 타입이 문자열 : CLOB 나머지 : BLOB @Transient DB Table Column 과 객체 Field 정보를 매핑을 하고 싶지 않을 경우 사용 DB 에서 저장 및 조회가 안된다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"JPA Entity - 테이블 매핑","slug":"jpa/jpa-programming/entity/entity-table","date":"2021-12-04T19:31:46.000Z","updated":"2024-02-18T16:19:54.528Z","comments":true,"path":"2021/12/05/jpa/jpa-programming/entity/entity-table/","link":"","permalink":"https://ckck803.github.io/2021/12/05/jpa/jpa-programming/entity/entity-table/","excerpt":"목차 JPA Entity - 테이블 매핑 JPA Entity - Column 매핑 JPA Entity - 기본키 매핑 Entity 매핑에 사용하는 어노테이션 객체와 테이블 매핑 : @Entity , @Table 필드와 컬럼 매핑 : @Column 기본 키 매핑 : @Id 연관 관계 매핑 : @ManyToOne, @JoinColumn @Entity JPA 가 관리하는 클래스JPA 를 사용하기 위해서는 반드시 Entity 어노테이션을 붙여줘야 한다. 파라미터가 없는 기본 생성자를 반드시 생성해줘야 한다. final 클래스, enum, interface, inner 클래스 에는 사용이 불가능 하다. 저장할 field 에 final 키워드는 사용이 불가능하다. @Table Table 어노테이션은 Entity 와 매핑할 Database Table 을 지정한다.","text":"목차 JPA Entity - 테이블 매핑 JPA Entity - Column 매핑 JPA Entity - 기본키 매핑 Entity 매핑에 사용하는 어노테이션 객체와 테이블 매핑 : @Entity , @Table 필드와 컬럼 매핑 : @Column 기본 키 매핑 : @Id 연관 관계 매핑 : @ManyToOne, @JoinColumn @Entity JPA 가 관리하는 클래스JPA 를 사용하기 위해서는 반드시 Entity 어노테이션을 붙여줘야 한다. 파라미터가 없는 기본 생성자를 반드시 생성해줘야 한다. final 클래스, enum, interface, inner 클래스 에는 사용이 불가능 하다. 저장할 field 에 final 키워드는 사용이 불가능하다. @Table Table 어노테이션은 Entity 와 매핑할 Database Table 을 지정한다. 이름 기능 기본 값 name 매핑할 테이블 이름 Entity 이름을 사용 catalog DataBase 에 catalog 매핑 schema DataBase 에 schema 매핑 uniqueConstraints DDL 생성시에 유니크 제약 조건 생성 DataBase 스키마 자동 생성 DDL 을 애플리케이션 실행 시점에 자동 생성 운영 서버에서는 create, create-drop, update 속성을 사용해서는 안된다. 테이블 중심 –&gt; 객체 중심 데이터 베이스 방언을 활용해서 데이터 베이스에 적절한 DDL 을 생성한다. 옵션 설명 create 기존 테이블을 DROP 한 후 CREATE 한다. (어플리케이션 종료한 후에도 테이블 유지) create-drop 기존 테이블을 DROP 한 후 CREATE 한다. (어플리케이션 종료시점에 테이블 DROP) update 기존 테이블을 DROP 하지 않고 변경된 부분만 반영 (ALTER) validate Entity 와 Table 이 정상적으로 매핑 됐는지 확인한다. none 아무 작업도 진행하지 않는다. create 기존 테이블을 DROP 한 후 CREATE 한다. Hibernate: drop table Member if existsHibernate: create table Member ( id bigint not null, name varchar(255), primary key (id) ) create-drop 기존 테이블을 DROP 한 후 CREATE 한다. (어플리케이션 종료시점에 테이블 DROP) Hibernate: drop table Member if existsHibernate: create table Member ( id bigint not null, name varchar(255), primary key (id) )Hibernate: /* select m from Member as m */ select member0_.id as id1_0_, member0_.name as name2_0_ from Member member0_ limit ? offset ?Hibernate: drop table Member if exists update 기존 테이블을 DROP 하지 않고 변경된 부분만 반영 (ALTER) Hibernate: alter table Member add column age integer not null validate Entity 와 Table 이 정상적으로 매핑 됐는지 확인한다. SchemaManagementException Exception in thread &quot;main&quot; javax.persistence.PersistenceException: [PersistenceUnit: hello] Unable to build Hibernate SessionFactory at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.persistenceException(EntityManagerFactoryBuilderImpl.java:1016) at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:942) at org.hibernate.jpa.HibernatePersistenceProvider.createEntityManagerFactory(HibernatePersistenceProvider.java:56) at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:79) at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:54) at hellojpa.JpaMain.main(JpaMain.java:13)Caused by: org.hibernate.tool.schema.spi.SchemaManagementException: Schema-validation: missing column [location] in table [Member] at org.hibernate.tool.schema.internal.AbstractSchemaValidator.validateTable(AbstractSchemaValidator.java:136) at org.hibernate.tool.schema.internal.GroupedSchemaValidatorImpl.validateTables(GroupedSchemaValidatorImpl.java:42) at org.hibernate.tool.schema.internal.AbstractSchemaValidator.performValidation(AbstractSchemaValidator.java:89) at org.hibernate.tool.schema.internal.AbstractSchemaValidator.doValidation(AbstractSchemaValidator.java:68) at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:191) at org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:72) at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:310) at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:467) at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:939) ... 4 more","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"Spring AOP - 용어 정리","slug":"spring/spring-aop/aspect/aop-aspect-02","date":"2021-12-03T22:31:07.000Z","updated":"2024-02-26T15:22:00.039Z","comments":true,"path":"2021/12/04/spring/spring-aop/aspect/aop-aspect-02/","link":"","permalink":"https://ckck803.github.io/2021/12/04/spring/spring-aop/aspect/aop-aspect-02/","excerpt":"목차 Spring AOP - Advice 종류 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring AOP - Aspect 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 조인 포인트 (JoinPoint) 어드바이스가 적용될 수 있는 위치 메소드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로그램 실행 중 지점 AOP 를 적용할 수 있는 모든 지점(추상적인 개념) Spring AOP 는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 시점으로 제한된다. 포인트 컷 (Pointcut) 어드바이스가 적용될 위치를 선별하는 기능","text":"목차 Spring AOP - Advice 종류 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring AOP - Aspect 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 조인 포인트 (JoinPoint) 어드바이스가 적용될 수 있는 위치 메소드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로그램 실행 중 지점 AOP 를 적용할 수 있는 모든 지점(추상적인 개념) Spring AOP 는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 시점으로 제한된다. 포인트 컷 (Pointcut) 어드바이스가 적용될 위치를 선별하는 기능 AspectJ 표현식을 사용해서 지정 프록시를 사용하는 Spring AOP 는 메서드 실행 시점만 포인트 컷으로 선별 가능 타겟 (Target) 부가기능(어드바이스)이 적용되는 객체 Pointcut 으로 특정 객체에 Advice 를 적용합니다. Advice 부가기능 조인 포인트에서 Aspect 에 의해 취해지는 조치 Around, Before, After 와 같은 다양한 종류의 어드바이스가 있다. Aspect 어드바이스와 포인트 컷을 모듈화 한 것 Advisor 하나의 어드바이스와 하나의 포인트 컷으로 구성 Spring AOP 에서만 사용되는 용어","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"AOP Aspect","slug":"Spring/Spring-AOP/AOP-Aspect","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/AOP-Aspect/"}],"tags":[]},{"title":"Spring AOP - 적용 방식","slug":"spring/spring-aop/aspect/aop-aspect-01","date":"2021-12-02T22:31:07.000Z","updated":"2024-02-26T15:21:55.501Z","comments":true,"path":"2021/12/03/spring/spring-aop/aspect/aop-aspect-01/","link":"","permalink":"https://ckck803.github.io/2021/12/03/spring/spring-aop/aspect/aop-aspect-01/","excerpt":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring AOP - Aspect 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 횡단 관심 사항횡단 관심 사항(Cross-cutting Concern)은 애플리케이션 전반에서 공통적으로 사용되는 기능입니다. 즉, 여러 모듈에서 공통으로 사용되는 기능으로서, 여러 코드에 걸쳐 분산되어 있을 수 있습니다. 이러한 횡단 관심 사항은 핵심 비즈니스 로직과 분리되어 있기 때문에 애플리케이션의 유지 보수성과 확장성에 영향을 미칩니다. 횡단 관심 사항의 예로는 로깅, 보안, 트랜잭션 처리 등이 있습니다. 예를 들어, 여러 모듈에서 공통적으로 로그를 출력해야 한다면, 모든 코드에 로그를 출력하는 코드를 추가해야 합니다. 하지만 이러한 방식은 유지 보수성이 떨어지고 코드 중복이 발생합니다. 이를 해결하기 위해 로그 출력과 같은 공통 기능을 모듈화하고 재사용 가능한 코드로 만들어주는 것이 바로 AOP의 역할입니다. AOP를 사용하면 핵심 로직 코드를 수정하지 않고도 횡단 관심 사항을 처리할 수 있습니다. 즉, 공통 기능을 모듈화하여 애플리케이션 전반에서 쉽게 사용할 수 있게 됩니다. 이를 통해 애플리케이션의 유지 보수성과 확장성이 향상되며, 코드의 가독성도 높아지는 등의 장점을 가집니다. Spring AOP AOP 를 사용하면 핵심기능 과 부가기능 이 코드상 완전히 분리 된다.","text":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring AOP - Aspect 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 횡단 관심 사항횡단 관심 사항(Cross-cutting Concern)은 애플리케이션 전반에서 공통적으로 사용되는 기능입니다. 즉, 여러 모듈에서 공통으로 사용되는 기능으로서, 여러 코드에 걸쳐 분산되어 있을 수 있습니다. 이러한 횡단 관심 사항은 핵심 비즈니스 로직과 분리되어 있기 때문에 애플리케이션의 유지 보수성과 확장성에 영향을 미칩니다. 횡단 관심 사항의 예로는 로깅, 보안, 트랜잭션 처리 등이 있습니다. 예를 들어, 여러 모듈에서 공통적으로 로그를 출력해야 한다면, 모든 코드에 로그를 출력하는 코드를 추가해야 합니다. 하지만 이러한 방식은 유지 보수성이 떨어지고 코드 중복이 발생합니다. 이를 해결하기 위해 로그 출력과 같은 공통 기능을 모듈화하고 재사용 가능한 코드로 만들어주는 것이 바로 AOP의 역할입니다. AOP를 사용하면 핵심 로직 코드를 수정하지 않고도 횡단 관심 사항을 처리할 수 있습니다. 즉, 공통 기능을 모듈화하여 애플리케이션 전반에서 쉽게 사용할 수 있게 됩니다. 이를 통해 애플리케이션의 유지 보수성과 확장성이 향상되며, 코드의 가독성도 높아지는 등의 장점을 가집니다. Spring AOP AOP 를 사용하면 핵심기능 과 부가기능 이 코드상 완전히 분리 된다. 스프링 AOP(Aspect-Oriented Programming)는 애플리케이션에서 공통적으로 사용되는 기능들을 모듈화하고, 재사용 가능한 코드로 만들어주는 모듈화 기능입니다. 이를 통해 애플리케이션에서 각각의 객체에서 반복되는 코드를 줄일 수 있으며, 객체 간의 결합도를 낮출 수 있습니다. 스프링 AOP는 프록시 기반의 AOP 방식을 사용합니다. 스프링에서는 AOP 구현을 위해 XML 기반 AOP 와 Annotation 기반 AOP 두 가지 방식을 제공합니다. Spring AOP 구성 요소 Aspect, Advice, JoinPoint, Pointcut 으로 구성됩니다. Aspect 애플리케이션 전반에서 공통으로 사용되는 기능을 모듈화한 것입니다. Advice Aspect에서 구현한 기능을 말하며, 횡단 관심 사항을 구현한 구체적인 메소드입니다. Before, After, Around 등의 Advice 유형이 있습니다. JoinPoint Advice가 적용될 위치입니다. 메소드 호출, 필드 접근 등이 JoinPoint가 될 수 있습니다. Pointcut Join point의 집합으로, Advice가 적용될 Join point를 선택합니다. AOP 적용 시점AOP 는 적용 되는 시점따라 컴파일 시점, 클래스 로딩 시점, 런타임 시점 세가지로 나눌 수 있습니다. 1. 컴파일 시점에 AOP 적용 - 바이트 코드 조작 자바 소스를 자바 바이트 코드로 컴파일 하는 시점에 부가 기능 로직을 추가 첫번째는 컴파일 시 AOP 가 적용되는 시점입니다. 컴파일러가 소스 코드를 바이트 코드 로 변환할 때, AOP 코드를 함께 조합합니다. 이 방식은 코드가 컴파일 되는 시점에 AOP가 적용되기 때문에, 애플리케이션의 실행 시간에 성능 문제가 발생할 확률이 낮습니다. 하지만 AOP를 적용하기 위해서는 코드의 재컴파일이 필요하기 때문에, 런타임에 동적으로 로딩되는 클래스에 대해서는 적용할 수 없습니다. 컴파일 시점에 AOP 를 적용하기 위해서는 AspectJ에서 제공하는 특별한 컴파일러를 사용해야 합니다. 원본 로직에 부가기능 로직이 추가되는 것을 Weaving 이라고 한다. 2. 클래스 로딩 시점에 AOP 적용 - class 파일 조작 자바 바이트 코드를 JVM 내 메모리 영역에 올리기 전에 부가기능 로직을 추가한다. 두번째는 클래스를 로딩 시 AOP 코드를 적용하여 class 파일 생성시 조작 방식 입니다. 이 방식은 런타임에 동적으로 로딩되는 클래스에 대해서도 AOP를 적용할 수 있으며, 애플리케이션의 실행 시간에 성능 문제가 발생할 확률이 낮습니다. 하지만 클래스를 로딩하는 시점에서 AOP 코드가 적용되기 때문에, 애플리케이션의 시작 시간이 느려질 수 있습니다. 클래스 로딩시점에 AOP 를 적용하는 것을 로드 타임 위빙 이라고 한다. 자바를 실행할 때 특별한 옵션을 통해 클래스 로더 조작기를 지정해야 한다. 3. 런타임 시점에 AOP 적용 어플리케이션이 실행중일 때 부가기능 로직을 추가한다. Spring AOP에서는 기본적으로 런타임 시점에 AOP가 적용됩니다. 세번째 방식은 애플리케이션이 실행되는 시점에 AOP 코드를 적용하는 런타임 시 적용하는 방식입니다. 이 방식은 애플리케이션의 실행 중에도 AOP를 적용할 수 있으며, 컴파일 시점이나 로드 시점에 비해 자유도가 높습니다. 하지만 AOP 코드를 적용하는 과정에서 애플리케이션의 성능에 영향을 미칠 수 있습니다. Spring AOP에서는 기본적으로 런타임 시 AOP 가 적용됩니다. 하지만 필요에 따라 컴파일 시점이나 로드 시점에서 AOP를 적용할 수 있도록 옵션을 제공합니다. 프록시 방식의 AOP 는 프록시를 통해야 부가기능을 사용할 수 있어 final, 생성자 와 같은 것에서는 AOP 기능을 적용하기 어려운 제한이 있습니다. AOP 적용 위치 AOP 적용 가능 위치 (JoinPoint) 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행 AOP 를 적용할 수 있는 위치를 JoinPoint 라고 한다. AspectJ 를 사용하면 컴파일 시점 과 클래스 로딩 시점 에서 AOP 를 적용할 수 있다. Spring AOP 는 프록시 방식을 사용해 AOP 를 적용하기 때문에 메서드 실행 시점 에만 AOP 를 적용할 수 있다. 프록시는 메서드 오버라이딩 개명으로 작동한다. 프록시를 사용하는 Spring AOP 의 JoinPoint 는 메서드 실행으로 제한된다. 스프링 컨에티너에서 관리하는 Bean 에만 Spring AOP 를 적용할 수 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"}],"tags":[]},{"title":"JAVA - String","slug":"java/string","date":"2021-12-02T14:16:32.000Z","updated":"2024-02-18T16:19:54.527Z","comments":true,"path":"2021/12/02/java/string/","link":"","permalink":"https://ckck803.github.io/2021/12/02/java/string/","excerpt":"StringStringBuilderStringBuffer","text":"StringStringBuilderStringBuffer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"}],"tags":[]},{"title":"JAVA - Garbage Collection(가비지 컬렉션)","slug":"computer-science/java/garbage-collection","date":"2021-12-02T14:16:32.000Z","updated":"2024-02-18T16:19:54.517Z","comments":true,"path":"2021/12/02/computer-science/java/garbage-collection/","link":"","permalink":"https://ckck803.github.io/2021/12/02/computer-science/java/garbage-collection/","excerpt":"목차 Post not found: computer-science/java/gc-tunning JAVA - Garbage Collection(가비지 컬렉션) JAVA - JVM (자바 가상 머신) JAVA - Garbage Collection(가비지 컬렉션) 동적 할당 받은 메모리 중에서 사용하지 않는 메모리를 해제해 메모리 누수를 막는 메모리 관리 기법 memory leak 을 없앨 수 있다. GC Root가 될 수 있는 대상들 Stack 영역의 데이터 Static 데이터 JNI에 의해 생성된 객체들 Mark And Sweep 알고리즘 참조가 유효한 Object를 Reachable 참조가 유효하지 않은 Object를 Unreachable 이라고 부른다. Mark GC Root로부터 모든 변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹하는 과정 Mark 과정에서 Reachable 한 객체와 Unreachable 한 객체를 스캔한다 Sweep Unreachable한 객체를 Heap 에서 제거하는 과정 Compact Sweep 후 분산된 객체들을 모아 메모리 단편화 가 이뤄지는 것을 막아준다.","text":"목차 Post not found: computer-science/java/gc-tunning JAVA - Garbage Collection(가비지 컬렉션) JAVA - JVM (자바 가상 머신) JAVA - Garbage Collection(가비지 컬렉션) 동적 할당 받은 메모리 중에서 사용하지 않는 메모리를 해제해 메모리 누수를 막는 메모리 관리 기법 memory leak 을 없앨 수 있다. GC Root가 될 수 있는 대상들 Stack 영역의 데이터 Static 데이터 JNI에 의해 생성된 객체들 Mark And Sweep 알고리즘 참조가 유효한 Object를 Reachable 참조가 유효하지 않은 Object를 Unreachable 이라고 부른다. Mark GC Root로부터 모든 변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹하는 과정 Mark 과정에서 Reachable 한 객체와 Unreachable 한 객체를 스캔한다 Sweep Unreachable한 객체를 Heap 에서 제거하는 과정 Compact Sweep 후 분산된 객체들을 모아 메모리 단편화 가 이뤄지는 것을 막아준다. Garbage Collection 작동 방식 Grabage Collection 은 크게 New Generation 에서 일어나는 Minor GC 와 Old Generation 에서 일어나는 Major GC 가 있다. Eden 영역에 새로운 객체 가 할당된다. Eden 영역이 가득 차게 되면 Gabage Collection 이 발생한다. (Minor GC) 살아 있는 객체는 Survivor 0 영역으로 이동한다. (Age 값이 증가한다.) Unreachable 한 객체는 사라진다. 또 다시 Eden 영역이 가득차게되면 Eden 영역과 Survivor 0 영역을 대상으로 Gabage Collection 이 발생한다. 살아 있는 객체는 Survivor 1 영역으로 이동하게 된다. 두 Survivor 공간 중 하나는 항상 비어 있어야 한다. 한 객체가 양쪽 Survivor 영역에 존재해서는 안된다. 특정 Age 값을 넘어가게 되면 Old Generation 으로 넘어가게 된다 (Promoted) Old Generation 영역이 가득차게 되면 Gabage Collection 이 발생한다 (Major GC) Gabage Collection 종류GC 는 크게 Young Generation 에서 발생하는 Minor GC 와 Old Generation 에서 발생하는 Major GC 두가지 타입으로 나뉜다. Stop the world Gabage Collection이 일어나는 동안 JVM 어플리케이션 실행이 멈추는 것 , GC를 실행하는 Thread 외 모든 Thread는 작업을 정지한다. Serial GC CPU 코어가 하나일 경우 사용하기 위한 방식으로 GC를 실행하는 Thread 가 하나다. 운영에서 절대 사용하면 안되는 GC Stop the world 시간이 다른 GC에 비해 길다. Mark &amp; Sweep &amp; Compact 알고리즘을 사용 Paralle GC 여러개의 Thread를 이용해 GC를 처리한다. Young 영역의 GC는 멀티 스레드 방식을 사용하기 때문에 Serial GC 에 비해 Stop The World 가 짧다. Java 8의 Default GC Concurrent Mark And Sweep(CMS) GC Stop the Wolrd 로 Application이 멈추는 현상을 줄이기 위해 만들어진 GCInitial Mark , Concurrent Mark , Remark , Concurrent Sweep 의 4가지 과정이 있다. Initial Mark GC Root가 참조하는 객체만을 마킹한다. Stop the World 가 발생한다. Concurrent Mark GC 대상의 객체가 참조하는 다른 객체들을 찾아 다니면서 추가적인 GC 대상을 마킹한다. Remark Concurrent Mark 단계를 검즌하는 과정 GC 대상이 추가적으로 확인 됐거나 참조가 제거 됐는지 등 확인한다. Stop The World 가 발생한다. Concurrent Sweep GC 대상을 삭제하는 과정 G1 GC Heap 영역을 여러개의 Region으로 나누고 각 Region 에서 Young Gen 과 Old Gen 을 유동적으로 사용하는 GC 전체 Heap 을 탐색하는 것이 아닌 Region 단위로 탐색해 Region 단위로 GC가 발생한다. 현재 GC 중에서 Stop The World 가 가장 짧다. JDK 11 에서 G1 GC 를 default로 채택했다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Programming Lanuage","slug":"CS/Programming-Lanuage","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/"},{"name":"JAVA","slug":"CS/Programming-Lanuage/JAVA","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/JAVA/"}],"tags":[]},{"title":"JAVA - JWT","slug":"java/jwt/jwt-01","date":"2021-12-02T14:16:32.000Z","updated":"2024-02-18T16:19:54.527Z","comments":true,"path":"2021/12/02/java/jwt/jwt-01/","link":"","permalink":"https://ckck803.github.io/2021/12/02/java/jwt/jwt-01/","excerpt":"JAVA - JWT Jwts.builder(JwtBuilder) 를 이용해 Token 을 생성하고 Jwts.parserBuilder(JwtParserBuilder) 를 이용해 전달 받은 Token 을 Parsing 한다. public class JwtMain &#123; public static void main(String args[]) &#123; String jwt = Jwts.builder() .setSubject(&quot;test&quot;) .compact(); Jwt&lt;Header, Claims&gt; headerClaimsJwt = Jwts.parserBuilder() .build() .parseClaimsJwt(jwt); // Token 정보를 가져온다. System.out.println(&quot;token : &quot; + jwt); // JWT Header 정보를 가져온다. System.out.println(&quot;JWT Header : &quot; + headerClaimsJwt.getHeader()); // JWT Body(Claims) 정보를 가져온다. System.out.println(&quot;JWT Claims : &quot; + headerClaimsJwt.getBody()); &#125;&#125; Token 에 서명을 진행하지 않았기 때문에 Signature 부분이 빠져있는 것을 확인할 수 있다. token : eyJhbGciOiJub25lIn0.eyJzdWIiOiJ0ZXN0In0.JWT Header : &#123;alg=none&#125;JWT Claims : &#123;sub=test&#125; JWT 암호화 (JWS) JwtBuilder 객체는 signWith 메소드를 이용해 Key 값과 암호 알고리즘 을 인자값으로 넘겨줘 서명한다. 서명의 유효성은 JwtParserBuilder 객체가 setSigningKey 메소드를 이용해 전달받은 Token 이 유효한지 확인한다. public class JwsMain &#123; public static String key = &quot;amF2YS1hcHBsaWNhdGlvbi1zZWN1cmUtc3R1ZHktand0LXNlY3JldGtleS1pcy1zaG91bGQtYmUtYmlnZ2VyLXRoYW4tNTEyYml0cw==&quot;; public static Long tokenValidityInMilliseconds = 100000L; public static void main(String args[]) &#123; Key secretKey = Keys.hmacShaKeyFor(key.getBytes()); String jwt = Jwts.builder() .setSubject(&quot;test&quot;) .signWith(secretKey, SignatureAlgorithm.HS512) // JWT 를 암호화 하기 위한 secret 과 알고리즘을 넣어준다. .compact(); Jws&lt;Claims&gt; claimsJws = Jwts.parserBuilder() .setSigningKey(secretKey) .build() .parseClaimsJws(jwt); Header header = claimsJws.getHeader(); Claims body = claimsJws.getBody(); System.out.println(&quot;token : &quot; + jwt); System.out.println(&quot;JWT Header : &quot; + header); System.out.println(&quot;JWT Claims : &quot; + body); &#125;&#125;","text":"JAVA - JWT Jwts.builder(JwtBuilder) 를 이용해 Token 을 생성하고 Jwts.parserBuilder(JwtParserBuilder) 를 이용해 전달 받은 Token 을 Parsing 한다. public class JwtMain &#123; public static void main(String args[]) &#123; String jwt = Jwts.builder() .setSubject(&quot;test&quot;) .compact(); Jwt&lt;Header, Claims&gt; headerClaimsJwt = Jwts.parserBuilder() .build() .parseClaimsJwt(jwt); // Token 정보를 가져온다. System.out.println(&quot;token : &quot; + jwt); // JWT Header 정보를 가져온다. System.out.println(&quot;JWT Header : &quot; + headerClaimsJwt.getHeader()); // JWT Body(Claims) 정보를 가져온다. System.out.println(&quot;JWT Claims : &quot; + headerClaimsJwt.getBody()); &#125;&#125; Token 에 서명을 진행하지 않았기 때문에 Signature 부분이 빠져있는 것을 확인할 수 있다. token : eyJhbGciOiJub25lIn0.eyJzdWIiOiJ0ZXN0In0.JWT Header : &#123;alg=none&#125;JWT Claims : &#123;sub=test&#125; JWT 암호화 (JWS) JwtBuilder 객체는 signWith 메소드를 이용해 Key 값과 암호 알고리즘 을 인자값으로 넘겨줘 서명한다. 서명의 유효성은 JwtParserBuilder 객체가 setSigningKey 메소드를 이용해 전달받은 Token 이 유효한지 확인한다. public class JwsMain &#123; public static String key = &quot;amF2YS1hcHBsaWNhdGlvbi1zZWN1cmUtc3R1ZHktand0LXNlY3JldGtleS1pcy1zaG91bGQtYmUtYmlnZ2VyLXRoYW4tNTEyYml0cw==&quot;; public static Long tokenValidityInMilliseconds = 100000L; public static void main(String args[]) &#123; Key secretKey = Keys.hmacShaKeyFor(key.getBytes()); String jwt = Jwts.builder() .setSubject(&quot;test&quot;) .signWith(secretKey, SignatureAlgorithm.HS512) // JWT 를 암호화 하기 위한 secret 과 알고리즘을 넣어준다. .compact(); Jws&lt;Claims&gt; claimsJws = Jwts.parserBuilder() .setSigningKey(secretKey) .build() .parseClaimsJws(jwt); Header header = claimsJws.getHeader(); Claims body = claimsJws.getBody(); System.out.println(&quot;token : &quot; + jwt); System.out.println(&quot;JWT Header : &quot; + header); System.out.println(&quot;JWT Claims : &quot; + body); &#125;&#125; Token 에 서명을 했기 때문에 Signature 부분이 추가 돼 있다. Json Web token = eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJEb25nd29vIiwiQXV0aCI6IllhbmciLCJleHAiOjE2Mzg1MjU5NTV9.2EQQCgVcXMIjfHMjl14HpCg9pT6_r5nM7KKOsmSXr7I6IS3I20XpDSXvuVGMU4FQrsXsszYmj8vWAly3ovSb2gJSON : &#123;sub=Dongwoo, Auth=Yang&#125; 서명 키(Secret) 와 관련된 예외 서명에 들어가는 secret 값을 짧게 하면 다음과 같은 예외가 발생한다. Exception in thread &quot;main&quot; io.jsonwebtoken.security.WeakKeyException: The specified key byte array is 152 bits which is not secure enough for any JWT HMAC-SHA algorithm. The JWT JWA Specification (RFC 7518, Section 3.2) states that keys used with HMAC-SHA algorithms MUST have a size &gt;= 256 bits (the key size must be greater than or equal to the hash output size). JWT 유효 시간 설정 JwtBuilder 객체가 setExpiration 메소드를 이용해 Token 유효시간을 설정한다. public class JwsTimeMain &#123; public static String key = &quot;amF2YS1hcHBsaWNhdGlvbi1zZWN1cmUtc3R1ZHktand0LXNlY3JldGtleS1pcy1zaG91bGQtYmUtYmlnZ2VyLXRoYW4tNTEyYml0cw==&quot;; public static String AUTHENTICATION = &quot;Auth&quot;; public static Long tokenValidityInMilliseconds = 100000L; public static void main(String args[]) throws ParseException &#123; Key secretKey = Keys.hmacShaKeyFor(key.getBytes()); Date date = new Date(System.currentTimeMillis()+ tokenValidityInMilliseconds); String jwt = Jwts.builder() .setSubject(&quot;test&quot;) .claim(AUTHENTICATION, &quot;jwt&quot;) .signWith(secretKey, SignatureAlgorithm.HS512) .setExpiration(date) .compact(); Jws&lt;Claims&gt; claimsJws = Jwts.parserBuilder() .setSigningKey(secretKey) .build() .parseClaimsJws(jwt); Header header = claimsJws.getHeader(); Claims body = claimsJws.getBody(); System.out.println(&quot;token : &quot; + jwt); System.out.println(&quot;JWT Header : &quot; + header); System.out.println(&quot;JWT Claims : &quot; + body); System.out.println(&quot;expiration time : &quot; + body.get(&quot;exp&quot;, Date.class)); System.out.println(&quot;expiration time : &quot; + body.getExpiration()); System.out.println(&quot;sub : &quot; + body.get(&quot;sub&quot;)); System.out.println(&quot;Auth : &quot; + body.get(&quot;Auth&quot;)); &#125;&#125; 전달 받은 토큰은 JwtParser 객체를 이용해 Parsing 하게 될 때 유효시간을 넘기면 ExpiredJwtException 예외가 발생하게 된다. Exception in thread &quot;main&quot; io.jsonwebtoken.ExpiredJwtException: JWT expired at 2021-12-04T04:41:07Z. Current time: 2021-12-04T04:41:07Z, a difference of 500 milliseconds. Allowed clock skew: 0 milliseconds. JWT 에서 발생할 수 있는 예외 예외 설명 SignatureException JWT 를 인증하기 위한 검증 secret 이 잘 못 됐을 경우 발생 ExpiredJwtException 토큰의 유효시간이 만료했을 때 발생 UnsupportedJwtException 수신한 JWT 가 Application에서 원하는 형식과 일치하지 않는 경우 발생 테스트 코드를 이용해 확인하기서명 암 복호화 키가 서로 다른 경우 - SignatureException@Testpublic void create_token_jws_SignatureException() throws InterruptedException &#123; Key key = Keys.hmacShaKeyFor(secrete.getBytes(StandardCharsets.UTF_8)); Key key2 = Keys.hmacShaKeyFor((secrete+&quot;abcd&quot;).getBytes(StandardCharsets.UTF_8)); String token = Jwts.builder() .setSubject(&quot;test&quot;) .signWith(key, SignatureAlgorithm.HS512) .compact(); assertThrows(SignatureException.class, () -&gt; &#123; Jwts.parserBuilder() .setSigningKey(key2) .build() .parseClaimsJws(token); &#125;);&#125; 토큰 시간이 만료된 경우 - ExpiredJwtExceptionsetExpiration 메소드를 이용한 Tokne 유효시간이 지나게 되면 ExpiredJwtException 예외가 발생한다. Exception in thread &quot;main&quot; io.jsonwebtoken.ExpiredJwtException: JWT expired at 2021-12-03T04:49:50Z. Current time: 2021-12-03T04:49:51Z, a difference of 1163 milliseconds. Allowed clock skew: 0 milliseconds. at io.jsonwebtoken.impl.DefaultJwtParser.parse(DefaultJwtParser.java:448) at io.jsonwebtoken.impl.DefaultJwtParser.parse(DefaultJwtParser.java:550) at io.jsonwebtoken.impl.DefaultJwtParser.parseClaimsJws(DefaultJwtParser.java:610) at io.jsonwebtoken.impl.ImmutableJwtParser.parseClaimsJws(ImmutableJwtParser.java:173) at JwtMain.main(JwtMain.java:31) @Testpublic void create_token_jws_ExpiredJwtException() throws InterruptedException &#123; Key key = Keys.hmacShaKeyFor(secrete.getBytes(StandardCharsets.UTF_8)); Long tokenValidityInMilliseconds = 100L; Date date = new Date(System.currentTimeMillis() + tokenValidityInMilliseconds); String token = Jwts.builder() .setSubject(&quot;test&quot;) .setExpiration(date) .signWith(key, SignatureAlgorithm.HS512) .compact(); // token Time Out을 일으키기 위한 Sleep Thread.sleep(1000L); assertThrows(ExpiredJwtException.class, () -&gt; &#123; Jwts.parserBuilder() .setSigningKey(key) .build() .parseClaimsJws(token); &#125;);&#125; 다른 유형의 Token을 전달 받은 경우 UnsupportedJwtException 전달 받은 Token 과 Parsing 방법이 일치하지 않을 경우 UnsupportedJwtException 예외가 발생 한다. 서명된 JWT(JWS) 를 parseClaimsJwt 메소드를 이용해 Parsing 할 경우 발생한다. @Testpublic void create_token_jws_UnsupportedJwtException()&#123; Key key = Keys.hmacShaKeyFor(secrete.getBytes(StandardCharsets.UTF_8)); String token = Jwts.builder() .setSubject(&quot;test&quot;) .signWith(key, SignatureAlgorithm.HS512) .compact(); // JWS 를 parseClaimsJwt 메소드를 이용해 Parsing 할 경우 UnsupportedJwtException 예외가 발생한다. assertThrows(UnsupportedJwtException.class, () -&gt; &#123; Jwts.parserBuilder() .setSigningKey(key) .build() .parseClaimsJwt(token); &#125;);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"}],"tags":[]},{"title":"JAVA - JVM (자바 가상 머신)","slug":"computer-science/java/jvm","date":"2021-12-02T12:16:32.000Z","updated":"2024-02-18T16:19:54.517Z","comments":true,"path":"2021/12/02/computer-science/java/jvm/","link":"","permalink":"https://ckck803.github.io/2021/12/02/computer-science/java/jvm/","excerpt":"목차 Post not found: computer-science/java/gc-tunning JAVA - Garbage Collection(가비지 컬렉션) JAVA - JVM (자바 가상 머신) JVM (자바 가상 머신) 자바 컴파일러에 의해 생성된 자바 바이트 코드(.class) 를 OS에 맞는 기계어로 변환해 실행할 수 있게 해준다.클래스 파일로 떨어질 수 있으면 어떤 언어라도 실행이 가능하다. (ex. kotlin) 자바 컴파일러에 의해 생성된 바이트 코드를 실행하는 표준이자 구현체다. JVM은 각 OS(운영체제) 에 맞게 설계가 돼 있다. 자바 바이트 코드만 있으면 JVM을 이용해 어느 운영체제에서나 실행이 가능하다. Stack 기반 가상 머신 JVM 구조 Class Loader, Memory, 실행 엔진(Execution Engine) 이 세가지로 구성 돼 있다.","text":"목차 Post not found: computer-science/java/gc-tunning JAVA - Garbage Collection(가비지 컬렉션) JAVA - JVM (자바 가상 머신) JVM (자바 가상 머신) 자바 컴파일러에 의해 생성된 자바 바이트 코드(.class) 를 OS에 맞는 기계어로 변환해 실행할 수 있게 해준다.클래스 파일로 떨어질 수 있으면 어떤 언어라도 실행이 가능하다. (ex. kotlin) 자바 컴파일러에 의해 생성된 바이트 코드를 실행하는 표준이자 구현체다. JVM은 각 OS(운영체제) 에 맞게 설계가 돼 있다. 자바 바이트 코드만 있으면 JVM을 이용해 어느 운영체제에서나 실행이 가능하다. Stack 기반 가상 머신 JVM 구조 Class Loader, Memory, 실행 엔진(Execution Engine) 이 세가지로 구성 돼 있다. Class Loader 클래스 파일에서 바이트 코드 를 읽고 메모리 에 저장한다.로딩, 링크, 초기화 세가지 과정을 거친다. 로딩 클래스로더가 클래스 파일을 읽고 Binary 데이터 를 생성한 뒤 Method 영역 에 저장한다. 로딩이 끝나면 해당 클래스 타입의 객체 를 생성한 후 Heap 영역에 저장한다. 링크 verify : 클래스 파일 이 유효한지 확인한다. 바이트 코드가 조작됐을 경우 에러를 발생 Prepare : 메모리 준비과정 Resolve : 객체들을 실제 레퍼런스에 연결한다. 초기화 static 값을 초기화 하고 변수를 할당하는 과정 클래스 로더 종류 부트 스트랩 클래스 로더 JAVA_HOME&#x2F;jre&#x2F;lib 디렉터리에 위치한 핵심 자바 라이브러리들을 불러들인다 확장 클래스 로더 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 또는 java.ext.dirs 시스템 변수에 위치해 있는 라이브러리들을 읽어들인다. 애플리케이션 클래스 로더 애플리케이션 클래스패스(애플리케이션 실행할 때 주는 -classpath 옵션 또는 java.class.path 환경 변수의 값에 해당하는 위치)에서 클래스를 읽는다. 메모리 스택 영역 각 Thread마다 스택 영역이 존재한다. 프로그램 실행과정에서 일시적으로 할당받고 소멸하는 영역 메서드 호출시 Stack Frame이 생성되며 메서드 정보, 지역변수들을 저장한다. 메서드가 종료되면 삭제된다. PC(Program Counter) 쓰레드 마다 다음 실행해야 할 명령어 정보가 저장 된다. Native method stack 바이트 코드가 아닌 기계어로 작성된 프로그램이 저장되는 영역 힙 영역 모든 인스턴스 객체(Object)가 저장되는 영역 JVM에 하나 밖에 없는 공유 자원 이다. 메소드 영역 클래스 수준의 정보 (클래스 이름, 부모 클래스 이름, 메소드, 변수등)가 저장 되고, 공유되는 영역이다. 모든 JVM 스레드에서 공유하는 메모리 영역 실행엔진 인터프리터 바이트 코드를 한줄 한줄 실행한다. JIT(Just In Time) 컴파일러 인터프리터 방식의 단점을 보완하기 위해 도입된 컴파일러 바이트 코드를 네이티브 코드로 컴파일 해준다. 일정 수준 이상으로 실행되는 코드가 존재할 때 해당 바이트 코드를 컴파일 한다.(Caching) 컴파일 한 결과물은 JVM 내 CodeCache 에 저장 된다. GC(Gabage Collection) 참조되지 않는 객체를 정리한다. JVM Default Heap Size 확인java -XX:+PrintFlagsFinal -version 2&gt;&amp;1 | grep -i -E &#x27;heapsize|MetaspaceSize|version&#x27;","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Programming Lanuage","slug":"CS/Programming-Lanuage","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/"},{"name":"JAVA","slug":"CS/Programming-Lanuage/JAVA","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/JAVA/"}],"tags":[]},{"title":"Spring AOP - Aspect","slug":"spring/spring-aop/aspect/aspect-01","date":"2021-12-02T09:31:07.000Z","updated":"2024-02-26T15:22:05.760Z","comments":true,"path":"2021/12/02/spring/spring-aop/aspect/aspect-01/","link":"","permalink":"https://ckck803.github.io/2021/12/02/spring/spring-aop/aspect/aspect-01/","excerpt":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring AOP - Aspect 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. Aspect 부가 기능 과 부가 기능 을 어디에 적용할지 적용할지를 정의 Aspect 는 애플리케이션 전반에서 공통적으로 사용되는 기능들을 모듈화하고, 재사용 가능한 코드로 만들어주는 모듈화 기능입니다. Aspect 를 사용한 프로그래밍을 관점 지향 프로그래밍 AOP (Aspect-Oriented Programming) 이라 합니다. AOP 를 적용함으로써 핵심 로직 코드를 수정하지 않고도 횡단 관심 사항(cross-cutting concern) 을 처리할 수 있습니다. Spring에서는 Aspect를 정의하기 위해 @Aspect 어노테이션을 사용하며, Aspect를 구현하기 위해 @Before, @After, @Around 등의 Advice 어노테이션을 사용합니다. 이러한 어노테이션을 사용하여 Advice를 구현하고, @Pointcut 어노테이션을 사용하여 Pointcut을 정의합니다. Aspect를 구현하여 애플리케이션 전반에 걸쳐 공통 기능을 모듈화하고 재사용 가능한 코드로 만들 수 있습니다. 이를 통해 애플리케이션의 유지 보수성과 확장성을 향상시킬 수 있습니다.","text":"목차 Spring AOP - Advice 종류 Spring AOP - 트랜잭션 순서 Spring AOP - Pointcut 참조 Spring AOP - 어드바이스 추가 Spring AOP - Pointcut 분리 Spring AOP - @Aspect Spring AOP - 용어 정리 Spring AOP - 적용 방식 Spring AOP - Aspect 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. Aspect 부가 기능 과 부가 기능 을 어디에 적용할지 적용할지를 정의 Aspect 는 애플리케이션 전반에서 공통적으로 사용되는 기능들을 모듈화하고, 재사용 가능한 코드로 만들어주는 모듈화 기능입니다. Aspect 를 사용한 프로그래밍을 관점 지향 프로그래밍 AOP (Aspect-Oriented Programming) 이라 합니다. AOP 를 적용함으로써 핵심 로직 코드를 수정하지 않고도 횡단 관심 사항(cross-cutting concern) 을 처리할 수 있습니다. Spring에서는 Aspect를 정의하기 위해 @Aspect 어노테이션을 사용하며, Aspect를 구현하기 위해 @Before, @After, @Around 등의 Advice 어노테이션을 사용합니다. 이러한 어노테이션을 사용하여 Advice를 구현하고, @Pointcut 어노테이션을 사용하여 Pointcut을 정의합니다. Aspect를 구현하여 애플리케이션 전반에 걸쳐 공통 기능을 모듈화하고 재사용 가능한 코드로 만들 수 있습니다. 이를 통해 애플리케이션의 유지 보수성과 확장성을 향상시킬 수 있습니다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"AspectJ","slug":"Spring/Spring-AOP/AspectJ","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/AspectJ/"}],"tags":[]},{"title":"BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용","slug":"spring/spring-aop/bean-post-processor/bean-post-processor-04","date":"2021-11-29T13:31:07.000Z","updated":"2024-02-26T15:22:35.755Z","comments":true,"path":"2021/11/29/spring/spring-aop/bean-post-processor/bean-post-processor-04/","link":"","permalink":"https://ckck803.github.io/2021/11/29/spring/spring-aop/bean-post-processor/bean-post-processor-04/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor - AutoProxyCreator BeanPostProcessor 를 이용한 프록시 객체 생성 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 여러개의 Advisor 적용빈 후처리기에서 프록시 객체 생성시 여러개의 포인트컷에 해당되는 객체가 있습니다. 객체가 여러개의 포인트 컷에 해당되더라도 프록시 객체는 한개만 생성됩니다. Advisor1 의 포인트 컷만 만족 프록시 객체 1개 생성, advisor1 만 포함 Advisor1, Advisor2 의 포인트 컷 모두 만족 프록시 객체 1개 생성, advisor1, advisor2 모두 포함 Advisor1, Advisor2 의 포인트 컷 모두 만족하지 않음 프록시 객체를 생성하지 않음 하나의 프록시에 여러개의 Advisor하나의 프록시 객체에 여러개의 Advisor 를 포함하는 형태로 프록시 객체가 생성됩니다.","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor - AutoProxyCreator BeanPostProcessor 를 이용한 프록시 객체 생성 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 여러개의 Advisor 적용빈 후처리기에서 프록시 객체 생성시 여러개의 포인트컷에 해당되는 객체가 있습니다. 객체가 여러개의 포인트 컷에 해당되더라도 프록시 객체는 한개만 생성됩니다. Advisor1 의 포인트 컷만 만족 프록시 객체 1개 생성, advisor1 만 포함 Advisor1, Advisor2 의 포인트 컷 모두 만족 프록시 객체 1개 생성, advisor1, advisor2 모두 포함 Advisor1, Advisor2 의 포인트 컷 모두 만족하지 않음 프록시 객체를 생성하지 않음 하나의 프록시에 여러개의 Advisor하나의 프록시 객체에 여러개의 Advisor 를 포함하는 형태로 프록시 객체가 생성됩니다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Bean Post Processor","slug":"Spring/Spring-AOP/Bean-Post-Processor","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Bean-Post-Processor/"}],"tags":[]},{"title":"BeanPostProcessor - AutoProxyCreator","slug":"spring/spring-aop/bean-post-processor/bean-post-processor-03","date":"2021-11-29T12:31:07.000Z","updated":"2024-02-26T15:22:30.858Z","comments":true,"path":"2021/11/29/spring/spring-aop/bean-post-processor/bean-post-processor-03/","link":"","permalink":"https://ckck803.github.io/2021/11/29/spring/spring-aop/bean-post-processor/bean-post-processor-03/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor - AutoProxyCreator BeanPostProcessor 를 이용한 프록시 객체 생성 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 라이브러리 추가implementation &#x27;org.springframework.boot:spring-boot-starter-aop&#x27; //추가 자동 프록시 생성기 - AutoProxyCreator 스프링에서 AnnotationAwareAspectJAutoProxyCreator 라는 빈 후처리기가 등록됩니다. AnnotationAwareAspectJAutoProxyCreator 는 스프링 빈으로 등록된 Advisor 를 자동으로 찾아 프록시 객체를 생성해줍니다. 또한, @AspectJ 와 관련된 AOP 기능도 자동으로 찾아서 처리해줍니다. Bean 으로 등록하기 위한 객체를 생성 후 빈 후처리기에 전달합니다. 빈 후처리기 중 자동 프록시 생성 빈 후처리기에서 모든 Advisor 를 조회합니다. Advisor 에 포함된 Pointcut 을 사용해 프록시를 적용할 대상인지 확인합니다. 이때 객체의 패키지정보, 클래스 정보 와 해당 객체내 모든 메소드를 하나하나씩 매칭합니다.","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor - AutoProxyCreator BeanPostProcessor 를 이용한 프록시 객체 생성 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 라이브러리 추가implementation &#x27;org.springframework.boot:spring-boot-starter-aop&#x27; //추가 자동 프록시 생성기 - AutoProxyCreator 스프링에서 AnnotationAwareAspectJAutoProxyCreator 라는 빈 후처리기가 등록됩니다. AnnotationAwareAspectJAutoProxyCreator 는 스프링 빈으로 등록된 Advisor 를 자동으로 찾아 프록시 객체를 생성해줍니다. 또한, @AspectJ 와 관련된 AOP 기능도 자동으로 찾아서 처리해줍니다. Bean 으로 등록하기 위한 객체를 생성 후 빈 후처리기에 전달합니다. 빈 후처리기 중 자동 프록시 생성 빈 후처리기에서 모든 Advisor 를 조회합니다. Advisor 에 포함된 Pointcut 을 사용해 프록시를 적용할 대상인지 확인합니다. 이때 객체의 패키지정보, 클래스 정보 와 해당 객체내 모든 메소드를 하나하나씩 매칭합니다. Pointcut 조건이 하나라도 만족하면 해당 객체는 프록시 객체가 됩니다. AutoProxyCreator 에서 반환된 프록시 객체는 스프링 Bean 저장소에 Bean 으로 저장됩니다. @Configuration@Import(&#123;AppV1Config.class, AppV2Config.class&#125;)public class AutoProxyConfig &#123; @Bean public Advisor advisor1(LogTrace logTrace) &#123; // 이름 기반으로 한 NameMatchMethodPointcut NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut(); pointcut.setMappedNames(&quot;request*&quot;, &quot;order*&quot;, &quot;save*&quot;); // advice LogTraceAdvice advice = new LogTraceAdvice(logTrace); return new DefaultPointcutAdvisor(pointcut, advice); &#125;&#125; 포인트 컷의 사용 프록시 객체 생성 여부 판단 - 생성 단계 프록시 생성단계에서 해당 빈이 프록시를 생성할 필요가 있는지 없는지 여부 판단하는데 사용합니다. 클래스, 메소드 조건 모두 비교, 이때 모든 메소드를 확인합니다. 조건에 맞는 메서드가 하나라도 있으면 프록시 객체로 생성합니다. 어드바이스 적용 여부 판단 - 사용 단계 프록시가 호출 됐을 때 어드바이스를 적용할지 여부를 포인트 컷을 이용해 확인한다. orderControllerV1 의 request 메서드는 포인트 컷 조건에 만족하므로 Advice 를 먼저 호출한다. orderControllerV1 의 nolog 메서드는 포인트 컷 조건을 만족하지 않으므로 Advice 를 호출하지 않는다. AspectJExpressionPointcut AspectJ 표현식을 사용해 프록시 객체를 생성할 수 있습니다. AspectJExpressionPointcut 는 AsepctJ 표현식을 사용해 프록시 객체를 생성할 수 있습니다. AspectJExpressionPointcut: AspectJ 표현식을 사용한 Advisor 생성 execution(* hello.proxy.app..*(..)): AspectJ 에서 제공하는 포인트컷 표현식 *: 모든 반환 타입 hello.proxy.app.. 해당 패키지와 그 하위 패키지 *(..) * : 모든 메서드 이름 (..) : 파라미터는 상관 없음 @Beanpublic Advisor advisor2(LogTrace logTrace) &#123; // AspectJ 문법을 기반으로 한 AspectJExpressionPointcut AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(&quot;execution(* hello.proxy.app..*(..))&quot;); // advice LogTraceAdvice advice = new LogTraceAdvice(logTrace); return new DefaultPointcutAdvisor(pointcut, advice);&#125; 해당 표현식으로 적용하면 no-log 에서도 로그가 찍히는 것을 확인할 수 있다. 2021-12-05 21:47:28.731 INFO 70615 --- [nio-8080-exec-6] h.p.trace.logtrace.ThreadLocalLogTrace : [afe68ae8] OrderControllerV1Impl.noLog()2021-12-05 21:47:28.732 INFO 70615 --- [nio-8080-exec-6] h.p.trace.logtrace.ThreadLocalLogTrace : [afe68ae8] OrderControllerV1Impl.noLog() time=1ms &amp;&amp; 와 || 등을 이용해 포인트컷 표현식을 다양하게 조합할 수 있습니다. @Beanpublic Advisor advisor3(LogTrace logTrace) &#123; // Point Cut AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(&quot;execution(* hello.proxy.app..*(..)) &amp;&amp; !execution(*hello.proxy.app..noLog(..))&quot;); // advice LogTraceAdvice advice = new LogTraceAdvice(logTrace); return new DefaultPointcutAdvisor(pointcut, advice);&#125; Spring Bean 후처리기 하나의 프록시에 여러개의 Advisor 적용프록시 자동 생성기 Advisor1 의 포인트 컷만 만족 프록시 1개 생성, advisor1 만 포함 Advisor1, Advisor2 의 포인트 컷 모두 만족 프록시 1개 생성, advisor1, advisor2 모두 포함 Advisor1, Advisor2 의 포인트 컷 모두 만족하지 않음 프록시를 생성하지 않음","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Bean Post Processor","slug":"Spring/Spring-AOP/Bean-Post-Processor","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Bean-Post-Processor/"}],"tags":[]},{"title":"BeanPostProcessor 를 이용한 프록시 객체 생성","slug":"spring/spring-aop/bean-post-processor/bean-post-processor-02","date":"2021-11-29T11:31:07.000Z","updated":"2024-02-26T15:22:27.318Z","comments":true,"path":"2021/11/29/spring/spring-aop/bean-post-processor/bean-post-processor-02/","link":"","permalink":"https://ckck803.github.io/2021/11/29/spring/spring-aop/bean-post-processor/bean-post-processor-02/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor - AutoProxyCreator BeanPostProcessor 를 이용한 프록시 객체 생성 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory &#x2F; 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. https://www.baeldung.com/spring-beanpostprocessor BeanPostProcessor 를 이용한 프록시 객체 생성빈 후처리기를 이용해 Bean 생성시점에 프록시 객체를 생성할 수 있습니다. 다만, 스프링에 등록되는 모든 빈들은 빈 후처리기로 넘어옵니다. 그래서 모든 Bean 에 대해 BeanPostProcessor 로직이 수행되므로 어떤 Bean 을 Proxy Bean 으로 생성할지에 대한 기준이 필요하다. BeanPostProcessor 를 이용한 프록시 객체 생성 과정빈 후처리기를 이용해 프록시 객체를 생성하는 방법은 4가지 단계가 있습니다. 첫번째는 Bean 대상이 되는 객체를 생성합니다. 두번째는 생성된 객체를 빈 후처리기에 전달합니다. 셋번째는 빈 후처리기에서 전달 받은 객체를 이용해 프록시 객체를 생성 후 반환합니다. 네번째 빈 후처리기에서 반환된 프록시 객체를 Bean 저장소에 등록합니다.","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor - AutoProxyCreator BeanPostProcessor 를 이용한 프록시 객체 생성 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory &#x2F; 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. https://www.baeldung.com/spring-beanpostprocessor BeanPostProcessor 를 이용한 프록시 객체 생성빈 후처리기를 이용해 Bean 생성시점에 프록시 객체를 생성할 수 있습니다. 다만, 스프링에 등록되는 모든 빈들은 빈 후처리기로 넘어옵니다. 그래서 모든 Bean 에 대해 BeanPostProcessor 로직이 수행되므로 어떤 Bean 을 Proxy Bean 으로 생성할지에 대한 기준이 필요하다. BeanPostProcessor 를 이용한 프록시 객체 생성 과정빈 후처리기를 이용해 프록시 객체를 생성하는 방법은 4가지 단계가 있습니다. 첫번째는 Bean 대상이 되는 객체를 생성합니다. 두번째는 생성된 객체를 빈 후처리기에 전달합니다. 셋번째는 빈 후처리기에서 전달 받은 객체를 이용해 프록시 객체를 생성 후 반환합니다. 네번째 빈 후처리기에서 반환된 프록시 객체를 Bean 저장소에 등록합니다. 프록시 객체 생성 예 - PackageLogTracePostProcessor 생성PackageLogTracePostProcessor 는 넘어온 Bean 의 Package 를 확인 후 Proxy 객체 를 생성합니다. Package 이름이 설정된 basePackage 로 시작하면 Proxy 객체를 반환하고 아닐 경우에는 그대로를 다시 반환한다. @Slf4jpublic class PackageLogTracePostProcessor implements BeanPostProcessor &#123; private final String basePackage; private final Advisor advisor; public PackageLogTracePostProcessor(String basePackage, Advisor advisor) &#123; this.basePackage = basePackage; this.advisor = advisor; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; log.info(&quot;param beanName = &#123;&#125; bean = &#123;&#125;&quot;, beanName, bean.getClass()); // 프록시 적용 대상 여부 체크 // 프록시 적용 대상이 아니면 원본을 그대로 진행 String packageName = bean.getClass().getPackageName(); if (!packageName.startsWith(basePackage)) &#123; return bean; &#125; // 프록시 대상이면 프록시를 만들어서 반환 ProxyFactory proxyFactory = new ProxyFactory(bean); proxyFactory.addAdvisor(advisor); Object proxy = proxyFactory.getProxy(); log.info(&quot;create Proxy : target = &#123;&#125; proxy = &#123;&#125;&quot;, bean.getClass(), proxy.getClass()); // 프록시 객체를 반환한다. return proxy; &#125;&#125; BeanPostProcessor 등록 logTracePostProcessor 특정 패키지를 기준으로 Proxy 를 생성하는 BeanProcessor 를 Spring Bean 으로 등록 한다. BeanProcessor 를 Bean 으로 등록하면 자동으로 동작한다. @Slf4j@Configuration@Import(&#123;AppV1Config.class, AppV2Config.class&#125;)public class BeanPostProcessorConfig &#123; @Bean public PackageLogTracePostProcessor logTracePostProcessor(LogTrace logTrace)&#123; // hello.proxy.app 패키지에 속한 클래스만 적용된다. return new PackageLogTracePostProcessor(&quot;hello.proxy.app&quot;, getAdvisor(logTrace)); &#125; private Advisor getAdvisor(LogTrace logTrace) &#123; // Point Cut NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut(); pointcut.setMappedNames(&quot;request*&quot;, &quot;order*&quot;, &quot;save*&quot;); // advice LogTraceAdvice advice = new LogTraceAdvice(logTrace); // Pointcut 과 Advice 를 이용해 Advisor 객체를 생성한다. return new DefaultPointcutAdvisor(pointcut, advice); &#125;&#125; @Import(BeanPostProcessorConfig.class)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Bean Post Processor","slug":"Spring/Spring-AOP/Bean-Post-Processor","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Bean-Post-Processor/"}],"tags":[]},{"title":"BeanPostProcessor","slug":"spring/spring-aop/bean-post-processor/bean-post-processor-01","date":"2021-11-29T09:31:07.000Z","updated":"2024-02-26T15:22:12.280Z","comments":true,"path":"2021/11/29/spring/spring-aop/bean-post-processor/bean-post-processor-01/","link":"","permalink":"https://ckck803.github.io/2021/11/29/spring/spring-aop/bean-post-processor/bean-post-processor-01/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor - AutoProxyCreator BeanPostProcessor 를 이용한 프록시 객체 생성 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. https://www.baeldung.com/spring-beanpostprocessor BeanPostProcessor Spring Bean 을 등록하는 시점에 특정 로직을 수행하기 위해 사용하는 hook (LifeCycle 에 간섭할 수 있다.)Spring Bean 전체에 공통 로직을 수행할 때 사용하면 유용하다 BeanPostProcessor 는 Bean 의 생성과 초기화를 제어하는 인터페이스입니다. 이 인터페이스를 사용하면 스프링 빈이 생성되고 초기화되는 과정에서 추가적인 작업을 수행할 수 있습니다. 예를 들어, 스프링 빈의 필드를 초기화하거나, 빈 객체의 프록시를 생성하는 등의 작업을 수행할 수 있습니다. BeanPostProcessor 인터페이스","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor - AutoProxyCreator BeanPostProcessor 를 이용한 프록시 객체 생성 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. https://www.baeldung.com/spring-beanpostprocessor BeanPostProcessor Spring Bean 을 등록하는 시점에 특정 로직을 수행하기 위해 사용하는 hook (LifeCycle 에 간섭할 수 있다.)Spring Bean 전체에 공통 로직을 수행할 때 사용하면 유용하다 BeanPostProcessor 는 Bean 의 생성과 초기화를 제어하는 인터페이스입니다. 이 인터페이스를 사용하면 스프링 빈이 생성되고 초기화되는 과정에서 추가적인 작업을 수행할 수 있습니다. 예를 들어, 스프링 빈의 필드를 초기화하거나, 빈 객체의 프록시를 생성하는 등의 작업을 수행할 수 있습니다. BeanPostProcessor 인터페이스public interface BeanPostProcessor &#123; @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125;&#125; postProcessBeforeInitialization Bean 이 초기화되기 전에 호출되는 메소드 postProcessAfterInitialization Bean 이 초기화된 후에 호출되는 메소드 BeanPostProcessor 생성BeanPostProcessor 인터페이스를 구현한 AToBPostProcessor 에서는 Bean 이 초기화 된후 넘어온 객체가 A 일 경우 B 객체로 새로 생성해 반환한다. @Slf4jstatic class AToBPostProcessor implements BeanPostProcessor&#123; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; log.info(&quot;beanName = &#123;&#125; bean = &#123;&#125;&quot;, beanName, bean); // 넘어온 Bean 이 A 객체일 경우 B 를 반환한다. if(bean instanceof A)&#123; return new B(); &#125; return bean; &#125;&#125; @Testvoid BasicConfig()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanPostProcessorConfig.class); // beanA 이름으로 B 객체가 Bean으로 등록된다. B b = applicationContext.getBean(&quot;beanA&quot;, B.class); b.helloA(); // A 는 빈으로 등록되지 않는다. assertThrows(NoSuchBeanDefinitionException.class, () -&gt; &#123; applicationContext.getBean(A.class); &#125;);&#125;@Slf4j@Configurationstatic class BeanPostProcessorConfig&#123; @Bean(name = &quot;beanA&quot;) public A a()&#123; return new A(); &#125; // Bean 후처리기 AToBPostProcessor 를 Bean 으로 등록한다. @Bean public AToBPostProcessor helloPostProcessor () &#123; return new AToBPostProcessor(); &#125;&#125;@Slf4jstatic class A&#123; public void helloA()&#123; log.info(&quot;hello A&quot;); &#125;&#125;@Slf4jstatic class B&#123; public void helloA()&#123; log.info(&quot;hello B&quot;); &#125;&#125; 09:39:32.378 [Test worker] INFO hello.proxy.postprocessor.BasicTest$AToBPostProcessor - beanName = beanA bean = hello.proxy.postprocessor.BasicTest$A@4b4dd21609:39:32.398 [Test worker] INFO hello.proxy.postprocessor.BasicTest$B - hello B","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Bean Post Processor","slug":"Spring/Spring-AOP/Bean-Post-Processor","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Bean-Post-Processor/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - ProxyFactory 적용","slug":"spring/spring-aop/spring-proxy/spring-proxy-07","date":"2021-11-27T21:31:07.000Z","updated":"2024-02-26T15:26:43.192Z","comments":true,"path":"2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-07/","link":"","permalink":"https://ckck803.github.io/2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-07/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 인터페이스 객체에 프록시 팩토리 적용스프링에서 제공하는 MethodInterceptor 인터페이스를 이용해 import org.aopalliance.intercept.MethodInterceptor;public class LogTraceAdvice implements MethodInterceptor &#123; private final LogTrace logTrace; public LogTraceAdvice(LogTrace logTrace) &#123; this.logTrace = logTrace; &#125; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; TraceStatus status = null; try &#123; Method method = invocation.getMethod(); String message = method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName() + &quot;()&quot;; status = logTrace.begin(message); // 로직 호출 Object result = invocation.proceed(); logTrace.end(status); return result; &#125; catch (Exception ex) &#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; @Slf4j@Configurationpublic class ProxyFactoryConfigV1 &#123; @Bean public OrderControllerV1 orderControllerV1(LogTrace logTrace)&#123; OrderControllerV1 orderController = new OrderControllerV1Impl(orderServiceV1(logTrace)); // OrderControllerV1 객체를 Proxy 객체로 생성한다. ProxyFactory factory = new ProxyFactory(orderController); factory.addAdvisor(getAdvisor(logTrace)); // Advisor 를 적용한다. OrderControllerV1 proxy = (OrderControllerV1) factory.getProxy(); log.info(&quot;ProxyFactory proxy = &#123;&#125;, target = &#123;&#125;&quot;, proxy.getClass(), orderController); return proxy; &#125; @Bean public OrderServiceV1 orderServiceV1(LogTrace logTrace)&#123; OrderServiceV1Impl orderService = new OrderServiceV1Impl(orderRepositoryV1(logTrace)); // OrderServiceV1Impl 객체를 Proxy 객체로 생성한다. ProxyFactory factory = new ProxyFactory(orderService); factory.addAdvisor(getAdvisor(logTrace)); // Advisor 를 적용한다. OrderServiceV1 proxy = (OrderServiceV1) factory.getProxy(); log.info(&quot;ProxyFactory proxy = &#123;&#125;, target = &#123;&#125;&quot;, proxy.getClass(), orderService); return proxy; &#125; @Bean public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace)&#123; OrderRepositoryV1Impl orderRepository = new OrderRepositoryV1Impl(); // OrderRepositoryV1Impl 객체를 Proxy 객체로 생성한다. ProxyFactory factory = new ProxyFactory(orderRepository); factory.addAdvisor(getAdvisor(logTrace)); // Advisor 를 적용한다. OrderRepositoryV1 proxy = (OrderRepositoryV1) factory.getProxy(); log.info(&quot;ProxyFactory proxy = &#123;&#125;, target = &#123;&#125;&quot;, proxy.getClass(), orderRepository); return proxy; &#125; private Advisor getAdvisor(LogTrace logTrace) &#123; // Point Cut NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut(); pointcut.setMappedNames(&quot;request*&quot;, &quot;order*&quot;, &quot;save*&quot;); // advice LogTraceAdvice advice = new LogTraceAdvice(logTrace); // Pointcut과 Advice 를 이용해 Advisor 객체를 만들어준다. return new DefaultPointcutAdvisor(pointcut, advice); &#125;&#125; 애플리케이션 로딩 시점에서 해당 Bean 이 Loading 되는 것을 확인할 수 있다. 2021-12-05 01:09:21.671 INFO 64531 --- [ main] h.p.c.v.ProxyFactoryConfigV1 : ProxyFactory proxy = class com.sun.proxy.$Proxy50, target = hello.proxy.app.v1.OrderRepositoryV1Impl@5555ffcf2021-12-05 01:09:21.673 INFO 64531 --- [ main] h.p.c.v.ProxyFactoryConfigV1 : ProxyFactory proxy = class com.sun.proxy.$Proxy52, target = hello.proxy.app.v1.OrderServiceV1Impl@5a2fa51f2021-12-05 01:09:21.674 INFO 64531 --- [ main] h.p.c.v.ProxyFactoryConfigV1 : ProxyFactory proxy = class com.sun.proxy.$Proxy53, target = hello.proxy.app.v1.OrderControllerV1Impl@6ecdbab8","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 인터페이스 객체에 프록시 팩토리 적용스프링에서 제공하는 MethodInterceptor 인터페이스를 이용해 import org.aopalliance.intercept.MethodInterceptor;public class LogTraceAdvice implements MethodInterceptor &#123; private final LogTrace logTrace; public LogTraceAdvice(LogTrace logTrace) &#123; this.logTrace = logTrace; &#125; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; TraceStatus status = null; try &#123; Method method = invocation.getMethod(); String message = method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName() + &quot;()&quot;; status = logTrace.begin(message); // 로직 호출 Object result = invocation.proceed(); logTrace.end(status); return result; &#125; catch (Exception ex) &#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; @Slf4j@Configurationpublic class ProxyFactoryConfigV1 &#123; @Bean public OrderControllerV1 orderControllerV1(LogTrace logTrace)&#123; OrderControllerV1 orderController = new OrderControllerV1Impl(orderServiceV1(logTrace)); // OrderControllerV1 객체를 Proxy 객체로 생성한다. ProxyFactory factory = new ProxyFactory(orderController); factory.addAdvisor(getAdvisor(logTrace)); // Advisor 를 적용한다. OrderControllerV1 proxy = (OrderControllerV1) factory.getProxy(); log.info(&quot;ProxyFactory proxy = &#123;&#125;, target = &#123;&#125;&quot;, proxy.getClass(), orderController); return proxy; &#125; @Bean public OrderServiceV1 orderServiceV1(LogTrace logTrace)&#123; OrderServiceV1Impl orderService = new OrderServiceV1Impl(orderRepositoryV1(logTrace)); // OrderServiceV1Impl 객체를 Proxy 객체로 생성한다. ProxyFactory factory = new ProxyFactory(orderService); factory.addAdvisor(getAdvisor(logTrace)); // Advisor 를 적용한다. OrderServiceV1 proxy = (OrderServiceV1) factory.getProxy(); log.info(&quot;ProxyFactory proxy = &#123;&#125;, target = &#123;&#125;&quot;, proxy.getClass(), orderService); return proxy; &#125; @Bean public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace)&#123; OrderRepositoryV1Impl orderRepository = new OrderRepositoryV1Impl(); // OrderRepositoryV1Impl 객체를 Proxy 객체로 생성한다. ProxyFactory factory = new ProxyFactory(orderRepository); factory.addAdvisor(getAdvisor(logTrace)); // Advisor 를 적용한다. OrderRepositoryV1 proxy = (OrderRepositoryV1) factory.getProxy(); log.info(&quot;ProxyFactory proxy = &#123;&#125;, target = &#123;&#125;&quot;, proxy.getClass(), orderRepository); return proxy; &#125; private Advisor getAdvisor(LogTrace logTrace) &#123; // Point Cut NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut(); pointcut.setMappedNames(&quot;request*&quot;, &quot;order*&quot;, &quot;save*&quot;); // advice LogTraceAdvice advice = new LogTraceAdvice(logTrace); // Pointcut과 Advice 를 이용해 Advisor 객체를 만들어준다. return new DefaultPointcutAdvisor(pointcut, advice); &#125;&#125; 애플리케이션 로딩 시점에서 해당 Bean 이 Loading 되는 것을 확인할 수 있다. 2021-12-05 01:09:21.671 INFO 64531 --- [ main] h.p.c.v.ProxyFactoryConfigV1 : ProxyFactory proxy = class com.sun.proxy.$Proxy50, target = hello.proxy.app.v1.OrderRepositoryV1Impl@5555ffcf2021-12-05 01:09:21.673 INFO 64531 --- [ main] h.p.c.v.ProxyFactoryConfigV1 : ProxyFactory proxy = class com.sun.proxy.$Proxy52, target = hello.proxy.app.v1.OrderServiceV1Impl@5a2fa51f2021-12-05 01:09:21.674 INFO 64531 --- [ main] h.p.c.v.ProxyFactoryConfigV1 : ProxyFactory proxy = class com.sun.proxy.$Proxy53, target = hello.proxy.app.v1.OrderControllerV1Impl@6ecdbab8 구체클래스에 프록시 팩토리 적용 구체 클래스에 적용 @Slf4j@Configurationpublic class ProxyFactoryConfigV2 &#123; @Bean public OrderControllerV2 orderControllerV2(LogTrace logTrace)&#123; OrderControllerV2 orderController = new OrderControllerV2(orderServiceV2(logTrace)); // OrderControllerV2 객체를 Proxy 객체로 생성 ProxyFactory factory = new ProxyFactory(orderController); factory.addAdvisor(getAdvisor(logTrace)); OrderControllerV2 proxy = (OrderControllerV2) factory.getProxy(); log.info(&quot;ProxyFactory proxy = &#123;&#125;, target = &#123;&#125;&quot;, proxy.getClass(), orderController); return proxy; &#125; @Bean public OrderServiceV2 orderServiceV2(LogTrace logTrace)&#123; OrderServiceV2 orderService = new OrderServiceV2(orderRepositoryV2(logTrace)); // OrderServiceV2 객체를 Proxy 객체로 생성 ProxyFactory factory = new ProxyFactory(orderService); factory.addAdvisor(getAdvisor(logTrace)); OrderServiceV2 proxy = (OrderServiceV2) factory.getProxy(); log.info(&quot;ProxyFactory proxy = &#123;&#125;, target = &#123;&#125;&quot;, proxy.getClass(), orderService); return proxy; &#125; @Bean public OrderRepositoryV2 orderRepositoryV2(LogTrace logTrace)&#123; OrderRepositoryV2 orderRepository = new OrderRepositoryV2(); // OrderRepositoryV2 객체를 Proxy 객체로 생성 ProxyFactory factory = new ProxyFactory(orderRepository); factory.addAdvisor(getAdvisor(logTrace)); OrderRepositoryV2 proxy = (OrderRepositoryV2) factory.getProxy(); log.info(&quot;ProxyFactory proxy = &#123;&#125;, target = &#123;&#125;&quot;, proxy.getClass(), orderRepository); return proxy; &#125; private Advisor getAdvisor(LogTrace logTrace) &#123; // Point Cut NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut(); pointcut.setMappedNames(&quot;request*&quot;, &quot;order*&quot;, &quot;save*&quot;); // advice LogTraceAdvice advice = new LogTraceAdvice(logTrace); // Pointcut 과 Advice 를 이용해 Advisor 객체를 생성한다. return new DefaultPointcutAdvisor(pointcut, advice); &#125;&#125; CGLIB 로 생성된 것을 확인할 수 있다. 2021-12-05 01:18:11.287 INFO 64747 --- [ main] h.p.c.v.ProxyFactoryConfigV2 : ProxyFactory proxy = class hello.proxy.app.v2.OrderRepositoryV2$$EnhancerBySpringCGLIB$$47389dce, target = hello.proxy.app.v2.OrderRepositoryV2@75961f162021-12-05 01:18:11.292 INFO 64747 --- [ main] h.p.c.v.ProxyFactoryConfigV2 : ProxyFactory proxy = class hello.proxy.app.v2.OrderServiceV2$$EnhancerBySpringCGLIB$$9b88cbf1, target = hello.proxy.app.v2.OrderServiceV2@2dd2e2702021-12-05 01:18:11.295 INFO 64747 --- [ main] h.p.c.v.ProxyFactoryConfigV2 : ProxyFactory proxy = class hello.proxy.app.v2.OrderControllerV2$$EnhancerBySpringCGLIB$$493fc484, target = hello.proxy.app.v2.OrderControllerV2@7d04529c","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Spring Proxy","slug":"Spring/Spring-AOP/Spring-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Spring-Proxy/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용","slug":"spring/spring-aop/spring-proxy/spring-proxy-06-multi-advisor","date":"2021-11-27T20:31:07.000Z","updated":"2024-02-26T15:26:38.365Z","comments":true,"path":"2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-06-multi-advisor/","link":"","permalink":"https://ckck803.github.io/2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-06-multi-advisor/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 여러 Advisor 와 함께 적용 하나의 Target 에 여러 Advisor 를 적용한다. // 여러개의 프록시 객체// client -&gt; proxy2(advisor2) -&gt; proxy1(advisor1) -&gt; target// Proxy 1 생성ServiceInterface target = new ServiceImpl();ProxyFactory proxyFactory = new ProxyFactory(target);// Advisor 인터페이스의 가장 일반적인 구현체DefaultPointcutAdvisor advisor1 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice1());// ProxyFactory 에 적용할 Advisor 를 지정한다.proxyFactory.addAdvisor(advisor1);ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();/////////////////////////////////////////////////////////////////////////////////////////////// Proxy 2 생성 (taget -&gt; proxy 1 입력)ProxyFactory proxyFactory2 = new ProxyFactory(proxy);// Advisor 인터페이스의 가장 일반적인 구현체DefaultPointcutAdvisor advisor2 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice2());// ProxyFactory 에 적용할 Advisor 를 지정한다.proxyFactory2.addAdvisor(advisor2);ServiceInterface proxy2 = (ServiceInterface) proxyFactory2.getProxy();proxy2.save(); 00:36:05.734 [Test worker] INFO hello.proxy.advisor.MultiAdvisorTest$Advice2 - advice2 호출00:36:05.737 [Test worker] INFO hello.proxy.advisor.MultiAdvisorTest$Advice1 - advice1 호출00:36:05.737 [Test worker] INFO hello.proxy.common.service.ServiceImpl - save 호출 하나의 프록시로 여러개의 Advisor 적용 위에서는 여러 Advisor 를 적용하기 위해서는 여러개의 프록시를 생성 해야 한다는 문제점이 있다.스프링 AOP 에서는 하나의 프록시만 생성 하고 여러개의 Advisor 를 적용 할 수 있도록 지원한다.","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. 여러 Advisor 와 함께 적용 하나의 Target 에 여러 Advisor 를 적용한다. // 여러개의 프록시 객체// client -&gt; proxy2(advisor2) -&gt; proxy1(advisor1) -&gt; target// Proxy 1 생성ServiceInterface target = new ServiceImpl();ProxyFactory proxyFactory = new ProxyFactory(target);// Advisor 인터페이스의 가장 일반적인 구현체DefaultPointcutAdvisor advisor1 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice1());// ProxyFactory 에 적용할 Advisor 를 지정한다.proxyFactory.addAdvisor(advisor1);ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();/////////////////////////////////////////////////////////////////////////////////////////////// Proxy 2 생성 (taget -&gt; proxy 1 입력)ProxyFactory proxyFactory2 = new ProxyFactory(proxy);// Advisor 인터페이스의 가장 일반적인 구현체DefaultPointcutAdvisor advisor2 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice2());// ProxyFactory 에 적용할 Advisor 를 지정한다.proxyFactory2.addAdvisor(advisor2);ServiceInterface proxy2 = (ServiceInterface) proxyFactory2.getProxy();proxy2.save(); 00:36:05.734 [Test worker] INFO hello.proxy.advisor.MultiAdvisorTest$Advice2 - advice2 호출00:36:05.737 [Test worker] INFO hello.proxy.advisor.MultiAdvisorTest$Advice1 - advice1 호출00:36:05.737 [Test worker] INFO hello.proxy.common.service.ServiceImpl - save 호출 하나의 프록시로 여러개의 Advisor 적용 위에서는 여러 Advisor 를 적용하기 위해서는 여러개의 프록시를 생성 해야 한다는 문제점이 있다.스프링 AOP 에서는 하나의 프록시만 생성 하고 여러개의 Advisor 를 적용 할 수 있도록 지원한다. 여러개의 Advisor 를 등록 후 호춯될때 순서는 등록한 순서대로 호출됩니다. // 하나의 프록시 여러개의 Advisor// client -&gt; proxy -&gt; advisor2 -&gt; advisor1 -&gt; target// Advisor 객체 생성DefaultPointcutAdvisor advisor1 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice1());DefaultPointcutAdvisor advisor2 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice2());// Proxy 객체 생성ServiceInterface target = new ServiceImpl();ProxyFactory proxyFactory = new ProxyFactory(target);// 등록하는 순서대로 Advisor 가 호출된다.proxyFactory.addAdvisor(advisor2);proxyFactory.addAdvisor(advisor1);ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();proxy.save(); 23:30:55.675 [Test worker] INFO hello.proxy.advisor.MultiAdvisorTest$Advice2 - advice2 호출23:30:55.676 [Test worker] INFO hello.proxy.advisor.MultiAdvisorTest$Advice1 - advice1 호출23:30:55.677 [Test worker] INFO hello.proxy.common.service.ServiceImpl - save 호출","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Spring Proxy","slug":"Spring/Spring-AOP/Spring-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Spring-Proxy/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut","slug":"spring/spring-aop/spring-proxy/spring-proxy-05-spring-pointcut","date":"2021-11-27T19:31:07.000Z","updated":"2024-02-26T15:26:34.017Z","comments":true,"path":"2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-05-spring-pointcut/","link":"","permalink":"https://ckck803.github.io/2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-05-spring-pointcut/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. save 메서드는 어드바이스 로직을 적용하지만, find 메서드에서는 어드바이스 로직을 적용하지 않도록 설정하기 Spring 에서 제공하는 Pointcut 가장 많이 사용하는 Pointcut 구현체는 AspectJExpressionPointcut 다. 클래스 설명 NameMatchMethodPointcut 메서드 이름을 기반으로 매칭한다. 내부적으로 PatternMatchUtils 을 사용한다. JdkRegexpMethodPointcut JDK 정규 표현식을 기반으로 포인트 컷을 한다. AnnotationMatchingPointcut 애노테이션으로 매칭한다. AspectJExpressionPointcut aspectJ 표현식으로 매칭한다. ServiceInterface target = new ServiceImpl();ProxyFactory proxyFactory = new ProxyFactory(target);// Spring 에서 제공하는 PointcutNameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();pointcut.setMappedNames(&quot;save&quot;);// Advisor 인터페이스의 가장 일반적인 구현체DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, new TimeAdvice());// ProxyFactory 에 적용할 Advisor 를 지정한다.proxyFactory.addAdvisor(advisor);ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();proxy.save();proxy.find(); 00:14:12.347 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행00:14:12.349 [Test worker] INFO hello.proxy.common.service.ServiceImpl - save 호출00:14:12.349 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료 resultTime = 000:14:12.351 [Test worker] INFO hello.proxy.common.service.ServiceImpl - find 호출","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. save 메서드는 어드바이스 로직을 적용하지만, find 메서드에서는 어드바이스 로직을 적용하지 않도록 설정하기 Spring 에서 제공하는 Pointcut 가장 많이 사용하는 Pointcut 구현체는 AspectJExpressionPointcut 다. 클래스 설명 NameMatchMethodPointcut 메서드 이름을 기반으로 매칭한다. 내부적으로 PatternMatchUtils 을 사용한다. JdkRegexpMethodPointcut JDK 정규 표현식을 기반으로 포인트 컷을 한다. AnnotationMatchingPointcut 애노테이션으로 매칭한다. AspectJExpressionPointcut aspectJ 표현식으로 매칭한다. ServiceInterface target = new ServiceImpl();ProxyFactory proxyFactory = new ProxyFactory(target);// Spring 에서 제공하는 PointcutNameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();pointcut.setMappedNames(&quot;save&quot;);// Advisor 인터페이스의 가장 일반적인 구현체DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, new TimeAdvice());// ProxyFactory 에 적용할 Advisor 를 지정한다.proxyFactory.addAdvisor(advisor);ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();proxy.save();proxy.find(); 00:14:12.347 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행00:14:12.349 [Test worker] INFO hello.proxy.common.service.ServiceImpl - save 호출00:14:12.349 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료 resultTime = 000:14:12.351 [Test worker] INFO hello.proxy.common.service.ServiceImpl - find 호출","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Spring Proxy","slug":"Spring/Spring-AOP/Spring-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Spring-Proxy/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Pointcut 만들기","slug":"spring/spring-aop/spring-proxy/spring-proxy-04-pointcut","date":"2021-11-27T18:31:07.000Z","updated":"2024-02-26T15:26:29.298Z","comments":true,"path":"2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-04-pointcut/","link":"","permalink":"https://ckck803.github.io/2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-04-pointcut/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. Pointcut 인터페이스 Pointcut 은 getClassFilter 메서드와 getMethodMatcher 메서드를 이용해 필터링 을 진행한다.둘다 TRUE 를 반환해야 Advice 를 적용할 수 있다 getClassFilter : Class 조건으로 Filter 하는 메서드 .getMethodMatcher : Method 조건으로 Filter 하는 메서드 public interface Pointcut &#123; // 클래스 조건으로 필터링 ClassFilter getClassFilter(); // 메서드 조건으로 필터링 MethodMatcher getMethodMatcher(); Pointcut TRUE = TruePointcut.INSTANCE;&#125; Pointcut 적용하기 save 메서드는 Advice 로직을 적용하지만, find 메서드에서는 Advice 로직을 적용하지 않도록 설정하기","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. Pointcut 인터페이스 Pointcut 은 getClassFilter 메서드와 getMethodMatcher 메서드를 이용해 필터링 을 진행한다.둘다 TRUE 를 반환해야 Advice 를 적용할 수 있다 getClassFilter : Class 조건으로 Filter 하는 메서드 .getMethodMatcher : Method 조건으로 Filter 하는 메서드 public interface Pointcut &#123; // 클래스 조건으로 필터링 ClassFilter getClassFilter(); // 메서드 조건으로 필터링 MethodMatcher getMethodMatcher(); Pointcut TRUE = TruePointcut.INSTANCE;&#125; Pointcut 적용하기 save 메서드는 Advice 로직을 적용하지만, find 메서드에서는 Advice 로직을 적용하지 않도록 설정하기 Pointcut 인터페이스를 구현을 통해 Class 를 이용한 ClassFilter 와 Method 를 이용한 MethodMatcher 를 Overriding 한다. 두 메소드가 true 를 반환해야 PointCut 을 적용할 수 있다. // Pointcut 생성static class MyPointCut implements Pointcut&#123; @Override public ClassFilter getClassFilter() &#123; return ClassFilter.TRUE; &#125; @Override public MethodMatcher getMethodMatcher() &#123; return new MyMethodMatcher(); &#125;&#125; MethodMatcher 인터페이스를 구현 Method 이름이 save 일 경우 true 를 반환해 부가 기능이 수행 될 수 있도록 한다. static class MyMethodMatcher implements MethodMatcher&#123; private String matchName = &quot;save&quot;; @Override public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; boolean result = method.getName().equals(matchName); log.info(&quot;포인트 컷 호출 method = &#123;&#125; targetClass = &#123;&#125;&quot;, method.getName(), targetClass); log.info(&quot;포인트 컷 결과 result = &#123;&#125;&quot;, result); return result; &#125; @Override public boolean isRuntime() &#123; return false; &#125; @Override public boolean matches(Method method, Class&lt;?&gt; targetClass, Object... args) &#123; return false; &#125;&#125; PointCut 을 Advisor 에 적용한다. ServiceInterface target = new ServiceImpl();ProxyFactory proxyFactory = new ProxyFactory(target);// Advisor 인터페이스의 가장 일반적인 구현체DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(new MyPointCut(), new TimeAdvice());// Proxy Factory 에 적용할 Advisor 를 지정한다.proxyFactory.addAdvisor(advisor);ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();proxy.save();proxy.find(); 00:05:44.717 [Test worker] INFO hello.proxy.advisor.AdvisorTest - 포인트 컷 호출 method = save targetClass = class hello.proxy.common.service.ServiceImpl00:05:44.720 [Test worker] INFO hello.proxy.advisor.AdvisorTest - 포인트 컷 결과 result = true00:05:44.723 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행00:05:44.723 [Test worker] INFO hello.proxy.common.service.ServiceImpl - save 호출00:05:44.723 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료 resultTime = 000:05:44.723 [Test worker] INFO hello.proxy.advisor.AdvisorTest - 포인트 컷 호출 method = find targetClass = class hello.proxy.common.service.ServiceImpl00:05:44.724 [Test worker] INFO hello.proxy.advisor.AdvisorTest - 포인트 컷 결과 result = false00:05:44.724 [Test worker] INFO hello.proxy.common.service.ServiceImpl - find 호출","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Spring Proxy","slug":"Spring/Spring-AOP/Spring-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Spring-Proxy/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Advisor","slug":"spring/spring-aop/spring-proxy/spring-proxy-03-advisor","date":"2021-11-27T17:31:07.000Z","updated":"2024-02-26T15:26:25.017Z","comments":true,"path":"2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-03-advisor/","link":"","permalink":"https://ckck803.github.io/2021/11/28/spring/spring-aop/spring-proxy/spring-proxy-03-advisor/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. Advisor Advisor는 Spring AOP에서 Advice, Pointcut, Advisor의 개념을 쉽게 사용할 수 있도록 제공합니다. Advice 는 메소드를 실행하기 전, 후, 혹은 예외가 발생했을 때 실행되는 부가 기능을 말하며, Pointcut 은 Advice가 적용될 메소드를 선택하는 기준입니다. Advisor 는 Advice 와 Pointcut 을 결합한 것으로, 어떤 메소드에 어떤 Advice 를 적용할지를 결정합니다. PointCut (포인트 컷) 어디에 부가 기능을 적용할지 적용하지 않을지 판단하는 필터링 로직 클래스 이름과 메서드 이름을 이용해 필터링 한다. Advice (어드바이스) 프록시가 호출하는 부가 기능 Advisor (어드바이저) 단순하게 하나의 포인트 컷 과 하나의 어드바이스 를 갖고 있는 것 DefaultPointcutAdvisor","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. Advisor Advisor는 Spring AOP에서 Advice, Pointcut, Advisor의 개념을 쉽게 사용할 수 있도록 제공합니다. Advice 는 메소드를 실행하기 전, 후, 혹은 예외가 발생했을 때 실행되는 부가 기능을 말하며, Pointcut 은 Advice가 적용될 메소드를 선택하는 기준입니다. Advisor 는 Advice 와 Pointcut 을 결합한 것으로, 어떤 메소드에 어떤 Advice 를 적용할지를 결정합니다. PointCut (포인트 컷) 어디에 부가 기능을 적용할지 적용하지 않을지 판단하는 필터링 로직 클래스 이름과 메서드 이름을 이용해 필터링 한다. Advice (어드바이스) 프록시가 호출하는 부가 기능 Advisor (어드바이저) 단순하게 하나의 포인트 컷 과 하나의 어드바이스 를 갖고 있는 것 DefaultPointcutAdvisorDefaultPointcutAdvisor 은 Advisor 의 기본 구현체입니다. 부가 기능을 어디에 적용할지 Pointcut 과 부가 기능 Advice 를 인자로 Advisor 객체를 생성하고 ProxyFactory 객체 addAdvisor 메소드들 이용해 Advisor 를 적용한다. public class DefaultPointcutAdvisor extends AbstractGenericPointcutAdvisor implements Serializable &#123; private Pointcut pointcut = Pointcut.TRUE; public DefaultPointcutAdvisor() &#123; &#125; public DefaultPointcutAdvisor(Advice advice) &#123; this(Pointcut.TRUE, advice); &#125; public DefaultPointcutAdvisor(Pointcut pointcut, Advice advice) &#123; this.pointcut = pointcut; setAdvice(advice); &#125; public void setPointcut(@Nullable Pointcut pointcut) &#123; this.pointcut = (pointcut != null ? pointcut : Pointcut.TRUE); &#125; @Override public Pointcut getPointcut() &#123; return this.pointcut; &#125; @Override public String toString() &#123; return getClass().getName() + &quot;: pointcut [&quot; + getPointcut() + &quot;]; advice [&quot; + getAdvice() + &quot;]&quot;; &#125;&#125; Advisor 생성 및 적용ServiceInterface target = new ServiceImpl();ProxyFactory proxyFactory = new ProxyFactory(target);// Advisor 인터페이스의 가장 일반적인 구현체DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(Pointcut.TRUE, new TimeAdvice());// Proxy Factory 에 적용할 Advisor 를 지정한다.proxyFactory.addAdvisor(advisor);ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();proxy.save();proxy.find(); 22:40:35.135 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행22:40:35.138 [Test worker] INFO hello.proxy.common.service.ServiceImpl - save 호출22:40:35.138 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료 resultTime = 022:40:35.139 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행22:40:35.140 [Test worker] INFO hello.proxy.common.service.ServiceImpl - find 호출22:40:35.140 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료 resultTime = 0","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Spring Proxy","slug":"Spring/Spring-AOP/Spring-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Spring-Proxy/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - CGLIB","slug":"spring/spring-aop/design-pattern/cglib/cglib-01","date":"2021-11-26T17:31:07.000Z","updated":"2024-02-26T15:22:42.325Z","comments":true,"path":"2021/11/27/spring/spring-aop/design-pattern/cglib/cglib-01/","link":"","permalink":"https://ckck803.github.io/2021/11/27/spring/spring-aop/design-pattern/cglib/cglib-01/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 참고 https://www.baeldung.com/cglib Dynamic Proxy 의 한계와 CGLIBDynamic Proxy 의 경우 인터페이스를 구현한 클래스에 대해서만 프록시 객체를 생성할 수 있습니다. 그렇다면 인터페이스가 없는 클래스의 경우 프록시 생성을 못하냐? 정답은 아닙니다. 자바에서는 인터페이스를 구현하지 않은 클래스에 대해서도 프록시 객체를 생성할 수 있도록 CGLIB 를 제공합니다. 차이점은 Dynamic Proxy 는 인터페이스 구현을 통해 프록시 객체를 생성하지만 CGLIB 는 상속 을 통해 프록시 객체를 생성한다는 것입니다. CGLIB 란? CGLIB 는 Code Generation Library의 약자로 런타임 시 Java 바이트 코드 를 조작해 동적으로 클래스를 생성하는 라이브러리다. JDK Dynamic 프록시와는 다르게 구체 클래스 만 갖고도 동적으로 Proxy 를 생성할 수 있다. CGLIB은 자바의 리플렉션(Reflection) API 와 바이트코드 조작(Bytecode Manipulation) 기술을 이용하여 클래스의 상속 구조를 이용해서 프록시 객체를 생성합니다. 이 과정에서 바이트코드를 조작하므로, JVM의 클래스 로딩 과정에서 원본 클래스의 바이트코드를 변경할 수 있습니다.","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 참고 https://www.baeldung.com/cglib Dynamic Proxy 의 한계와 CGLIBDynamic Proxy 의 경우 인터페이스를 구현한 클래스에 대해서만 프록시 객체를 생성할 수 있습니다. 그렇다면 인터페이스가 없는 클래스의 경우 프록시 생성을 못하냐? 정답은 아닙니다. 자바에서는 인터페이스를 구현하지 않은 클래스에 대해서도 프록시 객체를 생성할 수 있도록 CGLIB 를 제공합니다. 차이점은 Dynamic Proxy 는 인터페이스 구현을 통해 프록시 객체를 생성하지만 CGLIB 는 상속 을 통해 프록시 객체를 생성한다는 것입니다. CGLIB 란? CGLIB 는 Code Generation Library의 약자로 런타임 시 Java 바이트 코드 를 조작해 동적으로 클래스를 생성하는 라이브러리다. JDK Dynamic 프록시와는 다르게 구체 클래스 만 갖고도 동적으로 Proxy 를 생성할 수 있다. CGLIB은 자바의 리플렉션(Reflection) API 와 바이트코드 조작(Bytecode Manipulation) 기술을 이용하여 클래스의 상속 구조를 이용해서 프록시 객체를 생성합니다. 이 과정에서 바이트코드를 조작하므로, JVM의 클래스 로딩 과정에서 원본 클래스의 바이트코드를 변경할 수 있습니다. CGLIB을 이용하여 프록시 객체를 생성할 때는 Enhancer 클래스를 이용합니다. Enhancer 클래스는 동적으로 클래스를 생성할 때 필요한 정보를 받아서 CGLIB이 제공하는 Callback 인터페이스 를 이용해서 프록시 객체를 생성합니다. MethodInterceptor 인터페이스 - 부가기능 로직 작성 CGLIB 는 MethodInterceptor 를 이용해 JDK Dynamic Proxy 의 InvocationHandler 처럼 공통 로직 을 작성한다. MethodInterceptor 인터페이스의 intercept 메소드는 프록시 객체가 호출될 때, 요청을 가로채 호출된 메소드 대신 실행됩니다. 이를 이용하여, 메소드 호출 전후에 로그를 남기거나, 메소드 호출 시간을 측정하거나, 트랜잭션을 관리하는 등의 작업을 수행할 수 있습니다. MethodInterceptor 인터페이스는 자바의 다이나믹 프록시에서 제공하는 InvocationHandler와 유사한 역할을 합니다. 그러나 CGLIB은 상속 기반의 프록시 객체를 생성하므로, MethodInterceptor를 이용하여 원본 클래스의 메소드를 호출할 때, super 키워드를 이용하여 부모 클래스의 메소드를 호출할 수 있습니다. Object object : CGLIB 가 적용된 객체 Method method : 호출된 메소드 Object[] args : 메서드를 호출하면서 전달된 인수 MethodProxy proxy : 메서드 호출에 사용하는 객체 public interface MethodInterceptor extends Callback &#123; Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable;&#125; 부가기능 로직 작성method.invoke(target, args) 를 이용해 원본 클래스의 메소드를 호출하던 방식과 달리, CGLIB 은 methodProxy.invokeSuper(target, args) 를 이용해 원본 클래스의 메소드를 호출합니다. method.invoke(target, args) 로 실제 메소드를 호출해도 로직은 작동하지만 methodProxy.invokeSuper(target, args) 방식으로 호출하는게 성능상의 이접이 있다고 하니 참고하도록 하자! @Slf4jpublic class TimeMethodInterceptor implements MethodInterceptor &#123; private final Object target; public TimeMethodInterceptor(Object target) &#123; this.target = target; &#125; // 이 메소드는 세 개의 인자를 받습니다. // 첫 번째 인자는 프록시 객체 자신입니다. // 두 번째 인자는 원본 객체의 메소드입니다. // 세 번째 인자는 원본 객체의 메소드 호출 시 전달된 인자 배열입니다. @Override public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; log.info(&quot;TimeProxy 실행&quot;); long startTime = System.currentTimeMillis(); // 원본 클래스의 실제 메소드를 호출합니다. Object result = methodProxy.invoke(target, args); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;TimeProxy 종료 resultTime = &#123;&#125;&quot;, resultTime); return result; &#125;&#125; Enhancer - 프록시 객체 생성 CGLIB 에서는 Enhancer 를 이용해 Proxy 객체를 생성한다. 원본 클래스@Slf4jpublic class ConcreteService &#123; public void call() &#123; log.info(&quot;ConcreteService 호출&quot;); &#125;&#125; CGLIB 프록시 객체 생성 테스트 코드CGLIB 에서 프록시 객체를 생성하고자 할 때, Enhancer 를 이용해 프록시 객체를 생성합니다. Enhancer 객체 setSuperclass 메소드를 이용해 프록시 객체를 생성할 원본 클래스를 지정하고 setCallback 메소드를 이용해 프록시 객체에 부가기능로직이 구현된 MethodInterceptor 객체를 지정합니다. Enhancer 객체에 원본 클래스와 부가기능이 정의되면 create 메소드를 이용하여 프록시 객체를 생성할 수 있습니다. @Testvoid cglib()&#123; ConcreteService target = new ConcreteService(); // Enhancer 를 사용해 Proxy 를 생성한다. Enhancer enhancer = new Enhancer(); // CGLIB 는 상속을 통해 구체 클래스 프록시를 생성할 수 있습니다. enhancer.setSuperclass(ConcreteService.class); enhancer.setCallback(new TimeMethodInterceptor(target)); // setSuperclass 에서 지정한 클래스를 이용해 Proxy 객체를 생성한다. ConcreteService proxy = (ConcreteService) enhancer.create(); log.info(&quot;targetClass = &#123;&#125;&quot;, target.getClass()); log.info(&quot;proxyClass = &#123;&#125;&quot;, proxy.getClass()); // Proxy 객체를 통해 메소드를 호출하면, 부가기능이 실행됩니다. proxy.call();&#125; 테스트 결과Enhancer 클래스를 통해 CGLIB 프록시 객체가 생성된 것을 확인할 수 있습니다. 프록시 객체의 메소드가 호출되면, 부가기능이 실행되는 것을 확인할 수 있습니다. 23:52:18.794 [Test worker] INFO hello.proxy.cglib.CglibTest - targetClass = class hello.proxy.common.service.ConcreteService23:52:18.798 [Test worker] INFO hello.proxy.cglib.CglibTest - proxyClass = class hello.proxy.common.service.ConcreteService$$EnhancerByCGLIB$$25d6b0e323:52:18.798 [Test worker] INFO hello.proxy.cglib.code.TimeMethodInterceptor - TimeProxy 실행23:52:18.807 [Test worker] INFO hello.proxy.common.service.ConcreteService - ConcreteService 호출23:52:18.807 [Test worker] INFO hello.proxy.cglib.code.TimeMethodInterceptor - TimeProxy 종료 resultTime = 9 CGLIB 장단점CGLIB 을 이용한 프록시 객체 생성 방식은 다이나믹 프록시보다 더 빠른 속도를 보이며, 인터페이스를 구현하지 않은 클래스에 대해서도 프록시 객체를 생성할 수 있습니다. 하지만, 바이트코드를 조작하기 때문에 보안 검사 등에서 문제가 될 수 있습니다. 그리고 원본 클래스의 생성자나 private 메서드 등은 프록시 객체에서 호출할 수 없습니다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"CGLIB","slug":"Spring/Spring-고급편/CGLIB","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/CGLIB/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - MethodInterceptor","slug":"spring/spring-aop/spring-proxy/spring-proxy-02-MethodInterceptor","date":"2021-11-26T16:41:07.000Z","updated":"2024-02-26T15:26:17.765Z","comments":true,"path":"2021/11/27/spring/spring-aop/spring-proxy/spring-proxy-02-MethodInterceptor/","link":"","permalink":"https://ckck803.github.io/2021/11/27/spring/spring-aop/spring-proxy/spring-proxy-02-MethodInterceptor/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. MethodInterceptor - 부가기능 구현Spring 에서는 프록시 객체에 부가기능을 적용하기 위해 MethodInterceptor 인터페이스를 제공합니다. MethodInterceptor 인터페이스 구현을 통해 프록시 객체에 적용될 부가기능을 생성할 수 있습니다. MethodInterceptor 인터페이스 내 invoke 메소드 인자 MethodInvocation 객체에는 다음 메서드를 호출하는 방법, 현재 프록시 객체 인스턴스, args, 메서드 정보등이 표함돼 있다. CGLIB 에서 제공하는 MethodInterceptor 와 이름이 비슷하므로 구현시 주의할 필요가 있습니다. package org.aopalliance.intercept;public interface MethodInterceptor extends Interceptor &#123; Object invoke(MethodInvocation invocation) throws Throwable; &#125;","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. MethodInterceptor - 부가기능 구현Spring 에서는 프록시 객체에 부가기능을 적용하기 위해 MethodInterceptor 인터페이스를 제공합니다. MethodInterceptor 인터페이스 구현을 통해 프록시 객체에 적용될 부가기능을 생성할 수 있습니다. MethodInterceptor 인터페이스 내 invoke 메소드 인자 MethodInvocation 객체에는 다음 메서드를 호출하는 방법, 현재 프록시 객체 인스턴스, args, 메서드 정보등이 표함돼 있다. CGLIB 에서 제공하는 MethodInterceptor 와 이름이 비슷하므로 구현시 주의할 필요가 있습니다. package org.aopalliance.intercept;public interface MethodInterceptor extends Interceptor &#123; Object invoke(MethodInvocation invocation) throws Throwable; &#125; MethodInterceptor 구현MethodInterceptor 를 이용해 수행 시간 로그를 찍어주는 부가기능 로직 을 수행하는 Advice 를 만들어준다. @Slf4jpublic class TimeAdvice implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; log.info(&quot;TimeProxy 실행&quot;); long startTime = System.currentTimeMillis(); // Object result = method.invoke(target, args); // Spring 에서 제공하는 프록시 팩토리 기능 적용 start Object result = invocation.proceed(); // Spring 에서 제공하는 프록시 팩토리 기능 적용 end long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;TimeProxy 종료 resultTime = &#123;&#125;&quot;, resultTime); return result; &#125;&#125; 프록시 객체에 Advice(부가 기능) 적용ProxyFactory 를 이용해 프록시 객체를 생성합니다. ProxyFactory 는 전달받은 인스턴스 정보를 기반으로 프록시 객체를 생성합니다. 인터페이스가 있는 객체인 경우 JDK 동적 프록시 를 사용해 프록시 객체를 생성하고 인터페이스가 없을 경우에는 CGLIB 를 사용해 프록시 객체를 생성합니다. 생성된 프록시 객체에 addAdvice 메소드를 이용해 부가 기능을 위한 Advice 를 추가한다. // 인터페이스가 있으면 동적 프록시 사용ServiceInterface target = new ServiceImpl();// ProxyFactory 를 생성할 때 프록시 호출 대상을 인자로 넘겨준다.ProxyFactory proxyFactory = new ProxyFactory(target);// ProxyFactory 객체에 부가 기능을 위한 Advice 정보를 추가한다.proxyFactory.addAdvice(new TimeAdvice());ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();log.info(&quot;targetClass = &#123;&#125;&quot;, target.getClass());log.info(&quot;proxyClass = &#123;&#125;&quot;, proxy.getClass());proxy.save(); ProxyFactory 객체는 JDK Dynamic Proxy 를 기반으로 만들어진 것을 확인할 수 있다. 21:33:13.233 [Test worker] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass = class hello.proxy.common.service.ServiceImpl21:33:13.237 [Test worker] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass = class com.sun.proxy.$Proxy1321:33:13.242 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행21:33:13.243 [Test worker] INFO hello.proxy.common.service.ServiceImpl - save 호출21:33:13.243 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료 resultTime = 1 프록시 적용 확인테스트에서 ProxyFactory 를 통해 Proxy 객체가 생성됐는지 확인하고 Advice (부가기능) 로직을 수행하는지 확인합니다. 프록시 객체 생성시 인터페이스가 있는 객체일 경우 JDK Dynamic Proxy 를 이용해 프록시 객체를 생성됐는지 확인하고, 인터페이스가 없는 객체일 경우 CGLIB 를 이용해 프록시 객체를 생성했는지 확인합니다. Jdk Dynamic Proxy 를 이용한 Proxy 생성 확인ProxyFactory 를 이용해 프록시를 생성할 때 인터페이스가 있으면 JDK Dynamic Proxy 를 이용해 동적 프록시를 생성한다. // 인터페이스가 있으면 동적 프록시 사용ServiceInterface target = new ServiceImpl();ProxyFactory proxyFactory = new ProxyFactory(target);proxyFactory.addAdvice(new TimeAdvice());ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();log.info(&quot;targetClass = &#123;&#125;&quot;, target.getClass());log.info(&quot;proxyClass = &#123;&#125;&quot;, proxy.getClass());proxy.save();// Proxy Factory 를 이용해 만들었을 때 사용가능assertThat(AopUtils.isAopProxy(proxy)).isTrue(); // AopProxy 를 이용해 동적 프록시를 생성했는지 확인assertThat(AopUtils.isJdkDynamicProxy(proxy)).isTrue(); // JdkDynamicProxy 를 이용해 동적 프록시를 생성했는지 확인assertThat(AopUtils.isCglibProxy(proxy)).isFalse(); // CglibProxy 를 이용해 동적 프록시를 생성했는지 확인 com.sun.proxy.Proxy13 를 통해 JdkDynamicProxy 를 이용해 동적 프록시가 생성 된 것을 확인할 수 있다. 23:00:05.128 [Test worker] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass = class hello.proxy.common.service.ServiceImpl23:00:05.132 [Test worker] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass = class com.sun.proxy.$Proxy1323:00:05.136 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행23:00:05.136 [Test worker] INFO hello.proxy.common.service.ServiceImpl - save 호출23:00:05.136 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료 resultTime = 0 CGLIB 를 이용한 Proxy 생성 확인// 구체 클래스만 있으면 CGLIB 적용ConcreteService target = new ConcreteService();ProxyFactory proxyFactory = new ProxyFactory(target);proxyFactory.addAdvice(new TimeAdvice());ConcreteService proxy = (ConcreteService) proxyFactory.getProxy();log.info(&quot;targetClass = &#123;&#125;&quot;, target.getClass());log.info(&quot;proxyClass = &#123;&#125;&quot;, proxy.getClass());proxy.call();// Proxy Factory 를 이용해 만들었을 때 사용가능assertThat(AopUtils.isAopProxy(proxy)).isTrue();assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse();assertThat(AopUtils.isCglibProxy(proxy)).isTrue(); EnhancerBySpringCGLIB 를 통해 CGLIB 를 이용해 동적 프록시가 생성됐는지 확인할 수 있다. 21:50:00.561 [Test worker] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass = class hello.proxy.common.service.ConcreteService21:50:00.563 [Test worker] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass = class hello.proxy.common.service.ConcreteService$$EnhancerBySpringCGLIB$$8328efc521:50:00.565 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행21:50:00.576 [Test worker] INFO hello.proxy.common.service.ConcreteService - ConcreteService 호출21:50:00.576 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료 resultTime = 10 CGLIB 를 이용한 강제 Proxy 생성 확인ProxyFactory 가 프록시 객체 생성시 인터페이스가 있는 객체더라도 CGLIB 를 이용해 프록시 객체를 생성할 수 있습니다. ProxyFactory 클래스에서 제공하는 setProxyTargetClass 메소드에 true 값을 넣으면 프록시 객체 생성시 CGLIB 를 이용해 프록시 객체를 생성합니다. // ProxyTargetClass 옵션을 사용하면 인터페이스가 있어도 CGLIB를 사용하고, 클래스 기반 프록시 사용ConcreteService target = new ConcreteService();ProxyFactory proxyFactory = new ProxyFactory(target);proxyFactory.setProxyTargetClass(true); // 이 옵션이 있으면 항상 CGLIB 를 사용해 프록시를 생성한다.proxyFactory.addAdvice(new TimeAdvice());ConcreteService proxy = (ConcreteService) proxyFactory.getProxy();log.info(&quot;targetClass = &#123;&#125;&quot;, target.getClass());log.info(&quot;proxyClass = &#123;&#125;&quot;, proxy.getClass());proxy.call();// Proxy Factory 를 이용해 만들었을 때 사용가능assertThat(AopUtils.isAopProxy(proxy)).isTrue();assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse();assertThat(AopUtils.isCglibProxy(proxy)).isTrue(); EnhancerBySpringCGLIB 를 통해 setProxyTargetClass 메소드를 이용해 CGLIB 를 사용한 프록시 생성을 강제할 수 있음을 확인할 수 있다. 22:14:06.412 [Test worker] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass = class hello.proxy.common.service.ConcreteService22:14:06.414 [Test worker] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass = class hello.proxy.common.service.ConcreteService$$EnhancerBySpringCGLIB$$116d915622:14:06.416 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 실행22:14:06.427 [Test worker] INFO hello.proxy.common.service.ConcreteService - ConcreteService 호출22:14:06.427 [Test worker] INFO hello.proxy.common.advice.TimeAdvice - TimeProxy 종료 resultTime = 10","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Spring Proxy","slug":"Spring/Spring-AOP/Spring-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Spring-Proxy/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - ProxyFactory","slug":"spring/spring-aop/spring-proxy/spring-proxy-01-proxyfactory","date":"2021-11-26T16:31:07.000Z","updated":"2024-02-26T15:26:10.561Z","comments":true,"path":"2021/11/27/spring/spring-aop/spring-proxy/spring-proxy-01-proxyfactory/","link":"","permalink":"https://ckck803.github.io/2021/11/27/spring/spring-aop/spring-proxy/spring-proxy-01-proxyfactory/","excerpt":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. Spring 에서의 ProxyFactory Spring 에서는 프록시 객체를 생성하기 위해 ProxyFactory 를 제공합니다. Spring에서 ProxyFactory 는 프록시 객체를 생성하는 팩토리입니다. ProxyFactory 는 인터페이스가 있을 때는 JDK 동적 프록시 를 사용해 프록시 객체를 생성하고 인터페이스가 없을 경우에는 CGLIB 를 사용해 프록시 객체를 생성합니다. Advice Advice 는 프록시에 적용하는 부가 기능 로직 이다.JDK 동적 프록시 가 제공하는 InvocationHandler 와 CGLIB 가 제공하는 MethodInterceptor 의 개념과 유사하다.","text":"목차 BeanPostProcessor - 하나의 프록시에 여러개의 Advisor 적용 BeanPostProcessor Spring 핵심원리 고급편 - ProxyFactory 적용 Spring 핵심원리 고급편 - 여러 Advisor 와 함께 적용 Spring 핵심원리 고급편 - Spring 에서 제공하는 Pointcut Spring 핵심원리 고급편 - Pointcut 만들기 Spring 핵심원리 고급편 - Advisor Spring 핵심원리 고급편 - MethodInterceptor Spring 핵심원리 고급편 - ProxyFactory 참고본 포스트는 김영한의 스프링 핵심 원리 - 고급편 내용을 참고해 만들었습니다. Spring 에서의 ProxyFactory Spring 에서는 프록시 객체를 생성하기 위해 ProxyFactory 를 제공합니다. Spring에서 ProxyFactory 는 프록시 객체를 생성하는 팩토리입니다. ProxyFactory 는 인터페이스가 있을 때는 JDK 동적 프록시 를 사용해 프록시 객체를 생성하고 인터페이스가 없을 경우에는 CGLIB 를 사용해 프록시 객체를 생성합니다. Advice Advice 는 프록시에 적용하는 부가 기능 로직 이다.JDK 동적 프록시 가 제공하는 InvocationHandler 와 CGLIB 가 제공하는 MethodInterceptor 의 개념과 유사하다. Spring 은 부가기능 적용을 위해 JDK 동적 프록시 의 InvocationHandler 나 CGLIB 의 MethodInterceptor 를 각각 중복으로 따로 만드는 방식이 아닌 Advice 라는 개념을 도입했다. InvocationHandler 나 MethodInterceptor 가 Advice 를 호출하는 형식으로 부가 기능이 적용된다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"Spring Proxy","slug":"Spring/Spring-AOP/Spring-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Spring-Proxy/"}],"tags":[]},{"title":"JPA 연관 관계 - 상속 관계 Mapping","slug":"jpa/jpa-programming/mapping/inheritance-mapping","date":"2021-11-25T19:31:46.000Z","updated":"2024-02-18T16:19:54.529Z","comments":true,"path":"2021/11/26/jpa/jpa-programming/mapping/inheritance-mapping/","link":"","permalink":"https://ckck803.github.io/2021/11/26/jpa/jpa-programming/mapping/inheritance-mapping/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 JPA 상속 관계 Mapping 관계형 데이터 베이스는 상속 관계가 없다. 슈펴타입 서브타입 관계라는 모델링 기법이 객체의 상속과 유사하다. 상속관계 Mapping : 객체의 상속 관계와 DB 의 슈퍼타입 서브타입 관계를 Mapping 슈퍼타입 서브타입 논리 모델을 객체의 상속관계를 물리 모델로 구현하는 방법 객체의 상속관계를 슈퍼타입 서브타입 모델로 구현하는 방법은 3가지 방법이 있다. 전략 설명 조인 전략 각각 테이블로 변환 (연관 관계로 관리) 단일 테이블 전략 통합 테이블로 변환 (하나의 테이블로 관리) 구현 클래스마다 테이블 전략 서브타입 테이블로 변환 사용하는 어노테이션 @Inheritance @DiscriminatorColumn(name&#x3D;”DTYPE”) @DiscriminotorValue @Inheritance 전략","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 JPA 상속 관계 Mapping 관계형 데이터 베이스는 상속 관계가 없다. 슈펴타입 서브타입 관계라는 모델링 기법이 객체의 상속과 유사하다. 상속관계 Mapping : 객체의 상속 관계와 DB 의 슈퍼타입 서브타입 관계를 Mapping 슈퍼타입 서브타입 논리 모델을 객체의 상속관계를 물리 모델로 구현하는 방법 객체의 상속관계를 슈퍼타입 서브타입 모델로 구현하는 방법은 3가지 방법이 있다. 전략 설명 조인 전략 각각 테이블로 변환 (연관 관계로 관리) 단일 테이블 전략 통합 테이블로 변환 (하나의 테이블로 관리) 구현 클래스마다 테이블 전략 서브타입 테이블로 변환 사용하는 어노테이션 @Inheritance @DiscriminatorColumn(name&#x3D;”DTYPE”) @DiscriminotorValue @Inheritance 전략 strategy 설명 InheritanceType.JOINED 조인 전략 InheritanceType.SINGLE_TABLE 단일 테이블 전략 InheritanceType.TABLE_PER_CLASS 구현 클래스마다 테이블 전략 @Entitypublic class Item &#123; @Id @GeneratedValue private Long id; private String name; private int price;&#125; @Entitypublic class Album extends Item &#123; private String artist;&#125; @Entitypublic class Book extends Item&#123; private String author; private String isbn;&#125; @Entitypublic class Movie extends Item&#123; private String director; private String actor;&#125; 1. 조인 전략 @Inheritance(strategy &#x3D; InheritanceType.JOINED) Hibernate: create table Album (artist varchar(255), id bigint not null, primary key (id))Hibernate: create table Book (author varchar(255), isbn varchar(255), id bigint not null, primary key (id))Hibernate: create table Item (id bigint not null, name varchar(255), price integer not null, primary key (id))Hibernate: create table Movie (actor varchar(255), director varchar(255), id bigint not null, primary key (id))Hibernate: alter table Album add constraint FKcve1ph6vw9ihye8rbk26h5jm9 foreign key (id) references ItemHibernate: alter table Book add constraint FKbwwc3a7ch631uyv1b5o9tvysi foreign key (id) references ItemHibernate: alter table Movie add constraint FK5sq6d5agrc34ithpdfs0umo9g foreign key (id) references Item Movie movie = new Movie();movie.setDirector(&quot;aaaa&quot;);movie.setActor(&quot;bbbb&quot;);movie.setName(&quot;바람과 함께 사라지다.&quot;);movie.setPrice(10000);em.persist(movie);em.flush();em.clear();em.find(Movie.class, movie.getId()); 데이터 삽입데이터 삽입시 슈퍼타입과 서브타입 각각에 쿼리문에 보내지는 것을 확인할 수 있다. Hibernate: /* insert hellojpa.Movie */ insert into Item (name, price, id) values (?, ?, ?)Hibernate: /* insert hellojpa.Movie */ insert into Movie (actor, director, id) values (?, ?, ?) 데이터 조회데이터 조회시 슈퍼타입과 서브타입을 조인해서 가져오는 것을 확인할 수 있다. Hibernate: select movie0_.id as id1_2_0_, movie0_1_.name as name2_2_0_, movie0_1_.price as price3_2_0_, movie0_.actor as actor1_4_0_, movie0_.director as director2_4_0_ from Movie movie0_ inner join Item movie0_1_ on movie0_.id=movie0_1_.id where movie0_.id=? DTYPE 이 있을 경우 DTYPE 이 없을 경우 @DiscriminatorColumn 를 이용해 DTYPE 을 명시해 줄 수 있다. DTYPE 값은 @DiscriminotorValue 를 이용해 명시해 줄 수 있다. 기본값은 Entity Class 명이다. 어떤 객체에 맞춰서 슈퍼타입 데이터 가 들어왔는지 명확하게 알 수 있다. 2. 단일 테이블 전략 - JPA 기본 전략 @Inheritance(strategy &#x3D; InheritanceType.SINGLE_TABLE) 한 테이블에 모든 데이터가 들어가 관리되는 방식 한 테이블에 관리하기 때문에 DTYPE 이 자동적으로 생성된다. Hibernate: create table Item ( DTYPE varchar(31) not null, id bigint generated by default as identity, name varchar(255), price integer not null, artist varchar(255), author varchar(255), isbn varchar(255), actor varchar(255), director varchar(255), primary key (id)) Hibernate: /* insert hellojpa.Movie */ insert into Item (id, name, price, actor, director, DTYPE) values (null, ?, ?, ?, ?, &#x27;Movie&#x27;)Hibernate: select movie0_.id as id2_0_0_, movie0_.name as name3_0_0_, movie0_.price as price4_0_0_, movie0_.actor as actor8_0_0_, movie0_.director as director9_0_0_ from Item movie0_ where movie0_.id=? and movie0_.DTYPE=&#x27;Movie&#x27; 3. 구현 클래스마다 테이블 전략 Item Table 생성 쿼리가 별도로 실행되지 않는 것을 확인할 수 있다. Hibernate: create table Album (id bigint not null, name varchar(255), price integer not null, artist varchar(255), primary key (id))Hibernate: create table Book (id bigint not null, name varchar(255), price integer not null, author varchar(255), isbn varchar(255), primary key (id))Hibernate: create table Movie (id bigint not null, name varchar(255), price integer not null, actor varchar(255), director varchar(255), primary key (id)) 구현 테이블 마다 테이블 전략은 상위 타입으로 데이터 조회시 문제가 발생한다. 서브 타입 테이블을 전부 UNION 해서 조회 조건에 맞는 데이터가 있는지 확인한 후 가져온다. Hibernate: select item0_.id as id1_2_0_, item0_.name as name2_2_0_, item0_.price as price3_2_0_, item0_.artist as artist1_0_0_, item0_.author as author1_1_0_, item0_.isbn as isbn2_1_0_, item0_.actor as actor1_4_0_, item0_.director as director2_4_0_, item0_.clazz_ as clazz_0_ from ( select id, name, price, artist, null as author, null as isbn, null as actor, null as director, 1 as clazz_ from Album union all select id, name, price, null as artist, author, isbn, null as actor, null as director, 2 as clazz_ from Book union all select id, name, price, null as artist, null as author, null as isbn, actor, director, 3 as clazz_ from Movie ) item0_ where item0_.id=?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Dynamic Proxy 2","slug":"spring/spring-aop/design-pattern/dynamic-proxy/dynamic-proxy-02","date":"2021-11-25T18:31:07.000Z","updated":"2024-02-26T15:23:36.207Z","comments":true,"path":"2021/11/26/spring/spring-aop/design-pattern/dynamic-proxy/dynamic-proxy-02/","link":"","permalink":"https://ckck803.github.io/2021/11/26/spring/spring-aop/design-pattern/dynamic-proxy/dynamic-proxy-02/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 public class LogTraceBasicHandler implements InvocationHandler &#123; private final Object target; private final LogTrace logTrace; public LogTraceBasicHandler(Object target, LogTrace logTrace) &#123; this.target = target; this.logTrace = logTrace; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; TraceStatus status = null; try &#123; String message = method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName() + &quot;()&quot;; status = logTrace.begin(message); // 로직 호출 method.invoke(target, args); logTrace.end(status); return result; &#125; catch (Exception ex) &#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; @Configurationpublic class DynamicBasicProxyConfig &#123; @Bean public OrderControllerV1 orderControllerV1(LogTrace logTrace)&#123; OrderControllerV1 orderControllerV1 = new OrderControllerV1Impl(orderServiceV1(logTrace)); // Proxy 객체 생성 OrderControllerV1 proxy = (OrderControllerV1) Proxy .newProxyInstance( OrderControllerV1.class.getClassLoader(), new Class[]&#123;OrderControllerV1.class&#125;, new LogTraceBasicHandler(orderControllerV1, logTrace)); return proxy; &#125; @Bean public OrderServiceV1 orderServiceV1(LogTrace logTrace)&#123; OrderServiceV1 orderServiceV1 = new OrderServiceV1Impl(orderRepositoryV1(logTrace)); // Proxy 객체 생성 OrderServiceV1 proxy = (OrderServiceV1) Proxy .newProxyInstance( OrderServiceV1.class.getClassLoader(), new Class[]&#123;OrderServiceV1.class&#125;, new LogTraceBasicHandler(orderServiceV1, logTrace)); return proxy; &#125; @Bean public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace)&#123; OrderRepositoryV1 orderRepository = new OrderRepositoryV1Impl(); // Proxy 객체 생성 OrderRepositoryV1 proxy = (OrderRepositoryV1) Proxy .newProxyInstance( OrderRepositoryV1.class.getClassLoader(), new Class[]&#123;OrderRepositoryV1.class&#125;, new LogTraceBasicHandler(orderRepository, logTrace)); return proxy; &#125;&#125; @Import(DynamicBasicProxyConfig.class)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; 2021-11-28 22:18:58.331 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] OrderControllerV1.request()2021-11-28 22:18:58.333 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] |--&gt;OrderServiceV1.orderItem()2021-11-28 22:18:58.333 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] | |--&gt;OrderRepositoryV1.save()2021-11-28 22:18:59.338 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] | |&lt;--OrderRepositoryV1.save() time=1005ms2021-11-28 22:18:59.338 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] |&lt;--OrderServiceV1.orderItem() time=1006ms2021-11-28 22:18:59.339 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] OrderControllerV1.request() time=1007ms 특정 메소드에만 부가기능 로직 적용PatternMatchUtils.simpleMatch 를 사용해 메소드 이름이 조건을 만족하는지 Pattern Matching 한다.","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 public class LogTraceBasicHandler implements InvocationHandler &#123; private final Object target; private final LogTrace logTrace; public LogTraceBasicHandler(Object target, LogTrace logTrace) &#123; this.target = target; this.logTrace = logTrace; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; TraceStatus status = null; try &#123; String message = method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName() + &quot;()&quot;; status = logTrace.begin(message); // 로직 호출 method.invoke(target, args); logTrace.end(status); return result; &#125; catch (Exception ex) &#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; @Configurationpublic class DynamicBasicProxyConfig &#123; @Bean public OrderControllerV1 orderControllerV1(LogTrace logTrace)&#123; OrderControllerV1 orderControllerV1 = new OrderControllerV1Impl(orderServiceV1(logTrace)); // Proxy 객체 생성 OrderControllerV1 proxy = (OrderControllerV1) Proxy .newProxyInstance( OrderControllerV1.class.getClassLoader(), new Class[]&#123;OrderControllerV1.class&#125;, new LogTraceBasicHandler(orderControllerV1, logTrace)); return proxy; &#125; @Bean public OrderServiceV1 orderServiceV1(LogTrace logTrace)&#123; OrderServiceV1 orderServiceV1 = new OrderServiceV1Impl(orderRepositoryV1(logTrace)); // Proxy 객체 생성 OrderServiceV1 proxy = (OrderServiceV1) Proxy .newProxyInstance( OrderServiceV1.class.getClassLoader(), new Class[]&#123;OrderServiceV1.class&#125;, new LogTraceBasicHandler(orderServiceV1, logTrace)); return proxy; &#125; @Bean public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace)&#123; OrderRepositoryV1 orderRepository = new OrderRepositoryV1Impl(); // Proxy 객체 생성 OrderRepositoryV1 proxy = (OrderRepositoryV1) Proxy .newProxyInstance( OrderRepositoryV1.class.getClassLoader(), new Class[]&#123;OrderRepositoryV1.class&#125;, new LogTraceBasicHandler(orderRepository, logTrace)); return proxy; &#125;&#125; @Import(DynamicBasicProxyConfig.class)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; 2021-11-28 22:18:58.331 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] OrderControllerV1.request()2021-11-28 22:18:58.333 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] |--&gt;OrderServiceV1.orderItem()2021-11-28 22:18:58.333 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] | |--&gt;OrderRepositoryV1.save()2021-11-28 22:18:59.338 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] | |&lt;--OrderRepositoryV1.save() time=1005ms2021-11-28 22:18:59.338 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] |&lt;--OrderServiceV1.orderItem() time=1006ms2021-11-28 22:18:59.339 INFO 3357 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [4e72efcd] OrderControllerV1.request() time=1007ms 특정 메소드에만 부가기능 로직 적용PatternMatchUtils.simpleMatch 를 사용해 메소드 이름이 조건을 만족하는지 Pattern Matching 한다. pattern : pattern 과 정확히 매칭되면 참 pattern* : pattern 으로 시작하면 참 *pattern : pattern 으로 끝나면 참 *pattern* : pattern 이 있으면 참 public class LogTraceFilterHandler implements InvocationHandler &#123; private final Object target; private final LogTrace logTrace; private final String[] patterns; public LogTraceFilterHandler(Object target, LogTrace logTrace, String[] patterns) &#123; this.target = target; this.logTrace = logTrace; this.patterns = patterns; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 메서드 이름 필터 String methodName = method.getName(); // save, request, reque*, *est // 특정 조건이 맞는 객체에 공통 기능을 적용한다. if(!PatternMatchUtils.simpleMatch(patterns, methodName))&#123; return method.invoke(target, args); &#125; TraceStatus status = null; try &#123; String message = method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName() + &quot;()&quot;; status = logTrace.begin(message); // 로직 호출 Object result = method.invoke(target, args); logTrace.end(status); return result; &#125; catch (Exception ex) &#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; public class DynamicProxyFilterConfig &#123; private static final String[] PATTERNS = &#123;&quot;request*&quot;, &quot;order*&quot;, &quot;save*&quot;&#125;; @Bean public OrderControllerV1 orderControllerV1(LogTrace logTrace)&#123; OrderControllerV1 orderControllerV1 = new OrderControllerV1Impl(orderServiceV1(logTrace)); OrderControllerV1 proxy = (OrderControllerV1) Proxy.newProxyInstance(OrderControllerV1.class.getClassLoader(), new Class[]&#123;OrderControllerV1.class&#125;, new LogTraceFilterHandler(orderControllerV1, logTrace, PATTERNS)); return proxy; &#125; @Bean public OrderServiceV1 orderServiceV1(LogTrace logTrace)&#123; OrderServiceV1 orderServiceV1 = new OrderServiceV1Impl(orderRepositoryV1(logTrace)); OrderServiceV1 proxy = (OrderServiceV1) Proxy.newProxyInstance(OrderServiceV1.class.getClassLoader(), new Class[]&#123;OrderServiceV1.class&#125;, new LogTraceFilterHandler(orderServiceV1, logTrace, PATTERNS)); return proxy; &#125; @Bean public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace)&#123; OrderRepositoryV1 orderRepository = new OrderRepositoryV1Impl(); OrderRepositoryV1 proxy = (OrderRepositoryV1) Proxy.newProxyInstance(OrderRepositoryV1.class.getClassLoader(), new Class[]&#123;OrderRepositoryV1.class&#125;, new LogTraceFilterHandler(orderRepository, logTrace, PATTERNS)); return proxy; &#125;&#125; @Import(DynamicProxyFilterConfig.class)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Dynamic Proxy","slug":"Spring/Spring-고급편/Dynamic-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Dynamic-Proxy/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Dynamic Proxy 1","slug":"spring/spring-aop/design-pattern/dynamic-proxy/dynamic-proxy-01","date":"2021-11-25T17:31:07.000Z","updated":"2024-02-26T15:23:31.785Z","comments":true,"path":"2021/11/26/spring/spring-aop/design-pattern/dynamic-proxy/dynamic-proxy-01/","link":"","permalink":"https://ckck803.github.io/2021/11/26/spring/spring-aop/design-pattern/dynamic-proxy/dynamic-proxy-01/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 JDK 동적 프록시 JDK 동적 프록시는 인터페이스 를 기반으로 프록시 를 동적으로 만들어준다.JDK 동적 프록시는 자바 리플렉션(Reflection) 을 이용하여 런타임 시에 인터페이스를 구현하는 프록시 객체 를 생성하는 기술 동적 프록시 기술을 사용하면 개발자가 직접 Proxy 클래스를 생성할 필요가 없이 런타임시 리플랙션의 Proxy 클래스가 동적으로 생성해준다는 장점이 있다. 하지만, 문제가 발생하면 런타임 에러 가 발생하므로 컴파일 시 오류를 찾기가 어려운 문제점 또한 존재한다. 동적 프록시 기술을 사용하면 런타임시 프록시 객체 를 생성해준다. 리플렉션 을 이용해 프록시를 생성한다. 타겟 인터페이스와 동일한 형태로 생성 FactoryBean 을 통해서 생성 프록시 객체는 원본 객체의 대리자 역할을 하며, 클라이언트가 프록시 객체를 통해 원본 객체에 접근하면, 프록시 객체가 요청을 가로채서 필요한 전처리나 후처리를 수행한 후, 최종 결과를 반환합니다. 동적 프록시는 프로그래머가 직접 코드를 작성하지 않아도 인터페이스의 메서드 호출을 가로채서 처리할 수 있어서 매우 유용합니다. 예를 들어, AOP(Aspect Oriented Programming)에서는 동적 프록시를 이용해서 메서드 호출 전후에 로그를 남기거나, 보안 검사를 수행하거나, 트랜잭션 관리를 수행할 수 있습니다. JDK에서는 java.lang.reflect 패키지에서 Proxy 클래스 를 제공합니다. 이 클래스의 정적 메서드인 newProxyInstance() 메서드를 이용하면, 인터페이스와 InvocationHandler 인터페이스를 구현한 클래스를 전달하여 동적 프록시 객체를 생성할 수 있습니다. 이때, InvocationHandler 인터페이스를 구현한 클래스에서는 invoke() 메서드를 구현하여 원본 객체의 메서드 호출을 가로채서 필요한 작업을 수행하도록 구현합니다. newProxyInstance","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 JDK 동적 프록시 JDK 동적 프록시는 인터페이스 를 기반으로 프록시 를 동적으로 만들어준다.JDK 동적 프록시는 자바 리플렉션(Reflection) 을 이용하여 런타임 시에 인터페이스를 구현하는 프록시 객체 를 생성하는 기술 동적 프록시 기술을 사용하면 개발자가 직접 Proxy 클래스를 생성할 필요가 없이 런타임시 리플랙션의 Proxy 클래스가 동적으로 생성해준다는 장점이 있다. 하지만, 문제가 발생하면 런타임 에러 가 발생하므로 컴파일 시 오류를 찾기가 어려운 문제점 또한 존재한다. 동적 프록시 기술을 사용하면 런타임시 프록시 객체 를 생성해준다. 리플렉션 을 이용해 프록시를 생성한다. 타겟 인터페이스와 동일한 형태로 생성 FactoryBean 을 통해서 생성 프록시 객체는 원본 객체의 대리자 역할을 하며, 클라이언트가 프록시 객체를 통해 원본 객체에 접근하면, 프록시 객체가 요청을 가로채서 필요한 전처리나 후처리를 수행한 후, 최종 결과를 반환합니다. 동적 프록시는 프로그래머가 직접 코드를 작성하지 않아도 인터페이스의 메서드 호출을 가로채서 처리할 수 있어서 매우 유용합니다. 예를 들어, AOP(Aspect Oriented Programming)에서는 동적 프록시를 이용해서 메서드 호출 전후에 로그를 남기거나, 보안 검사를 수행하거나, 트랜잭션 관리를 수행할 수 있습니다. JDK에서는 java.lang.reflect 패키지에서 Proxy 클래스 를 제공합니다. 이 클래스의 정적 메서드인 newProxyInstance() 메서드를 이용하면, 인터페이스와 InvocationHandler 인터페이스를 구현한 클래스를 전달하여 동적 프록시 객체를 생성할 수 있습니다. 이때, InvocationHandler 인터페이스를 구현한 클래스에서는 invoke() 메서드를 구현하여 원본 객체의 메서드 호출을 가로채서 필요한 작업을 수행하도록 구현합니다. newProxyInstance Proxy 클래스 내 정적 메소드로 newProxyInstance 를 이용해 런타임 시 동적으로 프록시 객체 를 생성 후 반환한다. 전달 받은 인터페이스 를 기반으로 Proxy 클래스를 생성한 후 JVM 에 올리고 Proxy 객체를 반환한다. newProxyInstance 메소드는 세 개의 인자를 받습니다. 첫 번째 인자는 동적 프록시 객체를 생성할 클래스 로더(ClassLoader) 입니다. 두 번째 인자는 동적 프록시 객체가 구현해야 할 인터페이스 목록 입니다. 세 번째 인자는 InvocationHandler 인터페이스를 구현한 객체 입니다. newProxyInstance 메소드는 프록시 객체를 생성하여 반환합니다. 이 프록시 객체는 인터페이스 목록에 선언된 모든 메소드를 구현하며, 실제 호출 시 InvocationHandler에서 정의한 로직이 수행됩니다. ClassLoader Proxy 클래스를 JVM 으로 로드할 클래스 로더, null 을 전달할 시 기본 클래스 로더 사용 Class&lt;?&gt; 프록시 클래스가 구현할 인터페이스 목록(배열) InvocationHandler 메서드가 호출되었을때 실행될 Handler public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) InvocationHandler InvocationHandler 를 이용해 JDK 동적 프로시에 적용할 공통 로직 을 개발한다. InvocationHandler 인터페이스는 invoke 메소드 하나만을 가지고 있으며, 이 메소드는 동적 프록시 객체가 처리해야 할 모든 메소드 호출을 가로채서 처리할 수 있습니다. invoke 메소드는 세 개의 인자를 받습니다. 첫 번째 인자는 동적 프록시 객체 자체이며, 두 번째 인자는 원본 객체의 메소드입니다. 세 번째 인자는 원본 객체의 메소드 호출 시 전달된 인자 배열입니다. InvocationHandler를 구현한 객체에서는 invoke 메소드를 구현하여 프록시 객체가 요청을 가로챌 때 처리해야 할 로직을 구현합니다. 예를 들어, 메소드 호출 전후에 로그를 남기거나, 메소드 호출 시간을 측정하거나, 트랜잭션을 관리하는 등의 작업을 수행할 수 있습니다. InvocationHandler.java public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; Dynamic Proxy 생성 InvocationHandler 인터페이스를 이용해 프록시 객체 생성시 추가할 로직을 정의 한다. TimeInvocationHandler 클래스는 Target 클래스를 호출할 때 시작과 종료 로그를 찍어주는 공통 로직을 가지고 있다. @Slf4jpublic class TimeInvocationHandler implements InvocationHandler &#123; private final Object target; public TimeInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log.info(&quot;TimeProxy 실행&quot;); long startTime = System.currentTimeMillis(); // Reflection 을 이용해 target 인스턴스의 메서드를 실행한다. args 는 메서드 호출시 넘겨줄 인자 Object result = method.invoke(target, args); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;TimeProxy 종료 resultTime = &#123;&#125;&quot;, resultTime); return result; &#125;&#125; newProxyInstance 를 이용해 동적으로 Proxy 객체를 만들어준다. public interface AInterface &#123; String call();&#125; @Slf4jpublic class AImpl implements AInterface&#123; @Override public String call() &#123; log.info(&quot;A 호출&quot;); return &quot;a&quot;; &#125;&#125; newProxyInstance 를 이용해 동적으로 Proxy 객체를 생성 newProxyInstance 메소드를 이용해 실제 객체와 동일한 인터페이스 와 부가로직 이 추가된 프록시 객체를 생성한다. newProxyInstance 메소드는 AInterface 인터페이스를 이용해 시작과 종료 로그 를 찍어주는 프록시 객체를 생성한 후 반환한다. 반환된 Proxy 객체는 AInterface 인터페이스를 구현한 객체로 실제 객체와 동일한 메소드를 이용해 호출했을때 시작, 종료 로그가 찍히는 것을 확인할 수 있다. @Testvoid dynamicA()&#123; AInterface target = new AImpl(); // 동적 Proxy 에 적용할 Handler 로직 TimeInvocationHandler handler = new TimeInvocationHandler(target); // Proxy 객체 생성 AInterface proxy = (AInterface) Proxy // 현재 Thread 의 Context Loader, Interface 배열, InvocationHandler 객체를 인자로 넣어준다. .newProxyInstance(AInterface.class.getClassLoader(), new Class[]&#123;AInterface.class&#125;, handler); // Proxy 객체 호출 // Client 에서는 동일한 메소드를 사용하면 된다. proxy.call(); log.info(&quot;targetClass = &#123;&#125;&quot;, target.getClass()); log.info(&quot;proxyClass = &#123;&#125;&quot;, proxy.getClass());&#125; 프록시 객체 호출 결과프록시 객체를 호출했을 때 AImpl 객체를 호출하기 전에 시작, 종료 로그가 찍히는 것을 확인할 수 있다. 17:43:18.808 [Test worker] INFO hello.proxy.jdkdynamic.code.TimeInvocationHandler - TimeProxy 실행17:43:18.811 [Test worker] INFO hello.proxy.jdkdynamic.code.AImpl - A 호출17:43:18.811 [Test worker] INFO hello.proxy.jdkdynamic.code.TimeInvocationHandler - TimeProxy 종료 resultTime = 017:43:18.812 [Test worker] INFO hello.proxy.jdkdynamic.JdkDynamicProxyTest - targetClass = class hello.proxy.jdkdynamic.code.AImpl17:43:18.813 [Test worker] INFO hello.proxy.jdkdynamic.JdkDynamicProxyTest - proxyClass = class com.sun.proxy.$Proxy12 public interface BInterface &#123; String call();&#125; @Slf4jpublic class BImpl implements BInterface&#123; @Override public String call() &#123; log.info(&quot;B 호출&quot;); return &quot;b&quot;; &#125;&#125; @Testvoid dynamicB()&#123; BInterface target = new BImpl(); TimeInvocationHandler handler = new TimeInvocationHandler(target); // Proxy 객체 생성 BInterface proxy = (BInterface) Proxy .newProxyInstance(BInterface.class.getClassLoader(), new Class[]&#123;BInterface.class&#125;, handler); proxy.call(); log.info(&quot;targetClass = &#123;&#125;&quot;, target.getClass()); log.info(&quot;proxyClass = &#123;&#125;&quot;, proxy.getClass());&#125; 17:49:03.329 [Test worker] INFO hello.proxy.jdkdynamic.code.TimeInvocationHandler - TimeProxy 실행17:49:03.331 [Test worker] INFO hello.proxy.jdkdynamic.code.BImpl - B 호출17:49:03.331 [Test worker] INFO hello.proxy.jdkdynamic.code.TimeInvocationHandler - TimeProxy 종료 resultTime = 017:49:03.333 [Test worker] INFO hello.proxy.jdkdynamic.JdkDynamicProxyTest - targetClass = class hello.proxy.jdkdynamic.code.BImpl17:49:03.333 [Test worker] INFO hello.proxy.jdkdynamic.JdkDynamicProxyTest - proxyClass = class com.sun.proxy.$Proxy12","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Dynamic Proxy","slug":"Spring/Spring-고급편/Dynamic-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Dynamic-Proxy/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - 리플렉션","slug":"spring/spring-aop/design-pattern/dynamic-proxy/reflection","date":"2021-11-25T16:31:07.000Z","updated":"2024-02-26T15:23:40.274Z","comments":true,"path":"2021/11/26/spring/spring-aop/design-pattern/dynamic-proxy/reflection/","link":"","permalink":"https://ckck803.github.io/2021/11/26/spring/spring-aop/design-pattern/dynamic-proxy/reflection/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 리플렉션 구체적인 클래스 타입을 알지 못해도 해당 클래스의 메소드, 타입, 변수들을 사용할 수 있도록 하는 자바 API 자바 Reflection 은 실행 중인 자바 프로그램 에서 클래스 정보에 접근하도록 하는 기술입니다. Reflection을 사용하면 클래스나 인터페이스의 이름, 필드의 이름, 타입 및 값, 메서드의 이름, 파라미터 타입 등의 정보를 가져오고 조작할 수 있습니다. 이를 통해 객체의 생성, 필드값 설정, 메서드 호출 등을 동적으로 수행할 수 있습니다. 리플렉션 - API클래스 정보 가져오기 - forNameClass 클래스의 forName 메서드를 사용하여 클래스 정보를 가져옵니다. 예를 들어, 다음과 같이 클래스 정보를 가져올 수 있습니다. Class&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;);","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 리플렉션 구체적인 클래스 타입을 알지 못해도 해당 클래스의 메소드, 타입, 변수들을 사용할 수 있도록 하는 자바 API 자바 Reflection 은 실행 중인 자바 프로그램 에서 클래스 정보에 접근하도록 하는 기술입니다. Reflection을 사용하면 클래스나 인터페이스의 이름, 필드의 이름, 타입 및 값, 메서드의 이름, 파라미터 타입 등의 정보를 가져오고 조작할 수 있습니다. 이를 통해 객체의 생성, 필드값 설정, 메서드 호출 등을 동적으로 수행할 수 있습니다. 리플렉션 - API클래스 정보 가져오기 - forNameClass 클래스의 forName 메서드를 사용하여 클래스 정보를 가져옵니다. 예를 들어, 다음과 같이 클래스 정보를 가져올 수 있습니다. Class&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;); 메서드 정보 가져오기 - getMethodClass 클래스의 getMethod 메서드를 사용하여 메서드 메타정보를 가져옵니다. 또한, 메서드 호출시 파라미터 값들이 필요한 경우 parameterTypes 를 사용하여 메서드의 파라미터 타입을 배열 형태로 지정할 수 있습니다. Class&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;);// 메소드 정보를 가져올 때 파라미터 정보를 배열 형태로 같이 넘겨준다.Method myMethod = myClass.getMethod(&quot;myMethod&quot;);// 메소드에 파라미터가 있을 경우 배열 형태로 같이 넘겨준다.Method myMethod = myClass.getMethod(&quot;myMethod&quot;, parameterTypes); 메서드 호출하기 - invokeReflection을 사용하여 메서드를 호출할 때는 Method 클래스의 invoke 메서드를 사용하여 target 객체내 메서드를 호출할 수 있습니다. Class&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;);Method myMethod = myClass.getMethod(&quot;myMethod&quot;);Object result = myMethod.invoke(target, args); target 객체내 메소드 호출시 다음과 같이 파라미터 타입을 지정해서 호출할 수도 있습니다. Class&lt;?&gt; myClass = MyClass.class;// 메소드 호출시 파라미터가 필요한 경우 파라미터 타입을 지정해서 메소드 정보를 가져온다.Method myMethod = myClass.getMethod(&quot;myMethod&quot;, int.class, String.class);// 메소드 호출시 파라미터가 필요한 경우 파라미터를 배열 형태로 같이 넘겨준다. Object result = myMethod.invoke(target, 123, &quot;hello&quot;); 필드 정보 가져오기 - getFieldClass 클래스의 getField 메서드를 사용하여 필드 정보를 가져옵니다. Class&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;);Field myField = myClass.getField(&quot;myField&quot;); 필드 값 가져오기 - getField 클래스의 get 메서드를 사용하여 target 객체내 필드 값 정보를 가져옵니다. Class&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;);Field myField = myClass.getField(&quot;myField&quot;);Object fieldValue = myField.get(target); Reflection 사용하기@Testvoid reflection0()&#123; Hello target = new Hello(); // 공통 로직 1 시작 log.info(&quot;start&quot;); String result1 = target.callA(); // 호출하는 메서드만 다름 log.info(&quot;result = &#123;&#125;&quot;, result1); // 공통 로직 1 종료 // 공통 로직 2 시작 log.info(&quot;start&quot;); String result2 = target.callB(); // 호출하는 메서드마 다름 log.info(&quot;result = &#123;&#125;&quot;, result2); // 공통 로직 2 종료&#125;@Slf4jstatic class Hello()&#123; public String callA()&#123; log.info(&quot;callA&quot;); return &quot;A&quot;; &#125; public String callB()&#123; log.info(&quot;callB&quot;); return &quot;B&quot;; &#125;&#125; Reflection 적용 전체 코드 흐름은 비슷하고 중간에 호출하는 메서드 하나만 다르다. log.info(&quot;start&quot;);String result = xxx(); // 호출하는 메서드마 다름log.info(&quot;result = &#123;&#125;&quot;, result); @Testvoid reflection1() throws Exception&#123; // 클래스 정보 Class classHello = Class.forName(&quot;hello.proxy.jdkdynamic.ReflectionTest$Hello&quot;); Hello target = new Hello(); // CallA 메서드 정보 Method methodCallA = classHello.getMethod(&quot;callA&quot;); Object result1 = methodCallA.invoke(target); // 인스턴스 정보를 넘겨준다. log.info(&quot;result = &#123;&#125;&quot;, result1); // CallB 메서드 정보 Method methodCallB = classHello.getMethod(&quot;callB&quot;); Object result2 = methodCallB.invoke(target); // 인스턴스 정보를 넘겨준다. log.info(&quot;result = &#123;&#125;&quot;, result2);&#125; 15:14:29.958 [Test worker] INFO hello.proxy.jdkdynamic.ReflectionTest$Hello - callA15:14:29.959 [Test worker] INFO hello.proxy.jdkdynamic.ReflectionTest - result = A15:14:29.960 [Test worker] INFO hello.proxy.jdkdynamic.ReflectionTest$Hello - callB15:14:29.960 [Test worker] INFO hello.proxy.jdkdynamic.ReflectionTest - result = B @Testvoid reflection2() throws Exception&#123; // 클래스 정보 Class classHello = Class.forName(&quot;hello.proxy.jdkdynamic.ReflectionTest$Hello&quot;); Hello target = new Hello(); // CallA 메서드 정보 Method methodCallA = classHello.getMethod(&quot;callA&quot;); dynamicCall(methodCallA, target); // CallB 메서드 정보 Method methodCallB = classHello.getMethod(&quot;callB&quot;); dynamicCall(methodCallB, target);&#125;private void dynamicCall(Method method, Object target) throws InvocationTargetException, IllegalAccessException &#123; log.info(&quot;start&quot;); Object result = method.invoke(target); log.info(&quot;result = &#123;&#125;&quot;, result);&#125; 리플렉션 단점 클래스와 메서드의 메타정보를 이용한 리플렉션 기술은 런타임 에 동작하기 때문에 컴파일 시점에서 에러를 잡을 수 없다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Dynamic Proxy","slug":"Spring/Spring-고급편/Dynamic-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Dynamic-Proxy/"}],"tags":[]},{"title":"컴파일 언어, 인터프리터 언어, 하이브리드 언어","slug":"computer-science/programming-language/build","date":"2021-11-24T21:16:13.000Z","updated":"2024-02-18T16:19:54.521Z","comments":true,"path":"2021/11/25/computer-science/programming-language/build/","link":"","permalink":"https://ckck803.github.io/2021/11/25/computer-science/programming-language/build/","excerpt":"빌드 : 소스 코드를 컴퓨터에서 실행하능한 파일로 만드는 과정 컴파일 : 원시 코드에서 목적 코드로 번역하는 과정","text":"빌드 : 소스 코드를 컴퓨터에서 실행하능한 파일로 만드는 과정 컴파일 : 원시 코드에서 목적 코드로 번역하는 과정","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Programming Lanuage","slug":"CS/Programming-Lanuage","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/"}],"tags":[]},{"title":"컴파일 언어, 인터프리터 언어, 하이브리드 언어","slug":"computer-science/programming-language/compile-interpreter","date":"2021-11-24T21:16:13.000Z","updated":"2024-02-18T16:19:54.521Z","comments":true,"path":"2021/11/25/computer-science/programming-language/compile-interpreter/","link":"","permalink":"https://ckck803.github.io/2021/11/25/computer-science/programming-language/compile-interpreter/","excerpt":"컴파일 언어, 인터프리터 언어, 하이브리드 언어 객체 지향 3요소 객체 지향 설계 5원칙 SOLID 컴파일 언어, 인터프리터 언어, 하이브리드 언어컴파일 언어 고급 언어로 작성된 코드를 Compiler(컴파일러) 를 이용해 목적 코드 로 번역하는 과정을 거치는 언어좁은 의미에서는 소스 코드를 기계어 로 번역해주는 과정을 컴파일이라 한다. 프로그램을 한번에 번연한 후 실행한다. 한번에 모든 소스를 번역하기 때문에 메모리 사용량이 크다. 번역 속도가 느림 실행 속도는 빠름 번역과 실행이 따로 이뤄지기 때문에 실행 파일 (ex. .exe) 이 생성된다. C, C++ 언어가 대표적인 컴파일 언어다. 인터프리터 언어 컴파일 언어와는 다르게 소스코드를 원시코드(기계어)로 번역하는 과정을 거치지 않는 언어Interpreter(인터프리터) 를 이용해 한줄씩 읽어가면서 명령을 처리한다. 번역 속도가 빠름 실행 속도는 느림 번역과 실행이 한번에 이뤄지기 때문에 별도의 실행파일이 만들어지지 않는다. Python, Javascript 가 대표적인 인터프리터 언어다. 하이브리드 언어 컴파일 기법과 인터프리터 기법을 모두 사용하는 언어","text":"컴파일 언어, 인터프리터 언어, 하이브리드 언어 객체 지향 3요소 객체 지향 설계 5원칙 SOLID 컴파일 언어, 인터프리터 언어, 하이브리드 언어컴파일 언어 고급 언어로 작성된 코드를 Compiler(컴파일러) 를 이용해 목적 코드 로 번역하는 과정을 거치는 언어좁은 의미에서는 소스 코드를 기계어 로 번역해주는 과정을 컴파일이라 한다. 프로그램을 한번에 번연한 후 실행한다. 한번에 모든 소스를 번역하기 때문에 메모리 사용량이 크다. 번역 속도가 느림 실행 속도는 빠름 번역과 실행이 따로 이뤄지기 때문에 실행 파일 (ex. .exe) 이 생성된다. C, C++ 언어가 대표적인 컴파일 언어다. 인터프리터 언어 컴파일 언어와는 다르게 소스코드를 원시코드(기계어)로 번역하는 과정을 거치지 않는 언어Interpreter(인터프리터) 를 이용해 한줄씩 읽어가면서 명령을 처리한다. 번역 속도가 빠름 실행 속도는 느림 번역과 실행이 한번에 이뤄지기 때문에 별도의 실행파일이 만들어지지 않는다. Python, Javascript 가 대표적인 인터프리터 언어다. 하이브리드 언어 컴파일 기법과 인터프리터 기법을 모두 사용하는 언어 컴파일러에 의해 중간 코드로 변환되고 다양한 시스템의 인터프리터에 의해 실행 프로그램 이식성이 좋아 어떤 컴퓨터 시스템에서든 즉시 실행이 가능하다. JAVA, C# 이 대표적인 하이브리드 언어다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Programming Lanuage","slug":"CS/Programming-Lanuage","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/"}],"tags":[]},{"title":"JPA 연관 관계 - 영속성 전이 Cascade","slug":"jpa/jpa-programming/mapping/jpa-cascade","date":"2021-11-24T19:31:46.000Z","updated":"2024-02-18T16:19:54.530Z","comments":true,"path":"2021/11/25/jpa/jpa-programming/mapping/jpa-cascade/","link":"","permalink":"https://ckck803.github.io/2021/11/25/jpa/jpa-programming/mapping/jpa-cascade/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 JPA 영속성 전이 Cascade Cascading 이란, 특정 Entity 에 작업을 수행했을 때, 같은 작업이 연관된 Entity 에도 일어나는 것을 의미한다. 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다. 엔티티를 연속화 할때 연관된 엔티티도 함께 영속화 하는 편리함을 제공한다. 영속성 전이 옵션 CascadeType.ALL 상위 Entity 에서 발생한 모든 작업을 하위 Entity 로 모두 전파 CascadeType.PERSIST 상위 Entity 를 영속화 하는 작업이 일어 날때 하위 Entity 도 같이 영속화 한다. CascadeType.MERGE 상위 Entity 에서 발생한 Merge 작업을 하위 Entity 까지 Merge 작업을 전파한다. CascadeType.REMOVE 상위 Entity 를 삭제할 때 하위 Entity 까지 삭제한다. CascadeType.REFRESH DataBase 로부터 상위 Entity 를 다시 읽어올때 하위 Entity 까지 다시 읽어온다. CascadeType.DETACH 상위 Entity 를 영속성 컨텍스트에서 제거할 때 하위 Entity 까지 같이 제거한다. @Entity@NoArgsConstructor@AllArgsConstructor@Setter@Getterpublic class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL) private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;(); public void addPhone(Phone phone)&#123; phones.add(phone); phone.setPerson(this); &#125;&#125; @Entity@Builder@NoArgsConstructor@AllArgsConstructor@Getter@Setterpublic class Phone &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) public Long id; public String phoneNumber; @ManyToOne @JoinColumn(name = &quot;PERSON_ID&quot;) public Person person;&#125;","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 JPA 영속성 전이 Cascade Cascading 이란, 특정 Entity 에 작업을 수행했을 때, 같은 작업이 연관된 Entity 에도 일어나는 것을 의미한다. 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다. 엔티티를 연속화 할때 연관된 엔티티도 함께 영속화 하는 편리함을 제공한다. 영속성 전이 옵션 CascadeType.ALL 상위 Entity 에서 발생한 모든 작업을 하위 Entity 로 모두 전파 CascadeType.PERSIST 상위 Entity 를 영속화 하는 작업이 일어 날때 하위 Entity 도 같이 영속화 한다. CascadeType.MERGE 상위 Entity 에서 발생한 Merge 작업을 하위 Entity 까지 Merge 작업을 전파한다. CascadeType.REMOVE 상위 Entity 를 삭제할 때 하위 Entity 까지 삭제한다. CascadeType.REFRESH DataBase 로부터 상위 Entity 를 다시 읽어올때 하위 Entity 까지 다시 읽어온다. CascadeType.DETACH 상위 Entity 를 영속성 컨텍스트에서 제거할 때 하위 Entity 까지 같이 제거한다. @Entity@NoArgsConstructor@AllArgsConstructor@Setter@Getterpublic class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL) private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;(); public void addPhone(Phone phone)&#123; phones.add(phone); phone.setPerson(this); &#125;&#125; @Entity@Builder@NoArgsConstructor@AllArgsConstructor@Getter@Setterpublic class Phone &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) public Long id; public String phoneNumber; @ManyToOne @JoinColumn(name = &quot;PERSON_ID&quot;) public Person person;&#125; 1. CascadeType.ALL 상위 Entity 에서 발생한 모든 작업을 하위 Entity 로 모두 전파한다. @Testvoid cascadeAllTest() &#123; Phone phone = new Phone(); phone.setPhoneNumber(&quot;010-1234-1234&quot;); Person person = new Person(); person.setName(&quot;tester&quot;); person.addPhone(phone); entityManager.persist(person); entityManager.flush();&#125; Hibernate: insert into person (id, name) values (null, ?)Hibernate: insert into phone (id, person_id, phone_number) values (null, ?, ?) 2. CascadeType.PERSIST 상위 Entity 를 영속화 하는 작업이 일어 날때 하위 Entity 도 같이 영속화 한다. @Testvoid cascadePersistTest() &#123; Phone phone = new Phone(); phone.setPhoneNumber(&quot;010-1234-1234&quot;); Person person = new Person(); person.setName(&quot;tester&quot;); person.addPhone(phone); entityManager.persist(person); entityManager.flush(); entityManager.remove(person); // 만약 지우게 될 경우 예외가 발생하게 된다.&#125; Hibernate: insert into person (id, name) values (null, ?)Hibernate: insert into phone (id, person_id, phone_number) values (null, ?, ?) 3. CascadeType.MERGE 상위 Entity 에서 발생한 Merge 작업을 하위 Entity 까지 Merge 작업을 전파한다. @Testvoid cascadeMergeTest() &#123; Phone phone = new Phone(); phone.setPhoneNumber(&quot;010-1234-1234&quot;); Person person = new Person(); person.setName(&quot;tester&quot;); person.addPhone(phone); entityManager.persist(person); entityManager.persist(phone); entityManager.flush(); // 영속성 Context 를 초기화 한다. entityManager.clear(); Person savedPerson = phone.getPerson(); phone.setPhoneNumber(&quot;010-1111-2222&quot;); savedPerson.setName(&quot;tester2&quot;); // Person 객체를 merge 할 경우 하위 Phone 객체까지 같이 영속성 Context 로 올라오게 된다. entityManager.merge(person);&#125; Hibernate: insert into person (id, name) values (null, ?)Hibernate: insert into phone (id, person_id, phone_number) values (null, ?, ?)Hibernate: select person0_.id as id1_0_1_, person0_.name as name2_0_1_, phones1_.person_id as person_i3_1_3_, phones1_.id as id1_1_3_, phones1_.id as id1_1_0_, phones1_.person_id as person_i3_1_0_, phones1_.phone_number as phone_nu2_1_0_ from person person0_ left outer join phone phones1_ on person0_.id=phones1_.person_id where person0_.id=?Hibernate: update phone set person_id=?, phone_number=? where id=?Hibernate: update person set name=? where id=? 4. CascadeType.REMOVE 상위 Entity 를 삭제할 때 하위 Entity 까지 삭제한다. @Testvoid cascadeRemoveTest() &#123; Phone phone = new Phone(); phone.setPhoneNumber(&quot;010-1234-1234&quot;); Person person = new Person(); person.setName(&quot;tester&quot;); person.addPhone(phone); entityManager.persist(person); entityManager.persist(phone); entityManager.flush(); Long personId = person.getId(); entityManager.clear(); Person savedPerson = entityManager.find(Person.class, personId); // Person 객체를 삭제할 경우 하위 Phone 객체까지 삭제된다. entityManager.remove(savedPerson);&#125; Hibernate: delete from phone where id=?Hibernate: delete from person where id=? 5. CascadeType.REFRESH DataBase 로부터 상위 Entity 를 다시 읽어올때 하위 Entity 까지 다시 읽어온다. @Testvoid cascadeRefreshTest() &#123; Phone phone = new Phone(); phone.setPhoneNumber(&quot;010-1234-1234&quot;); Person person = new Person(); person.setName(&quot;tester&quot;); person.addPhone(phone); entityManager.persist(person); entityManager.persist(phone); entityManager.flush(); person.setName(&quot;test2&quot;); phone.setPhoneNumber(&quot;010-1111-2222&quot;); // Person 객체와 하위 Phone 객체까지 영속성 Context 내 데이터가 초기화 된다. entityManager.refresh(person); // DataBase 에 데이터가 반영되지 않은 상태에서 Refresh 작업이 일어났기 때문에 상태가 초기화 된다. assertThat(person.getName()).isEqualTo(&quot;tester&quot;); assertThat(phone.getPhoneNumber()).isEqualTo(&quot;010-1234-1234&quot;);&#125; update 가 이뤄지지 않은 것을 확인할 수 있다. Hibernate: insert into person (id, name) values (null, ?)Hibernate: insert into phone (id, person_id, phone_number) values (null, ?, ?)Hibernate: select phone0_.id as id1_1_0_, phone0_.person_id as person_i3_1_0_, phone0_.phone_number as phone_nu2_1_0_ from phone phone0_ where phone0_.id=?Hibernate: select person0_.id as id1_0_1_, person0_.name as name2_0_1_, phones1_.person_id as person_i3_1_3_, phones1_.id as id1_1_3_, phones1_.id as id1_1_0_, phones1_.person_id as person_i3_1_0_, phones1_.phone_number as phone_nu2_1_0_ from person person0_ left outer join phone phones1_ on person0_.id=phones1_.person_id where person0_.id=? 6. CascadeType.DETACH 상위 Entity 를 영속성 컨텍스트에서 제거할 때 하위 Entity 까지 같이 제거한다. @Testvoid cascadeDetachTest() &#123; Phone phone = new Phone(); phone.setPhoneNumber(&quot;010-1234-1234&quot;); Person person = new Person(); person.setName(&quot;tester&quot;); person.addPhone(phone); entityManager.persist(person); entityManager.persist(phone); entityManager.flush(); assertThat(entityManager.contains(person)).isTrue(); assertThat(entityManager.contains(phone)).isTrue(); // Person 객체가 영속성 Context 에서 detach 될때 관련된 Phone 객체도 같이 detach 된다. entityManager.detach(person); assertThat(entityManager.contains(person)).isFalse(); assertThat(entityManager.contains(phone)).isFalse();&#125; 영속성 전이 주의점 소유자가 하나일때 사용하는 것이 좋다. 다른 테이블과 연관관계가 있을 경우에 사용하게 되면 문제가 생길 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2","slug":"spring/spring-aop/design-pattern/concrete-proxy/concrete-proxy-04","date":"2021-11-21T22:31:07.000Z","updated":"2024-02-26T15:22:54.633Z","comments":true,"path":"2021/11/22/spring/spring-aop/design-pattern/concrete-proxy/concrete-proxy-04/","link":"","permalink":"https://ckck803.github.io/2021/11/22/spring/spring-aop/design-pattern/concrete-proxy/concrete-proxy-04/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2public class OrderRepositoryConcreteProxy extends OrderRepositoryV2 &#123; private final OrderRepositoryV2 target; private final LogTrace logTrace; public OrderRepositoryConcreteProxy(OrderRepositoryV2 target, LogTrace logTrace) &#123; this.target = target; this.logTrace = logTrace; &#125; @Override public void save(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderRepository.request()&quot;); // target 호출 target.save(itemId); logTrace.end(status); &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; public class OrderServiceConcreteProxy extends OrderServiceV2 &#123; private final OrderServiceV2 target; private final LogTrace logTrace; public OrderServiceConcreteProxy(OrderServiceV2 target, LogTrace logTrace) &#123; super(null); this.target = target; this.logTrace = logTrace; &#125; @Override public void orderItem(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderService.orderItem()&quot;); // target 호출 target.orderItem(itemId); logTrace.end(status); &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; public class OrderControllerConcreteProxy extends OrderControllerV2 &#123; private final OrderControllerV2 target; private final LogTrace logTrace; public OrderControllerConcreteProxy(OrderControllerV2 target, LogTrace logTrace) &#123; super(null); this.target = target; this.logTrace = logTrace; &#125; @Override public String request(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderController.request()&quot;); // target 호출 String result = target.request(itemId); logTrace.end(status); return result; &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125; @Override public String noLog() &#123; return target.noLog(); &#125;&#125; @Configurationpublic class ConcreteProxyConfig &#123; @Bean public OrderControllerV2 orderControllerV2(LogTrace logTrace)&#123; OrderControllerV2 controllerImpl = new OrderControllerV2(orderServiceV2(logTrace)); return new OrderControllerConcreteProxy(controllerImpl, logTrace); &#125; @Bean public OrderServiceV2 orderServiceV2(LogTrace logTrace)&#123; OrderServiceV2 serviceImpl = new OrderServiceV2(orderRepositoryV2(logTrace)); return new OrderServiceConcreteProxy(serviceImpl, logTrace); &#125; @Bean public OrderRepositoryV2 orderRepositoryV2(LogTrace logTrace)&#123; OrderRepositoryV2 repositoryImpl = new OrderRepositoryV2(); return new OrderRepositoryConcreteProxy(repositoryImpl, logTrace); &#125;&#125; //@Import(AppV1Config.class)//@Import(&#123;AppV1Config.class, AppV2Config.class&#125;)//@Import(InterfaceProxyConfig.class)@Import(ConcreteProxyConfig.class)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; 2021-11-28 14:45:36.692 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] OrderController.request()2021-11-28 14:45:36.693 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] |--&gt;OrderService.orderItem()2021-11-28 14:45:36.693 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] | |--&gt;OrderRepository.request()2021-11-28 14:45:37.696 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] | |&lt;--OrderRepository.request() time=1003ms2021-11-28 14:45:37.696 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] |&lt;--OrderService.orderItem() time=1003ms2021-11-28 14:45:37.697 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] OrderController.request() time=1005ms","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2public class OrderRepositoryConcreteProxy extends OrderRepositoryV2 &#123; private final OrderRepositoryV2 target; private final LogTrace logTrace; public OrderRepositoryConcreteProxy(OrderRepositoryV2 target, LogTrace logTrace) &#123; this.target = target; this.logTrace = logTrace; &#125; @Override public void save(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderRepository.request()&quot;); // target 호출 target.save(itemId); logTrace.end(status); &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; public class OrderServiceConcreteProxy extends OrderServiceV2 &#123; private final OrderServiceV2 target; private final LogTrace logTrace; public OrderServiceConcreteProxy(OrderServiceV2 target, LogTrace logTrace) &#123; super(null); this.target = target; this.logTrace = logTrace; &#125; @Override public void orderItem(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderService.orderItem()&quot;); // target 호출 target.orderItem(itemId); logTrace.end(status); &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; public class OrderControllerConcreteProxy extends OrderControllerV2 &#123; private final OrderControllerV2 target; private final LogTrace logTrace; public OrderControllerConcreteProxy(OrderControllerV2 target, LogTrace logTrace) &#123; super(null); this.target = target; this.logTrace = logTrace; &#125; @Override public String request(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderController.request()&quot;); // target 호출 String result = target.request(itemId); logTrace.end(status); return result; &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125; @Override public String noLog() &#123; return target.noLog(); &#125;&#125; @Configurationpublic class ConcreteProxyConfig &#123; @Bean public OrderControllerV2 orderControllerV2(LogTrace logTrace)&#123; OrderControllerV2 controllerImpl = new OrderControllerV2(orderServiceV2(logTrace)); return new OrderControllerConcreteProxy(controllerImpl, logTrace); &#125; @Bean public OrderServiceV2 orderServiceV2(LogTrace logTrace)&#123; OrderServiceV2 serviceImpl = new OrderServiceV2(orderRepositoryV2(logTrace)); return new OrderServiceConcreteProxy(serviceImpl, logTrace); &#125; @Bean public OrderRepositoryV2 orderRepositoryV2(LogTrace logTrace)&#123; OrderRepositoryV2 repositoryImpl = new OrderRepositoryV2(); return new OrderRepositoryConcreteProxy(repositoryImpl, logTrace); &#125;&#125; //@Import(AppV1Config.class)//@Import(&#123;AppV1Config.class, AppV2Config.class&#125;)//@Import(InterfaceProxyConfig.class)@Import(ConcreteProxyConfig.class)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; 2021-11-28 14:45:36.692 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] OrderController.request()2021-11-28 14:45:36.693 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] |--&gt;OrderService.orderItem()2021-11-28 14:45:36.693 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] | |--&gt;OrderRepository.request()2021-11-28 14:45:37.696 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] | |&lt;--OrderRepository.request() time=1003ms2021-11-28 14:45:37.696 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] |&lt;--OrderService.orderItem() time=1003ms2021-11-28 14:45:37.697 INFO 98295 --- [nio-8080-exec-1] h.p.trace.logtrace.ThreadLocalLogTrace : [56d57615] OrderController.request() time=1005ms","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Decorator 패턴","slug":"Spring/Spring-고급편/Decorator-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Decorator-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - 구체 클래스 기반 프록시","slug":"spring/spring-aop/design-pattern/concrete-proxy/concrete-proxy-02","date":"2021-11-21T20:31:07.000Z","updated":"2024-02-26T15:22:51.300Z","comments":true,"path":"2021/11/22/spring/spring-aop/design-pattern/concrete-proxy/concrete-proxy-02/","link":"","permalink":"https://ckck803.github.io/2021/11/22/spring/spring-aop/design-pattern/concrete-proxy/concrete-proxy-02/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시@Slf4jpublic class ConcreteLogic &#123; public String operation()&#123; log.info(&quot;ConcreteLogic 실행&quot;); return &quot;data&quot;; &#125;&#125; public class ConcreteClient &#123; private ConcreteLogic concreteLogic; public ConcreteClient(ConcreteLogic concreteLogic) &#123; this.concreteLogic = concreteLogic; &#125; public void execute()&#123; concreteLogic.operation(); &#125;&#125; @Testvoid noProxy()&#123; ConcreteLogic concreteLogic = new ConcreteLogic(); ConcreteClient client = new ConcreteClient(concreteLogic); client.execute();&#125; 구체 클래스 기반 프록시 적용 자바에서 다형성은 인터페이스를 구현하든 상위 클래스를 상속하던 상위 타입만 맞으면 다형성이 적용 된다.","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시@Slf4jpublic class ConcreteLogic &#123; public String operation()&#123; log.info(&quot;ConcreteLogic 실행&quot;); return &quot;data&quot;; &#125;&#125; public class ConcreteClient &#123; private ConcreteLogic concreteLogic; public ConcreteClient(ConcreteLogic concreteLogic) &#123; this.concreteLogic = concreteLogic; &#125; public void execute()&#123; concreteLogic.operation(); &#125;&#125; @Testvoid noProxy()&#123; ConcreteLogic concreteLogic = new ConcreteLogic(); ConcreteClient client = new ConcreteClient(concreteLogic); client.execute();&#125; 구체 클래스 기반 프록시 적용 자바에서 다형성은 인터페이스를 구현하든 상위 클래스를 상속하던 상위 타입만 맞으면 다형성이 적용 된다. @Slf4jpublic class TimeProxy extends ConcreteLogic&#123; private ConcreteLogic concreteLogic; public TimeProxy(ConcreteLogic concreteLogic) &#123; this.concreteLogic = concreteLogic; &#125; @Override public String operation()&#123; log.info(&quot;TimeDecorator 실행&quot;); long startTime = System.currentTimeMillis(); String result = concreteLogic.operation(); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;TimeDecorator 종료 resultTime = &#123;&#125;ms&quot;, resultTime); return result; &#125;&#125; @Testvoid addProxy()&#123; ConcreteLogic concreteLogic = new ConcreteLogic(); TimeProxy timeProxy = new TimeProxy(concreteLogic); ConcreteClient client = new ConcreteClient(timeProxy); client.execute();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Decorator 패턴","slug":"Spring/Spring-고급편/Decorator-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Decorator-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - 인터페이스 프록시 1","slug":"spring/spring-aop/design-pattern/concrete-proxy/concrete-proxy-01","date":"2021-11-21T19:31:07.000Z","updated":"2024-02-26T15:22:47.687Z","comments":true,"path":"2021/11/22/spring/spring-aop/design-pattern/concrete-proxy/concrete-proxy-01/","link":"","permalink":"https://ckck803.github.io/2021/11/22/spring/spring-aop/design-pattern/concrete-proxy/concrete-proxy-01/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 @RequiredArgsConstructorpublic class OrderRepositoryInterfaceProxy implements OrderRepositoryV1 &#123; // 실제 객체 참조 private final OrderRepositoryV1 target; private final LogTrace logTrace; @Override public void save(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderRepository.request()&quot;); // target 호출 target.save(itemId); logTrace.end(status); &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; @RequiredArgsConstructorpublic class OrderServiceInterfaceProxy implements OrderServiceV1 &#123; private final OrderServiceV1 target; private final LogTrace logTrace; @Override public void orderItem(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderService.orderItem()&quot;); // target 호출 target.orderItem(itemId); logTrace.end(status); &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; @RequiredArgsConstructorpublic class OrderControllerInterfaceProxy implements OrderControllerV1 &#123; private final OrderControllerV1 target; private final LogTrace logTrace; @Override public String request(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderController.request()&quot;); // target 호출 String result = target.request(itemId); logTrace.end(status); return result; &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125; @Override public String noLog() &#123; return target.noLog(); &#125;&#125; Proxy Bean 등록@Configurationpublic class InterfaceProxyConfig &#123; @Bean public OrderControllerV1 orderController(LogTrace logTrace)&#123; OrderControllerV1Impl controllerImpl = new OrderControllerV1Impl(orderService(logTrace)); return new OrderControllerInterfaceProxy(controllerImpl, logTrace); &#125; @Bean public OrderServiceV1 orderService(LogTrace logTrace)&#123; OrderServiceV1Impl orderServiceImpl = new OrderServiceV1Impl(orderRepository(logTrace)); return new OrderServiceInterfaceProxy(orderServiceImpl, logTrace); &#125; @Bean public OrderRepositoryV1 orderRepository(LogTrace logTrace)&#123; OrderRepositoryV1 orderRepositoryImpl = new OrderRepositoryV1Impl(); return new OrderRepositoryInterfaceProxy(orderRepositoryImpl, logTrace); &#125;&#125; //@Import(AppV1Config.class)//@Import(&#123;AppV1Config.class, AppV2Config.class&#125;)@Import(InterfaceProxyConfig.class)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; 2021-11-28 13:54:09.793 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] OrderController.request()2021-11-28 13:54:09.795 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] |--&gt;OrderService.orderItem()2021-11-28 13:54:09.795 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] | |--&gt;OrderRepository.request()2021-11-28 13:54:10.798 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] | |&lt;--OrderRepository.request() time=1003ms2021-11-28 13:54:10.798 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] |&lt;--OrderService.orderItem() time=1003ms2021-11-28 13:54:10.798 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] OrderController.request() time=1005ms","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 @RequiredArgsConstructorpublic class OrderRepositoryInterfaceProxy implements OrderRepositoryV1 &#123; // 실제 객체 참조 private final OrderRepositoryV1 target; private final LogTrace logTrace; @Override public void save(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderRepository.request()&quot;); // target 호출 target.save(itemId); logTrace.end(status); &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; @RequiredArgsConstructorpublic class OrderServiceInterfaceProxy implements OrderServiceV1 &#123; private final OrderServiceV1 target; private final LogTrace logTrace; @Override public void orderItem(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderService.orderItem()&quot;); // target 호출 target.orderItem(itemId); logTrace.end(status); &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125;&#125; @RequiredArgsConstructorpublic class OrderControllerInterfaceProxy implements OrderControllerV1 &#123; private final OrderControllerV1 target; private final LogTrace logTrace; @Override public String request(String itemId) &#123; TraceStatus status = null; try&#123; status = logTrace.begin(&quot;OrderController.request()&quot;); // target 호출 String result = target.request(itemId); logTrace.end(status); return result; &#125;catch (Exception ex)&#123; logTrace.exception(status, ex); throw ex; &#125; &#125; @Override public String noLog() &#123; return target.noLog(); &#125;&#125; Proxy Bean 등록@Configurationpublic class InterfaceProxyConfig &#123; @Bean public OrderControllerV1 orderController(LogTrace logTrace)&#123; OrderControllerV1Impl controllerImpl = new OrderControllerV1Impl(orderService(logTrace)); return new OrderControllerInterfaceProxy(controllerImpl, logTrace); &#125; @Bean public OrderServiceV1 orderService(LogTrace logTrace)&#123; OrderServiceV1Impl orderServiceImpl = new OrderServiceV1Impl(orderRepository(logTrace)); return new OrderServiceInterfaceProxy(orderServiceImpl, logTrace); &#125; @Bean public OrderRepositoryV1 orderRepository(LogTrace logTrace)&#123; OrderRepositoryV1 orderRepositoryImpl = new OrderRepositoryV1Impl(); return new OrderRepositoryInterfaceProxy(orderRepositoryImpl, logTrace); &#125;&#125; //@Import(AppV1Config.class)//@Import(&#123;AppV1Config.class, AppV2Config.class&#125;)@Import(InterfaceProxyConfig.class)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; 2021-11-28 13:54:09.793 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] OrderController.request()2021-11-28 13:54:09.795 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] |--&gt;OrderService.orderItem()2021-11-28 13:54:09.795 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] | |--&gt;OrderRepository.request()2021-11-28 13:54:10.798 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] | |&lt;--OrderRepository.request() time=1003ms2021-11-28 13:54:10.798 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] |&lt;--OrderService.orderItem() time=1003ms2021-11-28 13:54:10.798 INFO 97198 --- [nio-8080-exec-2] h.p.trace.logtrace.ThreadLocalLogTrace : [86b4baba] OrderController.request() time=1005ms","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Decorator 패턴","slug":"Spring/Spring-고급편/Decorator-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Decorator-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Decorator Pattern 2","slug":"spring/spring-aop/design-pattern/decorator/decorator-02","date":"2021-11-21T17:31:07.000Z","updated":"2024-02-26T15:23:04.573Z","comments":true,"path":"2021/11/22/spring/spring-aop/design-pattern/decorator/decorator-02/","link":"","permalink":"https://ckck803.github.io/2021/11/22/spring/spring-aop/design-pattern/decorator/decorator-02/","excerpt":"목차 Post not found: springboot/spring-aop/cglib/cglib-01 Post not found: springboot/spring-aop/dynamic-proxy/dynamic-proxy-02 Post not found: springboot/spring-aop/dynamic-proxy/dynamic-proxy-01 Post not found: springboot/spring-aop/dynamic-proxy/reflection Post not found: springboot/spring-aop/concrete-proxy/concrete-proxy-04 Post not found: springboot/spring-aop/concrete-proxy/concrete-proxy-02 Post not found: springboot/spring-aop/concrete-proxy/concrete-proxy-01 Post not found: springboot/spring-aop/decorator/decorator-02 Post not found: springboot/spring-aop/decorator/decorator-01 Post not found: springboot/spring-aop/proxy-pattern/proxy-04 Post not found: springboot/spring-aop/proxy-pattern/proxy-03 Post not found: springboot/spring-aop/proxy-pattern/proxy-02 Post not found: springboot/spring-aop/proxy-pattern/proxy-01 Post not found: springboot/spring-aop/strategy-pattern/strategy-pattern-01 Post not found: springboot/spring-aop/template-method/template-method-01 Spring 핵심원리 고급편 - Decorator Pattern 적용@Slf4jpublic class TimeDecorator implements Component&#123; private Component component; public TimeDecorator(Component component) &#123; this.component = component; &#125; @Override public String operation() &#123; log.info(&quot;TimeDecorator 실행&quot;); long startTime = System.currentTimeMillis(); String result = component.operation(); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;TimeDecorator 종료 resultTime = &#123;&#125;ms&quot;, resultTime); return null; &#125;&#125; @Testvoid decorator2()&#123; Component realComponent = new RealComponent(); Component messageDecorator = new MessageDecorator(realComponent); Component timeDecorator = new TimeDecorator(messageDecorator); DecoratorPatternClient client = new DecoratorPatternClient(timeDecorator); client.execute();&#125; Decoratro Pattern 은 항상 내부에 꾸며 줄 대상(Component) 가 존재해야 한다.","text":"목차 Post not found: springboot/spring-aop/cglib/cglib-01 Post not found: springboot/spring-aop/dynamic-proxy/dynamic-proxy-02 Post not found: springboot/spring-aop/dynamic-proxy/dynamic-proxy-01 Post not found: springboot/spring-aop/dynamic-proxy/reflection Post not found: springboot/spring-aop/concrete-proxy/concrete-proxy-04 Post not found: springboot/spring-aop/concrete-proxy/concrete-proxy-02 Post not found: springboot/spring-aop/concrete-proxy/concrete-proxy-01 Post not found: springboot/spring-aop/decorator/decorator-02 Post not found: springboot/spring-aop/decorator/decorator-01 Post not found: springboot/spring-aop/proxy-pattern/proxy-04 Post not found: springboot/spring-aop/proxy-pattern/proxy-03 Post not found: springboot/spring-aop/proxy-pattern/proxy-02 Post not found: springboot/spring-aop/proxy-pattern/proxy-01 Post not found: springboot/spring-aop/strategy-pattern/strategy-pattern-01 Post not found: springboot/spring-aop/template-method/template-method-01 Spring 핵심원리 고급편 - Decorator Pattern 적용@Slf4jpublic class TimeDecorator implements Component&#123; private Component component; public TimeDecorator(Component component) &#123; this.component = component; &#125; @Override public String operation() &#123; log.info(&quot;TimeDecorator 실행&quot;); long startTime = System.currentTimeMillis(); String result = component.operation(); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;TimeDecorator 종료 resultTime = &#123;&#125;ms&quot;, resultTime); return null; &#125;&#125; @Testvoid decorator2()&#123; Component realComponent = new RealComponent(); Component messageDecorator = new MessageDecorator(realComponent); Component timeDecorator = new TimeDecorator(messageDecorator); DecoratorPatternClient client = new DecoratorPatternClient(timeDecorator); client.execute();&#125; Decoratro Pattern 은 항상 내부에 꾸며 줄 대상(Component) 가 존재해야 한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Decorator 패턴","slug":"Spring/Spring-고급편/Decorator-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Decorator-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Decorator Pattern 1","slug":"spring/spring-aop/design-pattern/decorator/decorator-01","date":"2021-11-21T16:31:07.000Z","updated":"2024-02-26T15:22:59.402Z","comments":true,"path":"2021/11/22/spring/spring-aop/design-pattern/decorator/decorator-01/","link":"","permalink":"https://ckck803.github.io/2021/11/22/spring/spring-aop/design-pattern/decorator/decorator-01/","excerpt":"목차 Post not found: spring/design-pattern/spring-aop/cglib/cglib-01 Post not found: spring/design-pattern/spring-aop/dynamic-proxy/dynamic-proxy-02 Post not found: spring/design-pattern/spring-aop/dynamic-proxy/dynamic-proxy-01 Post not found: spring/design-pattern/spring-aop/dynamic-proxy/reflection Post not found: spring/design-pattern/spring-aop/concrete-proxy/concrete-proxy-04 Post not found: spring/design-pattern/spring-aop/concrete-proxy/concrete-proxy-02 Post not found: spring/design-pattern/spring-aop/concrete-proxy/concrete-proxy-01 Post not found: spring/design-pattern/spring-aop/decorator/decorator-02 Post not found: spring/design-pattern/spring-aop/decorator/decorator-01 Post not found: spring/design-pattern/spring-aop/proxy-pattern/proxy-04 Post not found: spring/design-pattern/spring-aop/proxy-pattern/proxy-03 Post not found: spring/design-pattern/spring-aop/proxy-pattern/proxy-02 Post not found: spring/design-pattern/spring-aop/proxy-pattern/proxy-01 Post not found: spring/design-pattern/spring-aop/strategy-pattern/strategy-pattern-01 Post not found: spring/design-pattern/spring-aop/template-method/template-method-01 Decorator 패턴 Decorator 패턴 은 기존 객체 수정없이 부가 기능 추가 를 위해 주로 사용하는 디자인 패턴이다. Decorator 패턴은 객체 지향 디자인 원칙 중 하나인 개방-폐쇄 원칙(OCP) 을 따릅니다. 이 패턴을 사용하면 코드의 수정 없이 기존 클래스에 새로운 기능을 추가하거나 기존 기능을 수정할 수 있습니다. Decorator 클래스는 기본 객체와 같은 인터페이스를 사용해 구현되며, 기본 객체를 Wrapping 하여 추가적인 기능을 제공합니다. 이러한 구조는 객체 간의 결합도를 낮추고, 유연성과 확장성을 높입니다. 기존 객체를 감싸는 Wrapper 클래스 를 만들고, Wrapper 클래스에 새로운 기능을 추가하는 방식으로 새로운 기능을 추가하거나 기존 기능을 수정하는데 사용됩니다. Decorator 패턴을 사용하면 객체의 기존 동작을 변경하지 않고도 객체에 새로운 동작을 추가할 수 있습니다. Decorator 패턴의 구성요소 Component 인터페이스나 추상 클래스로 정의된 기본 객체의 공통 인터페이스입니다. ConcreteComponent Component 인터페이스를 구현한 실제 객체입니다. Decorator Component 인터페이스를 구현하며, 기본 객체를 래핑하고 추가적인 기능을 제공하는 추상 클래스입니다. ConcreteDecorator Decorator 추상 클래스를 상속받아 기본 객체를 래핑하고 추가적인 기능을 구현한 실제 객체입니다.","text":"목차 Post not found: spring/design-pattern/spring-aop/cglib/cglib-01 Post not found: spring/design-pattern/spring-aop/dynamic-proxy/dynamic-proxy-02 Post not found: spring/design-pattern/spring-aop/dynamic-proxy/dynamic-proxy-01 Post not found: spring/design-pattern/spring-aop/dynamic-proxy/reflection Post not found: spring/design-pattern/spring-aop/concrete-proxy/concrete-proxy-04 Post not found: spring/design-pattern/spring-aop/concrete-proxy/concrete-proxy-02 Post not found: spring/design-pattern/spring-aop/concrete-proxy/concrete-proxy-01 Post not found: spring/design-pattern/spring-aop/decorator/decorator-02 Post not found: spring/design-pattern/spring-aop/decorator/decorator-01 Post not found: spring/design-pattern/spring-aop/proxy-pattern/proxy-04 Post not found: spring/design-pattern/spring-aop/proxy-pattern/proxy-03 Post not found: spring/design-pattern/spring-aop/proxy-pattern/proxy-02 Post not found: spring/design-pattern/spring-aop/proxy-pattern/proxy-01 Post not found: spring/design-pattern/spring-aop/strategy-pattern/strategy-pattern-01 Post not found: spring/design-pattern/spring-aop/template-method/template-method-01 Decorator 패턴 Decorator 패턴 은 기존 객체 수정없이 부가 기능 추가 를 위해 주로 사용하는 디자인 패턴이다. Decorator 패턴은 객체 지향 디자인 원칙 중 하나인 개방-폐쇄 원칙(OCP) 을 따릅니다. 이 패턴을 사용하면 코드의 수정 없이 기존 클래스에 새로운 기능을 추가하거나 기존 기능을 수정할 수 있습니다. Decorator 클래스는 기본 객체와 같은 인터페이스를 사용해 구현되며, 기본 객체를 Wrapping 하여 추가적인 기능을 제공합니다. 이러한 구조는 객체 간의 결합도를 낮추고, 유연성과 확장성을 높입니다. 기존 객체를 감싸는 Wrapper 클래스 를 만들고, Wrapper 클래스에 새로운 기능을 추가하는 방식으로 새로운 기능을 추가하거나 기존 기능을 수정하는데 사용됩니다. Decorator 패턴을 사용하면 객체의 기존 동작을 변경하지 않고도 객체에 새로운 동작을 추가할 수 있습니다. Decorator 패턴의 구성요소 Component 인터페이스나 추상 클래스로 정의된 기본 객체의 공통 인터페이스입니다. ConcreteComponent Component 인터페이스를 구현한 실제 객체입니다. Decorator Component 인터페이스를 구현하며, 기본 객체를 래핑하고 추가적인 기능을 제공하는 추상 클래스입니다. ConcreteDecorator Decorator 추상 클래스를 상속받아 기본 객체를 래핑하고 추가적인 기능을 구현한 실제 객체입니다. 인터페이스public interface Component &#123; String operation();&#125; 대상 객체@Slf4jpublic class RealComponent implements Component&#123; @Override public String operation() &#123; log.info(&quot;Real Component 실행&quot;); return &quot;data&quot;; &#125;&#125; Client 코드@Slf4jpublic class DecoratorPatternClient &#123; private Component component; public DecoratorPatternClient(Component component)&#123; this.component = component; &#125; public void execute()&#123; String result = component.operation(); log.info(&quot;result = &#123;&#125;&quot;, result); &#125;&#125; 실행 및 결과@Slf4jpublic class DecoratorPatternTest &#123; @Test void noDecorator()&#123; Component component = new RealComponent(); DecoratorPatternClient client = new DecoratorPatternClient(component); client.execute(); &#125;&#125; 데코레이터 패턴 적용 MessageDecorator 는 Component 인터페이스를 구현해 생성하고 내부적으로 대상 Component 객체를 관리한다. MessageDecorator 에서 구현된 Method 는 부가기능을 수행하는 로직을 수행하고 대상 Component 객체를 호출한다. @Slf4jpublic class MessageDecorator implements Component&#123; private Component component; // 생성자를 통한 의존성 주입 public MessageDecorator(Component component) &#123; this.component = component; &#125; @Override public String operation() &#123; log.info(&quot;MessageDecorator 실행&quot;); // 대상 객체를 호출한다. String result = component.operation(); String decoResult = &quot;*****&quot; + result + &quot;*****&quot; ; log.info(&quot;MessageDecorator 꾸미기 적용 전 = &#123;&#125;, 적용 후 = &#123;&#125;&quot;, result, decoResult); return decoResult; &#125;&#125; 실행 및 결과실제 객체 RealComponent 를 이용해 부가기능이 적용된 MessageDecorator 객체를 생성해준다. @Testvoid decorator1()&#123; Component realComponent = new RealComponent(); Component messageDecorator = new MessageDecorator(realComponent); DecoratorPatternClient client = new DecoratorPatternClient(messageDecorator); client.execute();&#125; 실행 결과를 통해 MessageDecorator 가 호출돼 부가기능 로직이 수행되고 실제 객체 RealComponent 가 호출된 것을 확인할 수 있다. 여러개의 데코레이터 추가","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Decorator 패턴","slug":"Spring/Spring-고급편/Decorator-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Decorator-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록","slug":"spring/spring-aop/design-pattern/proxy-pattern/proxy-04","date":"2021-11-20T18:31:07.000Z","updated":"2024-02-26T15:23:58.742Z","comments":true,"path":"2021/11/21/spring/spring-aop/design-pattern/proxy-pattern/proxy-04/","link":"","permalink":"https://ckck803.github.io/2021/11/21/spring/spring-aop/design-pattern/proxy-pattern/proxy-04/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Spring 핵심원리 고급편 - Proxy Pattern 컴포넌트 스캔으로 자동 빈 등록@Repositorypublic class OrderRepositoryV3 &#123; public void save(String itemId) &#123; if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; @Servicepublic class OrderServiceV3 &#123; private final OrderRepositoryV3 orderRepository; public OrderServiceV3(OrderRepositoryV3 orderRepository) &#123; this.orderRepository = orderRepository; &#125; public void orderItem(String itemId) &#123; orderRepository.save(itemId); &#125;&#125; @RestController@Slf4jpublic class OrderControllerV3 &#123; private final OrderServiceV3 orderService; public OrderControllerV3(OrderServiceV3 orderService) &#123; this.orderService = orderService; &#125; @GetMapping(&quot;/v3/request&quot;) public String request(String itemId) &#123; orderService.orderItem(itemId); return &quot;ok&quot;; &#125; @GetMapping(&quot;/v3/no-log&quot;) public String noLog() &#123; return &quot;ok&quot;; &#125;&#125;","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Spring 핵심원리 고급편 - Proxy Pattern 컴포넌트 스캔으로 자동 빈 등록@Repositorypublic class OrderRepositoryV3 &#123; public void save(String itemId) &#123; if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; @Servicepublic class OrderServiceV3 &#123; private final OrderRepositoryV3 orderRepository; public OrderServiceV3(OrderRepositoryV3 orderRepository) &#123; this.orderRepository = orderRepository; &#125; public void orderItem(String itemId) &#123; orderRepository.save(itemId); &#125;&#125; @RestController@Slf4jpublic class OrderControllerV3 &#123; private final OrderServiceV3 orderService; public OrderControllerV3(OrderServiceV3 orderService) &#123; this.orderService = orderService; &#125; @GetMapping(&quot;/v3/request&quot;) public String request(String itemId) &#123; orderService.orderItem(itemId); return &quot;ok&quot;; &#125; @GetMapping(&quot;/v3/no-log&quot;) public String noLog() &#123; return &quot;ok&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Proxy 패턴","slug":"Spring/Spring-고급편/Proxy-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Proxy-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스","slug":"spring/spring-aop/design-pattern/proxy-pattern/proxy-03","date":"2021-11-20T17:31:07.000Z","updated":"2024-02-26T15:23:55.448Z","comments":true,"path":"2021/11/21/spring/spring-aop/design-pattern/proxy-pattern/proxy-03/","link":"","permalink":"https://ckck803.github.io/2021/11/21/spring/spring-aop/design-pattern/proxy-pattern/proxy-03/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Spring 핵심원리 고급편 - Proxy Pattern 인터페이스 없는 없는 구체 클래스Repositorypublic class OrderRepositoryV2 &#123; public void save(String itemId) &#123; if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; Servicepublic class OrderServiceV2 &#123; private final OrderRepositoryV2 orderRepository; public OrderServiceV2(OrderRepositoryV2 orderRepository) &#123; this.orderRepository = orderRepository; &#125; public void orderItem(String itemId) &#123; orderRepository.save(itemId); &#125;&#125; Controller@Slf4j@RequestMapping@ResponseBodypublic class OrderControllerV2 &#123; private final OrderServiceV2 orderService; public OrderControllerV2(OrderServiceV2 orderService) &#123; this.orderService = orderService; &#125; @GetMapping(&quot;/v2/request&quot;) public String request(String itemId) &#123; orderService.orderItem(itemId); return &quot;ok&quot;; &#125; @GetMapping(&quot;/v2/no-log&quot;) public String noLog() &#123; return &quot;ok&quot;; &#125;&#125; Bean 등록","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Spring 핵심원리 고급편 - Proxy Pattern 인터페이스 없는 없는 구체 클래스Repositorypublic class OrderRepositoryV2 &#123; public void save(String itemId) &#123; if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; Servicepublic class OrderServiceV2 &#123; private final OrderRepositoryV2 orderRepository; public OrderServiceV2(OrderRepositoryV2 orderRepository) &#123; this.orderRepository = orderRepository; &#125; public void orderItem(String itemId) &#123; orderRepository.save(itemId); &#125;&#125; Controller@Slf4j@RequestMapping@ResponseBodypublic class OrderControllerV2 &#123; private final OrderServiceV2 orderService; public OrderControllerV2(OrderServiceV2 orderService) &#123; this.orderService = orderService; &#125; @GetMapping(&quot;/v2/request&quot;) public String request(String itemId) &#123; orderService.orderItem(itemId); return &quot;ok&quot;; &#125; @GetMapping(&quot;/v2/no-log&quot;) public String noLog() &#123; return &quot;ok&quot;; &#125;&#125; Bean 등록@Configurationpublic class AppV2Config &#123; @Bean public OrderControllerV2 orderControllerV2()&#123; return new OrderControllerV2(orderServiceV2()); &#125; @Bean public OrderServiceV2 orderServiceV2()&#123; return new OrderServiceV2(orderRepositoryV2()); &#125; @Bean public OrderRepositoryV2 orderRepositoryV2()&#123; return new OrderRepositoryV2(); &#125;&#125; //@Import(AppV1Config.class)@Import(&#123;AppV1Config.class, AppV2Config.class&#125;)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Proxy 패턴","slug":"Spring/Spring-고급편/Proxy-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Proxy-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스","slug":"spring/spring-aop/design-pattern/proxy-pattern/proxy-02","date":"2021-11-20T16:31:07.000Z","updated":"2024-02-26T15:23:51.154Z","comments":true,"path":"2021/11/21/spring/spring-aop/design-pattern/proxy-pattern/proxy-02/","link":"","permalink":"https://ckck803.github.io/2021/11/21/spring/spring-aop/design-pattern/proxy-pattern/proxy-02/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Proxy 패턴 기능을 수행하는 실제 객체 대신 가상의 객체(Proxy) 를 생성해 로직의 흐름을 제어 하는 방법 Proxy 는 사전적인 의미로 대리자, 대변인의 의미를 갖고 있다. 프로그램 로직 실행시 실제 객체 대신 Proxy 객체에 로직을 대신 맡기게 된다.(객체의 접근을 제어한다.) 실제 객체 생성을 해당 객체를 사용하기 전 시점까지 미룰 수 있는 장점이 있다.(lazy-loading 가능) RepositoryRepository 인터페이스public interface OrderRepositoryV1 &#123; void save(String itemId);&#125; Repository 구현 클래스public class OrderRepositoryV1Impl implements OrderRepositoryV1&#123; @Override public void save(String itemId) &#123; if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125;","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Proxy 패턴 기능을 수행하는 실제 객체 대신 가상의 객체(Proxy) 를 생성해 로직의 흐름을 제어 하는 방법 Proxy 는 사전적인 의미로 대리자, 대변인의 의미를 갖고 있다. 프로그램 로직 실행시 실제 객체 대신 Proxy 객체에 로직을 대신 맡기게 된다.(객체의 접근을 제어한다.) 실제 객체 생성을 해당 객체를 사용하기 전 시점까지 미룰 수 있는 장점이 있다.(lazy-loading 가능) RepositoryRepository 인터페이스public interface OrderRepositoryV1 &#123; void save(String itemId);&#125; Repository 구현 클래스public class OrderRepositoryV1Impl implements OrderRepositoryV1&#123; @Override public void save(String itemId) &#123; if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; ServiceService 인터페이스public interface OrderServiceV1 &#123; void orderItem(String itemId);&#125; Service 구현 클래스public class OrderServiceV1Impl implements OrderServiceV1&#123; private final OrderRepositoryV1 orderRepository; public OrderServiceV1Impl(OrderRepositoryV1 orderRepositoryV1) &#123; this.orderRepository = orderRepositoryV1; &#125; @Override public void orderItem(String itemId) &#123; orderRepository.save(itemId); &#125;&#125; ControllerController 인터페이스@RequestMapping@ResponseBodypublic interface OrderControllerV1 &#123; @GetMapping(&quot;/v1/request&quot;) String request(@RequestParam(&quot;itemId&quot;) String itemId); @GetMapping(&quot;/v1/no-log&quot;) String noLog();&#125; Controller 구현 클래스public class OrderControllerV1Impl implements OrderControllerV1&#123; private final OrderServiceV1 orderService; public OrderControllerV1Impl(OrderServiceV1 orderService) &#123; this.orderService = orderService; &#125; @Override public String request(String itemId) &#123; orderService.orderItem(itemId); return &quot;ok&quot;; &#125; @Override public String noLog() &#123; return &quot;ok&quot;; &#125;&#125; Bean 등록@Configurationpublic class AppV1Config &#123; @Bean public OrderControllerV1 orderControllerV1()&#123; return new OrderControllerV1Impl(orderServiceV1()); &#125; @Bean public OrderServiceV1 orderServiceV1()&#123; return new OrderServiceV1Impl(orderRepositoryV1()); &#125; @Bean public OrderRepositoryV1 orderRepositoryV1()&#123; return new OrderRepositoryV1Impl(); &#125;&#125; @Import(AppV1Config.class)@SpringBootApplication(scanBasePackages = &quot;hello.proxy.app&quot;) //주의public class ProxyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProxyApplication.class, args); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Proxy 패턴","slug":"Spring/Spring-고급편/Proxy-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Proxy-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Proxy 패턴","slug":"spring/spring-aop/design-pattern/proxy-pattern/proxy-01","date":"2021-11-20T15:31:07.000Z","updated":"2024-02-26T15:23:47.496Z","comments":true,"path":"2021/11/21/spring/spring-aop/design-pattern/proxy-pattern/proxy-01/","link":"","permalink":"https://ckck803.github.io/2021/11/21/spring/spring-aop/design-pattern/proxy-pattern/proxy-01/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Proxy 패턴 - 실제 객체에 대한 접근 제어를 위한 디자인 패턴 기능을 수행하는 실제 (Real) 객체 대신 가상의 (Proxy) 객체 를 이용해 실제 객체 에 대한 접근을 제어 하는 디자인 패턴 프록시 패턴은 객체 지향 프로그래밍에서 사용되는 디자인 패턴 중 하나로 실제 객체와 같은 인터페이스 를 제공하는 객체를 사용하여 실제 객체에 대한 접근을 제어하는 데 사용됩니다. 즉, 프록시 객체를 사용하여 실제 객체에 대한 액세스를 제어할 수 있습니다. 프록시 객체는 실제 객체에 대한 참조를 유지하고, 클라이언트가 실제 객체에 액세스하려고 할 때 대신 실제 객체에 대한 요청을 처리합니다. 프록시 객체는 실제 객체와 같은 인터페이스를 구현하므로, 클라이언트는 프록시 객체와 실제 객체를 동일한 방식으로 사용할 수 있습니다. 프록시 패턴의 사용 사례로는 다음과 같은 것들이 있습니다. 원격 객체에 대한 액세스 원격 객체에 대한 액세스를 제어하려면, 클라이언트는 원격 객체에 직접 액세스하지 않고, 원격 객체를 대신하여 프록시 객체를 사용합니다. 이때 프록시 객체는 원격 객체에 대한 액세스를 제어하고, 원격 객체에 대한 요청을 처리합니다. 보안 프록시 객체를 사용하여 실제 객체에 대한 액세스를 제어하면, 보안상 이점이 있습니다. 프록시 객체를 사용하면, 클라이언트는 실제 객체에 직접 액세스하지 않고, 프록시 객체를 통해 액세스하므로, 실제 객체에 대한 액세스를 제어하고 보안을 유지할 수 있습니다. 비용 실제 객체에 대한 액세스 비용이 높은 경우, 프록시 객체를 사용하여 액세스 비용을 줄일 수 있습니다. 예를 들어, 원격 객체에 대한 액세스는 네트워크 비용이 들기 때문에, 원격 객체에 직접 액세스하는 것보다 프록시 객체를 사용하여 원격 객체에 대한 액세스 비용을 줄일 수 있습니다. 캐싱 프록시 객체를 사용하여 실제 객체에 대한 액세스를 캐싱할 수 있습니다. 이때 프록시 객체는 실제 객체에 대한 요청을 처리하기 전에 캐시된 결과를 반환합니다. 이를 통해, 실제 객체에 대한 액세스 비용을 줄이고, 성능을 향상시킬 수 있습니다. Proxy 패턴의 구성 요소","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Proxy 패턴 - 실제 객체에 대한 접근 제어를 위한 디자인 패턴 기능을 수행하는 실제 (Real) 객체 대신 가상의 (Proxy) 객체 를 이용해 실제 객체 에 대한 접근을 제어 하는 디자인 패턴 프록시 패턴은 객체 지향 프로그래밍에서 사용되는 디자인 패턴 중 하나로 실제 객체와 같은 인터페이스 를 제공하는 객체를 사용하여 실제 객체에 대한 접근을 제어하는 데 사용됩니다. 즉, 프록시 객체를 사용하여 실제 객체에 대한 액세스를 제어할 수 있습니다. 프록시 객체는 실제 객체에 대한 참조를 유지하고, 클라이언트가 실제 객체에 액세스하려고 할 때 대신 실제 객체에 대한 요청을 처리합니다. 프록시 객체는 실제 객체와 같은 인터페이스를 구현하므로, 클라이언트는 프록시 객체와 실제 객체를 동일한 방식으로 사용할 수 있습니다. 프록시 패턴의 사용 사례로는 다음과 같은 것들이 있습니다. 원격 객체에 대한 액세스 원격 객체에 대한 액세스를 제어하려면, 클라이언트는 원격 객체에 직접 액세스하지 않고, 원격 객체를 대신하여 프록시 객체를 사용합니다. 이때 프록시 객체는 원격 객체에 대한 액세스를 제어하고, 원격 객체에 대한 요청을 처리합니다. 보안 프록시 객체를 사용하여 실제 객체에 대한 액세스를 제어하면, 보안상 이점이 있습니다. 프록시 객체를 사용하면, 클라이언트는 실제 객체에 직접 액세스하지 않고, 프록시 객체를 통해 액세스하므로, 실제 객체에 대한 액세스를 제어하고 보안을 유지할 수 있습니다. 비용 실제 객체에 대한 액세스 비용이 높은 경우, 프록시 객체를 사용하여 액세스 비용을 줄일 수 있습니다. 예를 들어, 원격 객체에 대한 액세스는 네트워크 비용이 들기 때문에, 원격 객체에 직접 액세스하는 것보다 프록시 객체를 사용하여 원격 객체에 대한 액세스 비용을 줄일 수 있습니다. 캐싱 프록시 객체를 사용하여 실제 객체에 대한 액세스를 캐싱할 수 있습니다. 이때 프록시 객체는 실제 객체에 대한 요청을 처리하기 전에 캐시된 결과를 반환합니다. 이를 통해, 실제 객체에 대한 액세스 비용을 줄이고, 성능을 향상시킬 수 있습니다. Proxy 패턴의 구성 요소 Subject 실제 객체와 대리자 객체가 구현해야 하는 공통 인터페이스입니다. 이 인터페이스를 통해 실제 객체와 대리자 객체를 동일한 인터페이스를 갖도록 만들어줍니다. Real Subject 실제 객체를 나타냅니다. 이 객체는 Proxy 객체에서 대신하는 역할을 합니다. Proxy Real Subject를 대신해서 클라이언트로부터 요청을 받아 처리합니다. Real Subject에 대한 참조를 유지하고, 클라이언트에게 Real Subject와 동일한 인터페이스를 제공합니다. Proxy는 Real Subject에 대한 접근을 제어하고, 실제 객체를 생성하거나 초기화하는 역할을 합니다. Proxy 의 주요 기능 Proxy 가 중간에 있으면 접근 제어 와 부가 기능 추가 를 수행할 수 있다. 객체의 접근 제어 프로그램 로직 실행시 실제 객체 대신 Proxy 객체에 로직을 대신 맡기게 된다. 권한에 따른 접근 차단 권한별로 실제 객체에 접근을 제한하도록 한다. Lazy-Loading 실제 객체 생성을 해당 객체를 사용하기 전 시점까지 미룰 수 있는 장점이 있다. Caching DB 와 같이 요청이 길어지는 값을 미리 저장해 실제 객체에 대한 접근을 줄인다. 부가 기능 추가 요청 값, 응답 값을 중간에 변경 추가 로그 남기기 Proxy Chain Proxy 객체가 또 다른 Proxy 객체를 부를 수 있다. Proxy 패턴의 의존 관계 Proxy 패턴은 실제 객체와 같은 인터페이스 를 사용한다. Client 객체 입장에서는 Server 객체 실행시 Server 객체를 실행하든 Proxy 객체를 실행하든 동일하게 실행이 되야 하기 때문에 같은 인터페이스를 이용해 구현해야 한다. 인터페이스public interface Subject &#123; String operation();&#125; 실제 객체@Slf4jpublic class RealSubject implements Subject&#123; @Override public String operation() &#123; log.info(&quot;실제 객체 호출&quot;); sleep(1000); return &quot;data&quot;; &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; Client 코드public class ProxyPatternClient &#123; private Subject subject; // 생성자 주입을 통해 Subject 객체를 주입한다. public ProxyPatternClient(Subject subject)&#123; this.subject = subject; &#125; public void execute()&#123; subject.operation(); &#125;&#125; 비즈니스 로직 실행 및 결과client 객체내 execute 메소드를 호출하게 되면 execute 내부 로직을 반복해서 3번 실행하는 것을 확인할 수 있다. public class ProxyPatternTest &#123; @Test void noProxyTest()&#123; RealSubject realSubject = new RealSubject(); ProxyPatternClient client = new ProxyPatternClient(realSubject); client.execute(); client.execute(); client.execute(); &#125;&#125; 00:03:29.052 [Test worker] INFO hello.proxy.pureproxy.proxy.code.RealSubject - 실제 객체 호출00:03:30.059 [Test worker] INFO hello.proxy.pureproxy.proxy.code.RealSubject - 실제 객체 호출00:03:31.062 [Test worker] INFO hello.proxy.pureproxy.proxy.code.RealSubject - 실제 객체 호출 Proxy 패턴 적용 - 프록시 클래스 생성Proxy 패턴을 적용해 RealSubject 객체 접근을 제어한다. 우선, RealSubject 를 만들때 사용한 Subject 인터페이스를 이용해 CacheProxy 클래스를 생성합니다. CacheProxy 는 저장된 값이 없을 경우 RealSubject 객체 대한 접근해 데이터를 가져오고 저장된 값이 있을 경우 RealSubject 객체 접근을 생략하고 저장된 값을 반환하도록 한다. @Slf4jpublic class CacheProxy implements Subject&#123; // Proxy 객체 내 실제 객체를 저장 private Subject target; // 실제 객체 실행 결과를 저장하기 위한 객체 private String cacheValue; public CacheProxy(Subject target) &#123; this.target = target; &#125; @Override public String operation() &#123; log.info(&quot;프록시 호출&quot;); // 값을 캐싱해 놓음으로써 매번 객체를 생성 및 DB 로부터 데이터를 불러오는 작업을 생략 한다. // 1. 캐싱된 값이 없을 경우 실제 객체에 대한 접근이 이뤄진다. // 2. 캐싱된 값이 있을 경우 실제 객체에 대한 접근이 이뤄지지 않는다. if(cacheValue == null)&#123; // 실제 객체 실행 cacheValue = target.operation(); &#125; return cacheValue; &#125;&#125; 비즈니스 로직 실행 및 결과 RealSubject 코드와 클라이언트 코드를 변경하지 않고 Proxy 객체를 통해 접근 제어 를 했다. 처음에는 실제 객체를 실행해 실행 결과를 받고 두번째 부터는 캐싱한 결과 를 받는다. 실제 객체 대신 Proxy 객체 주입 을 통해 런타임시 client -&gt; cacheProxy -&gt; realSubject 로 의존 관계가 형성된다. @Testvoid cacheProxyTest()&#123; RealSubject realSubject = new RealSubject(); // 실제 객체를 이용해 Proxy 객체 생성 CacheProxy cacheProxy = new CacheProxy(realSubject); // Client 에 실제 객체 대신 Proxy 객체를 주입 Client 가 Proxy 객체를 실행하도록 한다. ProxyPatternClient client = new ProxyPatternClient(cacheProxy); client.execute(); // 처음에는 실제 객체를 실행해 실행 결과를 받는다. client.execute(); // 두번째 부터는 캐싱한 결과를 받는다. client.execute();&#125; 실행 결과를 통해 Proxy 객체 CacheProxy 를 호출 후 실제 객체 RealSubject 를 호출한 것을 확인할 수 있다. 또한, 한번 호출 후 값이 캐싱되면 더 이상 실제 객체에 대한 접근이 이뤄지지 않는 것을 확인할 수 있다. 11:03:11.638 [Test worker] INFO hello.proxy.pureproxy.proxy.code.CacheProxy - 프록시 호출11:03:11.640 [Test worker] INFO hello.proxy.pureproxy.proxy.code.RealSubject - 실제 객체 호출11:03:12.645 [Test worker] INFO hello.proxy.pureproxy.proxy.code.CacheProxy - 프록시 호출11:03:12.645 [Test worker] INFO hello.proxy.pureproxy.proxy.code.CacheProxy - 프록시 호출","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Proxy 패턴","slug":"Spring/Spring-고급편/Proxy-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Proxy-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Template Callback 패턴","slug":"spring/spring-aop/design-pattern/template-callback-pattern/Template-Callback-Pattern-01","date":"2021-11-20T07:31:07.000Z","updated":"2024-02-26T15:24:16.617Z","comments":true,"path":"2021/11/20/spring/spring-aop/design-pattern/template-callback-pattern/Template-Callback-Pattern-01/","link":"","permalink":"https://ckck803.github.io/2021/11/20/spring/spring-aop/design-pattern/template-callback-pattern/Template-Callback-Pattern-01/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 콜백이란 콜백, 콜에프터 함수란 다른 코드의 인수로서 넘겨주는 실행 가능한 코드콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수 있고, 아니면 나중에 실행할 수 있다. public interface Callback &#123; void call();&#125; @Slf4jpublic class TimeLogTemplate &#123; public void execute(Callback callback)&#123; long startTime = System.currentTimeMillis(); // 비즈니스 로직 실행 callback.call(); // 비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;resultTime = &#123;&#125;&quot;, resultTime); &#125;&#125; Template Callback Pattern 실행직접적으로 Callback 객체내 call 메소드를 실행하는 것이 아닌 TimeLogTemplate 객체에서 execute 메소드를 실행하게 되면 Callback 객체를 넘겨주고 execute 내에서 Callback 객체의 call 메소드가 실행된다. @Slf4jpublic class TemplateCallbackTest &#123; @Test void callbackV1()&#123; TimeLogTemplate template = new TimeLogTemplate(); template.execute(new Callback() &#123; @Override public void call() &#123; log.info(&quot;비즈니스 로직 1 실행&quot;); &#125; &#125;); // 람다식 적용 template.execute(() -&gt; log.info(&quot;비즈니스 로직 2 실행&quot;)); &#125;&#125;","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 콜백이란 콜백, 콜에프터 함수란 다른 코드의 인수로서 넘겨주는 실행 가능한 코드콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수 있고, 아니면 나중에 실행할 수 있다. public interface Callback &#123; void call();&#125; @Slf4jpublic class TimeLogTemplate &#123; public void execute(Callback callback)&#123; long startTime = System.currentTimeMillis(); // 비즈니스 로직 실행 callback.call(); // 비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;resultTime = &#123;&#125;&quot;, resultTime); &#125;&#125; Template Callback Pattern 실행직접적으로 Callback 객체내 call 메소드를 실행하는 것이 아닌 TimeLogTemplate 객체에서 execute 메소드를 실행하게 되면 Callback 객체를 넘겨주고 execute 내에서 Callback 객체의 call 메소드가 실행된다. @Slf4jpublic class TemplateCallbackTest &#123; @Test void callbackV1()&#123; TimeLogTemplate template = new TimeLogTemplate(); template.execute(new Callback() &#123; @Override public void call() &#123; log.info(&quot;비즈니스 로직 1 실행&quot;); &#125; &#125;); // 람다식 적용 template.execute(() -&gt; log.info(&quot;비즈니스 로직 2 실행&quot;)); &#125;&#125; Template Callback Pattern 적용public class TraceTemplate &#123; private final LogTrace trace; public TraceTemplate(LogTrace trace)&#123; this.trace = trace; &#125; public &lt;T&gt; T execute(String message, TraceCallback&lt;T&gt; callback)&#123; TraceStatus status = null; try&#123; status = trace.begin(message); // 로직 호출 T result = callback.call(); trace.end(status); return result; &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; &#125; &#125;&#125; @RestControllerpublic class OrderControllerV5 &#123; private final OrderServiceV5 orderService; private final TraceTemplate template; public OrderControllerV5(OrderServiceV5 orderService, LogTrace logTrace) &#123; this.orderService = orderService; this.template = new TraceTemplate(logTrace); &#125; @GetMapping(&quot;/v5/request&quot;) public String request(String itemId)&#123; return template.execute(&quot;OrderController.request()&quot;, new TraceCallback&lt;String&gt;() &#123; @Override public String call() &#123; orderService.orderItem(itemId); return &quot;ok&quot;; &#125; &#125;); &#125;&#125; @Servicepublic class OrderServiceV5 &#123; private final OrderRepositoryV5 orderRepository; private final TraceTemplate template; public OrderServiceV5(OrderRepositoryV5 orderRepository, LogTrace trace) &#123; this.orderRepository = orderRepository; this.template = new TraceTemplate(trace); &#125; public void orderItem (String itemId)&#123; template.execute(&quot;OrderService.orderItem()&quot;, () -&gt; &#123; orderRepository.save(itemId); return null; &#125;); &#125;&#125; @Repositorypublic class OrderRepositoryV5 &#123; private final TraceTemplate template; public OrderRepositoryV5(LogTrace logTrace) &#123; this.template = new TraceTemplate(logTrace); &#125; public void save(String itemId)&#123; template.execute(&quot;OrderRepository.save()&quot;, () -&gt; &#123; if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); return null; &#125;); &#125; private void sleep(int millis) &#123; try&#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Template Callback 패턴","slug":"Spring/Spring-고급편/Template-Callback-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Template-Callback-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Strategy 패턴","slug":"spring/spring-aop/design-pattern/strategy-pattern/Strategy-Pattern-01","date":"2021-11-20T06:31:07.000Z","updated":"2024-02-26T15:24:11.416Z","comments":true,"path":"2021/11/20/spring/spring-aop/design-pattern/strategy-pattern/Strategy-Pattern-01/","link":"","permalink":"https://ckck803.github.io/2021/11/20/spring/spring-aop/design-pattern/strategy-pattern/Strategy-Pattern-01/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Strategy 패턴 Strategy 패턴 은 변하지 않는 부분을 Context 에 두고 변하는 부분을 Strategy 라는 Interface 를 만들고 해당 인터페이스를 구현해 코드 중복성을 해결한다. Strategy 패턴 코드 중복 문제를 해결하기 위한 디자인 패턴 중 하나로 Context 와 Strategy 으로 구성됩니다. 공통 로직은 Context 클래스로 만들어 관리하고 서로 다른 로직들을 Strategy 인터페이스를 구현하는 방식으로 코드 중복 문제를 해결합니다. Strategy 패턴 에서 Context 클래스는 내부에 Strategy 클래스를 가지고 있습니다. 이 구조는 Context 객체가 실행될 때, 내부에 저장된 Strategy 객체를 활용하여 작업을 수행하게 됩니다. 따라서 Context 객체는 실행 시 Strategy 객체에 의존하게 됩니다. Strategy 클래스들은 서로 다른 로직을 가지고 있지만 동일한 인터페이스로 구현됩니다. 결과적으로 Context 클래스는 동일한 메소드 호출을 통해 다양한 Strategy 객체를 실행할 수 있습니다. Template Method 패턴과의 차이점은 공통적인 부분을 추상 클래스에서 관리하고 상속을 통해 변하는 부분을 구현해 코드 중복성을 해결 했습니다. Startegy Pattern 은 상속이 아니라 위임 으로 문제를 해결한다. Strategy 인터페이스 - 변하는 로직을 관리","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Strategy 패턴 Strategy 패턴 은 변하지 않는 부분을 Context 에 두고 변하는 부분을 Strategy 라는 Interface 를 만들고 해당 인터페이스를 구현해 코드 중복성을 해결한다. Strategy 패턴 코드 중복 문제를 해결하기 위한 디자인 패턴 중 하나로 Context 와 Strategy 으로 구성됩니다. 공통 로직은 Context 클래스로 만들어 관리하고 서로 다른 로직들을 Strategy 인터페이스를 구현하는 방식으로 코드 중복 문제를 해결합니다. Strategy 패턴 에서 Context 클래스는 내부에 Strategy 클래스를 가지고 있습니다. 이 구조는 Context 객체가 실행될 때, 내부에 저장된 Strategy 객체를 활용하여 작업을 수행하게 됩니다. 따라서 Context 객체는 실행 시 Strategy 객체에 의존하게 됩니다. Strategy 클래스들은 서로 다른 로직을 가지고 있지만 동일한 인터페이스로 구현됩니다. 결과적으로 Context 클래스는 동일한 메소드 호출을 통해 다양한 Strategy 객체를 실행할 수 있습니다. Template Method 패턴과의 차이점은 공통적인 부분을 추상 클래스에서 관리하고 상속을 통해 변하는 부분을 구현해 코드 중복성을 해결 했습니다. Startegy Pattern 은 상속이 아니라 위임 으로 문제를 해결한다. Strategy 인터페이스 - 변하는 로직을 관리public interface Strategy &#123; void call();&#125; Strategy 구현체StrategyLogic1 클래스와 StrategyLogic2 클래스는 동일한 Strategy 인터페이스를 이용해 구현합니다. @Slf4jpublic class StrategyLogic1 implements Strategy&#123; @Override public void call() &#123; log.info(&quot;비즈니스 로직 1 실행&quot;); &#125;&#125; @Slf4jpublic class StrategyLogic2 implements Strategy&#123; @Override public void call() &#123; log.info(&quot;비즈니스 로직 2 실행&quot;); &#125;&#125; Context - 변하지 않는 공통 로직을 관리 전략 패턴의 핵심은 Context 는 Strategy 인터페이스에 의존한다는 것이다. ContextV1 객체는 내부에 Strategy 객체를 갖고 있는 모습을 확인할 수 있습니다. ContextV1 객체 초기화시 다양한 Strategy 객체를 전달함으로써 공통 로직을 수행하면서 다양한 로직을 수행할 수 있습니다. 결과적으로 공통적인 코드를 분리함으로써 코드 중복을 줄이고 재사용성을 높일 수 있었습니다. Spring 에서 사용하는 의존성 주입 방식 이 바로 Strategy Pattern 입니다. 공통적으로 수행되는 Spring 프레임워크에 특정 로직을 수행하도록 구현된 객체를 전달함으로써 공통된 Spring 로직과 개인이 구현한 로직을 수행할 수 있습니다. 큰 뼈대를 갖는 Context 는 수정하지 않으면서 특정로직을 수행하는 Stategy 만 생성해 실행함으로써 객체 지향 원칙 중 하나인 개방-폐쇄 원칙(OCP) 을 따르는 것을 확인할 수 있습니다. @Slf4jpublic class ContextV1 &#123; // Strategy 인터페이스에 의존 private Strategy strategy; public ContextV1 (Strategy strategy)&#123; this.strategy = strategy; &#125; public void execute()&#123; long startTime = System.currentTimeMillis(); // 비즈니스 로직 실행 strategy.call(); // Strategy 객체를 실행 // 비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;resultTime = &#123;&#125;&quot;, resultTime); &#125;&#125; Strategy Pattern 실행 및 결과공통 로직을 수행하는 ContextV1 객체에 StrategyLogic1 객체와 StrategyLogic2 객체를 주입해 줌으로써 서로다른 로직을 수행하게 됩니다. StrategyLogic1 객체와 StrategyLogic2 객체는 같은 Strategy 인터페이스를 이용해 구현되었기 때문에 ContextV1 객체는 동일한 메소드를 이용해 주입된 객체를 실행시킬 수 있습니다. @Testvoid strategyV1()&#123; StrategyLogic1 strategyLogic1 = new StrategyLogic1(); // StrategyLogic1 객체를 ContextV1 에 주입해준다. ContextV1 context1 = new ContextV1(strategyLogic1); context1.execute(); StrategyLogic2 strategyLogic2 = new StrategyLogic2(); // StrategyLogic2 객체를 ContextV1 에 주입해준다. ContextV1 context2 = new ContextV1(strategyLogic2); context2.execute();&#125; 익명 내부 클래스 사용@Testvoid strategyV2()&#123; Strategy strategyLogic1 = new Strategy() &#123; @Override public void call() &#123; log.info(&quot;비즈니스 로직 1 실행&quot;); &#125; &#125;; ContextV1 contextV1 = new ContextV1(strategyLogic1); log.info(&quot;strategyLogic1 = &#123;&#125;&quot;, contextV1.getClass()); contextV1.execute(); Strategy strategyLogic2 = new Strategy() &#123; @Override public void call() &#123; log.info(&quot;비즈니스 로직 2 실행&quot;); &#125; &#125;; ContextV1 contextV2 = new ContextV1(strategyLogic2); log.info(&quot;strategyLogic2 = &#123;&#125;&quot;, contextV2.getClass()); contextV2.execute();&#125; 익명 내부 클래스 &amp; 람다 이용하기@Testvoid strategyV3() &#123; ContextV1 contextV1 = new ContextV1(new Strategy() &#123; @Override public void call() &#123; log.info(&quot;비즈니스 로직 1 실행&quot;); &#125; &#125;); log.info(&quot;strategyLogic1 = &#123;&#125;&quot;, contextV1.getClass()); contextV1.execute(); ContextV1 contextV2 = new ContextV1(() -&gt; log.info(&quot;비즈니스 로직 2 실행&quot;)); log.info(&quot;strategyLogic2 = &#123;&#125;&quot;, contextV2.getClass()); contextV2.execute();&#125; 파라미터로 전달 받는 방식 Strategy 를 필드로 갖지 않고, 파라미터로 전달 받는다. @Slf4jpublic class ContextV2 &#123; // private Strategy strategy; // Strategy 를 필드로 갖지 않고, 파라미터로 전달 받는다. public void execute(Strategy strategy)&#123; long startTime = System.currentTimeMillis(); // 비즈니스 로직 실행 strategy.call(); // 비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;resultTime = &#123;&#125;&quot;, resultTime); &#125;&#125; Context 를 실행할 때마다 파라미터를 전달 받는다. @Testvoid strategyV1()&#123; ContextV2 context = new ContextV2(); context.execute(new StrategyLogic1()); context.execute(new StrategyLogic2());&#125; @Testvoid strategyV2()&#123; ContextV2 context = new ContextV2(); context.execute(new Strategy() &#123; @Override public void call() &#123; log.info(&quot;비즈니스 로직 1 실행&quot;); &#125; &#125;); context.execute(new Strategy() &#123; @Override public void call() &#123; log.info(&quot;비즈니스 로직 2 실행&quot;); &#125; &#125;);&#125; @Testvoid strategyV3()&#123; ContextV2 context = new ContextV2(); context.execute(() -&gt; log.info(&quot;비즈니스 로직 1 실행&quot;)); context.execute(() -&gt; log.info(&quot;비즈니스 로직 2 실행&quot;));&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Strategy 패턴","slug":"Spring/Spring-고급편/Strategy-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Strategy-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"객체 지향 설계 5원칙 SOLID","slug":"computer-science/programming-language/object/solid","date":"2021-11-20T05:16:17.000Z","updated":"2024-02-18T16:19:54.521Z","comments":true,"path":"2021/11/20/computer-science/programming-language/object/solid/","link":"","permalink":"https://ckck803.github.io/2021/11/20/computer-science/programming-language/object/solid/","excerpt":"컴파일 언어, 인터프리터 언어, 하이브리드 언어 객체 지향 3요소 객체 지향 설계 5원칙 SOLID 객체 지향 설계 5원칙 SOLID1. SRP(Single Responsibility Principle) - 단일 책임 원칙한 클래스는 하나의 책임(역할)만 가져야 한다. 역할의 분리라고 생각하면 편하다!변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따르는 것 2. OCP(Open Close Principle) - 개방 폐쇄 원칙 확장 에는 열려 있으나 변경 에는 닫혀 있어야 한다. 기존 코드에 대한 수정은 직접적으로 하지 않고 기능을 확장, 추가 할 수 있도록 해야 한다. 인터페이스와 추상 클래스를 이용해 공통적인 작업에 대해 추상화 를 진행 상속과 구현을 이용해 기존 코드(상위 클래스)에 대한 수정 없이 기능을 확장시킬 수 있다. 이는 곧 다형성 을 이용한 기능 확장이다. OCP 문제점","text":"컴파일 언어, 인터프리터 언어, 하이브리드 언어 객체 지향 3요소 객체 지향 설계 5원칙 SOLID 객체 지향 설계 5원칙 SOLID1. SRP(Single Responsibility Principle) - 단일 책임 원칙한 클래스는 하나의 책임(역할)만 가져야 한다. 역할의 분리라고 생각하면 편하다!변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따르는 것 2. OCP(Open Close Principle) - 개방 폐쇄 원칙 확장 에는 열려 있으나 변경 에는 닫혀 있어야 한다. 기존 코드에 대한 수정은 직접적으로 하지 않고 기능을 확장, 추가 할 수 있도록 해야 한다. 인터페이스와 추상 클래스를 이용해 공통적인 작업에 대해 추상화 를 진행 상속과 구현을 이용해 기존 코드(상위 클래스)에 대한 수정 없이 기능을 확장시킬 수 있다. 이는 곧 다형성 을 이용한 기능 확장이다. OCP 문제점 구현 객체를 변경하기 위해서는 Client 코드를 변경해야 하는 문제점이 있다. 코드 변경이 이뤄지기 때문에 OCP 원칙을 깨지게 된다. 객체를 생성 하고 연관관계 를 맺어주는 별도의 조립, 설정자가 필요하다. Spring 에서는 Spring Container 가 해당 역할을 한다. class OwnerController &#123; // private OwnerRepository repository = new MemoryOwnerRepository(); // MemoryOwnerRepository 에서 JdbcOwnerRepository 로 변경하기 위해서는 코드에 대한 변경이 필요하다. private OwnerRepository repository = new JdbcOwnerRepository();&#125; 3. LSP(The Liskov Substitution Principle) - 라스코프 치환 원칙 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. 인터페이스 규약을 잘 지켜야 한다. 4. ISP(Interface Segregation Principle) - 인터페이스 분리 원칙 하나의 범용 인터페이스보다 특정 클라이언트를 위한 여러 인터페이스가 좋다. 5. DIP(Dependency Inversion Principle) - 의존 관계 역전 원칙 프로그래머는 추상화 에 의존해야지, 구체화 에 의존하면 안된다. 구현 클래스에 의존하지 않고, 인터페이스에 의존하라는 뜻이다. Client 가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 스프링과 객체 지향 원칙스프링은 DI(Dependency Injection)과 DI 컨테이너를 통해 OCP와 DIP를 가능하게 지원한다. client의 코드 변경 없이 개발이 가능하다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Programming Lanuage","slug":"CS/Programming-Lanuage","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Template Method 패턴","slug":"spring/spring-aop/design-pattern/template-method-pattern/Template-Method-Pattern-01","date":"2021-11-20T01:31:07.000Z","updated":"2024-02-26T15:24:20.926Z","comments":true,"path":"2021/11/20/spring/spring-aop/design-pattern/template-method-pattern/Template-Method-Pattern-01/","link":"","permalink":"https://ckck803.github.io/2021/11/20/spring/spring-aop/design-pattern/template-method-pattern/Template-Method-Pattern-01/","excerpt":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Template Method 패턴 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법. 변하지 않는 기능은 슈퍼클래스 에 만들어두고 자주 변경되며 확장할 기능은 서브클래스 에서 만들도록 한다.(토비의 스프링) 변하는 부분과 변하지 않는 부분 을 분리한다. 템플릿은 기준이 되는 거대한 틀이다. 템플릿 안에 변하지 않는 부분을 넣고, 일부 변하는 부분을 별도로 호출한다. 구조가 동일하고 중간에 핵심기능을 사용하는 코드만 다르다. Template Method 패턴 적용 전@Slf4jpublic class TemplateMethodTest &#123; @Test void templateMethodV0()&#123; logic1(); logic2(); &#125; private void logic1()&#123; long startTime = System.currentTimeMillis(); // 비즈니스 로직 실행 log.info(&quot;비즈니스 로직1 실행&quot;); // 비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;resultTime = &#123;&#125;&quot;, resultTime); &#125; private void logic2 ()&#123; long startTime = System.currentTimeMillis(); // 비즈니스 로직 실행 log.info(&quot;비즈니스 로직1 실행&quot;); // 비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;resultTime = &#123;&#125;&quot;, resultTime); &#125;&#125; Template Method 패턴 적용 후","text":"목차 Spring 핵심원리 고급편 - CGLIB Spring 핵심원리 고급편 - Dynamic Proxy 2 Spring 핵심원리 고급편 - Dynamic Proxy 1 Spring 핵심원리 고급편 - 리플렉션 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 적용 2 Spring 핵심원리 고급편 - 구체 클래스 기반 프록시 Spring 핵심원리 고급편 - 인터페이스 프록시 1 Spring 핵심원리 고급편 - Decorator Pattern 2 Spring 핵심원리 고급편 - Decorator Pattern 1 Spring 핵심원리 고급편 - Proxy 패턴 컴포넌트 스캔으로 자동 빈 등록 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스 없는 없는 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 인터페이스와 구체 클래스 Spring 핵심원리 고급편 - Proxy 패턴 Spring 핵심원리 고급편 - Strategy 패턴 Spring 핵심원리 고급편 - Template Method 패턴 Template Method 패턴 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법. 변하지 않는 기능은 슈퍼클래스 에 만들어두고 자주 변경되며 확장할 기능은 서브클래스 에서 만들도록 한다.(토비의 스프링) 변하는 부분과 변하지 않는 부분 을 분리한다. 템플릿은 기준이 되는 거대한 틀이다. 템플릿 안에 변하지 않는 부분을 넣고, 일부 변하는 부분을 별도로 호출한다. 구조가 동일하고 중간에 핵심기능을 사용하는 코드만 다르다. Template Method 패턴 적용 전@Slf4jpublic class TemplateMethodTest &#123; @Test void templateMethodV0()&#123; logic1(); logic2(); &#125; private void logic1()&#123; long startTime = System.currentTimeMillis(); // 비즈니스 로직 실행 log.info(&quot;비즈니스 로직1 실행&quot;); // 비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;resultTime = &#123;&#125;&quot;, resultTime); &#125; private void logic2 ()&#123; long startTime = System.currentTimeMillis(); // 비즈니스 로직 실행 log.info(&quot;비즈니스 로직1 실행&quot;); // 비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;resultTime = &#123;&#125;&quot;, resultTime); &#125;&#125; Template Method 패턴 적용 후로그를 찍은 공통적인 로직 을 묶어 하나의 Template 을 만들어준다. 추상화된 Method 를 Template 내에 넣어줌으로써 하위 객체에서 각각의 비즈니스 로직을 구현하도록 한다. 이를 통해 비즈니스 로직 실행시 시작 시간과 종료시간에 대한 로그를 찍고 싶은 객체는 AbstractTemplate 객체를 상속해 구현하면 된다. 상속 을 통해 추상 클래스에서 구현된 공통 로직을 하위 클래스에 그대로 적용할 수 있다. 중복된 코드 작성 을 줄일 수 있다. @Slf4jpublic abstract class AbstractTemplate &#123; public void execute()&#123; long startTime = System.currentTimeMillis(); // 비즈니스 로직 실행 call(); // 상속 // 비즈니스 로직 종료 long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;resultTime = &#123;&#125;&quot;, resultTime); &#125; // Overriding 을 통해 하위 클래스에서 call 메소드를 구현하도록 한다. protected abstract void call();&#125; @Slf4jpublic class SubclassLogic1 extends AbstractTemplate&#123; @Override protected void call() &#123; log.info(&quot;비즈니스 로직 1 실행&quot;); &#125;&#125; @Slf4jpublic class SubclassLogic2 extends AbstractTemplate&#123; @Override protected void call() &#123; log.info(&quot;비즈니스 로직 2 실행&quot;); &#125;&#125; 실행@Testvoid templateMethodV1()&#123; AbstractTemplate template1 = new SubclassLogic1(); template1.execute(); AbstractTemplate template2 = new SubclassLogic1(); template2.execute();&#125; 02:25:23.488 [Test worker] INFO com.example.advancedspring.trace.template.TemplateMethodTest - 비즈니스 로직 1 실행02:25:23.491 [Test worker] INFO com.example.advancedspring.trace.template.code.AbstractTemplate - resultTime = 502:25:23.493 [Test worker] INFO com.example.advancedspring.trace.template.TemplateMethodTest - 비즈니스 로직 2 실행02:25:23.493 [Test worker] INFO com.example.advancedspring.trace.template.code.AbstractTemplate - resultTime = 0 익명 내부 클래스 사용하기 템플릿 메서드 패턴은 클래스를 계속 만들어 줘야 하는 단점이 있다.익명 내부 클래스를 사용하면 해당 단점을 보완할 수 있다. @Testvoid templateMethodV2()&#123; AbstractTemplate template = new AbstractTemplate() &#123; @Override protected void call() &#123; log.info(&quot;비즈니스 로직 1 실행&quot;); &#125; &#125;; template.execute(); AbstractTemplate template2 = new AbstractTemplate() &#123; @Override protected void call() &#123; log.info(&quot;비즈니스 로직 2 실행&quot;); &#125; &#125;; template2.execute();&#125; 02:25:23.488 [Test worker] INFO com.example.advancedspring.trace.template.TemplateMethodTest - 비즈니스 로직 1 실행02:25:23.491 [Test worker] INFO com.example.advancedspring.trace.template.code.AbstractTemplate - resultTime = 502:25:23.493 [Test worker] INFO com.example.advancedspring.trace.template.TemplateMethodTest - 비즈니스 로직 2 실행02:25:23.493 [Test worker] INFO com.example.advancedspring.trace.template.code.AbstractTemplate - resultTime = 0 Spring 핵심원리 고급편 - Template Method Pattern 적용public abstract class AbstractTemplate&lt;T&gt; &#123; private final LogTrace trace; public AbstractTemplate(LogTrace logTrace)&#123; this.trace = logTrace; &#125; public T execute(String message)&#123; TraceStatus status = null; try&#123; status = trace.begin(message); // 로직 호출 T result = call(); trace.end(status); return result; &#125;catch (Exception e)&#123; &#125; &#125; protected abstract T call();&#125; @GetMapping(&quot;/v4/request&quot;)public String request(String itemId)&#123; AbstractTemplate&lt;String&gt; template = new AbstractTemplate&lt;&gt;(trace) &#123; @Override protected String call() &#123; orderService.orderItem(itemId); return &quot;ok&quot;; &#125; &#125;; return template.execute(&quot;OrderController.request()&quot;);&#125; @Service@RequiredArgsConstructorpublic class OrderServiceV4 &#123; private final OrderRepositoryV4 orderRepository; private final LogTrace trace; public void orderItem (String itemId)&#123; TraceStatus status = null; AbstractTemplate&lt;Void&gt; template = new AbstractTemplate&lt;&gt;(trace) &#123; @Override protected Void call() &#123; orderRepository.save(itemId); return null; &#125; &#125;; template.execute(&quot;OrderService.orderItem()&quot;); &#125;&#125; @Repository@RequiredArgsConstructorpublic class OrderRepositoryV4 &#123; private final LogTrace trace; public void save(String itemId)&#123; TraceStatus status = null; AbstractTemplate&lt;Void&gt; template = new AbstractTemplate&lt;&gt;(trace) &#123; @Override protected Void call() &#123; if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); return null; &#125; &#125;; template.execute(&quot;OrderRepository.save()&quot;); &#125; private void sleep(int millis) &#123; try&#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"Template Method 패턴","slug":"Spring/Spring-고급편/Template-Method-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Template-Method-%ED%8C%A8%ED%84%B4/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - ThreadLocal","slug":"spring/spring-aop/threadlocal/threadlocal-06","date":"2021-11-19T21:31:07.000Z","updated":"2024-02-26T15:27:20.179Z","comments":true,"path":"2021/11/20/spring/spring-aop/threadlocal/threadlocal-06/","link":"","permalink":"https://ckck803.github.io/2021/11/20/spring/spring-aop/threadlocal/threadlocal-06/","excerpt":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 ThreadLocal@Configurationpublic class LogTraceConfig &#123;// @Bean// public LogTrace logTrace()&#123;// return new FieldLogTrace();// &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; Thread 별로 로그가 정확하게 나눠진 것을 확인할 수 있다. 2021-12-06 02:15:37.485 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] OrderController.request()2021-12-06 02:15:37.485 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] |--&gt;OrderService.orderItem()2021-12-06 02:15:37.486 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] | |--&gt;OrderRepository.save()2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] | |&lt;--OrderRepository.save() time=1002ms2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] |&lt;--OrderService.orderItem() time=1003ms2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] OrderController.request() time=1003ms 2021-12-06 02:15:37.648 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] OrderController.request()2021-12-06 02:15:37.648 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] |--&gt;OrderService.orderItem()2021-12-06 02:15:37.648 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] | |--&gt;OrderRepository.save()2021-12-06 02:15:38.652 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] | |&lt;--OrderRepository.save() time=1004ms2021-12-06 02:15:38.653 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] |&lt;--OrderService.orderItem() time=1005ms2021-12-06 02:15:38.653 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] OrderController.request() time=1005ms","text":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 ThreadLocal@Configurationpublic class LogTraceConfig &#123;// @Bean// public LogTrace logTrace()&#123;// return new FieldLogTrace();// &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; Thread 별로 로그가 정확하게 나눠진 것을 확인할 수 있다. 2021-12-06 02:15:37.485 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] OrderController.request()2021-12-06 02:15:37.485 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] |--&gt;OrderService.orderItem()2021-12-06 02:15:37.486 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] | |--&gt;OrderRepository.save()2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] | |&lt;--OrderRepository.save() time=1002ms2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] |&lt;--OrderService.orderItem() time=1003ms2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] OrderController.request() time=1003ms 2021-12-06 02:15:37.648 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] OrderController.request()2021-12-06 02:15:37.648 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] |--&gt;OrderService.orderItem()2021-12-06 02:15:37.648 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] | |--&gt;OrderRepository.save()2021-12-06 02:15:38.652 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] | |&lt;--OrderRepository.save() time=1004ms2021-12-06 02:15:38.653 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] |&lt;--OrderService.orderItem() time=1005ms2021-12-06 02:15:38.653 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] OrderController.request() time=1005ms","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"ThreadLocal","slug":"Spring/Spring-고급편/ThreadLocal","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/ThreadLocal/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - ThreadLocal 적용","slug":"spring/spring-aop/threadlocal/threadlocal-05","date":"2021-11-19T20:31:07.000Z","updated":"2024-02-26T15:27:17.025Z","comments":true,"path":"2021/11/20/spring/spring-aop/threadlocal/threadlocal-05/","link":"","permalink":"https://ckck803.github.io/2021/11/20/spring/spring-aop/threadlocal/threadlocal-05/","excerpt":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 ThreadLocal 적용@Slf4jpublic class ThreadLocalLogTrace implements LogTrace &#123; private static final String START_PREFIX = &quot;--&gt;&quot;; private static final String COMPLETE_PREFIX = &quot;&lt;--&quot;; private static final String EX_PREFIX = &quot;&lt;X-&quot;; private ThreadLocal&lt;TraceId&gt; traceIdHolder; // traceId 동기화, 동시성 이슈 @Override public TraceStatus begin(String message) &#123; syncTraceId(); TraceId traceId = traceIdHolder.get(); Long startTimeMs = System.currentTimeMillis(); log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125;&quot;, traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message); return new TraceStatus(traceId, startTimeMs, message); &#125; private void syncTraceId()&#123; TraceId traceId = traceIdHolder.get(); if(traceId == null)&#123; traceIdHolder.set(new TraceId()); &#125;else&#123; traceIdHolder.set(traceId.createNextId()); &#125; &#125; @Override public void end(TraceStatus status) &#123; complete(status, null); &#125; @Override public void exception(TraceStatus status, Exception e) &#123; complete(status, e); &#125; private void complete(TraceStatus status, Exception e) &#123; Long stopTimeMs = System.currentTimeMillis(); long resultTimeMs = stopTimeMs - status.getStartTimeMs(); TraceId traceId = status.getTraceId(); if (e == null) &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms&quot;, traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs); &#125; else &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms ex=&#123;&#125;&quot;, traceId.getId(), addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs, e.toString()); &#125; releaseTraceId(); &#125; private void releaseTraceId() &#123; TraceId traceId = traceIdHolder.get(); if(traceId.isFirstLevel())&#123; traceIdHolder.remove(); // destroy &#125;else&#123; traceIdHolder.set(traceId.createPreviousId()); &#125; &#125; private static String addSpace(String prefix, int level) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; level; i++) &#123; sb.append((i == level - 1) ? &quot;|&quot; + prefix : &quot;| &quot;); &#125; return sb.toString(); &#125;&#125; class ThreadLocalLogTraceTest &#123; ThreadLocalLogTrace trace = new ThreadLocalLogTrace(); @Test void begin_end_level2()&#123; TraceStatus status1 = trace.begin(&quot;hello1&quot;); TraceStatus status2 = trace.begin(&quot;hello2&quot;); trace.end(status2); trace.end(status1); &#125; @Test void begin_end_level2_exception()&#123; TraceStatus status1 = trace.begin(&quot;hello1&quot;); TraceStatus status2 = trace.begin(&quot;hello2&quot;); trace.exception(status2, new IllegalStateException()); trace.exception(status1, new IllegalStateException()); &#125;&#125; 15:20:49.175 [Test worker] INFO com.example.advancedspring.trace.logtrace.ThreadLocalLogTrace - [fb5762b8] hello115:20:49.179 [Test worker] INFO com.example.advancedspring.trace.logtrace.ThreadLocalLogTrace - [fb5762b8] |--&gt;hello215:20:49.180 [Test worker] INFO com.example.advancedspring.trace.logtrace.ThreadLocalLogTrace - [fb5762b8] |&lt;--hello2 time=3ms15:20:49.180 [Test worker] INFO com.example.advancedspring.trace.logtrace.ThreadLocalLogTrace - [fb5762b8] hello1 time=6ms @Configurationpublic class LogTraceConfig &#123;// @Bean// public LogTrace logTrace()&#123;// return new FieldLogTrace();// &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; Thread 별로 로그가 정확하게 나눠진 것을 확인할 수 있다. 2021-12-06 02:15:37.485 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] OrderController.request()2021-12-06 02:15:37.485 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] |--&gt;OrderService.orderItem()2021-12-06 02:15:37.486 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] | |--&gt;OrderRepository.save()2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] | |&lt;--OrderRepository.save() time=1002ms2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] |&lt;--OrderService.orderItem() time=1003ms2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] OrderController.request() time=1003ms","text":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 ThreadLocal 적용@Slf4jpublic class ThreadLocalLogTrace implements LogTrace &#123; private static final String START_PREFIX = &quot;--&gt;&quot;; private static final String COMPLETE_PREFIX = &quot;&lt;--&quot;; private static final String EX_PREFIX = &quot;&lt;X-&quot;; private ThreadLocal&lt;TraceId&gt; traceIdHolder; // traceId 동기화, 동시성 이슈 @Override public TraceStatus begin(String message) &#123; syncTraceId(); TraceId traceId = traceIdHolder.get(); Long startTimeMs = System.currentTimeMillis(); log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125;&quot;, traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message); return new TraceStatus(traceId, startTimeMs, message); &#125; private void syncTraceId()&#123; TraceId traceId = traceIdHolder.get(); if(traceId == null)&#123; traceIdHolder.set(new TraceId()); &#125;else&#123; traceIdHolder.set(traceId.createNextId()); &#125; &#125; @Override public void end(TraceStatus status) &#123; complete(status, null); &#125; @Override public void exception(TraceStatus status, Exception e) &#123; complete(status, e); &#125; private void complete(TraceStatus status, Exception e) &#123; Long stopTimeMs = System.currentTimeMillis(); long resultTimeMs = stopTimeMs - status.getStartTimeMs(); TraceId traceId = status.getTraceId(); if (e == null) &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms&quot;, traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs); &#125; else &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms ex=&#123;&#125;&quot;, traceId.getId(), addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs, e.toString()); &#125; releaseTraceId(); &#125; private void releaseTraceId() &#123; TraceId traceId = traceIdHolder.get(); if(traceId.isFirstLevel())&#123; traceIdHolder.remove(); // destroy &#125;else&#123; traceIdHolder.set(traceId.createPreviousId()); &#125; &#125; private static String addSpace(String prefix, int level) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; level; i++) &#123; sb.append((i == level - 1) ? &quot;|&quot; + prefix : &quot;| &quot;); &#125; return sb.toString(); &#125;&#125; class ThreadLocalLogTraceTest &#123; ThreadLocalLogTrace trace = new ThreadLocalLogTrace(); @Test void begin_end_level2()&#123; TraceStatus status1 = trace.begin(&quot;hello1&quot;); TraceStatus status2 = trace.begin(&quot;hello2&quot;); trace.end(status2); trace.end(status1); &#125; @Test void begin_end_level2_exception()&#123; TraceStatus status1 = trace.begin(&quot;hello1&quot;); TraceStatus status2 = trace.begin(&quot;hello2&quot;); trace.exception(status2, new IllegalStateException()); trace.exception(status1, new IllegalStateException()); &#125;&#125; 15:20:49.175 [Test worker] INFO com.example.advancedspring.trace.logtrace.ThreadLocalLogTrace - [fb5762b8] hello115:20:49.179 [Test worker] INFO com.example.advancedspring.trace.logtrace.ThreadLocalLogTrace - [fb5762b8] |--&gt;hello215:20:49.180 [Test worker] INFO com.example.advancedspring.trace.logtrace.ThreadLocalLogTrace - [fb5762b8] |&lt;--hello2 time=3ms15:20:49.180 [Test worker] INFO com.example.advancedspring.trace.logtrace.ThreadLocalLogTrace - [fb5762b8] hello1 time=6ms @Configurationpublic class LogTraceConfig &#123;// @Bean// public LogTrace logTrace()&#123;// return new FieldLogTrace();// &#125; @Bean public LogTrace logTrace()&#123; return new ThreadLocalLogTrace(); &#125;&#125; Thread 별로 로그가 정확하게 나눠진 것을 확인할 수 있다. 2021-12-06 02:15:37.485 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] OrderController.request()2021-12-06 02:15:37.485 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] |--&gt;OrderService.orderItem()2021-12-06 02:15:37.486 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] | |--&gt;OrderRepository.save()2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] | |&lt;--OrderRepository.save() time=1002ms2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] |&lt;--OrderService.orderItem() time=1003ms2021-12-06 02:15:38.488 INFO 21903 --- [nio-8080-exec-1] c.e.a.t.logtrace.ThreadLocalLogTrace : [0b8754c1] OrderController.request() time=1003ms 2021-12-06 02:15:37.648 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] OrderController.request()2021-12-06 02:15:37.648 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] |--&gt;OrderService.orderItem()2021-12-06 02:15:37.648 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] | |--&gt;OrderRepository.save()2021-12-06 02:15:38.652 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] | |&lt;--OrderRepository.save() time=1004ms2021-12-06 02:15:38.653 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] |&lt;--OrderService.orderItem() time=1005ms2021-12-06 02:15:38.653 INFO 21903 --- [nio-8080-exec-2] c.e.a.t.logtrace.ThreadLocalLogTrace : [9e39132f] OrderController.request() time=1005ms","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"ThreadLocal","slug":"Spring/Spring-고급편/ThreadLocal","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/ThreadLocal/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - ThreadLocal","slug":"spring/spring-aop/threadlocal/threadlocal-04","date":"2021-11-19T19:31:07.000Z","updated":"2024-02-26T15:27:13.445Z","comments":true,"path":"2021/11/20/spring/spring-aop/threadlocal/threadlocal-04/","link":"","permalink":"https://ckck803.github.io/2021/11/20/spring/spring-aop/threadlocal/threadlocal-04/","excerpt":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 ThreadLocal ThreadLocal은 해당 Thread 만 접근할 수 있는 저장소다ThreadLocal을 사용하게 되면 각 Thread마다 별도의 저장소를 제공한다. 사용법 값 저장 : ThreadLocal.set(value) 값 조회 : ThreadLocal.get() 값 삭제 : ThreadLocal.remove() 해당 Thread 가 ThreadLocal 을 모두 사용하고 나면 ThreadLocal.remove() 를 호출해 ThreadLocal 에 저장된 값을 제거해 줘야 한다. @Slf4jpublic class ThreadLocalService &#123; private ThreadLocal&lt;String&gt; nameStore = new ThreadLocal&lt;&gt;(); public String logic(String name) &#123; log.info(&quot;저장 name=&#123;&#125; -&gt; nameStore = &#123;&#125;&quot;, name, nameStore.get()); nameStore.set(name); sleep(1000); log.info(&quot;조회 nameStore = &#123;&#125;&quot;, nameStore.get()); return nameStore.get(); &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; @Slf4jpublic class ThreadLocalServiceTest &#123; private ThreadLocalService service = new ThreadLocalService(); @Test public void field()&#123; log.info(&quot;main start&quot;); Runnable userA = () -&gt; &#123; service.logic(&quot;userA&quot;); &#125;; Runnable userB = () -&gt; &#123; service.logic(&quot;userB&quot;); &#125;; Thread threadA = new Thread(userA); threadA.setName(&quot;thread - A&quot;); Thread threadB = new Thread(userB); threadB.setName(&quot;thread - B&quot;); threadA.start(); sleep(100); threadB.start(); sleep(2000); // 메인 Thread 종료 대기 &#125; private void sleep(int millis)&#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 15:09:42.290 [Test worker] INFO com.example.advancedspring.trace.threadlocal.ThreadLocalServiceTest - main start15:09:42.293 [thread - A] INFO com.example.advancedspring.trace.threadlocal.code.ThreadLocalService - 저장 name=userA -&gt; nameStore = null15:09:42.397 [thread - B] INFO com.example.advancedspring.trace.threadlocal.code.ThreadLocalService - 저장 name=userB -&gt; nameStore = null15:09:43.301 [thread - A] INFO com.example.advancedspring.trace.threadlocal.code.ThreadLocalService - 조회 nameStore = userA15:09:43.400 [thread - B] INFO com.example.advancedspring.trace.threadlocal.code.ThreadLocalService - 조회 nameStore = userB15:09:44.402 [Test worker] INFO com.example.advancedspring.trace.threadlocal.ThreadLocalServiceTest - main exit","text":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 ThreadLocal ThreadLocal은 해당 Thread 만 접근할 수 있는 저장소다ThreadLocal을 사용하게 되면 각 Thread마다 별도의 저장소를 제공한다. 사용법 값 저장 : ThreadLocal.set(value) 값 조회 : ThreadLocal.get() 값 삭제 : ThreadLocal.remove() 해당 Thread 가 ThreadLocal 을 모두 사용하고 나면 ThreadLocal.remove() 를 호출해 ThreadLocal 에 저장된 값을 제거해 줘야 한다. @Slf4jpublic class ThreadLocalService &#123; private ThreadLocal&lt;String&gt; nameStore = new ThreadLocal&lt;&gt;(); public String logic(String name) &#123; log.info(&quot;저장 name=&#123;&#125; -&gt; nameStore = &#123;&#125;&quot;, name, nameStore.get()); nameStore.set(name); sleep(1000); log.info(&quot;조회 nameStore = &#123;&#125;&quot;, nameStore.get()); return nameStore.get(); &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; @Slf4jpublic class ThreadLocalServiceTest &#123; private ThreadLocalService service = new ThreadLocalService(); @Test public void field()&#123; log.info(&quot;main start&quot;); Runnable userA = () -&gt; &#123; service.logic(&quot;userA&quot;); &#125;; Runnable userB = () -&gt; &#123; service.logic(&quot;userB&quot;); &#125;; Thread threadA = new Thread(userA); threadA.setName(&quot;thread - A&quot;); Thread threadB = new Thread(userB); threadB.setName(&quot;thread - B&quot;); threadA.start(); sleep(100); threadB.start(); sleep(2000); // 메인 Thread 종료 대기 &#125; private void sleep(int millis)&#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 15:09:42.290 [Test worker] INFO com.example.advancedspring.trace.threadlocal.ThreadLocalServiceTest - main start15:09:42.293 [thread - A] INFO com.example.advancedspring.trace.threadlocal.code.ThreadLocalService - 저장 name=userA -&gt; nameStore = null15:09:42.397 [thread - B] INFO com.example.advancedspring.trace.threadlocal.code.ThreadLocalService - 저장 name=userB -&gt; nameStore = null15:09:43.301 [thread - A] INFO com.example.advancedspring.trace.threadlocal.code.ThreadLocalService - 조회 nameStore = userA15:09:43.400 [thread - B] INFO com.example.advancedspring.trace.threadlocal.code.ThreadLocalService - 조회 nameStore = userB15:09:44.402 [Test worker] INFO com.example.advancedspring.trace.threadlocal.ThreadLocalServiceTest - main exit","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"ThreadLocal","slug":"Spring/Spring-고급편/ThreadLocal","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/ThreadLocal/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - 동시성 이슈","slug":"spring/spring-aop/threadlocal/threadlocal-03","date":"2021-11-19T18:31:07.000Z","updated":"2024-02-26T15:27:09.955Z","comments":true,"path":"2021/11/20/spring/spring-aop/threadlocal/threadlocal-03/","link":"","permalink":"https://ckck803.github.io/2021/11/20/spring/spring-aop/threadlocal/threadlocal-03/","excerpt":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 동시성 이슈 발생 여러 Thread가 동시에 Application 로직을 호출하게 되면서 Level 상태값이 꼬여서 보이게 된다. Thread 로 구분해서 로그 확인2021-12-06 02:18:26.028 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] OrderController.request()2021-12-06 02:18:26.029 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] |--&gt;OrderService.orderItem()2021-12-06 02:18:26.029 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | |--&gt;OrderRepository.save()2021-12-06 02:18:27.033 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | |&lt;--OrderRepository.save() time=1004ms2021-12-06 02:18:27.033 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] |&lt;--OrderService.orderItem() time=1004ms2021-12-06 02:18:27.033 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] OrderController.request() time=1005ms 2021-12-06 02:18:26.114 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | |--&gt;OrderController.request()2021-12-06 02:18:26.115 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | | |--&gt;OrderService.orderItem()2021-12-06 02:18:26.115 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | | | |--&gt;OrderRepository.save()2021-12-06 02:18:27.119 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | | | |&lt;--OrderRepository.save() time=1004ms2021-12-06 02:18:27.120 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | | |&lt;--OrderService.orderItem() time=1005ms2021-12-06 02:18:27.120 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | |&lt;--OrderController.request() time=1006ms Thread 를 이용한 테스트 코드 작성@Slf4jpublic class FieldService &#123; private String nameStore; public String logic(String name)&#123; log.info(&quot;저장 name=&#123;&#125; -&gt; nameStore = &#123;&#125;&quot;, name, nameStore); nameStore = name; sleep(1000); log.info(&quot;조회 nameStore = &#123;&#125;&quot;, nameStore); return nameStore; &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","text":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 동시성 이슈 발생 여러 Thread가 동시에 Application 로직을 호출하게 되면서 Level 상태값이 꼬여서 보이게 된다. Thread 로 구분해서 로그 확인2021-12-06 02:18:26.028 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] OrderController.request()2021-12-06 02:18:26.029 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] |--&gt;OrderService.orderItem()2021-12-06 02:18:26.029 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | |--&gt;OrderRepository.save()2021-12-06 02:18:27.033 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | |&lt;--OrderRepository.save() time=1004ms2021-12-06 02:18:27.033 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] |&lt;--OrderService.orderItem() time=1004ms2021-12-06 02:18:27.033 INFO 22044 --- [nio-8080-exec-1] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] OrderController.request() time=1005ms 2021-12-06 02:18:26.114 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | |--&gt;OrderController.request()2021-12-06 02:18:26.115 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | | |--&gt;OrderService.orderItem()2021-12-06 02:18:26.115 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | | | |--&gt;OrderRepository.save()2021-12-06 02:18:27.119 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | | | |&lt;--OrderRepository.save() time=1004ms2021-12-06 02:18:27.120 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | | |&lt;--OrderService.orderItem() time=1005ms2021-12-06 02:18:27.120 INFO 22044 --- [nio-8080-exec-2] c.e.a.trace.logtrace.FieldLogTrace : [c0f5fc0a] | | |&lt;--OrderController.request() time=1006ms Thread 를 이용한 테스트 코드 작성@Slf4jpublic class FieldService &#123; private String nameStore; public String logic(String name)&#123; log.info(&quot;저장 name=&#123;&#125; -&gt; nameStore = &#123;&#125;&quot;, name, nameStore); nameStore = name; sleep(1000); log.info(&quot;조회 nameStore = &#123;&#125;&quot;, nameStore); return nameStore; &#125; private void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; @Slf4jpublic class FieldServiceTest &#123; private FieldService fieldService = new FieldService(); @Test public void field()&#123; log.info(&quot;main start&quot;); Runnable userA = () -&gt; &#123; fieldService.logic(&quot;userA&quot;); &#125;; Runnable userB = () -&gt; &#123; fieldService.logic(&quot;userA&quot;); &#125;; Thread threadA = new Thread(userA); threadA.setName(&quot;thread - A&quot;); Thread threadB = new Thread(userB); threadB.setName(&quot;thread - B&quot;); threadA.start(); sleep(2000); threadB.start(); &#125; private void sleep(int millis)&#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 14:10:58.072 [Test worker] INFO com.example.advancedspring.trace.threadlocal.FieldServiceTest - main start14:10:58.076 [thread - A] INFO com.example.advancedspring.trace.threadlocal.code.FieldService - 저장 name=userA -&gt; nameStore = null14:10:59.081 [thread - A] INFO com.example.advancedspring.trace.threadlocal.code.FieldService - 조회 nameStore = userA14:11:00.078 [thread - B] INFO com.example.advancedspring.trace.threadlocal.code.FieldService - 저장 name=userB -&gt; nameStore = userA14:11:01.080 [thread - B] INFO com.example.advancedspring.trace.threadlocal.code.FieldService - 조회 nameStore = userB 동시성 이슈가 발생하는 코드@Testpublic void field()&#123; log.info(&quot;main start&quot;); Runnable userA = () -&gt; &#123; fieldService.logic(&quot;userA&quot;); &#125;; Runnable userB = () -&gt; &#123; fieldService.logic(&quot;userB&quot;); &#125;; Thread threadA = new Thread(userA); threadA.setName(&quot;thread - A&quot;); Thread threadB = new Thread(userB); threadB.setName(&quot;thread - B&quot;); threadA.start(); sleep(100); threadB.start(); sleep(2000); // 메인 Thread 종료 대기&#125; 14:32:12.377 [Test worker] INFO com.example.advancedspring.trace.threadlocal.FieldServiceTest - main start14:32:12.381 [thread - A] INFO com.example.advancedspring.trace.threadlocal.code.FieldService - 저장 name=userA -&gt; nameStore = null14:32:12.483 [thread - B] INFO com.example.advancedspring.trace.threadlocal.code.FieldService - 저장 name=userB -&gt; nameStore = userA14:32:13.387 [thread - A] INFO com.example.advancedspring.trace.threadlocal.code.FieldService - 조회 nameStore = userB14:32:13.489 [thread - B] INFO com.example.advancedspring.trace.threadlocal.code.FieldService - 조회 nameStore = userB 동시성 문제는 지역 변수에서는 발생하지 않는다. 지역 변수는 쓰레드마다 각각 다른 메모리 영역에 할당된다.동시성 문제가 발생하는 곳은 같은 인스턴스의 필드 (주로 싱글톤에서 발생) 또는 static 같은 공용 필드에서 발생한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"ThreadLocal","slug":"Spring/Spring-고급편/ThreadLocal","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/ThreadLocal/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - 필드 동기화 적용","slug":"spring/spring-aop/threadlocal/threadlocal-02","date":"2021-11-19T17:31:07.000Z","updated":"2024-02-26T15:27:05.708Z","comments":true,"path":"2021/11/20/spring/spring-aop/threadlocal/threadlocal-02/","link":"","permalink":"https://ckck803.github.io/2021/11/20/spring/spring-aop/threadlocal/threadlocal-02/","excerpt":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 필드 동기화 적용Bean 으로 등록@Configuration public class LogTraceConfig &#123; @Bean public LogTrace logTrace() &#123; return new FieldLogTrace(); &#125; &#125; @RestController@RequiredArgsConstructorpublic class OrderControllerV3 &#123; private final OrderServiceV3 orderService; private final LogTrace trace; @GetMapping(&quot;/v3/request&quot;) public String request(String itemId)&#123; System.out.println(itemId); TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderController.request()&quot;); orderService.orderItem(itemId); trace.end(status); return &quot;ok&quot;; &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Service@RequiredArgsConstructorpublic class OrderServiceV3 &#123; private final OrderRepositoryV3 orderRepository; private final LogTrace trace; public void orderItem (String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderService.orderItem()&quot;); orderRepository.save(itemId); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Repository@RequiredArgsConstructorpublic class OrderRepositoryV3 &#123; private final LogTrace trace; public void save(String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderRepository.save()&quot;); // 저장 로직 if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125; private void sleep(int millis) &#123; try&#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","text":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 필드 동기화 적용Bean 으로 등록@Configuration public class LogTraceConfig &#123; @Bean public LogTrace logTrace() &#123; return new FieldLogTrace(); &#125; &#125; @RestController@RequiredArgsConstructorpublic class OrderControllerV3 &#123; private final OrderServiceV3 orderService; private final LogTrace trace; @GetMapping(&quot;/v3/request&quot;) public String request(String itemId)&#123; System.out.println(itemId); TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderController.request()&quot;); orderService.orderItem(itemId); trace.end(status); return &quot;ok&quot;; &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Service@RequiredArgsConstructorpublic class OrderServiceV3 &#123; private final OrderRepositoryV3 orderRepository; private final LogTrace trace; public void orderItem (String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderService.orderItem()&quot;); orderRepository.save(itemId); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Repository@RequiredArgsConstructorpublic class OrderRepositoryV3 &#123; private final LogTrace trace; public void save(String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderRepository.save()&quot;); // 저장 로직 if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125; private void sleep(int millis) &#123; try&#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"ThreadLocal","slug":"Spring/Spring-고급편/ThreadLocal","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/ThreadLocal/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - 필드 동기화","slug":"spring/spring-aop/threadlocal/threadlocal-01","date":"2021-11-19T16:31:07.000Z","updated":"2024-02-26T15:27:00.716Z","comments":true,"path":"2021/11/20/spring/spring-aop/threadlocal/threadlocal-01/","link":"","permalink":"https://ckck803.github.io/2021/11/20/spring/spring-aop/threadlocal/threadlocal-01/","excerpt":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 필드 동기화public interface LogTrace &#123; TraceStatus begin(String message); void end(TraceStatus status); void exception(TraceStatus status, Exception e);&#125; 필드 동기화를 위한 로그 분석기 만들기 TraceId 객체가 없을 경우 새로 생성한다. TraceId 객체가 있을 경우 Level 을 증가 시킨다. private void syncTraceId()&#123; if(traceIdHolder == null)&#123; traceIdHolder = new TraceId(); &#125;else&#123; traceIdHolder = traceIdHolder.createNextId(); &#125;&#125; TraceId 내 Level 이 0일 경우 해당 객체를 null 로 초기화 한다. TraceId 내 Level 이 0이 아닐 경우 Level을 1 감소시킨다. private void releaseTraceId() &#123; if(traceIdHolder.isFirstLevel())&#123; traceIdHolder = null; // destroy &#125;else&#123; traceIdHolder = traceIdHolder.createPreviousId(); &#125;&#125; TraceId 객체는 파라미터로 전달되는 것이 아니라 traceIdHolder 필드에 저장된다.","text":"목차 Post not found: springboot/spring-aop/threadlocal/threadlocal-01 Post not found: springboot/spring-aop/threadlocal/threadlocal-02 Post not found: springboot/spring-aop/threadlocal/threadlocal-03 Post not found: springboot/spring-aop/threadlocal/threadlocal-04 Post not found: springboot/spring-aop/threadlocal/threadlocal-05 Post not found: springboot/spring-aop/threadlocal/threadlocal-06 필드 동기화public interface LogTrace &#123; TraceStatus begin(String message); void end(TraceStatus status); void exception(TraceStatus status, Exception e);&#125; 필드 동기화를 위한 로그 분석기 만들기 TraceId 객체가 없을 경우 새로 생성한다. TraceId 객체가 있을 경우 Level 을 증가 시킨다. private void syncTraceId()&#123; if(traceIdHolder == null)&#123; traceIdHolder = new TraceId(); &#125;else&#123; traceIdHolder = traceIdHolder.createNextId(); &#125;&#125; TraceId 내 Level 이 0일 경우 해당 객체를 null 로 초기화 한다. TraceId 내 Level 이 0이 아닐 경우 Level을 1 감소시킨다. private void releaseTraceId() &#123; if(traceIdHolder.isFirstLevel())&#123; traceIdHolder = null; // destroy &#125;else&#123; traceIdHolder = traceIdHolder.createPreviousId(); &#125;&#125; TraceId 객체는 파라미터로 전달되는 것이 아니라 traceIdHolder 필드에 저장된다. @Slf4jpublic class FieldLogTrace implements LogTrace &#123; private static final String START_PREFIX = &quot;--&gt;&quot;; private static final String COMPLETE_PREFIX = &quot;&lt;--&quot;; private static final String EX_PREFIX = &quot;&lt;X-&quot;; private TraceId traceIdHolder; // traceId 동기화, 동시성 이슈 @Override public TraceStatus begin(String message) &#123; syncTraceId(); TraceId traceId = traceIdHolder; Long startTimeMs = System.currentTimeMillis(); log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125;&quot;, traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message); return new TraceStatus(traceId, startTimeMs, message); &#125; private void syncTraceId()&#123; if(traceIdHolder == null)&#123; traceIdHolder = new TraceId(); &#125;else&#123; traceIdHolder = traceIdHolder.createNextId(); &#125; &#125; @Override public void end(TraceStatus status) &#123; complete(status, null); &#125; @Override public void exception(TraceStatus status, Exception e) &#123; complete(status, e); &#125; private void complete(TraceStatus status, Exception e) &#123; Long stopTimeMs = System.currentTimeMillis(); long resultTimeMs = stopTimeMs - status.getStartTimeMs(); TraceId traceId = status.getTraceId(); if (e == null) &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms&quot;, traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs); &#125; else &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms ex=&#123;&#125;&quot;, traceId.getId(), addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs, e.toString()); &#125; releaseTraceId(); &#125; private void releaseTraceId() &#123; if(traceIdHolder.isFirstLevel())&#123; traceIdHolder = null; // destroy &#125;else&#123; traceIdHolder = traceIdHolder.createPreviousId(); &#125; &#125; private static String addSpace(String prefix, int level) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; level; i++) &#123; sb.append((i == level - 1) ? &quot;|&quot; + prefix : &quot;| &quot;); &#125; return sb.toString(); &#125;&#125; class FieldLogTraceTest &#123; FieldLogTrace trace = new FieldLogTrace(); @Test void begin_end_level2()&#123; TraceStatus status1 = trace.begin(&quot;hello1&quot;); TraceStatus status2 = trace.begin(&quot;hello2&quot;); trace.end(status2); trace.end(status1); &#125; @Test void begin_end_level2_exception()&#123; TraceStatus status1 = trace.begin(&quot;hello1&quot;); TraceStatus status2 = trace.begin(&quot;hello2&quot;); trace.exception(status2, new IllegalStateException()); trace.exception(status1, new IllegalStateException()); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"ThreadLocal","slug":"Spring/Spring-고급편/ThreadLocal","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/ThreadLocal/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Logging Filter 파라미터 동기화 개발","slug":"spring/spring-aop/log-trace/log-trace-03","date":"2021-11-18T18:31:07.000Z","updated":"2024-02-26T15:24:33.544Z","comments":true,"path":"2021/11/19/spring/spring-aop/log-trace/log-trace-03/","link":"","permalink":"https://ckck803.github.io/2021/11/19/spring/spring-aop/log-trace/log-trace-03/","excerpt":"목차 Post not found: springboot/spring-aop/log-trace/log-trace-01 Post not found: springboot/spring-aop/log-trace/log-trace-02 Post not found: springboot/spring-aop/log-trace/log-trace-03 Spring 핵심원리 고급편 - Logging Filter 파라미터 동기화 개발Logging Filter 파라미터 동기화 개발@Slf4j@Componentpublic class HelloTraceV2 &#123; private static final String START_PREFIX = &quot;--&gt;&quot;; private static final String COMPLETE_PREFIX = &quot;&lt;--&quot;; private static final String EX_PREFIX = &quot;&lt;X-&quot;; public TraceStatus begin(String message) &#123; TraceId traceId = new TraceId(); Long startTimeMs = System.currentTimeMillis(); log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125;&quot;, traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message); return new TraceStatus(traceId, startTimeMs, message); &#125; public TraceStatus beginSync(TraceId beforeTraceId, String message) &#123; TraceId nextId = beforeTraceId.createNextId(); Long startTimeMs = System.currentTimeMillis(); log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125;&quot;, nextId.getId(), addSpace(START_PREFIX, nextId.getLevel()), message); return new TraceStatus(nextId, startTimeMs, message); &#125; public void end(TraceStatus status) &#123; complete(status, null); &#125; public void exception(TraceStatus status, Exception e) &#123; complete(status, e); &#125; private void complete(TraceStatus status, Exception e) &#123; Long stopTimeMs = System.currentTimeMillis(); long resultTimeMs = stopTimeMs - status.getStartTimeMs(); TraceId traceId = status.getTraceId(); if (e == null) &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms&quot;, traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs); &#125; else &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms ex=&#123;&#125;&quot;, traceId.getId(), addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs, e.toString()); &#125; &#125; private static String addSpace(String prefix, int level) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; level; i++) &#123; sb.append((i == level - 1) ? &quot;|&quot; + prefix : &quot;| &quot;); &#125; return sb.toString(); &#125;&#125; @RestController@RequiredArgsConstructorpublic class OrderControllerV2 &#123; private final OrderServiceV2 orderService; private final HelloTraceV2 trace; @GetMapping(&quot;/v2/request&quot;) public String request(String itemId)&#123; System.out.println(itemId); TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderController.request()&quot;); orderService.orderItem(status.getTraceId(), itemId); trace.end(status); return &quot;ok&quot;; &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Service@RequiredArgsConstructorpublic class OrderServiceV2 &#123; private final OrderRepositoryV2 orderRepository; private final HelloTraceV2 trace; public void orderItem(TraceId traceId, String itemId)&#123; TraceStatus status = null; try &#123; status = trace.beginSync(traceId, &quot;OrderService.orderItem()&quot;); orderRepository.save(status.getTraceId(),itemId); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Repository@RequiredArgsConstructorpublic class OrderRepositoryV2 &#123; private final HelloTraceV2 trace; public void save(TraceId traceId, String itemId)&#123; TraceStatus status = null; try &#123; status = trace.beginSync(traceId,&quot;OrderRepository.save()&quot;); // 저장 로직 if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125; private void sleep(int millis) &#123; try&#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","text":"목차 Post not found: springboot/spring-aop/log-trace/log-trace-01 Post not found: springboot/spring-aop/log-trace/log-trace-02 Post not found: springboot/spring-aop/log-trace/log-trace-03 Spring 핵심원리 고급편 - Logging Filter 파라미터 동기화 개발Logging Filter 파라미터 동기화 개발@Slf4j@Componentpublic class HelloTraceV2 &#123; private static final String START_PREFIX = &quot;--&gt;&quot;; private static final String COMPLETE_PREFIX = &quot;&lt;--&quot;; private static final String EX_PREFIX = &quot;&lt;X-&quot;; public TraceStatus begin(String message) &#123; TraceId traceId = new TraceId(); Long startTimeMs = System.currentTimeMillis(); log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125;&quot;, traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message); return new TraceStatus(traceId, startTimeMs, message); &#125; public TraceStatus beginSync(TraceId beforeTraceId, String message) &#123; TraceId nextId = beforeTraceId.createNextId(); Long startTimeMs = System.currentTimeMillis(); log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125;&quot;, nextId.getId(), addSpace(START_PREFIX, nextId.getLevel()), message); return new TraceStatus(nextId, startTimeMs, message); &#125; public void end(TraceStatus status) &#123; complete(status, null); &#125; public void exception(TraceStatus status, Exception e) &#123; complete(status, e); &#125; private void complete(TraceStatus status, Exception e) &#123; Long stopTimeMs = System.currentTimeMillis(); long resultTimeMs = stopTimeMs - status.getStartTimeMs(); TraceId traceId = status.getTraceId(); if (e == null) &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms&quot;, traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs); &#125; else &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms ex=&#123;&#125;&quot;, traceId.getId(), addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs, e.toString()); &#125; &#125; private static String addSpace(String prefix, int level) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; level; i++) &#123; sb.append((i == level - 1) ? &quot;|&quot; + prefix : &quot;| &quot;); &#125; return sb.toString(); &#125;&#125; @RestController@RequiredArgsConstructorpublic class OrderControllerV2 &#123; private final OrderServiceV2 orderService; private final HelloTraceV2 trace; @GetMapping(&quot;/v2/request&quot;) public String request(String itemId)&#123; System.out.println(itemId); TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderController.request()&quot;); orderService.orderItem(status.getTraceId(), itemId); trace.end(status); return &quot;ok&quot;; &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Service@RequiredArgsConstructorpublic class OrderServiceV2 &#123; private final OrderRepositoryV2 orderRepository; private final HelloTraceV2 trace; public void orderItem(TraceId traceId, String itemId)&#123; TraceStatus status = null; try &#123; status = trace.beginSync(traceId, &quot;OrderService.orderItem()&quot;); orderRepository.save(status.getTraceId(),itemId); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Repository@RequiredArgsConstructorpublic class OrderRepositoryV2 &#123; private final HelloTraceV2 trace; public void save(TraceId traceId, String itemId)&#123; TraceStatus status = null; try &#123; status = trace.beginSync(traceId,&quot;OrderRepository.save()&quot;); // 저장 로직 if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125; private void sleep(int millis) &#123; try&#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Logging Filter","slug":"spring/spring-aop/log-trace/log-trace-02","date":"2021-11-18T17:31:07.000Z","updated":"2024-02-26T15:24:30.388Z","comments":true,"path":"2021/11/19/spring/spring-aop/log-trace/log-trace-02/","link":"","permalink":"https://ckck803.github.io/2021/11/19/spring/spring-aop/log-trace/log-trace-02/","excerpt":"목차 Post not found: springboot/spring-aop/log-trace/log-trace-01 Post not found: springboot/spring-aop/log-trace/log-trace-02 Post not found: springboot/spring-aop/log-trace/log-trace-03 Spring 핵심원리 고급편 - Logging Filter@RestController@RequiredArgsConstructorpublic class OrderControllerV1 &#123; private final OrderServiceV1 orderService; private final HelloTraceV1 trace; @GetMapping(&quot;/v1/request&quot;) public String request(String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderController.request()&quot;); orderService.orderItem(itemId); trace.end(status); return &quot;ok&quot;; &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Service@RequiredArgsConstructorpublic class OrderServiceV1 &#123; private final OrderRepositoryV1 orderRepository; private final HelloTraceV1 trace; public void orderItem(String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderService.orderItem()&quot;); orderRepository.save(itemId); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Repository@RequiredArgsConstructorpublic class OrderRepositoryV1 &#123; private final HelloTraceV1 trace; public void save(String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderRepository.save()&quot;); // 저장 로직 if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125; private void sleep(int millis) &#123; try&#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","text":"목차 Post not found: springboot/spring-aop/log-trace/log-trace-01 Post not found: springboot/spring-aop/log-trace/log-trace-02 Post not found: springboot/spring-aop/log-trace/log-trace-03 Spring 핵심원리 고급편 - Logging Filter@RestController@RequiredArgsConstructorpublic class OrderControllerV1 &#123; private final OrderServiceV1 orderService; private final HelloTraceV1 trace; @GetMapping(&quot;/v1/request&quot;) public String request(String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderController.request()&quot;); orderService.orderItem(itemId); trace.end(status); return &quot;ok&quot;; &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Service@RequiredArgsConstructorpublic class OrderServiceV1 &#123; private final OrderRepositoryV1 orderRepository; private final HelloTraceV1 trace; public void orderItem(String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderService.orderItem()&quot;); orderRepository.save(itemId); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125;&#125; @Repository@RequiredArgsConstructorpublic class OrderRepositoryV1 &#123; private final HelloTraceV1 trace; public void save(String itemId)&#123; TraceStatus status = null; try &#123; status = trace.begin(&quot;OrderRepository.save()&quot;); // 저장 로직 if(itemId.equals(&quot;ex&quot;))&#123; throw new IllegalStateException(&quot;예외 발생!&quot;); &#125; sleep(1000); trace.end(status); &#125;catch (Exception e)&#123; trace.exception(status, e); throw e; // 예외를 반드시 던져 줘야 한다. &#125; &#125; private void sleep(int millis) &#123; try&#123; Thread.sleep(millis); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"}],"tags":[]},{"title":"Spring 핵심원리 고급편 - Logging Filter","slug":"spring/spring-aop/log-trace/log-trace-01","date":"2021-11-17T16:31:07.000Z","updated":"2024-02-26T15:24:25.816Z","comments":true,"path":"2021/11/18/spring/spring-aop/log-trace/log-trace-01/","link":"","permalink":"https://ckck803.github.io/2021/11/18/spring/spring-aop/log-trace/log-trace-01/","excerpt":"목차 Post not found: springboot/spring-aop/log-trace/log-trace-01 Post not found: springboot/spring-aop/log-trace/log-trace-02 Post not found: springboot/spring-aop/log-trace/log-trace-03 Spring 핵심원리 고급편 - Logging FilterTraceId - 트랜잭션 Id와 level을 관리public class TraceId &#123; private String id; // 트랜잭션 ID private int level; // 깊이를 표현할 수 있는 Level public TraceId() &#123; this.id = creatId(); this.level = 0; &#125; private TraceId(String id, int level)&#123; this.id = id; this.level = level; &#125; public String creatId() &#123; return UUID.randomUUID().toString().substring(0, 8); &#125; public TraceId createNextId()&#123; return new TraceId(id, level+1); &#125; // 트랜잭션 ID 는 기존과 같고 Level 은 하나 감소시킨다. public TraceId createPreviousId()&#123; return new TraceId(id, level-1); &#125; public boolean isFirstLevel()&#123; return level == 0; &#125;&#125; TraceStatus - 로그 상태 정보를 나타낸다. traceId 내부에 트랜잭션 Id 와 Level 을 가지고 있다. startTimeMs 로그 시작 시간이다. 로그 종료시 이 시작 시간을 기준으로 시작 ~ 종료까지 수행시간을 구할 수 있다. message 시작시 사용한 메시지다. 로그 종료시에 사용해 출력한다. public class TraceStatus &#123; private TraceId traceId; private Long startTimeMs; private String message; public TraceStatus(TraceId traceId, Long startTimeMs, String message) &#123; this.traceId = traceId; this.startTimeMs = startTimeMs; this.message = message; &#125; public TraceId getTraceId() &#123; return traceId; &#125; public Long getStartTimeMs() &#123; return startTimeMs; &#125; public String getMessage() &#123; return message; &#125;&#125; @Slf4j@Componentpublic class HelloTraceV1 &#123; private static final String START_PREFIX = &quot;--&gt;&quot;; private static final String COMPLETE_PREFIX = &quot;&lt;--&quot;; private static final String EX_PREFIX = &quot;&lt;X-&quot;; public TraceStatus begin(String message) &#123; TraceId traceId = new TraceId(); Long startTimeMs = System.currentTimeMillis(); log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125;&quot;, traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message); return new TraceStatus(traceId, startTimeMs, message); &#125; public void end(TraceStatus status) &#123; complete(status, null); &#125; public void exception(TraceStatus status, Exception e) &#123; complete(status, e); &#125; private void complete(TraceStatus status, Exception e) &#123; Long stopTimeMs = System.currentTimeMillis(); long resultTimeMs = stopTimeMs - status.getStartTimeMs(); TraceId traceId = status.getTraceId(); if (e == null) &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms&quot;, traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs); &#125; else &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms ex=&#123;&#125;&quot;, traceId.getId(), addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs, e.toString()); &#125; &#125; private static String addSpace(String prefix, int level) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; level; i++) &#123; sb.append((i == level - 1) ? &quot;|&quot; + prefix : &quot;| &quot;); &#125; return sb.toString(); &#125;&#125; 테스트 코드 작성","text":"목차 Post not found: springboot/spring-aop/log-trace/log-trace-01 Post not found: springboot/spring-aop/log-trace/log-trace-02 Post not found: springboot/spring-aop/log-trace/log-trace-03 Spring 핵심원리 고급편 - Logging FilterTraceId - 트랜잭션 Id와 level을 관리public class TraceId &#123; private String id; // 트랜잭션 ID private int level; // 깊이를 표현할 수 있는 Level public TraceId() &#123; this.id = creatId(); this.level = 0; &#125; private TraceId(String id, int level)&#123; this.id = id; this.level = level; &#125; public String creatId() &#123; return UUID.randomUUID().toString().substring(0, 8); &#125; public TraceId createNextId()&#123; return new TraceId(id, level+1); &#125; // 트랜잭션 ID 는 기존과 같고 Level 은 하나 감소시킨다. public TraceId createPreviousId()&#123; return new TraceId(id, level-1); &#125; public boolean isFirstLevel()&#123; return level == 0; &#125;&#125; TraceStatus - 로그 상태 정보를 나타낸다. traceId 내부에 트랜잭션 Id 와 Level 을 가지고 있다. startTimeMs 로그 시작 시간이다. 로그 종료시 이 시작 시간을 기준으로 시작 ~ 종료까지 수행시간을 구할 수 있다. message 시작시 사용한 메시지다. 로그 종료시에 사용해 출력한다. public class TraceStatus &#123; private TraceId traceId; private Long startTimeMs; private String message; public TraceStatus(TraceId traceId, Long startTimeMs, String message) &#123; this.traceId = traceId; this.startTimeMs = startTimeMs; this.message = message; &#125; public TraceId getTraceId() &#123; return traceId; &#125; public Long getStartTimeMs() &#123; return startTimeMs; &#125; public String getMessage() &#123; return message; &#125;&#125; @Slf4j@Componentpublic class HelloTraceV1 &#123; private static final String START_PREFIX = &quot;--&gt;&quot;; private static final String COMPLETE_PREFIX = &quot;&lt;--&quot;; private static final String EX_PREFIX = &quot;&lt;X-&quot;; public TraceStatus begin(String message) &#123; TraceId traceId = new TraceId(); Long startTimeMs = System.currentTimeMillis(); log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125;&quot;, traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message); return new TraceStatus(traceId, startTimeMs, message); &#125; public void end(TraceStatus status) &#123; complete(status, null); &#125; public void exception(TraceStatus status, Exception e) &#123; complete(status, e); &#125; private void complete(TraceStatus status, Exception e) &#123; Long stopTimeMs = System.currentTimeMillis(); long resultTimeMs = stopTimeMs - status.getStartTimeMs(); TraceId traceId = status.getTraceId(); if (e == null) &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms&quot;, traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs); &#125; else &#123; log.info(&quot;[&#123;&#125;] &#123;&#125;&#123;&#125; time=&#123;&#125;ms ex=&#123;&#125;&quot;, traceId.getId(), addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs, e.toString()); &#125; &#125; private static String addSpace(String prefix, int level) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; level; i++) &#123; sb.append((i == level - 1) ? &quot;|&quot; + prefix : &quot;| &quot;); &#125; return sb.toString(); &#125;&#125; 테스트 코드 작성@Testpublic void begin_end()&#123; HelloTraceV1 trace = new HelloTraceV1(); TraceStatus traceStatus = trace.begin(&quot;hello&quot;); trace.end(traceStatus);&#125; [942a9566] hello[942a9566] hello time=4ms ex=java.lang.IllegalStateException @Testpublic void begin_exception()&#123; HelloTraceV1 trace = new HelloTraceV1(); TraceStatus traceStatus = trace.begin(&quot;hello&quot;); trace.exception(traceStatus, new IllegalStateException());&#125; [3eca720c] hello[3eca720c] hello time=3ms ex=java.lang.IllegalStateException","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"}],"tags":[]},{"title":"STL - map 컨테니어","slug":"stl/map","date":"2021-11-15T20:31:46.000Z","updated":"2024-02-18T16:19:54.508Z","comments":true,"path":"2021/11/16/stl/map/","link":"","permalink":"https://ckck803.github.io/2021/11/16/stl/map/","excerpt":"map 연관 컨테이너 에서 원소로 Key와 Value의 쌍으로 저장되는 컨테이너[] 연산자를 이용해 value 에 접근 할 수 있다. (value &#x3D; m[key] 형태로 사용) key 는 중복해서 저장될 수 없다. 노드 기반 컨테이너 균현 이진 트리로 구현돼 있다. Map Member 함수 함수 설명 반환 값 begin() 첫번째 원소를 가르키는 iterator 를 가져온다 iterator end() 마지막 원소를 가르키는 다음 iterator 를 가져온다 iterator clear() map 내 모든 원소를 삭제한다 empty() map 이 비었는지 확인한다 bool size() map 에 저장된 원소의 개수를 가져온다 int find(key) map 내 key 가 저장된 iterator 를 가져온다. 없으면 end iterator를 반환한다 iterator count(key) map 내 key 의 개수를 가져온다 int erase(key) map 내 key 원소를 삭제한후 다음 원소를 가르키는 itrator를 반환한다 iterator erase(iterator) iterator 가 가르키는 원소를 삭제한 후 다음 원소를 가르키는 iterator를 반환한다 iterator erase(begin, end) iterator begin에서 end까지 원소를 삭제한 후 다음 원소를 가르키는 iterator를 반환한다 iterator insert(key) map 에 key 를 삽입한 후 저장된 iterator와 성공 여부를 담는 Pair 객체를 반환한다 Pair&lt;iterator, bool&gt; insert(begin, end) iterator begin에서 end까지 원소를 map 에 삽입한다. lower_bound(key) key 값 보다 같거나 큰 값이 처음으로 나타나는 iterator 를 반환한다. (이상) iterator upper_bound(key) key 값 보다 큰 값이 처음으로 나타나는 iterator 를 반환한다. (초과) iterator","text":"map 연관 컨테이너 에서 원소로 Key와 Value의 쌍으로 저장되는 컨테이너[] 연산자를 이용해 value 에 접근 할 수 있다. (value &#x3D; m[key] 형태로 사용) key 는 중복해서 저장될 수 없다. 노드 기반 컨테이너 균현 이진 트리로 구현돼 있다. Map Member 함수 함수 설명 반환 값 begin() 첫번째 원소를 가르키는 iterator 를 가져온다 iterator end() 마지막 원소를 가르키는 다음 iterator 를 가져온다 iterator clear() map 내 모든 원소를 삭제한다 empty() map 이 비었는지 확인한다 bool size() map 에 저장된 원소의 개수를 가져온다 int find(key) map 내 key 가 저장된 iterator 를 가져온다. 없으면 end iterator를 반환한다 iterator count(key) map 내 key 의 개수를 가져온다 int erase(key) map 내 key 원소를 삭제한후 다음 원소를 가르키는 itrator를 반환한다 iterator erase(iterator) iterator 가 가르키는 원소를 삭제한 후 다음 원소를 가르키는 iterator를 반환한다 iterator erase(begin, end) iterator begin에서 end까지 원소를 삭제한 후 다음 원소를 가르키는 iterator를 반환한다 iterator insert(key) map 에 key 를 삽입한 후 저장된 iterator와 성공 여부를 담는 Pair 객체를 반환한다 Pair&lt;iterator, bool&gt; insert(begin, end) iterator begin에서 end까지 원소를 map 에 삽입한다. lower_bound(key) key 값 보다 같거나 큰 값이 처음으로 나타나는 iterator 를 반환한다. (이상) iterator upper_bound(key) key 값 보다 큰 값이 처음으로 나타나는 iterator 를 반환한다. (초과) iterator","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Cpp","slug":"Programming/Cpp","permalink":"https://ckck803.github.io/categories/Programming/Cpp/"},{"name":"STL","slug":"Programming/Cpp/STL","permalink":"https://ckck803.github.io/categories/Programming/Cpp/STL/"}],"tags":[]},{"title":"STL - set 컨테이너","slug":"stl/set","date":"2021-11-15T19:31:46.000Z","updated":"2024-02-18T16:19:54.508Z","comments":true,"path":"2021/11/16/stl/set/","link":"","permalink":"https://ckck803.github.io/2021/11/16/stl/set/","excerpt":"set 연관 컨테이너 에서 key 라 불리는 원소의 집합으로 이뤄진 컨테이너 key 는 중복해서 저장될 수 없다. 노드 기반 컨테이너 균현 이진 트리로 구현돼 있다. 시퀸스 컨테이너로 배열과 비슷하지만 동적으로 데이터를 추가할 수 있고, 크기가 자동으로 늘어난다는 장점이 있다. Set Member 함수 함수 설명 반환 값 begin() 첫번째 원소를 가르키는 iterator 를 가져온다 iterator end() 마지막 원소를 가르키는 다음 iterator 를 가져온다 iterator clear() set 내 모든 원소를 삭제한다 empty() set 이 비었는지 확인한다 bool size() set 에 저장된 원소의 개수를 가져온다 int find(key) set 내 key 가 저장된 iterator 를 가져온다. 없으면 end iterator를 반환한다 iterator count(key) set 내 key 의 개수를 가져온다 int erase(key) set 내 key 원소를 삭제한후 다음 원소를 가르키는 itrator를 반환한다 iterator erase(iterator) iterator 가 가르키는 원소를 삭제한 후 다음 원소를 가르키는 iterator를 반환한다 iterator erase(begin, end) iterator begin에서 end까지 원소를 삭제한 후 다음 원소를 가르키는 iterator를 반환한다 iterator insert(key) set 에 key 를 삽입한 후 저장된 iterator와 성공 여부를 담는 Pair 객체를 반환한다 Pair&lt;iterator, bool&gt; insert(begin, end) iterator begin에서 end까지 원소를 set 에 삽입한다. lower_bound(key) key 값 보다 같거나 큰 값이 처음으로 나타나는 iterator 를 반환한다. (이상) iterator upper_bound(key) key 값 보다 큰 값이 처음으로 나타나는 iterator 를 반환한다. (초과) iterator insert(begin, end) 다른 컨테이너어 저장된 데이터를 set 에 데이터를 넣을때 사용하면 유용한 함수다.","text":"set 연관 컨테이너 에서 key 라 불리는 원소의 집합으로 이뤄진 컨테이너 key 는 중복해서 저장될 수 없다. 노드 기반 컨테이너 균현 이진 트리로 구현돼 있다. 시퀸스 컨테이너로 배열과 비슷하지만 동적으로 데이터를 추가할 수 있고, 크기가 자동으로 늘어난다는 장점이 있다. Set Member 함수 함수 설명 반환 값 begin() 첫번째 원소를 가르키는 iterator 를 가져온다 iterator end() 마지막 원소를 가르키는 다음 iterator 를 가져온다 iterator clear() set 내 모든 원소를 삭제한다 empty() set 이 비었는지 확인한다 bool size() set 에 저장된 원소의 개수를 가져온다 int find(key) set 내 key 가 저장된 iterator 를 가져온다. 없으면 end iterator를 반환한다 iterator count(key) set 내 key 의 개수를 가져온다 int erase(key) set 내 key 원소를 삭제한후 다음 원소를 가르키는 itrator를 반환한다 iterator erase(iterator) iterator 가 가르키는 원소를 삭제한 후 다음 원소를 가르키는 iterator를 반환한다 iterator erase(begin, end) iterator begin에서 end까지 원소를 삭제한 후 다음 원소를 가르키는 iterator를 반환한다 iterator insert(key) set 에 key 를 삽입한 후 저장된 iterator와 성공 여부를 담는 Pair 객체를 반환한다 Pair&lt;iterator, bool&gt; insert(begin, end) iterator begin에서 end까지 원소를 set 에 삽입한다. lower_bound(key) key 값 보다 같거나 큰 값이 처음으로 나타나는 iterator 를 반환한다. (이상) iterator upper_bound(key) key 값 보다 큰 값이 처음으로 나타나는 iterator 를 반환한다. (초과) iterator insert(begin, end) 다른 컨테이너어 저장된 데이터를 set 에 데이터를 넣을때 사용하면 유용한 함수다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Cpp","slug":"Programming/Cpp","permalink":"https://ckck803.github.io/categories/Programming/Cpp/"},{"name":"STL","slug":"Programming/Cpp/STL","permalink":"https://ckck803.github.io/categories/Programming/Cpp/STL/"}],"tags":[]},{"title":"STL - vector 컨테이너","slug":"stl/vector","date":"2021-11-14T19:31:46.000Z","updated":"2024-02-18T16:19:54.508Z","comments":true,"path":"2021/11/15/stl/vector/","link":"","permalink":"https://ckck803.github.io/2021/11/15/stl/vector/","excerpt":"vector 시퀸스 컨테이너로 배열과 비슷하지만 동적으로 데이터를 추가할 수 있고, 크기가 자동으로 늘어난다는 장점이 있다. Vector Member 함수 함수 설명 반환 값 push_back(value) vector 끝에 value 를 넣는다 pop_back() vector 의 마지막 원소를 삭제한다 begin() vector 의 첫번째 원소를 가르키는 iterator를 가져온다 Iterator end() vector 의 마지막 원소 다음을 가르키는 iterator를 가져온다. Iterator clear() vector 내 모든 원소를 삭제한다. size() vector 에 저장된 원소의 개수를 반환한다. int empty() vector 가 비었는지 확인한다. bool insert(iterator, value) 해당 iterator가 가르키는 위치에 value를 삽입한다. insert(iterator, begin, end) 해당 iterator가 가르키는 위치에 특정 iterator 가르키는 begin 에서 end 까지 원소를 삽입한다. erase(iterator) 해당 iterator가 가르키는 원소를 삭제한다. 반환 값으로 다음 iterator 를 반환한다. Iterator erase(begin, end) begin 에서 end 범위까지 원소를 삭제한다. 반환 값으로 삭제한 마지막 원소 다음 iterator를 가져온다. Iterator assign(n, value) vector 에 value를 n 개 만큼 할당한다. 이전 값이 있더라도 초기화 되고 재할당된다. assign(begin, end) vector 값을 특정 iterator 가르키는 begin 에서 end 범위 값으로 할당한다 이전 값이 있더라도 초기화되고 재할당된다. at(index) index가 가르키는 value를 가져온다. 데이터 삽입 함수push_back 함수 push_back 함수는 vector 마지막에 원소를 넣어준다. #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); for (int a : v) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1 2 3","text":"vector 시퀸스 컨테이너로 배열과 비슷하지만 동적으로 데이터를 추가할 수 있고, 크기가 자동으로 늘어난다는 장점이 있다. Vector Member 함수 함수 설명 반환 값 push_back(value) vector 끝에 value 를 넣는다 pop_back() vector 의 마지막 원소를 삭제한다 begin() vector 의 첫번째 원소를 가르키는 iterator를 가져온다 Iterator end() vector 의 마지막 원소 다음을 가르키는 iterator를 가져온다. Iterator clear() vector 내 모든 원소를 삭제한다. size() vector 에 저장된 원소의 개수를 반환한다. int empty() vector 가 비었는지 확인한다. bool insert(iterator, value) 해당 iterator가 가르키는 위치에 value를 삽입한다. insert(iterator, begin, end) 해당 iterator가 가르키는 위치에 특정 iterator 가르키는 begin 에서 end 까지 원소를 삽입한다. erase(iterator) 해당 iterator가 가르키는 원소를 삭제한다. 반환 값으로 다음 iterator 를 반환한다. Iterator erase(begin, end) begin 에서 end 범위까지 원소를 삭제한다. 반환 값으로 삭제한 마지막 원소 다음 iterator를 가져온다. Iterator assign(n, value) vector 에 value를 n 개 만큼 할당한다. 이전 값이 있더라도 초기화 되고 재할당된다. assign(begin, end) vector 값을 특정 iterator 가르키는 begin 에서 end 범위 값으로 할당한다 이전 값이 있더라도 초기화되고 재할당된다. at(index) index가 가르키는 value를 가져온다. 데이터 삽입 함수push_back 함수 push_back 함수는 vector 마지막에 원소를 넣어준다. #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); for (int a : v) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1 2 3 insert 함수 vector 의 5번째 위치에 값 50을 삽입한다. #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; v.insert(v.begin() + 4, 50); // vector 5번째 위치에 50을 넣는다. for (int a : v) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1 2 3 4 50 5 6 7 8 9 10 insert 함수 - iterator를 이용한 데이터 삽입#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123; vector&lt;int&gt; v; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; for (int i = 0; i &lt; 5; i++) &#123; v2.push_back(i + 20); &#125; v.insert(v.begin() + 5, v2.begin(), v2.end()); // 6번째 위치에 v2 vector 데이터를 삽입한다. for (int a : v) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1 2 3 4 5 20 21 22 23 24 6 7 8 9 10 데이터 삭제 함수erase#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123; vector&lt;int&gt; v; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; v.erase(v.begin() + 7); // 8번째 원소를 삭제한다. for (int a : v) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1 2 3 4 5 6 7 9 10 erase - iterator를 이용한 데이터 삭제#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123; vector&lt;int&gt; v; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; v.erase(v.begin() + 4, v.begin() + 6); // 5번째 원소에서 6번째 원소를 삭제한다. for (int a : v) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1 2 3 4 7 8 9 10 assign 함수 보통은 다른 자료 구조를 vector 로 변환할 때 많이 사용한다. #include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123; vector&lt;int&gt; v; set&lt;int&gt; s; for (int i = 0; i &lt; 8; i++) &#123; s.insert(i + 1); &#125; // set 에 저장된 데이터를 vector 에 저장한다. v.assign(s.begin(), s.end()); for (int a : v) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1 2 3 4 5 6 7 8","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Cpp","slug":"Programming/Cpp","permalink":"https://ckck803.github.io/categories/Programming/Cpp/"},{"name":"STL","slug":"Programming/Cpp/STL","permalink":"https://ckck803.github.io/categories/Programming/Cpp/STL/"}],"tags":[]},{"title":"JPA 연관 관계 - @MappedSuperclass","slug":"jpa/jpa-programming/mapping/mapped-superclass","date":"2021-11-12T19:31:46.000Z","updated":"2024-02-18T16:19:54.531Z","comments":true,"path":"2021/11/13/jpa/jpa-programming/mapping/mapped-superclass/","link":"","permalink":"https://ckck803.github.io/2021/11/13/jpa/jpa-programming/mapping/mapped-superclass/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 공통 Mapping 정보를 관리하기 위한 MappedSuperclass Entity 에 공통적으로 들어가는 Mapping 정보를 관리해 코드가 중복해서 작성하는 것을 방지하기 위해 사용하는 어노테이션 상속관계 Mapping 이 아니다. 부모 클래스를 상속 받는 자식 클래스에 Mapping 정보만 을 제공한다. 직접 생성해서 사용할 일이 없으므로 추상클래스(abstract) 를 사용하는 것이 좋다. MappedSuperclass 클래스를 상속 받기 위해서는 같은 @MappedSuperclass 를 사용한 클래스나 @Entity 을 이용한 클래스만 상속이 가능하다. 요구 사항 모든 Entity 에는 생성자, 생성일, 수정자, 수정일 정보가 들어가야 한다. 모든 Entity 에 공통적으로 들어가는 Mapping 정보 를 관리하기 위한 BaseEntity 클래스를 생성한다. @MappedSuperclasspublic abstract class BaseEntity &#123; private String createdBy; private LocalDateTime createdDate; private String lastModifiedBy; private LocalDateTime lastModifiedDate;&#125;","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 공통 Mapping 정보를 관리하기 위한 MappedSuperclass Entity 에 공통적으로 들어가는 Mapping 정보를 관리해 코드가 중복해서 작성하는 것을 방지하기 위해 사용하는 어노테이션 상속관계 Mapping 이 아니다. 부모 클래스를 상속 받는 자식 클래스에 Mapping 정보만 을 제공한다. 직접 생성해서 사용할 일이 없으므로 추상클래스(abstract) 를 사용하는 것이 좋다. MappedSuperclass 클래스를 상속 받기 위해서는 같은 @MappedSuperclass 를 사용한 클래스나 @Entity 을 이용한 클래스만 상속이 가능하다. 요구 사항 모든 Entity 에는 생성자, 생성일, 수정자, 수정일 정보가 들어가야 한다. 모든 Entity 에 공통적으로 들어가는 Mapping 정보 를 관리하기 위한 BaseEntity 클래스를 생성한다. @MappedSuperclasspublic abstract class BaseEntity &#123; private String createdBy; private LocalDateTime createdDate; private String lastModifiedBy; private LocalDateTime lastModifiedDate;&#125; 공통 Mapping 정보는 상속 을 통해 현재 Entity 에 적용할 수 있다. Member 테이블이 생성될 때 공통 Mapping 가 적용될 수 있도록 BaseEntity 를 상속 받는다. @Entitypublic class Member extends BaseEntity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;MEMBER_ID&quot;) private long id; @Column(name = &quot;USERNAME&quot;) private String username; @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; public void changeTeam(Team team)&#123; this.team = team; team.getMembers().add(this); &#125;&#125; Member 테이블이 생성될 때 createdBy, createdDate, lastModifiedBy, lastModifiedDate 컬럼이 생성된 것을 확인할 수 있다. Team 테이블이 생성될 때 공통 Mapping 가 적용될 수 있도록 BaseEntity 를 상속 받는다. @Entitypublic class Team extends BaseEntity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;TEAM_ID&quot;) private Long id; private String name; @OneToMany(mappedBy = &quot;team&quot;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;(); public void addMember(Member member)&#123; member.setTeam(this); members.add(member); &#125;&#125; Team 테이블이 생성될 때 createdBy, createdDate, lastModifiedBy, lastModifiedDate 컬럼이 생성된 것을 확인할 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"트랜잭션 격리수준 (Isolation Level)","slug":"database/transaction/isolation-level","date":"2021-11-12T16:15:42.000Z","updated":"2024-02-18T16:19:54.525Z","comments":true,"path":"2021/11/13/database/transaction/isolation-level/","link":"","permalink":"https://ckck803.github.io/2021/11/13/database/transaction/isolation-level/","excerpt":"목차 트랜잭션과 ACID 트랜잭션 격리수준 (Isolation Level) 트랜잭션 격리수준이란 트랜잭션 격리 수준이란 동시에 여러개의 트랜잭션 처리를 할 때 트랜잭션끼리 얼마나 고립되어 있는지를 나타낸다.여러개의 트랜잭션이 공유 자원 에 접근해 작업(CRUD) 을 할때 자원의 일관성 을 지키기 위해 트랜잭션 작업을 얼마나 고립시킬지를 나타낸다. Read Uncommited Dirty Read 문제가 발생 Read Commited Non-Repeatable Read 문제가 발생 Repeatable Head Phantom Read 문제가 발생 Serializable 격리 수준에 따른 문제 Dirty Read Non-Repeatable Read Phantom Read Read Uncommited 발생 발생 발생 Read Commited 발생하지 않음 발생 발생 Repeatable Raead 발생하지 않음 발생하지 않음 발생 Serializable 발생하지 않음 발생하지 않음 발생하지 않음 Read Uncommited 현재 트랜잭션에서 일어난 변경 사항이 Commit 이나 Rollback 되지 않아도 다른 트랜잭션에서 변경된 값을 읽을 수 있다.","text":"목차 트랜잭션과 ACID 트랜잭션 격리수준 (Isolation Level) 트랜잭션 격리수준이란 트랜잭션 격리 수준이란 동시에 여러개의 트랜잭션 처리를 할 때 트랜잭션끼리 얼마나 고립되어 있는지를 나타낸다.여러개의 트랜잭션이 공유 자원 에 접근해 작업(CRUD) 을 할때 자원의 일관성 을 지키기 위해 트랜잭션 작업을 얼마나 고립시킬지를 나타낸다. Read Uncommited Dirty Read 문제가 발생 Read Commited Non-Repeatable Read 문제가 발생 Repeatable Head Phantom Read 문제가 발생 Serializable 격리 수준에 따른 문제 Dirty Read Non-Repeatable Read Phantom Read Read Uncommited 발생 발생 발생 Read Commited 발생하지 않음 발생 발생 Repeatable Raead 발생하지 않음 발생하지 않음 발생 Serializable 발생하지 않음 발생하지 않음 발생하지 않음 Read Uncommited 현재 트랜잭션에서 일어난 변경 사항이 Commit 이나 Rollback 되지 않아도 다른 트랜잭션에서 변경된 값을 읽을 수 있다. Dirty Read 현상이 발생 Commit 이 일어나기 전에 발생한 변경사항을 다른 Transaction 에서 조회할 수 있는 현상 Read Commited 다른 트랜잭션에서 일어난 변경 사항이 Commit되지 않았으면 Undo 영역 에 저장된 데이터를 읽어온다. Dirty Read가 발생하지 않는다. Non-Repeatable Read 현상이 발생한다. 한 트랜잭션 내에서 같은 데이터를 두번 조회 했을 때 이전 데이터와 일치 하지 않는 데이터 불일치 현상 Repeatable Read 트랜잭션 ID 를 이용해 현재 트랜잭션보다 이전에 일어난 변경사항 만 조회할 수 있다.즉, 트랜잭션 내에서 조회한 데이터는 트랜잭션 종료 시점 까지 같은 데이터를 반환한다. Phantom Read 가 발생한다.- 한 트랜잭션 내에서 같은 데이터를 두번 조회 했을 때 이전에 존재하지 않았던 값이 다시 조회했을 때 나타나는 현상- 트랜잭션 도중에 데이터 삽입(Insert) 을 허용하기 때문에 발생하는 문제 REPETABLE READ 이하에서만 발생한다 Serializable 가장 높은 격리 수준, 읽기 작업에도 Lock이 걸리게 된다. 데이터를 조회할때 Shared Lock 을 획득해야만 조회할 수 있다. 데이터를 변경할때는 Exclusive Lock 을 획득해야만 변경할 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"Transaction","slug":"CS/DataBase/Transaction","permalink":"https://ckck803.github.io/categories/CS/DataBase/Transaction/"}],"tags":[]},{"title":"데이터 베이스 Lock","slug":"database/transaction/lock","date":"2021-11-12T16:15:42.000Z","updated":"2024-02-18T16:19:54.525Z","comments":true,"path":"2021/11/13/database/transaction/lock/","link":"","permalink":"https://ckck803.github.io/2021/11/13/database/transaction/lock/","excerpt":"목차 트랜잭션과 ACID 트랜잭션 격리수준 (Isolation Level) Post not found: database/transaction/isolation-lock 데이터 베이스 Lock Optimitic Lock","text":"목차 트랜잭션과 ACID 트랜잭션 격리수준 (Isolation Level) Post not found: database/transaction/isolation-lock 데이터 베이스 Lock Optimitic Lock","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"Transaction","slug":"CS/DataBase/Transaction","permalink":"https://ckck803.github.io/categories/CS/DataBase/Transaction/"}],"tags":[]},{"title":"Docker Compose - Kafka 클러스터 구성하기","slug":"docker/docker-compose/kafka-cluster","date":"2021-11-11T17:16:13.000Z","updated":"2024-02-18T16:19:54.526Z","comments":true,"path":"2021/11/12/docker/docker-compose/kafka-cluster/","link":"","permalink":"https://ckck803.github.io/2021/11/12/docker/docker-compose/kafka-cluster/","excerpt":"목차 Docker Compose - Kafka 사용하기 Docker Compose - Kafka 클러스터 구성하기 zookeeper 설정version: &quot;3.6&quot;services: zookeeper: container_name: zookeeper image: wurstmeister/zookeeper:3.4.6 volumes: - &quot;./zookeeper/data:/data&quot; - &quot;./zookeeper/logs:/datalog&quot; ports: - &quot;2181:2181&quot; Kafka 설정 KAFKA_BROKER_ID KAFKA_ZOOKEEPER_CONNECT KAFKA_ADVERTISED_HOST_NAME KAFKA_ADVERTISED_PORT KAFKA_CREATE_TOPICS KAFKA_ADVERTISED_LISTENERS KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 version: &quot;3.6&quot;... kafka1: container_name: kafka1 image: wurstmeister/kafka:2.12-2.3.0 restart: on-failure ports: - &quot;9092:9092&quot; volumes: - /var/run/docker.sock:/var/run/docker.sock environment: KAFKA_BROKER_ID: 1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: 192.168.0.2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_CREATE_TOPICS: &quot;temp_topic:1:1&quot; KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.0.2:9092 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 depends_on: - zookeeper 전체 소스 코드version: &quot;3.6&quot;services: zookeeper: container_name: zookeeper image: wurstmeister/zookeeper:3.4.6 volumes: - &quot;./zookeeper/data:/data&quot; - &quot;./zookeeper/logs:/datalog&quot; ports: - &quot;2181:2181&quot; kafka1: container_name: kafka1 image: wurstmeister/kafka:2.12-2.3.0 restart: on-failure ports: - &quot;9092:9092&quot; volumes: - /var/run/docker.sock:/var/run/docker.sock environment: KAFKA_BROKER_ID: 1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: 192.168.0.2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_CREATE_TOPICS: &quot;temp_topic:1:1&quot; KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.0.2:9092 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 depends_on: - zookeeper kafka2: container_name: kafka2 image: wurstmeister/kafka:2.12-2.3.0 restart: on-failure ports: - &quot;9093:9092&quot; volumes: - /var/run/docker.sock:/var/run/docker.sock environment: KAFKA_BROKER_ID: 2 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: 192.168.0.2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.0.2:9093 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 depends_on: - zookeeper kafka3: container_name: kafka3 image: wurstmeister/kafka:2.12-2.3.0 restart: on-failure ports: - &quot;9094:9092&quot; volumes: - /var/run/docker.sock:/var/run/docker.sock environment: KAFKA_BROKER_ID: 3 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: 192.168.0.2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.0.2:9094 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 depends_on: - zookeeper","text":"목차 Docker Compose - Kafka 사용하기 Docker Compose - Kafka 클러스터 구성하기 zookeeper 설정version: &quot;3.6&quot;services: zookeeper: container_name: zookeeper image: wurstmeister/zookeeper:3.4.6 volumes: - &quot;./zookeeper/data:/data&quot; - &quot;./zookeeper/logs:/datalog&quot; ports: - &quot;2181:2181&quot; Kafka 설정 KAFKA_BROKER_ID KAFKA_ZOOKEEPER_CONNECT KAFKA_ADVERTISED_HOST_NAME KAFKA_ADVERTISED_PORT KAFKA_CREATE_TOPICS KAFKA_ADVERTISED_LISTENERS KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 version: &quot;3.6&quot;... kafka1: container_name: kafka1 image: wurstmeister/kafka:2.12-2.3.0 restart: on-failure ports: - &quot;9092:9092&quot; volumes: - /var/run/docker.sock:/var/run/docker.sock environment: KAFKA_BROKER_ID: 1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: 192.168.0.2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_CREATE_TOPICS: &quot;temp_topic:1:1&quot; KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.0.2:9092 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 depends_on: - zookeeper 전체 소스 코드version: &quot;3.6&quot;services: zookeeper: container_name: zookeeper image: wurstmeister/zookeeper:3.4.6 volumes: - &quot;./zookeeper/data:/data&quot; - &quot;./zookeeper/logs:/datalog&quot; ports: - &quot;2181:2181&quot; kafka1: container_name: kafka1 image: wurstmeister/kafka:2.12-2.3.0 restart: on-failure ports: - &quot;9092:9092&quot; volumes: - /var/run/docker.sock:/var/run/docker.sock environment: KAFKA_BROKER_ID: 1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: 192.168.0.2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_CREATE_TOPICS: &quot;temp_topic:1:1&quot; KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.0.2:9092 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 depends_on: - zookeeper kafka2: container_name: kafka2 image: wurstmeister/kafka:2.12-2.3.0 restart: on-failure ports: - &quot;9093:9092&quot; volumes: - /var/run/docker.sock:/var/run/docker.sock environment: KAFKA_BROKER_ID: 2 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: 192.168.0.2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.0.2:9093 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 depends_on: - zookeeper kafka3: container_name: kafka3 image: wurstmeister/kafka:2.12-2.3.0 restart: on-failure ports: - &quot;9094:9092&quot; volumes: - /var/run/docker.sock:/var/run/docker.sock environment: KAFKA_BROKER_ID: 3 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_HOST_NAME: 192.168.0.2 KAFKA_ADVERTISED_PORT: 9092 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.0.2:9094 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 depends_on: - zookeeper","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Docker","slug":"Programming/Docker","permalink":"https://ckck803.github.io/categories/Programming/Docker/"},{"name":"Docker Compose","slug":"Programming/Docker/Docker-Compose","permalink":"https://ckck803.github.io/categories/Programming/Docker/Docker-Compose/"}],"tags":[]},{"title":"Docker Compose - Kafka 사용하기","slug":"docker/docker-compose/kafka-single","date":"2021-11-11T16:16:13.000Z","updated":"2024-02-18T16:19:54.526Z","comments":true,"path":"2021/11/12/docker/docker-compose/kafka-single/","link":"","permalink":"https://ckck803.github.io/2021/11/12/docker/docker-compose/kafka-single/","excerpt":"목차 Docker Compose - Kafka 사용하기 Docker Compose - Kafka 클러스터 구성하기 Zookeeper 설정version: &quot;3&quot;services: zookeeper: container_name: local-zookeeper image: wurstmeister/zookeeper ports: - 2181:2181 Kafka 설정version: &quot;3&quot;services: zookeeper: container_name: local-zookeeper image: wurstmeister/zookeeper ports: - 2181:2181 kafka: container_name: local-kafka image: wurstmeister/kafka depends_on: - zookeeper ports: - 9092:9092 environment: KAFKA_ADVERTISED_HOST_NAME: 127.0.0.1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 volumes: - /var/run/docker.sock:/var/run/docker.sock 전체 소스 코드version: &quot;3&quot;services: zookeeper: container_name: local-zookeeper image: wurstmeister/zookeeper ports: - 2181:2181 kafka: container_name: local-kafka image: wurstmeister/kafka depends_on: - zookeeper ports: - 9092:9092 environment: KAFKA_ADVERTISED_HOST_NAME: 127.0.0.1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 volumes: - /var/run/docker.sock:/var/run/docker.sock","text":"목차 Docker Compose - Kafka 사용하기 Docker Compose - Kafka 클러스터 구성하기 Zookeeper 설정version: &quot;3&quot;services: zookeeper: container_name: local-zookeeper image: wurstmeister/zookeeper ports: - 2181:2181 Kafka 설정version: &quot;3&quot;services: zookeeper: container_name: local-zookeeper image: wurstmeister/zookeeper ports: - 2181:2181 kafka: container_name: local-kafka image: wurstmeister/kafka depends_on: - zookeeper ports: - 9092:9092 environment: KAFKA_ADVERTISED_HOST_NAME: 127.0.0.1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 volumes: - /var/run/docker.sock:/var/run/docker.sock 전체 소스 코드version: &quot;3&quot;services: zookeeper: container_name: local-zookeeper image: wurstmeister/zookeeper ports: - 2181:2181 kafka: container_name: local-kafka image: wurstmeister/kafka depends_on: - zookeeper ports: - 9092:9092 environment: KAFKA_ADVERTISED_HOST_NAME: 127.0.0.1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 volumes: - /var/run/docker.sock:/var/run/docker.sock","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Docker","slug":"Programming/Docker","permalink":"https://ckck803.github.io/categories/Programming/Docker/"}],"tags":[]},{"title":"Docker - Redis 사용하기","slug":"docker/docker-redis","date":"2021-11-10T18:16:13.000Z","updated":"2024-02-18T16:19:54.526Z","comments":true,"path":"2021/11/11/docker/docker-redis/","link":"","permalink":"https://ckck803.github.io/2021/11/11/docker/docker-redis/","excerpt":"Docker - Redis 사용하기","text":"Docker - Redis 사용하기","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Docker","slug":"Programming/Docker","permalink":"https://ckck803.github.io/categories/Programming/Docker/"}],"tags":[]},{"title":"Docker - Jenkins 사용하기","slug":"docker/docker-jenkins","date":"2021-11-10T17:16:13.000Z","updated":"2024-02-18T16:19:54.526Z","comments":true,"path":"2021/11/11/docker/docker-jenkins/","link":"","permalink":"https://ckck803.github.io/2021/11/11/docker/docker-jenkins/","excerpt":"Docker - Jenkins 사용하기# lts버전으로 실행시docker run -d -p 8090:8080 -p 50000:50000 -v ~/docker/jenkins:/var/jenkins_home jenkins/jenkins:lts# jdk11버전으로 실행시docker run -d -p 8090:8080 -p 50000:50000 -v ~/docker/jenkins-jdk11:/var/jenkins_home jenkins/jenkins:jdk11# docker container Id3c29b7adb686ad8310bf474fe91406e1ab8c569568e2ef2b5d09f40525aa78ee","text":"Docker - Jenkins 사용하기# lts버전으로 실행시docker run -d -p 8090:8080 -p 50000:50000 -v ~/docker/jenkins:/var/jenkins_home jenkins/jenkins:lts# jdk11버전으로 실행시docker run -d -p 8090:8080 -p 50000:50000 -v ~/docker/jenkins-jdk11:/var/jenkins_home jenkins/jenkins:jdk11# docker container Id3c29b7adb686ad8310bf474fe91406e1ab8c569568e2ef2b5d09f40525aa78ee","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Docker","slug":"Programming/Docker","permalink":"https://ckck803.github.io/categories/Programming/Docker/"}],"tags":[]},{"title":"Docker - MySQL 사용하기","slug":"docker/docker-mysql","date":"2021-11-10T16:16:13.000Z","updated":"2024-02-18T16:19:54.526Z","comments":true,"path":"2021/11/11/docker/docker-mysql/","link":"","permalink":"https://ckck803.github.io/2021/11/11/docker/docker-mysql/","excerpt":"Docker - MySQL 사용하기docker pull mysql:8.0.17 Docker MySQL 컨테이너 생성 및 실행 MySQL 외부 볼륨으로 잡아주기 호스트의 ~&#x2F;docker&#x2F;mysql 디렉토리를 MySQL 컨테이너의 &#x2F;var&#x2F;lib&#x2F;mysql 디렉토리로 마운트 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password --name mysql -v ~/docker/mysql:/var/lib/mysql mysql --character-set-server=utf8mb4 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password --name mysql -v ~/docker/mysql:/var/lib/mysql mysql:8.0.17 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci","text":"Docker - MySQL 사용하기docker pull mysql:8.0.17 Docker MySQL 컨테이너 생성 및 실행 MySQL 외부 볼륨으로 잡아주기 호스트의 ~&#x2F;docker&#x2F;mysql 디렉토리를 MySQL 컨테이너의 &#x2F;var&#x2F;lib&#x2F;mysql 디렉토리로 마운트 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password --name mysql -v ~/docker/mysql:/var/lib/mysql mysql --character-set-server=utf8mb4 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password --name mysql -v ~/docker/mysql:/var/lib/mysql mysql:8.0.17 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Docker","slug":"Programming/Docker","permalink":"https://ckck803.github.io/categories/Programming/Docker/"}],"tags":[]},{"title":"JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인","slug":"jpa/jpa-programming/mapping/jpa-mapping-4","date":"2021-11-05T22:31:46.000Z","updated":"2024-02-18T16:19:54.530Z","comments":true,"path":"2021/11/06/jpa/jpa-programming/mapping/jpa-mapping-4/","link":"","permalink":"https://ckck803.github.io/2021/11/06/jpa/jpa-programming/mapping/jpa-mapping-4/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 양방향 연관관계의 문제점 객체에서는 각기 다른 객체에서 참조하는 객체를 업데이트 하는 방법이 두 가지가 발생한다. 양방향 연관관계의 해결 방법 객체의 두 관계중 하나를 연관관계의 주인 으로 지정해 주인만이 외래 키를 관리하게 한다.(등록, 수정)주인이 아닌 쪽은 읽기만 가능하다 양방향 연관관계 주인 정하기 Foreign Key (외래키) 가 있는 곳을 주인으로 정해라 연관관계의 주인은 mappedBy 속성을 사용할 수 없다. 연관관계 주인이 아니면 mappedBy 속성을 사용할 수 있다.","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 양방향 연관관계의 문제점 객체에서는 각기 다른 객체에서 참조하는 객체를 업데이트 하는 방법이 두 가지가 발생한다. 양방향 연관관계의 해결 방법 객체의 두 관계중 하나를 연관관계의 주인 으로 지정해 주인만이 외래 키를 관리하게 한다.(등록, 수정)주인이 아닌 쪽은 읽기만 가능하다 양방향 연관관계 주인 정하기 Foreign Key (외래키) 가 있는 곳을 주인으로 정해라 연관관계의 주인은 mappedBy 속성을 사용할 수 없다. 연관관계 주인이 아니면 mappedBy 속성을 사용할 수 있다. 연관관계 주인이 아닌 객체에 데이터 업데이트Member member = new Member();member.setUsername(&quot;member1&quot;);entityManager.persist(member);Team team = new Team();team.setName(&quot;TeamA&quot;);team.getMembers().add(member);entityManager.persist(team); MEMBER 테이블 내 TEAM_ID 값이 들어가지 않은 것을 확인할 수 있다. 연관관계 주인인 객체에 데이터 업데이트Team team = new Team();team.setName(&quot;TeamA&quot;);// team.getMembers().add(member);entityManager.persist(team);Member member = new Member();member.setUsername(&quot;member1&quot;);member.setTeam(team);entityManager.persist(member); MEMBER 테이블 내 TEAM_ID 값이 정상적으로 들어간 것을 확인할 수 있다. 양방향 연관 관계 주의양쪽에 데이터를 Setting 해 준다. 데이터가 영속성 Context 내에만 존재할 경우 연관된 데이터 조회시 정상적으로 조회하지 못하는 문제가 발생한다.순수 객체 상태 를 고려해 항상 양쪽에 값을 설정한다. Team과 Member는 영속성 Context에만 데이터가 있는 상태 Team 내 Member List에는 현재 아무 값이 없는 상태 결과적으로 데이터를 못가져오게 된다. Team team = new Team();team.setName(&quot;TeamA&quot;);em.persist(team);Member member = new Member();member.setUsername(&quot;member1&quot;);member.setTeam(team);em.persist(member);Team findTeam = em.find(Team.class, team.getId()); // 1차 캐시List&lt;Member&gt; members = findTeam.getMembers();System.out.println(&quot;==========================&quot;);for (Member m : members) &#123; System.out.println(&quot;m = &quot; + m.getUsername());&#125;System.out.println(&quot;==========================&quot;); Team team = new Team();team.setName(&quot;TeamA&quot;);em.persist(team);Member member = new Member();member.setUsername(&quot;member1&quot;);member.setTeam(team);em.persist(member);team.getMembers().add(member);Team findTeam = em.find(Team.class, team.getId()); // 1차 캐시List&lt;Member&gt; members = findTeam.getMembers();System.out.println(&quot;=====================================================================&quot;);for (Member m : members) &#123; System.out.println(&quot;m = &quot; + m.getUsername());&#125;System.out.println(&quot;=====================================================================&quot;); Flush와 Clear를 team.getMembers().add(member); 값을 넣지 않아도 데이터가 정상적으로 출력 된다. Team team = new Team();team.setName(&quot;TeamA&quot;);em.persist(team);Member member = new Member();member.setUsername(&quot;member1&quot;);member.setTeam(team);em.persist(member);em.flush();em.clear();Team findTeam = em.find(Team.class, team.getId());List&lt;Member&gt; members = findTeam.getMembers();for (Member m : members) &#123; System.out.println(&quot;m = &quot; + m.getUsername());&#125; 연관관계 편의 메서드 생성Member 에 생성public void changeTeam(Team team)&#123; this.team = team; team.getMembers().add(this);&#125; @JoinColumn 는 name 속성에 Mapping 할 외래 키를 지정한다. @Entitypublic class Member &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;MEMBER_ID&quot;) private long id; @Column(name = &quot;USERNAME&quot;) private String username; @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; public void changeTeam(Team team)&#123; this.team = team; team.getMembers().add(this); &#125;&#125; Team 에 생성public void addMember(Member member)&#123; member.setTeam(this); members.add(member);&#125; mappedBy 는 양뱡향 연관관계일때 반대쪽에 매핑되는 Entity 필드 값을 준다. @Entitypublic class Team &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;TEAM_ID&quot;) private Long id; private String name; @OneToMany(mappedBy = &quot;team&quot;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;(); public void addMember(Member member)&#123; member.setTeam(this); members.add(member); &#125;&#125; 양방향 매핑시 무한 루프를 조심하자Member에서 toString 생성시 Team 객체를 만날 경우 Team 객체의 toString을 불러온다. Team 객체내 toString은 Member 객체의 toString을 불러오면서 무한 루프가 생기게된다. Member.java @Overridepublic String toString() &#123; return &quot;Member&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, team=&quot; + team + // 문제 발생 &#x27;&#125;&#x27;;&#125; Team.java @Overridepublic String toString() &#123; return &quot;Team&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, members=&quot; + members + // 문제 발생 &#x27;&#125;&#x27;;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"JPA 연관 관계 - 양방향 연관관계","slug":"jpa/jpa-programming/mapping/jpa-mapping-3","date":"2021-11-05T20:31:46.000Z","updated":"2024-02-18T16:19:54.530Z","comments":true,"path":"2021/11/06/jpa/jpa-programming/mapping/jpa-mapping-3/","link":"","permalink":"https://ckck803.github.io/2021/11/06/jpa/jpa-programming/mapping/jpa-mapping-3/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 객체와 테이블이 관계를 맺는 차이 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로다른 단방향 관계 2개 다.테이블은 외래키 하나 로 두 테이블의 연관관계를 관리한다. 객체 : 연관관계 2개 (단방향 2개) 회원 —&gt; 팀 연관관계 1개 (단방향) 팀 —&gt; 회원 연관관계 1개 (단방향) 테이블 : 연관관계 1개 (양방향 1개) 회원 &lt;—&gt; 팀의 연관관계 1개 (양방향) 양방향 연관관계로 설계하기1:N 연관관계 Mapping OneToMany 어노테이션을 이용해 1:N 연관관계를 Mapping 한다. mappedBy 속성을 이용해 연관된 Entity 클래스 내 field 이름을 넣어준다. @Entitypublic class Team &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;TEAM_ID&quot;) private Long id; private String name; @OneToMany(mappedBy = &quot;team&quot;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;();&#125;","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 객체와 테이블이 관계를 맺는 차이 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로다른 단방향 관계 2개 다.테이블은 외래키 하나 로 두 테이블의 연관관계를 관리한다. 객체 : 연관관계 2개 (단방향 2개) 회원 —&gt; 팀 연관관계 1개 (단방향) 팀 —&gt; 회원 연관관계 1개 (단방향) 테이블 : 연관관계 1개 (양방향 1개) 회원 &lt;—&gt; 팀의 연관관계 1개 (양방향) 양방향 연관관계로 설계하기1:N 연관관계 Mapping OneToMany 어노테이션을 이용해 1:N 연관관계를 Mapping 한다. mappedBy 속성을 이용해 연관된 Entity 클래스 내 field 이름을 넣어준다. @Entitypublic class Team &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;TEAM_ID&quot;) private Long id; private String name; @OneToMany(mappedBy = &quot;team&quot;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;();&#125; N:1 연관관계 Mapping ManyToOne 어노테이션과 JoinColumn 어노테이션을 이용해 N:1 연관관계를 Mapping 한다. @Entitypublic class Member &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;MEMBER_ID&quot;) private long id; @Column(name = &quot;USERNAME&quot;) private String username; @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team;&#125; JoinColumn 어노테이션을 이용한 외래키 관계 명시하기 Forign Key(외래 키) 생성시 JoinColumn 을 이용해 연관관계를 명시할 경우Forign Key(외래 키) 기본 값은 필드명 + _ + 참조하는 테이블의 컬럼명 으로 생성된다. @Entitypublic class Member &#123; @Id private long id; private String username; @ManyToOne @JoinColumn private Team team; // Team 객체를 Member 객체 내 Field 값으로 관리&#125; 외래키 생성시 JoinColumn 에 name 속성 을 이용할 경우외래키는 name 속성에 명시된 값으로 생성되는 것을 확인할 수 있다. @Entitypublic class Member &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;MEMBER_ID&quot;) private long id; @Column(name = &quot;USERNAME&quot;) private String username; @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team;&#125; Mapping된 데이터 가져오기Team team = new Team();team.setName(&quot;TeamA&quot;);entityManager.persist(team);Member member = new Member();member.setUsername(&quot;member1&quot;);member.setTeam(team);entityManager.persist(member);entityManager.flush();entityManager.clear();Member findMember = entityManager.find(Member.class, member.getId()); // Member가 속한 Team 정보를 가져온다.List&lt;Member&gt; members = findMember.getTeam().getMembers(); // Team에 속한 Member 정보를 가져온다.for (Member m : members) &#123; System.out.println(&quot;m = &quot; + m.getUsername());&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"JPA 연관 관계 - 객체 관계 모델링하기","slug":"jpa/jpa-programming/mapping/jpa-mapping-1","date":"2021-11-04T20:31:46.000Z","updated":"2024-02-18T16:19:54.530Z","comments":true,"path":"2021/11/05/jpa/jpa-programming/mapping/jpa-mapping-1/","link":"","permalink":"https://ckck803.github.io/2021/11/05/jpa/jpa-programming/mapping/jpa-mapping-1/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 외래키를 객체 내 Field 값 으로 모델링 @Entitypublic class Team &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;TEAM_ID&quot;) private Long id; @Column private String name;&#125; @Entitypublic class Member &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;MEMBER_ID&quot;) private long id; @Column(name = &quot;USERNAME&quot;) private String username; @Column(name = &quot;TEAM_ID&quot;) private Long teamId; // 외래키를 Field 값으로 갖는다.&#125; Member 가 소속된 Team 정보 가져오기 Member 가 소속된 Team 정보를 가져오기 위해서는 Member Id를 이용해 해당 Member 객체를 가져와 저장된 Team Id를 가져온 후 해당 Team Id를 이용해 Member가 소속된 Team 을 조회해야 한다. Team team = new Team();team.setName(&quot;TeamA&quot;);entityManager.persist(team);Member member = new Member();member.setUsername(&quot;member1&quot;);member.setTeamId(team.getId());entityManager.persist(member);Member findMember = entityManager.find(Member.class, member.getId());Long findTeamId = findMember.getTeamId();Team findTeam = entityManager.find(Team.class, findTeamId); 객체 지향 스럽지 못한 모델링","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 외래키를 객체 내 Field 값 으로 모델링 @Entitypublic class Team &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;TEAM_ID&quot;) private Long id; @Column private String name;&#125; @Entitypublic class Member &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;MEMBER_ID&quot;) private long id; @Column(name = &quot;USERNAME&quot;) private String username; @Column(name = &quot;TEAM_ID&quot;) private Long teamId; // 외래키를 Field 값으로 갖는다.&#125; Member 가 소속된 Team 정보 가져오기 Member 가 소속된 Team 정보를 가져오기 위해서는 Member Id를 이용해 해당 Member 객체를 가져와 저장된 Team Id를 가져온 후 해당 Team Id를 이용해 Member가 소속된 Team 을 조회해야 한다. Team team = new Team();team.setName(&quot;TeamA&quot;);entityManager.persist(team);Member member = new Member();member.setUsername(&quot;member1&quot;);member.setTeamId(team.getId());entityManager.persist(member);Member findMember = entityManager.find(Member.class, member.getId());Long findTeamId = findMember.getTeamId();Team findTeam = entityManager.find(Team.class, findTeamId); 객체 지향 스럽지 못한 모델링 위와 같이 모델링한 경우 한 객체 내에서 관련된 데이터를 가져오는 게 아닌 서로 다른 두개의 객체를 이용해 정보를 가져오기 때문에 객체 입장에서는 객체 지향 스럽지 못한 모델링이 된다.뭔가 연관돼 있는 듯 하지만 결국에 서로 다른 두개의 객체 를 가져온 느낌이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"JPA 연관 관계 - 객체 지향 스럽게 모델링 하기","slug":"jpa/jpa-programming/mapping/jpa-mapping-2","date":"2021-11-04T20:31:46.000Z","updated":"2024-02-18T16:19:54.530Z","comments":true,"path":"2021/11/05/jpa/jpa-programming/mapping/jpa-mapping-2/","link":"","permalink":"https://ckck803.github.io/2021/11/05/jpa/jpa-programming/mapping/jpa-mapping-2/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 객체 지향 스럽게 모델링 하기 객체는 참조를 이용해 다른 객체를 가져올 수 있다. 한 객체내에 관련된 객체 정보를 가질 수 있도록 모델링한다. Member 에서 Team 정보를 가져올 때 Member 객체 내 참조 를 통해 정보를 가져올 수 있다. N:1 연관 관계를 명시할 때는 @ManyToOne 과 @JoinColumn 을 이용해 관계를 나타낸다. @Entitypublic class Member &#123; @Id private long id; private String username; @ManyToOne @JoinColumn private Team team; // Member 객체 내에서 관련된 Team 객체를 관리할 수 있도록 변경&#125; Member 가 소속된 Team 정보 가져오기","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 객체 지향 스럽게 모델링 하기 객체는 참조를 이용해 다른 객체를 가져올 수 있다. 한 객체내에 관련된 객체 정보를 가질 수 있도록 모델링한다. Member 에서 Team 정보를 가져올 때 Member 객체 내 참조 를 통해 정보를 가져올 수 있다. N:1 연관 관계를 명시할 때는 @ManyToOne 과 @JoinColumn 을 이용해 관계를 나타낸다. @Entitypublic class Member &#123; @Id private long id; private String username; @ManyToOne @JoinColumn private Team team; // Member 객체 내에서 관련된 Team 객체를 관리할 수 있도록 변경&#125; Member 가 소속된 Team 정보 가져오기처음에 설계된 객체와는 다르게 Member 객체내에서 관련된 Team 정보를 가져올 수 있다. Team team = new Team();team.setName(&quot;TeamA&quot;);entityManager.persist(team);Member member = new Member();member.setUsername(&quot;member1&quot;);member.setTeam(team);entityManager.persist(team);// Member 객체내에서 연관된 Team 정보를 바로 조회한다.Member findMember = entityManager.find(Member.class, member.getId());Team findTeam = findMember.getTeam();entityManager.persist(member); 객체와 테이블간의 패러다임 차이 테이블의 경우 외래키를 이용해 양방향 조회가 가능하다.하지만, 객체에서 관계는 단방향으로만 관계를 맺기 때문에 반대 방향으로의 조회는 불가능 하다.반대 방향으로 조회가 가능하게 하려면 연관된 객체에서도 정보를 관리하도록 설계해야 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"JPA 연관 관계","slug":"jpa/jpa-programming/mapping/jpa-mapping","date":"2021-11-04T19:31:46.000Z","updated":"2024-02-18T16:19:54.530Z","comments":true,"path":"2021/11/05/jpa/jpa-programming/mapping/jpa-mapping/","link":"","permalink":"https://ckck803.github.io/2021/11/05/jpa/jpa-programming/mapping/jpa-mapping/","excerpt":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 JPA 연관 관계 테이블과 객체 간 패러타임 차이로 인해 생기는 문제가 있다. 그 중 대표적인게 테이블 연관관계 를 객체로 풀어내는 것테이블간의 연관관계를 객체 연관관계로 풀어내기 위해서는 아래 3가지 조건을 잘 이해해야 한다. 방향 테이블 연관관계는 양방향 객체의 연관관계는 단방향으로만 존재한다. 객체의 양방향 관계는 단방향 관계 2개를 이용해 만들어준다. 다중성 One To One(일대일) 1:1 One To Many(일대다) 1:N Many To One(다대일) N:1 Many To Many(다대다) N:M 연관관계의 주인 테이블 연관관계를 객체 양방향 연관관계로 만들기 위해서는 연관관계 주인 을 정해야 한다. 객체의 두 관계중 하나를 연관관계의 주인으로 지정해 주인만이 외래 키 를 관리하게 한다. 연관관계 주인은 외래키를 이용해 (등록, 수정) 등이 가능하지만 주인이 아닌 쪽은 읽기 만 가능하다 JoinColumn 어노테이션 외래키 를 매핑할 때 사용하는 어노테이션 속성 기능 기본 값 name 매필할 외래키 이름을 명시한다. 필드명 + _ + 참조하는 테이블 기본키 컬럼명 referencedColumnName 외래 키가 참조하는 대상 테이블 컬럼명 참조하는 테이블의 기본키 컬럼명 foreignKey 외래키 제약 조건을 직접 지정할 수 있다. unique, nullable, insertable, updatable, columnDefinition, table @Column 속성과 같다.","text":"목차 JPA 연관 관계 - 고아 객체 JPA 연관 관계 - 즉시로딩과 지연로딩 JPA 연관 관계 - 프록시 객체 JPA 연관 관계 - @MappedSuperclass JPA 연관 관계 - 상속 관계 Mapping JPA 연관 관계 - 영속성 전이 Cascade JPA 연관 관계 - 양방향 연관관계와 연관과계의 주인 JPA 연관 관계 - 양방향 연관관계 JPA 연관 관계 - 객체 지향 스럽게 모델링 하기 JPA 연관 관계 - 객체 관계 모델링하기 JPA 연관 관계 JPA 연관 관계 테이블과 객체 간 패러타임 차이로 인해 생기는 문제가 있다. 그 중 대표적인게 테이블 연관관계 를 객체로 풀어내는 것테이블간의 연관관계를 객체 연관관계로 풀어내기 위해서는 아래 3가지 조건을 잘 이해해야 한다. 방향 테이블 연관관계는 양방향 객체의 연관관계는 단방향으로만 존재한다. 객체의 양방향 관계는 단방향 관계 2개를 이용해 만들어준다. 다중성 One To One(일대일) 1:1 One To Many(일대다) 1:N Many To One(다대일) N:1 Many To Many(다대다) N:M 연관관계의 주인 테이블 연관관계를 객체 양방향 연관관계로 만들기 위해서는 연관관계 주인 을 정해야 한다. 객체의 두 관계중 하나를 연관관계의 주인으로 지정해 주인만이 외래 키 를 관리하게 한다. 연관관계 주인은 외래키를 이용해 (등록, 수정) 등이 가능하지만 주인이 아닌 쪽은 읽기 만 가능하다 JoinColumn 어노테이션 외래키 를 매핑할 때 사용하는 어노테이션 속성 기능 기본 값 name 매필할 외래키 이름을 명시한다. 필드명 + _ + 참조하는 테이블 기본키 컬럼명 referencedColumnName 외래 키가 참조하는 대상 테이블 컬럼명 참조하는 테이블의 기본키 컬럼명 foreignKey 외래키 제약 조건을 직접 지정할 수 있다. unique, nullable, insertable, updatable, columnDefinition, table @Column 속성과 같다. ManyToOne 어노테이션 N:1 관계를 Mapping 하기 위한 어노테이션 속성 기능 기본 값 optional true 는 해당 객체에 null 값이 들어갈 수 있다는 의미, false 는 해당 객체가 항상 있어야 함을 의미한다. 기본값은 true fetch Fetch 전략을 설정한다. @ManyToOne(fetch &#x3D; FetchType.EAGER) cascade targetEntity 연관된 엔티티의 타입 정보를 설정한다. OneToMany 어노테이션 1:N 관계를 Mapping 하기 위한 어노테이션 속성 기능 기본 값 mappedBy 양방향 연관관계 mapping 시 연관관계 주인인 Entity 필드를 명시한다 fetch Fetch 전략을 설정한다. @OneToMany(fetch &#x3D; FetchType.LAZY) cascade targetEntity 연관된 엔티티의 타입 정보를 설정한다. orphanRemoval","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"}],"tags":[]},{"title":"Spring Boot - WebMvcConfigurer","slug":"spring/spring-framework/configuration/springboot-WebMvcConfigurer","date":"2021-11-03T23:09:05.000Z","updated":"2024-02-26T15:53:09.750Z","comments":true,"path":"2021/11/04/spring/spring-framework/configuration/springboot-WebMvcConfigurer/","link":"","permalink":"https://ckck803.github.io/2021/11/04/spring/spring-framework/configuration/springboot-WebMvcConfigurer/","excerpt":"Matrix Variable 설정 참고 https://www.baeldung.com/spring-mvc-matrix-variables WebMvcConfigurer Spring MVC 설정을 추가, 변경하기 위해 사용하는 인터페이스WebMvcConfigurer 인터페이스는 CORS, Interceptor, ViewResolver, MessageConverter 등 여러가지 설정을 변경, 추가할 수 있게 도와준다. WebMvcConfigurer 인터페이스내 메소드들은 default 로 선어돼 있어 필요한 것만 구현하면 된다. add~: 기본 설정이 없는 Bean에 대하여 새로운 설정 Bean을 추가함 configure~: 기존 설정 대신 새롭게 정의한 설정 Bean을 사용한다. (set 메소드) extend~: 기존 설정에 새롭게 정의한 설정 Bean을 추가한다. (add 메소드) WebMvcConfigurer.java public interface WebMvcConfigurer &#123; default void configurePathMatch(PathMatchConfigurer configurer) &#123;&#125; default void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;&#125; default void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123;&#125; default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;&#125; default void addFormatters(FormatterRegistry registry) &#123;&#125; default void addInterceptors(InterceptorRegistry registry) &#123;&#125; default void addResourceHandlers(ResourceHandlerRegistry registry) &#123;&#125; default void addCorsMappings(CorsRegistry registry) &#123;&#125; default void addViewControllers(ViewControllerRegistry registry) &#123;&#125; default void configureViewResolvers(ViewResolverRegistry registry) &#123;&#125; default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;&#125; default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123;&#125; default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;&#125; default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;&#125; default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;&#125; default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;&#125; @Nullable default Validator getValidator() &#123;return null;&#125; @Nullable default MessageCodesResolver getMessageCodesResolver() &#123;return null;&#125;&#125; CORS 설정Spring Boot 에서는 기본적으로 CORS에 대한 설정이 없기 때문에 CORS 를 사용하기 위해서는 WebMvcConfigurer 내 addCorsMappings 메소드를 이용해 설정해줘야 한다.","text":"Matrix Variable 설정 참고 https://www.baeldung.com/spring-mvc-matrix-variables WebMvcConfigurer Spring MVC 설정을 추가, 변경하기 위해 사용하는 인터페이스WebMvcConfigurer 인터페이스는 CORS, Interceptor, ViewResolver, MessageConverter 등 여러가지 설정을 변경, 추가할 수 있게 도와준다. WebMvcConfigurer 인터페이스내 메소드들은 default 로 선어돼 있어 필요한 것만 구현하면 된다. add~: 기본 설정이 없는 Bean에 대하여 새로운 설정 Bean을 추가함 configure~: 기존 설정 대신 새롭게 정의한 설정 Bean을 사용한다. (set 메소드) extend~: 기존 설정에 새롭게 정의한 설정 Bean을 추가한다. (add 메소드) WebMvcConfigurer.java public interface WebMvcConfigurer &#123; default void configurePathMatch(PathMatchConfigurer configurer) &#123;&#125; default void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;&#125; default void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123;&#125; default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;&#125; default void addFormatters(FormatterRegistry registry) &#123;&#125; default void addInterceptors(InterceptorRegistry registry) &#123;&#125; default void addResourceHandlers(ResourceHandlerRegistry registry) &#123;&#125; default void addCorsMappings(CorsRegistry registry) &#123;&#125; default void addViewControllers(ViewControllerRegistry registry) &#123;&#125; default void configureViewResolvers(ViewResolverRegistry registry) &#123;&#125; default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;&#125; default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123;&#125; default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;&#125; default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;&#125; default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;&#125; default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;&#125; @Nullable default Validator getValidator() &#123;return null;&#125; @Nullable default MessageCodesResolver getMessageCodesResolver() &#123;return null;&#125;&#125; CORS 설정Spring Boot 에서는 기본적으로 CORS에 대한 설정이 없기 때문에 CORS 를 사용하기 위해서는 WebMvcConfigurer 내 addCorsMappings 메소드를 이용해 설정해줘야 한다. @Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;);&#125; Matrix Variable 사용 설정Spring Boot 에서 매트릭 형태의 변수를 사용하기 위해서 기존에 true인 removeSemicolonContent 설정을 false로 변경해야 한다. WebMvcConfigurer 내 configurePathMatch 메소드를 이용해 기존 설정을 변경한다. @Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; UrlPathHelper urlPathHelper = new UrlPathHelper(); urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"}],"tags":[]},{"title":"운영체제 - Inter Process Communication(프로세스간의 통신)","slug":"computer-science/os/deadlock","date":"2021-11-03T21:16:13.000Z","updated":"2024-02-18T16:19:54.520Z","comments":true,"path":"2021/11/04/computer-science/os/deadlock/","link":"","permalink":"https://ckck803.github.io/2021/11/04/computer-science/os/deadlock/","excerpt":"상호 배제(Mutual Exclusion) Busy Waiting Sleep and WakeUp Semaphore(세마포어) Mutex(뮤텍스) Monitor Message Passing Barriers Busy Waiting Busy Waiting 은 loop문 을 이용해 공유 자원을 사용할 수 있는지 계속 확인하는 방법이다. cpu자원을 계속해서 낭비하기 때문에 무조건 적으로 피해야 한다. 기다리는 시간이 매우 작을 때만 사용하는 것이 좋다. Semaphore(세마포어) 공유된 자원의 데이터에 한번에 여러 프로세스가 접근하지 못하게 하는 알고리즘 공유자원에 따라 몇개의 프로세스를 접근시킬지에 따라서 이진 세마포어 와 계수형 세마포어 로 나뉘게 된다","text":"상호 배제(Mutual Exclusion) Busy Waiting Sleep and WakeUp Semaphore(세마포어) Mutex(뮤텍스) Monitor Message Passing Barriers Busy Waiting Busy Waiting 은 loop문 을 이용해 공유 자원을 사용할 수 있는지 계속 확인하는 방법이다. cpu자원을 계속해서 낭비하기 때문에 무조건 적으로 피해야 한다. 기다리는 시간이 매우 작을 때만 사용하는 것이 좋다. Semaphore(세마포어) 공유된 자원의 데이터에 한번에 여러 프로세스가 접근하지 못하게 하는 알고리즘 공유자원에 따라 몇개의 프로세스를 접근시킬지에 따라서 이진 세마포어 와 계수형 세마포어 로 나뉘게 된다 이진 세마포어(binary semaphore) 계수형 세마포어(counting semaphore) 뮤텍스 공유된 자원의 데이터에 한번에 여러 쓰레드가 접근하지 못하게 하는 알고리즘 Locking 매커니즘을 사용 모니터 주로 고급 언어에서 이 기능을 지원한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Process","slug":"CS/Process","permalink":"https://ckck803.github.io/categories/CS/Process/"}],"tags":[]},{"title":"Inter Process Communication(프로세스간의 통신)","slug":"computer-science/os/process/ipc","date":"2021-11-03T21:16:13.000Z","updated":"2024-03-03T05:21:21.573Z","comments":true,"path":"2021/11/04/computer-science/os/process/ipc/","link":"","permalink":"https://ckck803.github.io/2021/11/04/computer-science/os/process/ipc/","excerpt":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) IPC(프로세스간의 통신) 란? 프로세스간의 데이터 및 정보를 주고 받기 위한 메커니즘kernel 에서 IPC를 위한 도구를 제공하며, System call 형태로 프로세스에게 제공이 된다. 왜 IPC가 필요한가? 각각의 프로세스는 독립된 실행 객체이기 때문에 서로간의 통신이 어렵다. 그래서 kenerl에서 프로세스간의 통신을 위한 IPC을 제공하는 것이다. 공유 메모리 (Shared Memory)","text":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) IPC(프로세스간의 통신) 란? 프로세스간의 데이터 및 정보를 주고 받기 위한 메커니즘kernel 에서 IPC를 위한 도구를 제공하며, System call 형태로 프로세스에게 제공이 된다. 왜 IPC가 필요한가? 각각의 프로세스는 독립된 실행 객체이기 때문에 서로간의 통신이 어렵다. 그래서 kenerl에서 프로세스간의 통신을 위한 IPC을 제공하는 것이다. 공유 메모리 (Shared Memory) 이 공간에는 데이터가 어떤 형식인지, 어떤 위치에 저장되는지에 대해 운영체제가 관여하지 않는다. 장점 빠르다. 단점 Producer - Consumer 문제가 발생한다. 메시지 전달 (Message Passing) 커널을 경유해 메시지를 주고 받는다. 커널에서 하는 역할은 메시지들을 버퍼해주는 역할을 한다. 장점구현하기가 쉽다. 단점메시지를 전달하기 위해서는 커널을 거쳐야하기 때문에 속도가 느리다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"tags":[]},{"title":"프로세스 동기화","slug":"computer-science/os/process/syncronize","date":"2021-11-03T19:16:13.000Z","updated":"2024-03-03T05:21:39.899Z","comments":true,"path":"2021/11/04/computer-science/os/process/syncronize/","link":"","permalink":"https://ckck803.github.io/2021/11/04/computer-science/os/process/syncronize/","excerpt":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 프로세스 동기화의 목적 공유자원에 접근하는 여러 프로세스들이 치리순서에 상관없이 같은 결과를 얻을 수 있음을 보장하기 위해 도입된 개념, 이를 통해 공유되는 데이터의 일관성을 보장한다.쉽게 말해, 하나의 프로세스가 공유자원을 사용하고 있을 때, 다른 프로세스가 공유자원을 사용허지 못하도록 하는 것이다. Race Condition(경쟁상태) 공유자원에 여러개의 프로세스가 접근할 때 방생한다. 여러 프로세스가 공유데이터에 동시에 접근할 때 실행순서 에 따라서 실행 결과가 달라지는 현상이다. Critical Regions(임계 영역) 프로세스의 코드 부분에서 공유 자원에 들어가기 위한 코드부분을 임계영역(Criticla Regions) 이라고 부른다.프로세스 동기화 를 위해 임계 영역 내 코드는 공유 자원의 독점이 보장 돼야 한다.","text":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 프로세스 동기화의 목적 공유자원에 접근하는 여러 프로세스들이 치리순서에 상관없이 같은 결과를 얻을 수 있음을 보장하기 위해 도입된 개념, 이를 통해 공유되는 데이터의 일관성을 보장한다.쉽게 말해, 하나의 프로세스가 공유자원을 사용하고 있을 때, 다른 프로세스가 공유자원을 사용허지 못하도록 하는 것이다. Race Condition(경쟁상태) 공유자원에 여러개의 프로세스가 접근할 때 방생한다. 여러 프로세스가 공유데이터에 동시에 접근할 때 실행순서 에 따라서 실행 결과가 달라지는 현상이다. Critical Regions(임계 영역) 프로세스의 코드 부분에서 공유 자원에 들어가기 위한 코드부분을 임계영역(Criticla Regions) 이라고 부른다.프로세스 동기화 를 위해 임계 영역 내 코드는 공유 자원의 독점이 보장 돼야 한다. 교착 상태 교착 상태는 상호배제, 점유대기, 비선점, 순환대기 이 4가지 조건을 동시에 만족하면, 교착 상태에 빠졌다고 한다. 프로세스로부터 자원을 빼앗지 못하는 비선점 상황 한 자원에 여러 프로세스가 동시에 접근하지 못하는 상호배제 상태 자원1을 사용하는 프로세스A가 프로세스B가 사용하는 자원2를 요청할 경우 자원을 할당 받을 때까지 자원1을 가진 상태로 대기에 들어가는 점유 대기 상태가 된다. 이 때 프로세스B 또한 프로세스A가 사용하는 자원1을 요청하게 되면 프로세스 B역시 점유 대기 상태로 들어가는데 결국, 서로 상대방의 자원을 요청하는 사이클이 발생하는 순환대기 상태를 보이게된다 임계 구역 문제의 해결 조건 상호 배제 (Mutual Exclusion) : 어떤 프로세스(또는 스레드)가 임계 구역에서 작업 중일 때, 다른 프로세스는 임계 구역으로 접근할 수 없다. 진행 (Progress) : 임계 구역에서 작업 중인 프로세스가 없다면, 임계 구역으로 진입하려는 프로세스 중 하나를 적절히 선택하여 임계 구역에 진입할 수 있게 해야 한다. 유한 대기 (Bounded Waiting) : 다른 프로세스의 기아(Starvation)을 방지하기 위해, 임계 구역에 한 번 접근했던 프로세스는 다시 임계 구역에 들어갈 때 제한을 두어야 한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"tags":[]},{"title":"쓰레드","slug":"computer-science/os/thread/thread","date":"2021-11-03T18:16:13.000Z","updated":"2024-03-03T05:21:44.866Z","comments":true,"path":"2021/11/04/computer-science/os/thread/thread/","link":"","permalink":"https://ckck803.github.io/2021/11/04/computer-science/os/thread/thread/","excerpt":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) Thread 란? CPU에서 실행되는 실행 단위 한 프로세스 내에 여러개의 쓰레드가 존재할 수 있다. 같은 프로세스 환경에서 여러개의 쓰래드가 동일하게 발생할 수 있다.(멀티 쓰레드) a) 하나의 프로세스에 하나의 쓰레드가 존재하는 경우 각각의 프로세스는 독립적으로 움직인다. b) 하나의 프로세스내에 여러가지 쓰레드가 존재하는 경우(multi thread) 쓰레드는 결국 프로세스내의 수행 단위이기 때문에 프로세스단의 Address Space들을 공유한다. 대신, 각각의 쓰레드마다 PC(Program Counter), register, stack을 갖는다. 각각의 쓰레드는 하나의 프로세스를 수행하기 위해 상호 협력적인 관계를 갖는다. 쓰레드와 관련된 Procedures","text":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) Thread 란? CPU에서 실행되는 실행 단위 한 프로세스 내에 여러개의 쓰레드가 존재할 수 있다. 같은 프로세스 환경에서 여러개의 쓰래드가 동일하게 발생할 수 있다.(멀티 쓰레드) a) 하나의 프로세스에 하나의 쓰레드가 존재하는 경우 각각의 프로세스는 독립적으로 움직인다. b) 하나의 프로세스내에 여러가지 쓰레드가 존재하는 경우(multi thread) 쓰레드는 결국 프로세스내의 수행 단위이기 때문에 프로세스단의 Address Space들을 공유한다. 대신, 각각의 쓰레드마다 PC(Program Counter), register, stack을 갖는다. 각각의 쓰레드는 하나의 프로세스를 수행하기 위해 상호 협력적인 관계를 갖는다. 쓰레드와 관련된 Procedures thread_create(새로운 쓰레드를 생성) therad_exit thread_wait thread_yield(thread에만 있는 개념) 쓰레드를 사용하는 이유 많은 앱에서 한번에 여러가지 일을 수행하는 경우 쓰레드가 프로세스보다는 생성과 소멸시키는게 더 쉬워서 performance에 대한 이점을 얻을 수 있다. multiple CPU환경에서는 진짜로 병렬을 구현할 수 있다. 쓰레드를 구현하는 방법쓰레드는 User Space에서 그리고 Kernel에서 구현을 할 수 있다. User Space에서 쓰레드를 구현할 경우 User Level Thread Kernel 영역에서 쓰레드를 구현할 경우 Kernel Level Thread라 부른다. User Level Thread User Level Thread의 경우 Kernel은 Thread Table을 가지고 있지 못하므로 thread에 대한 정보는 모른다. 즉, OS가 Thread를 지원하지 않는다는 의미이다. Process에 blocking System Call이 발생할 경우 Process내부의 모든 프로세스도 block된다. Kernel Level Thread User Level Thread와는 달리 Kernel영역에 Thread Table이 추가됨을 확인 할 수 있다. 때문에 OS가 Thread를 지원한다. kernel이 Clock Interrupt를 사용해 Scheduling이 가능하다. Hybrid Implementations User Level Thread와 Kernel Level Threa를 합친 방법이다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"tags":[]},{"title":"프로세스 스케줄링 알고리즘","slug":"computer-science/os/process/scheduling-algorithm","date":"2021-11-03T17:16:13.000Z","updated":"2024-03-03T05:21:31.392Z","comments":true,"path":"2021/11/04/computer-science/os/process/scheduling-algorithm/","link":"","permalink":"https://ckck803.github.io/2021/11/04/computer-science/os/process/scheduling-algorithm/","excerpt":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 프로세스 스케줄링 알고리즘 프로세스 스케줄링이란? 이름에서 알 수 있듯이 프로세스 실행 순서 를 정해주는 것을 의미한다. 프로세스 실행 순서는 자원(CPU, Memory) 를 할당 받는 순서에 따라 실행된다. 프로세스 스케줄링의 목적은 Cpu나 Memory 같은 한정된 자원을 효율적으로 사용해 동일한 시간에 더 높은 처리 능력 을 갖기 위함이다. 스케줄링 알고리즘은 크게 비 선점 스케줄링 과 선점 스케줄링 으로 나뉜다. 비 선점 스케줄링 실행 중인 프로세스로 부터 CPU 자원 을 뺏어 올 수 없다. 한 프로세스에 CPU가 할당 되면 해당 작업이 끝나거나 대기상태로 전활될 때까지 CPU자원을 계속해서 차지한다. 비 신점 스케줄링으로는 FCFS, SJF, HRN 방식이 있다. FCFS(First Come, First Served) - 들어온 순서","text":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 프로세스 스케줄링 알고리즘 프로세스 스케줄링이란? 이름에서 알 수 있듯이 프로세스 실행 순서 를 정해주는 것을 의미한다. 프로세스 실행 순서는 자원(CPU, Memory) 를 할당 받는 순서에 따라 실행된다. 프로세스 스케줄링의 목적은 Cpu나 Memory 같은 한정된 자원을 효율적으로 사용해 동일한 시간에 더 높은 처리 능력 을 갖기 위함이다. 스케줄링 알고리즘은 크게 비 선점 스케줄링 과 선점 스케줄링 으로 나뉜다. 비 선점 스케줄링 실행 중인 프로세스로 부터 CPU 자원 을 뺏어 올 수 없다. 한 프로세스에 CPU가 할당 되면 해당 작업이 끝나거나 대기상태로 전활될 때까지 CPU자원을 계속해서 차지한다. 비 신점 스케줄링으로는 FCFS, SJF, HRN 방식이 있다. FCFS(First Come, First Served) - 들어온 순서 Ready Queue 에 들어온 순서대로 CPU자원을 할당해주는 방식이다. 구현이 엄청 단순하고 처리 순서가 확실해 확실한 작업 처리를 보장 받을 수 있다는 장점이 있지만 Convoy Effect 가 생길 수 있다는 단점이 있다. Convoy Effect : 긴 작업시간을 요구하는 프로세스 때문에 간단히 끝낼 프로세스가 자원을 할당 받지 못하는 상황이다. SJF(Shortest Job First) - 처리시간이 짧은 순서 Ready Queue 에서 처러시간이 짧은 Job을 우선적으로 처리해주는 알고리즘이다. Ready Qeueu에 있는 프로세스들을 작업시간을 기준으로 우선순위를 정한다.(우선순위 큐 사용) 작업시간이 가장 짧은 프로세스가 자원을 할당 받는 형식으로 작업을 한다. Average Waiting Time이 줄어든다는 장점이 있지만, Starvation 이 생길 수 있는 단점이 있다. Starvation : 작업시간이 길어 메모리상에 계속 프로세스가 존재하는 상태, 영구적으로 자원을 할당받지 못하고 갇혀 있을 수 있다.Aging : 들어온 시간 으로 우선순위를 메기는 방식, 오래 남아있을 수록 우선순위가 높아져 오래 남아 있는 프로세스들도 자원을 할당받을 수 있다. HRN(Hightest Response ratio Next) 스케줄링 SJF의 단점을 보완한 알고리즘, 처리시간 과 대기시간 을 모두 고려해 우선순위를 정한다. 처리시간 과 대기시간 을 고려한 공식을 적용한다. (대기시간 + 처리시간) &#x2F; 처리시간 대기시간이 길어지면 길어질 수록 높은 우선순위를 가질 수 있다. 선점 스케줄링 실행 중인 프로세스로부터 CPU 자원 을 뺏어 올 수 있다. 작업중인 프로세스를 중지시키고 CPU자원을 차지할 수 있도록 하는 방법이다. 선점 스케줄링 방식으로는 RR, SRT, MLQ 방식이 있다 RR(Round Robin) 스케줄링 FCFS알고리즘을 선점 스케줄링 형식으로 바꾼 버전이다. 보통 시분할 시스템 에서 사용이된다. 할당되는 시간이 커지면 커질 수록 FCFS알고리즘과 비슷해진다. SRT(Shortest Temainint Time) SJF알고리즘을 선점 스케줄링 형식으로 바꾼 버전 MLQ(Multi Level Queue : 다단계 큐) 작업들을 여러 종류의 Ready queue로 구분하여 스케줄링하는 기법 MFQ(Multi Level Feedback Qeueu : 다단계 피드백 큐) MLQ에서 생길 수 있는 Starvation을 보완한 스케줄링 기법. 우선숨위가 가장 낮은 큐는 FCFS 또는 RR을 사용하고 나머지는 모두 RR스케줄링을 사용한다. 우선순위가 높은 큐일수록 짧은 Time Slice를 주고 해당 Time Slice내에 못 끝내게 될 경우 우선순위가 한단계 낮은 큐로 보내진다. 반대로 일정시간동안 실행되지 못하고 남아있는 프로세스의 경우 우선순위가 한단계 높은 큐로 보내준다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"tags":[]},{"title":"프로세스 상태와 스케줄러","slug":"computer-science/os/process/scheduling","date":"2021-11-03T16:16:13.000Z","updated":"2024-03-03T05:21:34.701Z","comments":true,"path":"2021/11/04/computer-science/os/process/scheduling/","link":"","permalink":"https://ckck803.github.io/2021/11/04/computer-science/os/process/scheduling/","excerpt":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 운영체제 - 프로세스 상태와 스케줄러 시스템이 실행하고자 하는 프로세스에 CPU를 할당하는 과정 프로세스의 상태 프로세스는 Run, Ready, Wait라는 3가지 상태를 갖는다. Run CPU가 해당 프로세스를 수행하고 있는 상태 Ready 다른 프로세스를 실행하기위해 잠시 멈춘상태(실행가능한 상태) Wait 실행 불가능한 상태, 디스크를 읽거나 문자를 입력하는 등의 외부 이벤트가 발생할 때까지 멈춰있는 상태이다. Running Process가 어떤 값을 입력 받기 전까지는 Wait 상태가 된다. 스케줄러가 다른 프로세스를 선택한 경우 Running 프로세스는 Ready 상태가 된다. 스케줄러에의해 Ready 상태의 프로세스를 선택한 경우 다시 Running 상태가 된다. 값을 입력받을 경우 Wait 된 프로세스는 Ready 상태가 된다. 스케줄링이란","text":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 운영체제 - 프로세스 상태와 스케줄러 시스템이 실행하고자 하는 프로세스에 CPU를 할당하는 과정 프로세스의 상태 프로세스는 Run, Ready, Wait라는 3가지 상태를 갖는다. Run CPU가 해당 프로세스를 수행하고 있는 상태 Ready 다른 프로세스를 실행하기위해 잠시 멈춘상태(실행가능한 상태) Wait 실행 불가능한 상태, 디스크를 읽거나 문자를 입력하는 등의 외부 이벤트가 발생할 때까지 멈춰있는 상태이다. Running Process가 어떤 값을 입력 받기 전까지는 Wait 상태가 된다. 스케줄러가 다른 프로세스를 선택한 경우 Running 프로세스는 Ready 상태가 된다. 스케줄러에의해 Ready 상태의 프로세스를 선택한 경우 다시 Running 상태가 된다. 값을 입력받을 경우 Wait 된 프로세스는 Ready 상태가 된다. 스케줄링이란 스케줄링란 os내에서 프로세스가 CPU 위에서 실행될 수 있도록 제어해주는 프로그램 프로세스를 스케줄링하기 위한 queue에는 세가지 종류가 존재한다. Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합 Ready Queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합 Device Queue : Device I&#x2F;O 작업을 대기하고 있는 프로세스의 집합 장기 스케줄러 (Memoy 적재) 디스크에서 프로그램을 선택해 Memory(메모리) 로 적재하는 역할을 한다.요즘은 Viratual Memory Management 의 발달로 장기 스케줄러가 의미가 없어졌다. 한정된 메모리에 많은 프로세스들이 한꺼번에 올라올 경우, 대용량 메모리(디스크)에 임시로 저장된다. 대용량 메모리에 저장된 프로세스 중에서 어떤 프로세스에 메로리를 할당하여 Ready Queue 로 보낼지 결정하는 역할을 한다. 메모리와 디스크 사이의 스케줄링을 담당한다. 프로세스에 Memory 및 각종리소스를 할당한다. 다중 프로그래밍 제어 단기 스케줄러 (Cpu 할당) 프로세스에 CPU 를 할당해 프로세스를 실행하기 위한 역할을 한다. Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 run할지 결정한다. cpu와 메모리 사이의 스케줄링을 담당한다. 프로세스의 상태 : Ready -&gt; Run -&gt; Wait -&gt; Ready 중기 스케줄러 (메모리 관리) 시스템 성능저하를 방지하기 위해 메모리에 적재된 프로세스의 수 를 동적으로 조절하기 위한 스케줄러 프로세스에게서 memory를 deallocate한다. 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절한다. 다중 프로그래밍의 정도를 완화 프로세스의 상태 : Ready -&gt; Suspended","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"tags":[]},{"title":"프로세스 메모리 영역","slug":"computer-science/os/process/process-memory","date":"2021-11-03T15:16:13.000Z","updated":"2024-03-03T05:21:24.460Z","comments":true,"path":"2021/11/04/computer-science/os/process/process-memory/","link":"","permalink":"https://ckck803.github.io/2021/11/04/computer-science/os/process/process-memory/","excerpt":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 프로세스의 Address Space(주소공간) 프로그램이 실행되면 Process Address Space가 할당된다. Process Address Space는 Text(Code), Data, Stack, Head 4가지 영역으로 구분된다. 프로세스가 생행되면 각 프로세스는 운영체제로부터 독립된 메모리영역을 할당 받습니다. 때문에 한 프로세스 메모리 영역에 다른 프로세스가 접근할 수 없습니다. 프로세스 메모리 영역은 Code, Data, Heap, Stack 4가지 영역으로 구분됩니다. Text(Code) 프로그램 코드가 저장되는 메모리 영역 프로그램이 실행될 때 할당 됐다가 프로그램이 종료하면 해제된다. (고정된 영역) Read Only Data","text":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 프로세스의 Address Space(주소공간) 프로그램이 실행되면 Process Address Space가 할당된다. Process Address Space는 Text(Code), Data, Stack, Head 4가지 영역으로 구분된다. 프로세스가 생행되면 각 프로세스는 운영체제로부터 독립된 메모리영역을 할당 받습니다. 때문에 한 프로세스 메모리 영역에 다른 프로세스가 접근할 수 없습니다. 프로세스 메모리 영역은 Code, Data, Heap, Stack 4가지 영역으로 구분됩니다. Text(Code) 프로그램 코드가 저장되는 메모리 영역 프로그램이 실행될 때 할당 됐다가 프로그램이 종료하면 해제된다. (고정된 영역) Read Only Data 프로그램의 전역변수, 정적변수가 저장되는 메모리 영역 프로그램이 실행될 때 할당 됐다가 프로그램이 종료하면 해제된다. (고정된 영역) Read&#x2F;Write Stack 함수 호출시 할당됐다가 종료시 해제되는 메모리영역 지역변수와 매게변수를 저장하기 위한 메모리 영역 함수 호출과 함께 할당 됐다가 함수 호출이 끝나면 해제된다. Thread 별로 생성되는 영역이다. 메모리가 높은 주소에서 낮은 주소로 할당된다 Read&#x2F;Write Heap 동적 할당을 위한 메모리 영역 Run Time(런타임)에 크기가 결정되는 메모리 영역 Stack과는 반대로 메모리가 낮은 주소에서 높은 주소로 할당된다. Stack 과 Heap 의 메모리 할당 방식스택 영영과 힙 영역은 메모리를 효율적으로 사용하기 위해 서로 반대로 메모리를 항당합니다. 만약, 스택이나 힙에서 주어진 영역을 벗어나 상대방 메모리 영역을 침벌하게 되면 Overflow(오버 플로우) 라 합니다. 힙이 스택을 침범하는 경우를 Heap Overflow(힙 오버 플로우) 라 하고, 스택이 힙을 침범하는 경우를 Stack Overflow(스택 오버 플로우) 라 한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"tags":[]},{"title":"Process (프로세스)","slug":"computer-science/os/process/process","date":"2021-11-03T15:16:13.000Z","updated":"2024-03-03T05:21:27.659Z","comments":true,"path":"2021/11/04/computer-science/os/process/process/","link":"","permalink":"https://ckck803.github.io/2021/11/04/computer-science/os/process/process/","excerpt":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 프로세스의 정의 Process(프로세스) 는 현재 실행중인 프로그램을 의미한다. Process Control Block (프로세스 제어 블록) 운영체제(OS) 가 프로세스를 제어 하기 위해 정보를 저장해 놓은 곳, 프로세스의 상태 정보 를 저장하는 자료구조다. 프로세스 상태 관리 와 Context Switch(문맥 교환) 을 위해 필요하다. 프로세스 ID (PID) 프로세스의 고유 번호 프로세스 현재 상태 생성, 준비, 실행, 대기, 소멸등 프로세스의 상태를 저장한다. 프로세스 Counter(PC) 다음 실행될 명령어의 주소를 저장하는 Counter CPU에서는 PC를 통해 프로세스 명령어를 실행한다. Process 생성 새로운 프로세스는 현재 실행하고 있는 프로세스가 프로세스 생성 System Call을 실행할 때만 만들 수 있다. 프로세스를 생성하는 주요 event들","text":"목차 Thread Safe 쓰레드와 메모리구조 쓰레드 프로세스 동기화 프로세스 스케줄링 알고리즘 프로세스 상태와 스케줄러 Inter Process Communication(프로세스간의 통신) 프로세스 메모리 영역 Process (프로세스) 프로세스의 정의 Process(프로세스) 는 현재 실행중인 프로그램을 의미한다. Process Control Block (프로세스 제어 블록) 운영체제(OS) 가 프로세스를 제어 하기 위해 정보를 저장해 놓은 곳, 프로세스의 상태 정보 를 저장하는 자료구조다. 프로세스 상태 관리 와 Context Switch(문맥 교환) 을 위해 필요하다. 프로세스 ID (PID) 프로세스의 고유 번호 프로세스 현재 상태 생성, 준비, 실행, 대기, 소멸등 프로세스의 상태를 저장한다. 프로세스 Counter(PC) 다음 실행될 명령어의 주소를 저장하는 Counter CPU에서는 PC를 통해 프로세스 명령어를 실행한다. Process 생성 새로운 프로세스는 현재 실행하고 있는 프로세스가 프로세스 생성 System Call을 실행할 때만 만들 수 있다. 프로세스를 생성하는 주요 event들 System initialization 실행중인 프로세스가 프로세스 생성 System Call 명령어를 실행한경우 새로운 프로세스를 생성하라는 사용자 요청 배치 작업의 시작 Process의 종료 프로세스를 종료시키는 방법은 크게 자발적인 경우 와 비 자발적인 경우 로 나뉜다. 자발적인 경우 정상적인 종료 에러에의한 종료 비자발적이 경우 치명적인 오류로 인한 종료 다른 프로세스가 해당 프로세스를 죽인경우(kill 명령어)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"tags":[]},{"title":"Spring Rest API - Spring Boot Swagger 사용하기","slug":"spring/spring-rest/rest-api-05-swagger","date":"2021-11-03T14:47:05.000Z","updated":"2024-02-26T16:14:16.235Z","comments":true,"path":"2021/11/03/spring/spring-rest/rest-api-05-swagger/","link":"","permalink":"https://ckck803.github.io/2021/11/03/spring/spring-rest/rest-api-05-swagger/","excerpt":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - Spring Boot Swagger 사용하기 Swagger 란 Open API Specification(OAS) 를 위한 프레임워크다. 개발자가 REST API 서비스를 설계, 빌드, 문서화 할 수 있도록 도와준다. Swagger를 사용하기 위한 의존성 추가하기implementation &quot;io.springfox:springfox-boot-starter:3.0.0&quot; Swagger를 사용하기 위한 설정 추가 Docket Swagger 설정의 핵심이 되는 Bean apis ApiSelectorBuilder 를 생성 명시된 Package나 어노테이션를 대상으로 Swagger API 문서를 만든다. RequestHandlerSelectors 클래스 메소드를 통해 설정한다. any : 전부 basePackage : 명시된 패키지를 대상으로 Swagger API 문서를 만든다. withClassAnnotation : 명시된 어노테이션이 붙은 Class만 Swagger API 문서를 만든다. withMethodAnnotation : 명시된 어노테이션이 붙은 Method만 Swagger API 문서를 만든다. paths apis 에서 명시된 대상에서 paths 조건에 맞는 것만 Swagger API 문서를 만들 수 있도록 필터링 한다. Open API 3.0 사용한 방법","text":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - Spring Boot Swagger 사용하기 Swagger 란 Open API Specification(OAS) 를 위한 프레임워크다. 개발자가 REST API 서비스를 설계, 빌드, 문서화 할 수 있도록 도와준다. Swagger를 사용하기 위한 의존성 추가하기implementation &quot;io.springfox:springfox-boot-starter:3.0.0&quot; Swagger를 사용하기 위한 설정 추가 Docket Swagger 설정의 핵심이 되는 Bean apis ApiSelectorBuilder 를 생성 명시된 Package나 어노테이션를 대상으로 Swagger API 문서를 만든다. RequestHandlerSelectors 클래스 메소드를 통해 설정한다. any : 전부 basePackage : 명시된 패키지를 대상으로 Swagger API 문서를 만든다. withClassAnnotation : 명시된 어노테이션이 붙은 Class만 Swagger API 문서를 만든다. withMethodAnnotation : 명시된 어노테이션이 붙은 Method만 Swagger API 문서를 만든다. paths apis 에서 명시된 대상에서 paths 조건에 맞는 것만 Swagger API 문서를 만들 수 있도록 필터링 한다. Open API 3.0 사용한 방법SwaggerConfig.java @Configurationpublic class SwaggerConfig &#123; @Bean public Docket api() &#123; // Open Api Spec 3.0 return new Docket(DocumentationType.OAS_30) .select() .apis(RequestHandlerSelectors.any()) .**paths**(PathSelectors.any()) .build(); &#125;&#125; Swagger 2.0 사용한 방법@Beanpublic Docket api()&#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build();&#125; 접속 URLSwagger UI - http://localhost:8080/swagger-ui/index.html Swagger 정보 설정하기 Swagger API의 정보를 설정하기 위해 ApiInfo 를 제공한다. ApiInfoBuilder 를 이용해 title, description, version, license 등을 설정한 후 ApiInfo 객체를 생성할 수 있다. apiInfo 제목, 설명 등 Swagger API 문서에 대한 정보를 설정한다. @Beanpublic Docket api() &#123; return new Docket(DocumentationType.OAS_30) // open api spec 3.0 .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build() .apiInfo(apiInfo());&#125;private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;Sample Swagger Title&quot;) .description(&quot;sample swagger description&quot;) .version(&quot;1.0&quot;) .build();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Rest","slug":"Spring/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring/Spring-Rest/"}],"tags":[]},{"title":"객체 지향 3요소","slug":"computer-science/programming-language/object/object","date":"2021-10-28T14:16:32.000Z","updated":"2024-02-18T16:19:54.521Z","comments":true,"path":"2021/10/28/computer-science/programming-language/object/object/","link":"","permalink":"https://ckck803.github.io/2021/10/28/computer-science/programming-language/object/object/","excerpt":"컴파일 언어, 인터프리터 언어, 하이브리드 언어 객체 지향 3요소 객체 지향 설계 5원칙 SOLID 객체 지향 3요소1. 캡슐화 정보의 은닉 관련이 있는 변수와 함수를 묶는 작업 객체는 접근제어자를 이용해 외부에서 접근할 수 있는 정보 와 외부에서 접근할 수 없는 정보 를 분리해 관리할 수 있다. private : 클래스 내부에서만 접근 가능 public : 클래스 외부에서 접근 가능 protected : 자기 클래스 혹은 상속 받은 클래스에서만 접근이 가능 2. 상속 자원의 상속 자식 클래스가 부모 클래스의 모든 자원 (Field, Method) 를 물려 받는 것을 의미한다. 하나의 부모클래스는 여러개의 자식 클래스를 가질 수 있지만 그 반대는 안된다. 개발자는 상속을 통해 불필요한 코드를 줄일 수 있고 공통 자원 관리를 집중시킬 수 있다. (유지 보수가 편리하다.) 3. 다형성 여러가지 형태를 가질 수 있게 하는 특성대표적으로 오버라이딩 과 오버로딩 이 있다.","text":"컴파일 언어, 인터프리터 언어, 하이브리드 언어 객체 지향 3요소 객체 지향 설계 5원칙 SOLID 객체 지향 3요소1. 캡슐화 정보의 은닉 관련이 있는 변수와 함수를 묶는 작업 객체는 접근제어자를 이용해 외부에서 접근할 수 있는 정보 와 외부에서 접근할 수 없는 정보 를 분리해 관리할 수 있다. private : 클래스 내부에서만 접근 가능 public : 클래스 외부에서 접근 가능 protected : 자기 클래스 혹은 상속 받은 클래스에서만 접근이 가능 2. 상속 자원의 상속 자식 클래스가 부모 클래스의 모든 자원 (Field, Method) 를 물려 받는 것을 의미한다. 하나의 부모클래스는 여러개의 자식 클래스를 가질 수 있지만 그 반대는 안된다. 개발자는 상속을 통해 불필요한 코드를 줄일 수 있고 공통 자원 관리를 집중시킬 수 있다. (유지 보수가 편리하다.) 3. 다형성 여러가지 형태를 가질 수 있게 하는 특성대표적으로 오버라이딩 과 오버로딩 이 있다. 오버라이딩 기존의 기능을 덮어쓰고 새로운 기능을 구현하는 방식 interface Sample&#123; public void hello(String str);&#125;class SampleImpl implements Sample&#123; @Override public void hello(String str)&#123; System.out.println(&quot;Hello &quot; + srt); &#125;&#125;public class Main&#123; public static void main(String args[])&#123; Sample sample = new SampleImpl(); sample.hello(&quot;world!&quot;); &#125;&#125; 오버로딩 객체내 동일한 이름 을 가진 Method 를 여러개 사용할 수 있도록 하는 특성단, Paramater 종류 나 개수 가 달라야 한다. public class Main &#123; public void method()&#123; System.out.println(&quot;Hello world!&quot;); &#125; public void method(String str)&#123; System.out.println(&quot;Hello world! &quot; + str); &#125; public void method(int value)&#123; System.out.println(&quot;Hello world! &quot; + value); &#125; public void method(int value, String str)&#123; System.out.println(&quot;Hello world! &quot; + value + str); &#125;&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Programming Lanuage","slug":"CS/Programming-Lanuage","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/"}],"tags":[]},{"title":"Spring Security - UsernamePasswordAuthenticationFilter & AbstractAuthenticationProcessingFilter","slug":"spring/spring-security/security/authentication/usernamepasswordAuthenticationFilter","date":"2021-10-26T13:25:35.000Z","updated":"2024-02-26T16:25:18.967Z","comments":true,"path":"2021/10/26/spring/spring-security/security/authentication/usernamepasswordAuthenticationFilter/","link":"","permalink":"https://ckck803.github.io/2021/10/26/spring/spring-security/security/authentication/usernamepasswordAuthenticationFilter/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture AbstractAuthenticationProcessingFilter 인증 과정 AbstractAuthenticationProcessingFilter 는 Spring Security Filter에서 인증 과정을 구현한 추상 Class 다. 로그인을 진행하는 URL로 로그인 요청이 들어왔는지 확인한다. 요청에 대한 인증을 진행하고 Authentication 객체를 반환 받는다. Session 전략에 따라 적절한 처리를 진행한다. (Session Id 변경) 인증이 완료 됐으면 Authentication 객체를 SecurityContext에 저장한다. AbstractAuthenticationProcessingFilter.java @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; doFilter((HttpServletRequest)request, (HttpServletResponse)response, chain);&#125;private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 로그인을 진행하는 URL로 로그인 요청이 들어왔는지 확인한다. if (!requiresAuthentication(request, response)) &#123; chain.doFilter(request, response); return; &#125; try &#123; // 인증을 진행하고 생성된 Authentication 객체를 반환받는다. // AbstractAuthenticationProcessingFilter 를 상속받은 Class에 의해 구현되는 부분 Authentication authenticationResult = attemptAuthentication(request, response); if (authenticationResult == null) &#123; return; &#125; // Session에 대한 설정을 한다. Session Id를 변경 this.sessionStrategy.onAuthentication(authenticationResult, request, response); // Authentication success if (this.continueChainBeforeSuccessfulAuthentication) &#123; chain.doFilter(request, response); &#125; // 인증 후 처리를 진행한다. successfulAuthentication(request, response, chain, authenticationResult); &#125; catch (InternalAuthenticationServiceException failed) &#123; this.logger.error(&quot;An internal error occurred while trying to authenticate the user.&quot;, failed); unsuccessfulAuthentication(request, response, failed); &#125; catch (AuthenticationException ex) &#123; // Authentication failed unsuccessfulAuthentication(request, response, ex); &#125;&#125;","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture AbstractAuthenticationProcessingFilter 인증 과정 AbstractAuthenticationProcessingFilter 는 Spring Security Filter에서 인증 과정을 구현한 추상 Class 다. 로그인을 진행하는 URL로 로그인 요청이 들어왔는지 확인한다. 요청에 대한 인증을 진행하고 Authentication 객체를 반환 받는다. Session 전략에 따라 적절한 처리를 진행한다. (Session Id 변경) 인증이 완료 됐으면 Authentication 객체를 SecurityContext에 저장한다. AbstractAuthenticationProcessingFilter.java @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; doFilter((HttpServletRequest)request, (HttpServletResponse)response, chain);&#125;private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 로그인을 진행하는 URL로 로그인 요청이 들어왔는지 확인한다. if (!requiresAuthentication(request, response)) &#123; chain.doFilter(request, response); return; &#125; try &#123; // 인증을 진행하고 생성된 Authentication 객체를 반환받는다. // AbstractAuthenticationProcessingFilter 를 상속받은 Class에 의해 구현되는 부분 Authentication authenticationResult = attemptAuthentication(request, response); if (authenticationResult == null) &#123; return; &#125; // Session에 대한 설정을 한다. Session Id를 변경 this.sessionStrategy.onAuthentication(authenticationResult, request, response); // Authentication success if (this.continueChainBeforeSuccessfulAuthentication) &#123; chain.doFilter(request, response); &#125; // 인증 후 처리를 진행한다. successfulAuthentication(request, response, chain, authenticationResult); &#125; catch (InternalAuthenticationServiceException failed) &#123; this.logger.error(&quot;An internal error occurred while trying to authenticate the user.&quot;, failed); unsuccessfulAuthentication(request, response, failed); &#125; catch (AuthenticationException ex) &#123; // Authentication failed unsuccessfulAuthentication(request, response, ex); &#125;&#125; 요청이 로그인을 진행하는 URL로 로그인 요청이 들어왔는지 확인protected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) &#123; // 요청 URL이 로그인을 진행하는 URL과 일치하는지 확인한다. if (this.requiresAuthenticationRequestMatcher.matches(request)) &#123; return true; &#125; if (this.logger.isTraceEnabled()) &#123; this.logger .trace(LogMessage.format(&quot;Did not match request to %s&quot;, this.requiresAuthenticationRequestMatcher)); &#125; return false;&#125; Username과 Password를 이용한 인증 진행 - UsernamePasswordAuthenticationFilter AbstractAuthenticationProcessingFilter를 상속한 객체로 Username과 Password를 이용해 인증을 진행하는 Filter 다.인증 과정에서 Authentication 을 구현한 UsernamePasswordAuthenticationToken 을 사용한다. username, password를 이용해 UsernamePasswordAuthenticationToken 객체를 생성 생성된 UsernamePasswordAuthenticationToken 객체를 ProviderManager 를 이용해 인증을 진행 ProviderManager는 DaoAuthenticationProvider 를 이용해 UsernamePasswordAuthenticationToken 객체 인증을 진행 인증에 대한 적절한 Session 처리를 한 후 생성된 Authentication 객체를 SecurityContext에 저장한다. UsernamePasswordAuthenticationFilter.java @Overridepublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123; throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod()); &#125; // reqeust로부터 username을 가져온다. String username = obtainUsername(request); username = (username != null) ? username : &quot;&quot;; username = username.trim(); // request로부터 password를 가져온다. String password = obtainPassword(request); password = (password != null) ? password : &quot;&quot;; // 인증 객체 생성 UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); // AuthenticationManager를 이용해 인증을 진행한다. setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest);&#125; 인증 완료 후 작업 인증이 완료된 후 작업으로는 Session에 대한 처리 와 SecurityContext에 Authentication 객체를 등록하는 일이 남아 있다. Session 처리 - AbstractSessionFixationProtectionStrategy SessionAuthenticationStrategy 를 구현한 추상 클래스며, Session 고정 공격 을 피하기 위해 사용한다. AbstractSessionFixationProtectionStrategy.java @Overridepublic void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) &#123; boolean hadSessionAlready = request.getSession(false) != null; // Session이 없고 alwaysCreateSession 옵션이 false일 경우에는 그냥 반환한다. if (!hadSessionAlready &amp;&amp; !this.alwaysCreateSession) &#123; return; &#125; // 기존 Session을 가져오거나 없을 경우 새로운 Session을 생성한다. HttpSession session = request.getSession(); // Session이 존재하고 아직 유효한 경우 새로운 Session을 생성하고 기존 Session을 복사한다. if (hadSessionAlready &amp;&amp; request.isRequestedSessionIdValid()) &#123; String originalSessionId; String newSessionId; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; originalSessionId = session.getId(); // Session Id를 변경한다. session = applySessionFixation(request); newSessionId = session.getId(); &#125; // Session Id에 대한 유효성을 검사한다. if (originalSessionId.equals(newSessionId)) &#123; this.logger.warn(&quot;Your servlet container did not change the session ID when a new session &quot; + &quot;was created. You will not be adequately protected against session-fixation attacks&quot;); &#125; else &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Changed session id from %s&quot;, originalSessionId)); &#125; &#125; // Session Id가 변경 됐음음 Application에 알려준다. onSessionChange(originalSessionId, session, authentication); &#125;&#125; Session 처리 - ChangeSessionIdAuthenticationStrategy AbstractSessionFixationProtectionStrategy 구현체로 ChangeSessionIdAuthenticationStrategy 를 사용해 Session Id를 변경한다. ChangeSessionIdAuthenticationStrategy.java public final class ChangeSessionIdAuthenticationStrategy extends AbstractSessionFixationProtectionStrategy &#123; @Override HttpSession applySessionFixation(HttpServletRequest request) &#123; request.changeSessionId(); return request.getSession(); &#125;&#125; 인증이 완료된 Authentication 객체를 SecurityContext에 저장한다.successfulAuthentication 메소드는 인증이 성공적으로 이루어 졌을 때 호출되는 메소드로 크게 3가지 작업을 진행한다. SecurityContextHolder로부터 SecurityContext 객체를 가져와 Authentication 객체를 넣어준다. Remember Me에 대한 설정을 해준다. 인증이 완료 되면 successHandler를 이용해 정상적으로 인증이 완료 됐을 때의 작업을 진행한다. SecurityConfig에서 http.successHandler() 메소드로 등록한 Handler객체가 실행된다. AbstractAuthenticationProcessingFilter.java protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; // SecurityContextHolder에 Authentication 객체를 등록한다. SecurityContextHolder.getContext().setAuthentication(authResult); if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authResult)); &#125; this.rememberMeServices.loginSuccess(request, response, authResult); if (this.eventPublisher != null) &#123; this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass())); &#125; this.successHandler.onAuthenticationSuccess(request, response, authResult);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"인증 과정","slug":"Spring/Spring-Security/인증-과정","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95/"}],"tags":[]},{"title":"React 로그인 Modal 만들기 9 - Redux Saga 적용","slug":"react/login/login-modal-09-reduxsaga","date":"2021-10-25T04:10:40.000Z","updated":"2024-11-23T16:46:04.735Z","comments":true,"path":"2021/10/25/react/login/login-modal-09-reduxsaga/","link":"","permalink":"https://ckck803.github.io/2021/10/25/react/login/login-modal-09-reduxsaga/","excerpt":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 9 - Redux Saga 적용모듈 설치하기yarn add redux-saga Reducer 정의import &#123; SIGNUP_FAILURE, SIGNUP_REQUEST, SIGNUP_SUCCESS &#125; from &quot;../type&quot;;const initialState = &quot;&quot;;export const signupRequest = (form) =&gt; (&#123; type: SIGNUP_REQUEST, data: form,&#125;);const SignupReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case SIGNUP_REQUEST: return &#123; ...state, &#125;; case SIGNUP_SUCCESS: return &#123; ...state, &#125;; case SIGNUP_FAILURE: return &#123; ...state, &#125;; default: return state; &#125;&#125;;export default SignupReducer; import axios from &quot;axios&quot;;import &#123; LOGIN_FAILURE, LOGIN_REQUEST, LOGIN_SUCCESS &#125; from &quot;../type&quot;;const initialState = &#123; token: localStorage.getItem(&quot;token&quot;),&#125;;export const loginRequest = (loginData) =&gt; (&#123; type: LOGIN_REQUEST, data: loginData,&#125;);const LoginReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case LOGIN_REQUEST: console.log(&quot;Log In Reqeust&quot;); return &#123; ...state, &#125;; case LOGIN_SUCCESS: console.log(&quot;Log In Success&quot;); return &#123; ...state, token: localStorage.getItem(&quot;token&quot;), &#125;; case LOGIN_FAILURE: console.log(&quot;Log In Failure&quot;); return &#123; ...state, &#125;; default: return state; &#125;&#125;;export default LoginReducer; Root Reducer 생성import &#123; combineReducers &#125; from &quot;redux&quot;;import LoginReducer from &quot;./LoginReducer&quot;;import SignupReducer from &quot;./SignupReducer&quot;;const createRootReducer = combineReducers(&#123; LoginReducer, SignupReducer,&#125;);export default createRootReducer;","text":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 9 - Redux Saga 적용모듈 설치하기yarn add redux-saga Reducer 정의import &#123; SIGNUP_FAILURE, SIGNUP_REQUEST, SIGNUP_SUCCESS &#125; from &quot;../type&quot;;const initialState = &quot;&quot;;export const signupRequest = (form) =&gt; (&#123; type: SIGNUP_REQUEST, data: form,&#125;);const SignupReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case SIGNUP_REQUEST: return &#123; ...state, &#125;; case SIGNUP_SUCCESS: return &#123; ...state, &#125;; case SIGNUP_FAILURE: return &#123; ...state, &#125;; default: return state; &#125;&#125;;export default SignupReducer; import axios from &quot;axios&quot;;import &#123; LOGIN_FAILURE, LOGIN_REQUEST, LOGIN_SUCCESS &#125; from &quot;../type&quot;;const initialState = &#123; token: localStorage.getItem(&quot;token&quot;),&#125;;export const loginRequest = (loginData) =&gt; (&#123; type: LOGIN_REQUEST, data: loginData,&#125;);const LoginReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case LOGIN_REQUEST: console.log(&quot;Log In Reqeust&quot;); return &#123; ...state, &#125;; case LOGIN_SUCCESS: console.log(&quot;Log In Success&quot;); return &#123; ...state, token: localStorage.getItem(&quot;token&quot;), &#125;; case LOGIN_FAILURE: console.log(&quot;Log In Failure&quot;); return &#123; ...state, &#125;; default: return state; &#125;&#125;;export default LoginReducer; Root Reducer 생성import &#123; combineReducers &#125; from &quot;redux&quot;;import LoginReducer from &quot;./LoginReducer&quot;;import SignupReducer from &quot;./SignupReducer&quot;;const createRootReducer = combineReducers(&#123; LoginReducer, SignupReducer,&#125;);export default createRootReducer; Sagaimport axios from &quot;axios&quot;;import &#123; all, call, put, takeEvery, fork &#125; from &quot;redux-saga/effects&quot;;import &#123;&#125; from &quot;../reducers/LoginReducer&quot;;import &#123; SIGNUP_REQUEST, SIGNUP_SUCCESS &#125; from &quot;../type&quot;;const SignupUserAPI = (signupData) =&gt; &#123; return axios.post(&quot;/api/signup&quot;, signupData).then((response) =&gt; &#123; return response.data; &#125;);&#125;;function* signupUser(action) &#123; try &#123; const result = yield call(SignupUserAPI, action.data); yield put(&#123; type: SIGNUP_SUCCESS, data: result, &#125;); &#125; catch (e) &#123; yield put(&#123; type: SIGNUP_REQUEST, &#125;); &#125;&#125;function* watchSignupUser() &#123; yield takeEvery(SIGNUP_REQUEST, signupUser);&#125;export default function* signupSaga() &#123; yield all([fork(watchSignupUser)]);&#125; import axios from &quot;axios&quot;;import &#123; LOGIN_FAILURE, LOGIN_REQUEST, LOGIN_SUCCESS &#125; from &quot;../type&quot;;import &#123; all, call, fork, put, takeEvery &#125; from &quot;redux-saga/effects&quot;;const loginUserAPI = (loginData) =&gt; &#123; return axios .post(&quot;/api/login&quot;, loginData) .then((response) =&gt; &#123; localStorage.setItem(&quot;token&quot;, response.headers.authorization); return response.data; &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;);&#125;;function* loginUser(action) &#123; try &#123; const result = yield call(loginUserAPI, action.data); yield put(&#123; type: LOGIN_SUCCESS, data: result, &#125;); &#125; catch (e) &#123; yield put(&#123; type: LOGIN_FAILURE, &#125;); &#125;&#125;function* watchLoginUser() &#123; yield takeEvery(LOGIN_REQUEST, loginUser);&#125;export default function* loginSaga() &#123; yield all([fork(watchLoginUser)]);&#125; Root Saga 생성import &#123; all, fork &#125; from &quot;redux-saga/effects&quot;;import loginSaga from &quot;./LoginSaga&quot;;import signupSaga from &quot;./SignupSaga&quot;;export default function* rootSaga() &#123; yield all([fork(loginSaga), fork(signupSaga)]);&#125; import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;import &#123; composeWithDevTools &#125; from &#x27;redux-devtools-extension&#x27;; // 리덕스 개발자 도구import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;import createSagaMiddleware from &#x27;redux-saga&#x27;;import rootSaga from &#x27;./redux/sagas&#x27;;import createRootReducer from &#x27;./redux/reducers&#x27;;const sagaMiddleware = createSagaMiddleware();const store = createStore(createRootReducer, composeWithDevTools(applyMiddleware(sagaMiddleware)))sagaMiddleware.run(rootSaga);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&#x27;root&#x27;));reportWebVitals();","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"}],"tags":[]},{"title":"Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer","slug":"spring/spring-security/security/configure/authorization","date":"2021-10-25T01:25:35.000Z","updated":"2024-02-26T16:26:38.354Z","comments":true,"path":"2021/10/25/spring/spring-security/security/configure/authorization/","link":"","permalink":"https://ckck803.github.io/2021/10/25/spring/spring-security/security/configure/authorization/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 인가 API ExpressionUrlAuthorizationConfigurer 를 통해 자원에 접근하기 위한 다양한 인가 방식을 지원한다.역할(ROLE) 기반 인가 방식, 권한(Authority) 기반 인가 방식, IP 를 통한 인가 방식등 다양한 API를 제공한다. hasRole 명시된 권한에 접미사 ROLE_ 을 붙이고 해당 권한을 가진 사용자만 자원에 접근을 허용한다. hasAuthority 와 비슷한 개념이지만 hasRole 은 USER, MANAGER, ADMIN과 같은 역할 에 따라 자원에 대한 접근을 허용한다. hasAnyRole 명시된 권한들에 접미사 ROLE_ 을 붙이고 사용자가 하나라도 권한을 갖고 있으면 해당 자원에 대한 접근을 허용한다. hasAuthority 해당 권한을 가진 사용자만 자원에 접근을 허용한다. hasRole 와 비슷한 개념이지만 hasAuthority는 CREATE, READ, WRITE, DELETE 와 같이 권한 에 따라 자원에 대한 접근을 허용한다. hasAnyAuthority 명시된 권한들 중 하나라도 권한이 있는 사용자만 자원에 접근을 허용한다. hasIpAddress 특정 IP 에 대해 자원에 대한 접근을 허용할 때 사용한다. permitAll 권한에 대한 검증 없이 자원에 대한 접근을 허용한다. anonymous 익명 사용자의 접근을 허용 익명 사용자는 기본적으로 ROLE_ANONYMOUS 권한이 부여돼 있다. rememberMe Remember-Me 를 통해 인증된 사용자가 자원에 대한 접근을 허용한다. denyAll 모든 접근을 허용하지 않는다. authenticated 인증된 사용자만 자원에 대한 접근을 허용한다. fullyAuthenticated Remember-Me 를 통해 인증된 사용자를 제외하고 인증된 사용자에 대한 접근을 허용한다. ExpressionUrlAuthorizationConfigurerpublic ExpressionInterceptUrlRegistry hasRole(String role) &#123; return access(ExpressionUrlAuthorizationConfigurer .hasRole(ExpressionUrlAuthorizationConfigurer.this.rolePrefix, role));&#125;public ExpressionInterceptUrlRegistry hasAnyRole(String... roles) &#123; return access(ExpressionUrlAuthorizationConfigurer .hasAnyRole(ExpressionUrlAuthorizationConfigurer.this.rolePrefix, roles));&#125;public ExpressionInterceptUrlRegistry hasAuthority(String authority) &#123; return access(ExpressionUrlAuthorizationConfigurer.hasAuthority(authority));&#125;public ExpressionInterceptUrlRegistry hasAnyAuthority(String... authorities) &#123; return access(ExpressionUrlAuthorizationConfigurer.hasAnyAuthority(authorities));&#125;public ExpressionInterceptUrlRegistry hasIpAddress(String ipaddressExpression) &#123; return access(ExpressionUrlAuthorizationConfigurer.hasIpAddress(ipaddressExpression));&#125;public ExpressionInterceptUrlRegistry permitAll() &#123; return access(permitAll);&#125;public ExpressionInterceptUrlRegistry anonymous() &#123; return access(anonymous);&#125;public ExpressionInterceptUrlRegistry rememberMe() &#123; return access(rememberMe);&#125;public ExpressionInterceptUrlRegistry denyAll() &#123; return access(denyAll);&#125;public ExpressionInterceptUrlRegistry authenticated() &#123; return access(authenticated);&#125;public ExpressionInterceptUrlRegistry fullyAuthenticated() &#123; return access(fullyAuthenticated);&#125;public ExpressionInterceptUrlRegistry access(String attribute) &#123; if (this.not) &#123; attribute = &quot;!&quot; + attribute; &#125; interceptUrl(this.requestMatchers, SecurityConfig.createList(attribute)); return ExpressionUrlAuthorizationConfigurer.this.REGISTRY;&#125;","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 인가 API ExpressionUrlAuthorizationConfigurer 를 통해 자원에 접근하기 위한 다양한 인가 방식을 지원한다.역할(ROLE) 기반 인가 방식, 권한(Authority) 기반 인가 방식, IP 를 통한 인가 방식등 다양한 API를 제공한다. hasRole 명시된 권한에 접미사 ROLE_ 을 붙이고 해당 권한을 가진 사용자만 자원에 접근을 허용한다. hasAuthority 와 비슷한 개념이지만 hasRole 은 USER, MANAGER, ADMIN과 같은 역할 에 따라 자원에 대한 접근을 허용한다. hasAnyRole 명시된 권한들에 접미사 ROLE_ 을 붙이고 사용자가 하나라도 권한을 갖고 있으면 해당 자원에 대한 접근을 허용한다. hasAuthority 해당 권한을 가진 사용자만 자원에 접근을 허용한다. hasRole 와 비슷한 개념이지만 hasAuthority는 CREATE, READ, WRITE, DELETE 와 같이 권한 에 따라 자원에 대한 접근을 허용한다. hasAnyAuthority 명시된 권한들 중 하나라도 권한이 있는 사용자만 자원에 접근을 허용한다. hasIpAddress 특정 IP 에 대해 자원에 대한 접근을 허용할 때 사용한다. permitAll 권한에 대한 검증 없이 자원에 대한 접근을 허용한다. anonymous 익명 사용자의 접근을 허용 익명 사용자는 기본적으로 ROLE_ANONYMOUS 권한이 부여돼 있다. rememberMe Remember-Me 를 통해 인증된 사용자가 자원에 대한 접근을 허용한다. denyAll 모든 접근을 허용하지 않는다. authenticated 인증된 사용자만 자원에 대한 접근을 허용한다. fullyAuthenticated Remember-Me 를 통해 인증된 사용자를 제외하고 인증된 사용자에 대한 접근을 허용한다. ExpressionUrlAuthorizationConfigurerpublic ExpressionInterceptUrlRegistry hasRole(String role) &#123; return access(ExpressionUrlAuthorizationConfigurer .hasRole(ExpressionUrlAuthorizationConfigurer.this.rolePrefix, role));&#125;public ExpressionInterceptUrlRegistry hasAnyRole(String... roles) &#123; return access(ExpressionUrlAuthorizationConfigurer .hasAnyRole(ExpressionUrlAuthorizationConfigurer.this.rolePrefix, roles));&#125;public ExpressionInterceptUrlRegistry hasAuthority(String authority) &#123; return access(ExpressionUrlAuthorizationConfigurer.hasAuthority(authority));&#125;public ExpressionInterceptUrlRegistry hasAnyAuthority(String... authorities) &#123; return access(ExpressionUrlAuthorizationConfigurer.hasAnyAuthority(authorities));&#125;public ExpressionInterceptUrlRegistry hasIpAddress(String ipaddressExpression) &#123; return access(ExpressionUrlAuthorizationConfigurer.hasIpAddress(ipaddressExpression));&#125;public ExpressionInterceptUrlRegistry permitAll() &#123; return access(permitAll);&#125;public ExpressionInterceptUrlRegistry anonymous() &#123; return access(anonymous);&#125;public ExpressionInterceptUrlRegistry rememberMe() &#123; return access(rememberMe);&#125;public ExpressionInterceptUrlRegistry denyAll() &#123; return access(denyAll);&#125;public ExpressionInterceptUrlRegistry authenticated() &#123; return access(authenticated);&#125;public ExpressionInterceptUrlRegistry fullyAuthenticated() &#123; return access(fullyAuthenticated);&#125;public ExpressionInterceptUrlRegistry access(String attribute) &#123; if (this.not) &#123; attribute = &quot;!&quot; + attribute; &#125; interceptUrl(this.requestMatchers, SecurityConfig.createList(attribute)); return ExpressionUrlAuthorizationConfigurer.this.REGISTRY;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Security","slug":"Spring/Spring-Security/Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Security/"},{"name":"Config","slug":"Spring/Spring-Security/Security/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Security/Config/"}],"tags":[]},{"title":"Spring Security - SessionManagementFilter & ConcurrentSessionFilter","slug":"spring/spring-security/security/filter/sessionmanagementfilter","date":"2021-10-24T14:25:35.000Z","updated":"2024-02-26T16:27:56.166Z","comments":true,"path":"2021/10/24/spring/spring-security/security/filter/sessionmanagementfilter/","link":"","permalink":"https://ckck803.github.io/2021/10/24/spring/spring-security/security/filter/sessionmanagementfilter/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 SessionManagementFilter SessionManagementFilter 는 인증된 사용자에 대한 Session 관리 와 Session 공격으로 부터의 보호 를 위한 Filter Session 관리 인증시 사용자의 Session 등록, 조회, 삭제 등의 이력을 관리한다. 동시성 Session 제어 동일 계정으로 접속하는 최대 Session 수를 설정한다. Session 고정 보호 인증할때 마다 새로운 Session 쿠키를 새로 발급해 쿠키 조작을 방지한다. Session 생성 정책 SessionManagementFilter.java private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; if (request.getAttribute(FILTER_APPLIED) != null) &#123; chain.doFilter(request, response); return; &#125; request.setAttribute(FILTER_APPLIED, Boolean.TRUE); if (!this.securityContextRepository.containsContext(request)) &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication != null &amp;&amp; !this.trustResolver.isAnonymous(authentication)) &#123; try &#123; // 최대 생성 개수를 넘어섰는지?, Session 고정 공격이 들어왔는지? 등 // Session에 대한 인증을 진행한다. this.sessionAuthenticationStrategy.onAuthentication(authentication, request, response); &#125; catch (SessionAuthenticationException ex) &#123; this.logger.debug(&quot;SessionAuthenticationStrategy rejected the authentication object&quot;, ex); SecurityContextHolder.clearContext(); this.failureHandler.onAuthenticationFailure(request, response, ex); return; &#125; this.securityContextRepository.saveContext(SecurityContextHolder.getContext(), request, response); &#125; else &#123; if (request.getRequestedSessionId() != null &amp;&amp; !request.isRequestedSessionIdValid()) &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Request requested invalid session id %s&quot;, request.getRequestedSessionId())); &#125; if (this.invalidSessionStrategy != null) &#123; this.invalidSessionStrategy.onInvalidSessionDetected(request, response); return; &#125; &#125; &#125; &#125; chain.doFilter(request, response);&#125; Session 관리를 위한 SessionAuthenticationStrategy SessionAuthenticationStrategy 는 Session 이 존재하는지 확인하거나 Session 고정 공격에 대한 보호를 위해 Session Id를 변경한다.","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 SessionManagementFilter SessionManagementFilter 는 인증된 사용자에 대한 Session 관리 와 Session 공격으로 부터의 보호 를 위한 Filter Session 관리 인증시 사용자의 Session 등록, 조회, 삭제 등의 이력을 관리한다. 동시성 Session 제어 동일 계정으로 접속하는 최대 Session 수를 설정한다. Session 고정 보호 인증할때 마다 새로운 Session 쿠키를 새로 발급해 쿠키 조작을 방지한다. Session 생성 정책 SessionManagementFilter.java private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; if (request.getAttribute(FILTER_APPLIED) != null) &#123; chain.doFilter(request, response); return; &#125; request.setAttribute(FILTER_APPLIED, Boolean.TRUE); if (!this.securityContextRepository.containsContext(request)) &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication != null &amp;&amp; !this.trustResolver.isAnonymous(authentication)) &#123; try &#123; // 최대 생성 개수를 넘어섰는지?, Session 고정 공격이 들어왔는지? 등 // Session에 대한 인증을 진행한다. this.sessionAuthenticationStrategy.onAuthentication(authentication, request, response); &#125; catch (SessionAuthenticationException ex) &#123; this.logger.debug(&quot;SessionAuthenticationStrategy rejected the authentication object&quot;, ex); SecurityContextHolder.clearContext(); this.failureHandler.onAuthenticationFailure(request, response, ex); return; &#125; this.securityContextRepository.saveContext(SecurityContextHolder.getContext(), request, response); &#125; else &#123; if (request.getRequestedSessionId() != null &amp;&amp; !request.isRequestedSessionIdValid()) &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Request requested invalid session id %s&quot;, request.getRequestedSessionId())); &#125; if (this.invalidSessionStrategy != null) &#123; this.invalidSessionStrategy.onInvalidSessionDetected(request, response); return; &#125; &#125; &#125; &#125; chain.doFilter(request, response);&#125; Session 관리를 위한 SessionAuthenticationStrategy SessionAuthenticationStrategy 는 Session 이 존재하는지 확인하거나 Session 고정 공격에 대한 보호를 위해 Session Id를 변경한다. SessionAuthenticationStrategy.java public interface SessionAuthenticationStrategy &#123; void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) throws SessionAuthenticationException;&#125; SessionAuthenticationStrategy 객체들을 관리하기 위한 - CompositeSessionAuthenticationStrategy CompositeSessionAuthenticationStrategy 는 여러개의 SessionAuthenticationStrategy 를 갖고 요청에 대한 Session 인증 처리를 위임한다. @Overridepublic void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) throws SessionAuthenticationException &#123; int currentPosition = 0; int size = this.delegateStrategies.size(); for (SessionAuthenticationStrategy delegate : this.delegateStrategies) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(LogMessage.format(&quot;Preparing session with %s (%d/%d)&quot;, delegate.getClass().getSimpleName(), ++currentPosition, size)); &#125; delegate.onAuthentication(authentication, request, response); &#125;&#125; Session 을 저장하기 위한 - RegisterSessionAuthenticationStrategy RegisterSessionAuthenticationStrategy 는 인증이 성공적으로 끝난 후 사용자 Session을 저장한다. @Overridepublic void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) &#123; this.sessionRegistry.registerNewSession(request.getSession().getId(), authentication.getPrincipal());&#125; 동시성 Session 제어를 위한 - ConcurrentSessionControlAuthenticationStrategy ConcurrentSessionControlAuthenticationStrategy 은 한 사용자가 만들 수 있는 Session 이 최대 생성 개수 를 넘어갔는지 확인한다. @Overridepublic void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) &#123; int allowedSessions = getMaximumSessionsForThisUser(authentication); if (allowedSessions == -1) &#123; // We permit unlimited logins return; &#125; List&lt;SessionInformation&gt; sessions = this.sessionRegistry.getAllSessions(authentication.getPrincipal(), false); int sessionCount = sessions.size(); if (sessionCount &lt; allowedSessions) &#123; // They haven&#x27;t got too many login sessions running at present return; &#125; // 해당 사용자로 만들어진 Session의 개수와 허용된 Session 생성 개수를 비교한다. if (sessionCount == allowedSessions) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; for (SessionInformation si : sessions) &#123; if (si.getSessionId().equals(session.getId())) &#123; return; &#125; &#125; &#125; &#125; // Session이 최대치 보다 많이 생성된 경우에 대한 처리를 진행한다. allowableSessionsExceeded(sessions, allowedSessions, this.sessionRegistry);&#125; allowableSessionsExceeded 메소드는 현재 사용자의 인증에 대한 예외 처리를 진행하는 방법과이전 사용자 Session 정보를 만료하는 방법 이 있다. ConcurrentSessionControlAuthenticationStrategy.java protected void allowableSessionsExceeded(List&lt;SessionInformation&gt; sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException &#123; // 현재 사용자가 인증을 못하도록 예외를 발생시킨다. // Session이 허용된 개수보다 많이 만들어졌거나, Session 자체가 없을 경우 SessionAuthenticationException 을 발생시킨다. if (this.exceptionIfMaximumExceeded || (sessions == null)) &#123; throw new SessionAuthenticationException( this.messages.getMessage(&quot;ConcurrentSessionControlAuthenticationStrategy.exceededAllowed&quot;, new Object[] &#123; allowableSessions &#125;, &quot;Maximum sessions of &#123;0&#125; for this principal exceeded&quot;)); &#125; // 이전 사용자 Session 정보를 만료 한다. sessions.sort(Comparator.comparing(SessionInformation::getLastRequest)); int maximumSessionsExceededBy = sessions.size() - allowableSessions + 1; // 첫번째 사용자 정보를 가져와 만료한다. List&lt;SessionInformation&gt; sessionsToBeExpired = sessions.subList(0, maximumSessionsExceededBy); for (SessionInformation session : sessionsToBeExpired) &#123; session.expireNow(); &#125;&#125; Session 고정 공격 보호를 위한 - AbstractSessionFixationProtectionStrategy AbstractSessionFixationProtectionStrategy 는 Session 고정 공격 보호 공통적인 로직을 수행시키기 위해 만들어진 추상 Class Session을 가져온다. 만일 Session이 없을 경우 새로 생성한다. Session 고정에 대한 적절한 처리를 진행한다.(Session Id를 변경) Session Id가 변경 됐는지 확인한다. SessionFixationProtectionEvent 이벤트를 발생한다. AbstractSessionFixationProtectionStrategy.java @Overridepublic void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) &#123; // 만들어진 Session이 있으면 가져온다. boolean hadSessionAlready = request.getSession(false) != null; if (!hadSessionAlready &amp;&amp; !this.alwaysCreateSession) &#123; return; &#125; // Session을 생성한다. HttpSession session = request.getSession(); if (hadSessionAlready &amp;&amp; request.isRequestedSessionIdValid()) &#123; String originalSessionId; String newSessionId; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; originalSessionId = session.getId(); // Session 고정에 대한 적절한 처리를 진행한다.(Sessio Id를 변경) session = applySessionFixation(request); newSessionId = session.getId(); &#125; if (originalSessionId.equals(newSessionId)) &#123; this.logger.warn(&quot;Your servlet container did not change the session ID when a new session &quot; + &quot;was created. You will not be adequately protected against session-fixation attacks&quot;); &#125; else &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Changed session id from %s&quot;, originalSessionId)); &#125; &#125; onSessionChange(originalSessionId, session, authentication); &#125;&#125; Session Id를 변경 - ChangeSessionIdAuthenticationStrategy ChangeSessionIdAuthenticationStrategy 는 AbstractSessionFixationProtectionStrategy 상속한 Class 다ChangeSessionIdAuthenticationStrategy 는 Session 고정 공격 보호를 위한 방법으로 Session Id를 변경 한다. ChangeSessionIdAuthenticationStrategy.java public final class ChangeSessionIdAuthenticationStrategy extends AbstractSessionFixationProtectionStrategy &#123; @Override HttpSession applySessionFixation(HttpServletRequest request) &#123; request.changeSessionId(); return request.getSession(); &#125;&#125; ConcurrentSessionFilter - 동시성 Session 제어를 위한 Filter ConcurrentSessionFilter 는 SessionManagementFilter 와 함께 동시적 Session 제어를 위한 Filter 매 요청 마다 현재 사용자의 Session 만료 여부를 체크 Session이 만료 됐을 경우 즉시 만료 처리한다. Logout 처리 Session 만료 정보에 대한 이벤트를 발생시킨다. ConcurrentSessionFilter.java private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpSession session = request.getSession(false); if (session != null) &#123; SessionInformation info = this.sessionRegistry.getSessionInformation(session.getId()); if (info != null) &#123; // Session이 반료 됐는지 확인한다. if (info.isExpired()) &#123; this.logger.debug(LogMessage .of(() -&gt; &quot;Requested session ID &quot; + request.getRequestedSessionId() + &quot; has expired.&quot;)); // Session이 만료 됐을 경우 Logout 처리한다. doLogout(request, response); this.sessionInformationExpiredStrategy .onExpiredSessionDetected(new SessionInformationExpiredEvent(info, request, response)); return; &#125; // Session이 만료되지 않았을 경우 Session 시간을 갱신한다. this.sessionRegistry.refreshLastRequest(info.getSessionId()); &#125; &#125; chain.doFilter(request, response);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Filter","slug":"Spring/Spring-Security/Filter","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Filter/"}],"tags":[]},{"title":"Spring Security - RembmerMeAuthenticationFilter","slug":"spring/spring-security/security/filter/remembermeauthenticationfilter","date":"2021-10-24T13:25:35.000Z","updated":"2024-02-26T16:27:33.537Z","comments":true,"path":"2021/10/24/spring/spring-security/security/filter/remembermeauthenticationfilter/","link":"","permalink":"https://ckck803.github.io/2021/10/24/spring/spring-security/security/filter/remembermeauthenticationfilter/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://docs.spring.io/spring-security/reference/servlet/authentication/rememberme.html RembmerMeAuthenticationFilter Client 로부터 Request(요청) 이 오게 되면 Request 객체 Cookie 에 Remember Me Token 이 있는지 확인한다. Token 을 이용해 인증을 진행한 후 SecurityContext 에 Authentication 객체를 저장한다. RememberMeAuthenticationFilter.java private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // SecurityContext 내 Authentication 객체가 있는지 확인 한다. if (SecurityContextHolder.getContext().getAuthentication() != null) &#123; this.logger.debug(LogMessage .of(() -&gt; &quot;SecurityContextHolder not populated with remember-me token, as it already contained: &#x27;&quot; + SecurityContextHolder.getContext().getAuthentication() + &quot;&#x27;&quot;)); chain.doFilter(request, response); return; &#125; // Remember Me 인증을 진행한 후 Authentication 객체를 반환받는다. Authentication rememberMeAuth = this.rememberMeServices.autoLogin(request, response); if (rememberMeAuth != null) &#123; // Attempt authenticaton via AuthenticationManager try &#123; // RememberMeAuthenticationToken 객체내 Key 값에 대한 Hash 비교를 통해 유효성 인증을 진행 후 객체를 그대로 반환받는다. rememberMeAuth = this.authenticationManager.authenticate(rememberMeAuth); // SecurityContextHolder 에 인증 받은 Authentication 객체를 저장한다. SecurityContextHolder.getContext().setAuthentication(rememberMeAuth); // 인증 성공 후 후작업을 진행한다. onSuccessfulAuthentication(request, response, rememberMeAuth); this.logger.debug(LogMessage.of(() -&gt; &quot;SecurityContextHolder populated with remember-me token: &#x27;&quot; + SecurityContextHolder.getContext().getAuthentication() + &quot;&#x27;&quot;)); if (this.eventPublisher != null) &#123; this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent( SecurityContextHolder.getContext().getAuthentication(), this.getClass())); &#125; if (this.successHandler != null) &#123; this.successHandler.onAuthenticationSuccess(request, response, rememberMeAuth); return; &#125; &#125; catch (AuthenticationException ex) &#123; this.logger.debug(LogMessage .format(&quot;SecurityContextHolder not populated with remember-me token, as AuthenticationManager &quot; + &quot;rejected Authentication returned by RememberMeServices: &#x27;%s&#x27;; &quot; + &quot;invalidating remember-me token&quot;, rememberMeAuth), ex); this.rememberMeServices.loginFail(request, response); onUnsuccessfulAuthentication(request, response, ex); &#125; &#125; chain.doFilter(request, response);&#125; AbstractRememberMeServices","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://docs.spring.io/spring-security/reference/servlet/authentication/rememberme.html RembmerMeAuthenticationFilter Client 로부터 Request(요청) 이 오게 되면 Request 객체 Cookie 에 Remember Me Token 이 있는지 확인한다. Token 을 이용해 인증을 진행한 후 SecurityContext 에 Authentication 객체를 저장한다. RememberMeAuthenticationFilter.java private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // SecurityContext 내 Authentication 객체가 있는지 확인 한다. if (SecurityContextHolder.getContext().getAuthentication() != null) &#123; this.logger.debug(LogMessage .of(() -&gt; &quot;SecurityContextHolder not populated with remember-me token, as it already contained: &#x27;&quot; + SecurityContextHolder.getContext().getAuthentication() + &quot;&#x27;&quot;)); chain.doFilter(request, response); return; &#125; // Remember Me 인증을 진행한 후 Authentication 객체를 반환받는다. Authentication rememberMeAuth = this.rememberMeServices.autoLogin(request, response); if (rememberMeAuth != null) &#123; // Attempt authenticaton via AuthenticationManager try &#123; // RememberMeAuthenticationToken 객체내 Key 값에 대한 Hash 비교를 통해 유효성 인증을 진행 후 객체를 그대로 반환받는다. rememberMeAuth = this.authenticationManager.authenticate(rememberMeAuth); // SecurityContextHolder 에 인증 받은 Authentication 객체를 저장한다. SecurityContextHolder.getContext().setAuthentication(rememberMeAuth); // 인증 성공 후 후작업을 진행한다. onSuccessfulAuthentication(request, response, rememberMeAuth); this.logger.debug(LogMessage.of(() -&gt; &quot;SecurityContextHolder populated with remember-me token: &#x27;&quot; + SecurityContextHolder.getContext().getAuthentication() + &quot;&#x27;&quot;)); if (this.eventPublisher != null) &#123; this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent( SecurityContextHolder.getContext().getAuthentication(), this.getClass())); &#125; if (this.successHandler != null) &#123; this.successHandler.onAuthenticationSuccess(request, response, rememberMeAuth); return; &#125; &#125; catch (AuthenticationException ex) &#123; this.logger.debug(LogMessage .format(&quot;SecurityContextHolder not populated with remember-me token, as AuthenticationManager &quot; + &quot;rejected Authentication returned by RememberMeServices: &#x27;%s&#x27;; &quot; + &quot;invalidating remember-me token&quot;, rememberMeAuth), ex); this.rememberMeServices.loginFail(request, response); onUnsuccessfulAuthentication(request, response, ex); &#125; &#125; chain.doFilter(request, response);&#125; AbstractRememberMeServices Request 객체로 부터 Remember Me 정보를 가져온 후 Base64 로 인코딩 Remember Me 정보를 Decoding 한다 디코딩 된 Remember Me 를 이용해 Login 을 진행한 후 UserDetails 객체를 반환받는다. Key 와 UserDetails 객체를 이용해 RememberMeAuthenticationToken 객체를 생성한다. @Overridepublic final Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) &#123; // Cookie 로부터 Remeber Me Token 정보를 가져온다. String rememberMeCookie = extractRememberMeCookie(request); if (rememberMeCookie == null) &#123; return null; &#125; this.logger.debug(&quot;Remember-me cookie detected&quot;); if (rememberMeCookie.length() == 0) &#123; this.logger.debug(&quot;Cookie was empty&quot;); cancelCookie(request, response); return null; &#125; try &#123; // Base64 로 인코딩 Remember Me Token 정보를 Decoding 한다. String[] cookieTokens = decodeCookie(rememberMeCookie); // Token 을 이용해 Login 을 진행한 후 UserDetails 객체를 반환받는다. UserDetails user = processAutoLoginCookie(cookieTokens, request, response); this.userDetailsChecker.check(user); this.logger.debug(&quot;Remember-me cookie accepted&quot;); // UserDetails 를 이용해 RememberMeAuthenticationToken (Authentication) 를 생성 후 반환한다. return createSuccessfulAuthentication(request, user); &#125; catch (CookieTheftException ex) &#123; cancelCookie(request, response); throw ex; &#125; catch (UsernameNotFoundException ex) &#123; this.logger.debug(&quot;Remember-me login was valid but corresponding user not found.&quot;, ex); &#125; catch (InvalidCookieException ex) &#123; this.logger.debug(&quot;Invalid remember-me cookie: &quot; + ex.getMessage()); &#125; catch (AccountStatusException ex) &#123; this.logger.debug(&quot;Invalid UserDetails: &quot; + ex.getMessage()); &#125; catch (RememberMeAuthenticationException ex) &#123; this.logger.debug(ex.getMessage()); &#125; cancelCookie(request, response); return null;&#125; RememberMeAuthenticationProvider RememberMeAuthenticationToken 의 유효성을 판단할 때 Key 에 대한 Hash 값 비교를 통해 확인한다. @Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; if (!supports(authentication.getClass())) &#123; return null; &#125; if (this.key.hashCode() != ((RememberMeAuthenticationToken) authentication).getKeyHash()) &#123; throw new BadCredentialsException(this.messages.getMessage(&quot;RememberMeAuthenticationProvider.incorrectKey&quot;, &quot;The presented RememberMeAuthenticationToken does not contain the expected key&quot;)); &#125; return authentication;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Filter","slug":"Spring/Spring-Security/Filter","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Filter/"}],"tags":[]},{"title":"React 로그인 Modal 만들기 8 - Redux 사용하기","slug":"react/login/login-modal-08-redux","date":"2021-10-24T08:10:40.000Z","updated":"2024-11-23T16:46:04.109Z","comments":true,"path":"2021/10/24/react/login/login-modal-08-redux/","link":"","permalink":"https://ckck803.github.io/2021/10/24/react/login/login-modal-08-redux/","excerpt":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 8 - Redux 사용하기모듈 설치하기yarn add reduxyarn add react-redux Action 정의export const LOGIN_REQUEST = &quot;login/LOGIN_REQUEST&quot;; Action 생성 함수 및 Reducer 생성하기import axios from &#x27;axios&#x27;;import &#123; LOGIN_REQUEST &#125; from &quot;../type&quot;const initialState = &#123; token: localStorage.getItem(&#x27;token&#x27;),&#125;;export const loginRequest = (loginData) =&gt; &#123; const response = axios.post(&quot;/api/login&quot;, loginData) .then((response) =&gt; &#123; localStorage.setItem(&quot;token&quot;, response.headers.authorization); console.log(localStorage.getItem(&quot;token&quot;)); return response.data; &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); return &#123; type: LOGIN_REQUEST, data: response &#125;;&#125;;const LoginReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case LOGIN_REQUEST: return &#123; ...state, token: localStorage.getItem(&#x27;token&#x27;), &#125;; default: return state; &#125;&#125;export default LoginReducer; Store 생성하기","text":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 8 - Redux 사용하기모듈 설치하기yarn add reduxyarn add react-redux Action 정의export const LOGIN_REQUEST = &quot;login/LOGIN_REQUEST&quot;; Action 생성 함수 및 Reducer 생성하기import axios from &#x27;axios&#x27;;import &#123; LOGIN_REQUEST &#125; from &quot;../type&quot;const initialState = &#123; token: localStorage.getItem(&#x27;token&#x27;),&#125;;export const loginRequest = (loginData) =&gt; &#123; const response = axios.post(&quot;/api/login&quot;, loginData) .then((response) =&gt; &#123; localStorage.setItem(&quot;token&quot;, response.headers.authorization); console.log(localStorage.getItem(&quot;token&quot;)); return response.data; &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); return &#123; type: LOGIN_REQUEST, data: response &#125;;&#125;;const LoginReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case LOGIN_REQUEST: return &#123; ...state, token: localStorage.getItem(&#x27;token&#x27;), &#125;; default: return state; &#125;&#125;export default LoginReducer; Store 생성하기import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;import &#123; composeWithDevTools &#125; from &#x27;redux-devtools-extension&#x27;; import &#123; createStore &#125; from &#x27;redux&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;import LoginReducer from &#x27;./redux/reducers/LoginReducer&#x27;const store = createStore(LoginReducer, composeWithDevTools())ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&#x27;root&#x27;));// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals(); Dispatch 함수 적용import axios from &quot;axios&quot;;import &#123; useDispatch &#125; from &quot;react-redux&quot;;import &#123; loginRequest &#125; from &quot;../redux/reducers/LoginReducer&quot;;import React, &#123; useState, useCallback &#125; from &quot;react&quot;;import &#123; LoginBody, LoginFooter, LoginHeader, ModalBackGround, ModalBox,&#125; from &quot;../assets/css/login&quot;;const LoginTemplate = (&#123; open, close &#125;) =&gt; &#123; const [form, setForm] = useState(&#123; email: &quot;&quot;, password: &quot;&quot;, &#125;); const onChange = useCallback( (e) =&gt; &#123; setForm(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;, [form] ); const dispatch = useDispatch(); const onClick = useCallback(() =&gt; &#123; dispatch(loginRequest(form)); &#125;); return open ? ( &lt;ModalBackGround&gt; &lt;ModalBox&gt; &lt;LoginHeader&gt; 로그인 &lt;button className=&quot;close&quot; onClick=&#123;close&#125;&gt; &#123;&quot; &quot;&#125; &amp;times;&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/LoginHeader&gt; &lt;LoginBody className=&quot;login-body&quot;&gt; &lt;div&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;/LoginBody&gt; &lt;LoginFooter&gt; &lt;button onClick=&#123;onClick&#125;&gt;로그인&lt;/button&gt; &lt;/LoginFooter&gt; &lt;/ModalBox&gt; &lt;/ModalBackGround&gt; ) : null;&#125;;export default LoginTemplate;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"}],"tags":[]},{"title":"React 로그인 Modal 만들기 7 - JWT 적용하기","slug":"react/login/login-modal-07-back-jwt","date":"2021-10-23T08:10:40.000Z","updated":"2024-11-23T16:46:04.178Z","comments":true,"path":"2021/10/23/react/login/login-modal-07-back-jwt/","link":"","permalink":"https://ckck803.github.io/2021/10/23/react/login/login-modal-07-back-jwt/","excerpt":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 7 - JWT 적용하기Properties에 JWT 설정 값 추가JWT 를 암호화 하기 위한 key 값, token의 유효시간을 정의하기 위한 값, 그리고 토큰을 Http Header에 저장하기 위핸 Header Key를 정의해준다. application.yml jwt: header: Authorization secret: c2lsdmVybmluZS10ZWNoLXNwcmluZy1ib290LWp3dC10dXRvcmlhbC1zZWNyZXQtc2lsdmVybmluZS10ZWNoLXNwcmluZy1ib290LWp3dC10dXRvcmlhbC1zZWNyZXQK token-validity-in-seconds: 86400000 JWT를 다루기 위한 JwtUtils 생성 JwtUtils에서는 createToken 메소드를 이용해 새로운 JWT를 만들고 validateToken 메소드를 이용해 전달 받은 JWT의 유효성을 검증하고 getAuthentication 메소드를 이용해 전달 받은 JWT로부터 Authentication 객체를 가져오도록 한다. Jwts.builder 를 이용해 JWT를 생성하고 Jwts.parser 를 이용해 JWT로부터 정보를 가져온다. Value 어노테이션을 이용해 Properties에 저장한 token을 암호화 하기 위한 Key값과 token 유효시간 정보를 가져온다.","text":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 7 - JWT 적용하기Properties에 JWT 설정 값 추가JWT 를 암호화 하기 위한 key 값, token의 유효시간을 정의하기 위한 값, 그리고 토큰을 Http Header에 저장하기 위핸 Header Key를 정의해준다. application.yml jwt: header: Authorization secret: c2lsdmVybmluZS10ZWNoLXNwcmluZy1ib290LWp3dC10dXRvcmlhbC1zZWNyZXQtc2lsdmVybmluZS10ZWNoLXNwcmluZy1ib290LWp3dC10dXRvcmlhbC1zZWNyZXQK token-validity-in-seconds: 86400000 JWT를 다루기 위한 JwtUtils 생성 JwtUtils에서는 createToken 메소드를 이용해 새로운 JWT를 만들고 validateToken 메소드를 이용해 전달 받은 JWT의 유효성을 검증하고 getAuthentication 메소드를 이용해 전달 받은 JWT로부터 Authentication 객체를 가져오도록 한다. Jwts.builder 를 이용해 JWT를 생성하고 Jwts.parser 를 이용해 JWT로부터 정보를 가져온다. Value 어노테이션을 이용해 Properties에 저장한 token을 암호화 하기 위한 Key값과 token 유효시간 정보를 가져온다. JwtUtils.java @Component@Slf4jpublic class JwtUtils &#123; @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secretKey; @Value(&quot;$&#123;jwt.token-validity-in-seconds&#125;&quot;) private Long tokenValidityInMilliseconds; public String createToken(Authentication authentication)&#123; String authorities = authentication.getAuthorities().stream() .map((autority) -&gt; autority.getAuthority()) .collect(Collectors.joining(&quot;,&quot;)); Long now = (new Date()).getTime(); Date validity = new Date(now + this.tokenValidityInMilliseconds); String JsonWebToken = Jwts.builder() .setSubject(authentication.getName()) .claim(&quot;auth&quot;, authorities) .signWith(SignatureAlgorithm.HS512, secretKey) .setExpiration(validity) .compact(); return JsonWebToken; &#125; public Authentication getAuthentication(String token)&#123; Claims claims = Jwts .parser() .setSigningKey(secretKey) .parseClaimsJws(token) .getBody(); Collection&lt;? extends GrantedAuthority&gt; authorities = Arrays.stream(claims.get(&quot;auth&quot;).toString().split(&quot;,&quot;)) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); User principal = new User(claims.getSubject(), &quot;&quot;, authorities); return new JsonAuthenticationToken(principal, token, authorities); &#125; public boolean validateToken(String token)&#123; try&#123; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token); return true; &#125;catch (Exception e)&#123; log.info(&quot;JWT 토큰이 잘못되었습니다.&quot;); &#125; return false; &#125;&#125; JWT를 이용한 인증 Filter JwtAuthenticationFilter 에서는 Request Header 정보를 확인해 JWT가 전달 받았는지 확인하고, 전달 받은 JWT 의 유효성을 검증 한 후 Authentication 객체를 생성해 SecurityContext에 저장하는 절차를 거친다. JwtAuthenticationFilter.java @Component@RequiredArgsConstructorpublic class JwtAuthenticationFilter extends OncePerRequestFilter &#123; public final JwtUtils jwtUtils; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String token = null; String authorizationHeader = request.getHeader(&quot;authorization&quot;); if(authorizationHeader != null &amp;&amp; authorizationHeader.startsWith(&quot;Bearer &quot;))&#123; token = authorizationHeader.substring(7); &#125; if(token != null &amp;&amp; jwtUtils.validateToken(token))&#123; Authentication authentication = jwtUtils.getAuthentication(token); SecurityContextHolder.getContext().setAuthentication(authentication); &#125; filterChain.doFilter(request, response); &#125;&#125; 인증 후 JWT 만들기 사용자 인증이 끝나고 JWT를 만들어 주기 위해 JsonAuthenticationSuccessHandler 를 이용해 인증이 정상적으로 완료된 후 생성된 Authentication 객체를 이용해 JWT 를 만들어 준다. JsonAuthenticationSuccessHandler.java @RequiredArgsConstructorpublic class JsonAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; private final ObjectMapper objectMapper; private final JwtUtils jwtUtils; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; try &#123; UserDetails userDetails = (UserDetails) authentication.getPrincipal(); String jwt = jwtUtils.createToken(authentication); HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.add(&quot;Authorization&quot;, &quot;Bearer &quot; + jwt); response.setStatus(HttpStatus.OK.value()); objectMapper.writeValue(response.getWriter(), jwt); &#125; catch (Exception e) &#123; throw new ServletException(&quot;inavalid username/password&quot;); &#125; &#125;&#125; JWT를 사용하기 위한 Config 구성하기 JwtSecurityConfig 에서는 JWT 를 다루기 위한 JwtUtils 와 JWT를 이용해 인증을 진행하기 위한 JwtAuthenticationFilter 를 Bean으로 등록해 UsernamePasswordAuthenticationFilter 앞에 위치하도록 한다. @Configuration@EnableWebSecurity@RequiredArgsConstructor@Order(1)public class JwtSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public JwtAuthenticationFilter jwtAuthenticationFilter()&#123; return new JwtAuthenticationFilter(jwtUtils()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable(); http .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); &#125; @Bean public JwtUtils jwtUtils()&#123; return new JwtUtils(); &#125;&#125;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"}],"tags":[]},{"title":"React 로그인 Modal 만들기 6 - Login 구현","slug":"react/login/login-modal-06-back-login","date":"2021-10-22T07:10:40.000Z","updated":"2024-11-23T16:46:04.497Z","comments":true,"path":"2021/10/22/react/login/login-modal-06-back-login/","link":"","permalink":"https://ckck803.github.io/2021/10/22/react/login/login-modal-06-back-login/","excerpt":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 6 - Login 구현Json 인증 Filter 구현하기UsernamePasswordAuthenticationFilter 의 경우 Form Login을 위해 구현된 Filter라 Request Body로 요청이 들어오는 Login 요청을 적용하기는 어렵기에 JSON 을 이용해 Login을 진행할 수 있도록 JsonAuthenticationFilter 를 새로 만들어줄 필요가 있다. UsernamePasswordAuthenticationFilter 와 인증을 진행하는 과정은 비슷하므로 AbstractAuthenticationProcessingFilter 를 상속해 새로운 Filter를 생성해준다. JsonAuthenticationFilter.java public class JsonAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123; private static final String LOGIN_PROCESSING_URL = &quot;/api/login&quot;; @Autowired private ObjectMapper objectMapper; public JsonAuthenticationFilter() &#123; super(new AntPathRequestMatcher(LOGIN_PROCESSING_URL)); &#125; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException &#123; if(!isApplicationJSON(request))&#123; throw new IllegalStateException(&quot;Content Type is not Application/json&quot;); &#125; LoginDto loginDto = objectMapper.readValue(request.getReader(), LoginDto.class); if(ObjectUtils.isEmpty(loginDto.getUsername()) || ObjectUtils.isEmpty(loginDto.getPassword()))&#123; throw new IllegalArgumentException(&quot;Username or Password is empty&quot;); &#125; JsonAuthenticationToken jsonAuthenticationToken = new JsonAuthenticationToken(loginDto.getUsername(), loginDto.getPassword()); getAuthenticationManager().authenticate(jsonAuthenticationToken); return null; &#125; private boolean isApplicationJSON(HttpServletRequest httpServletRequest)&#123; if(httpServletRequest.getHeader(&quot;Content-type&quot;).equals(MediaType.APPLICATION_JSON_VALUE))&#123; return true; &#125; return false; &#125;&#125; 새로운 Authentication Token 만들기 JsonAuthenticationFilter 에서 사용하기 위한 새로운 Authentication 생성","text":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 6 - Login 구현Json 인증 Filter 구현하기UsernamePasswordAuthenticationFilter 의 경우 Form Login을 위해 구현된 Filter라 Request Body로 요청이 들어오는 Login 요청을 적용하기는 어렵기에 JSON 을 이용해 Login을 진행할 수 있도록 JsonAuthenticationFilter 를 새로 만들어줄 필요가 있다. UsernamePasswordAuthenticationFilter 와 인증을 진행하는 과정은 비슷하므로 AbstractAuthenticationProcessingFilter 를 상속해 새로운 Filter를 생성해준다. JsonAuthenticationFilter.java public class JsonAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123; private static final String LOGIN_PROCESSING_URL = &quot;/api/login&quot;; @Autowired private ObjectMapper objectMapper; public JsonAuthenticationFilter() &#123; super(new AntPathRequestMatcher(LOGIN_PROCESSING_URL)); &#125; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException &#123; if(!isApplicationJSON(request))&#123; throw new IllegalStateException(&quot;Content Type is not Application/json&quot;); &#125; LoginDto loginDto = objectMapper.readValue(request.getReader(), LoginDto.class); if(ObjectUtils.isEmpty(loginDto.getUsername()) || ObjectUtils.isEmpty(loginDto.getPassword()))&#123; throw new IllegalArgumentException(&quot;Username or Password is empty&quot;); &#125; JsonAuthenticationToken jsonAuthenticationToken = new JsonAuthenticationToken(loginDto.getUsername(), loginDto.getPassword()); getAuthenticationManager().authenticate(jsonAuthenticationToken); return null; &#125; private boolean isApplicationJSON(HttpServletRequest httpServletRequest)&#123; if(httpServletRequest.getHeader(&quot;Content-type&quot;).equals(MediaType.APPLICATION_JSON_VALUE))&#123; return true; &#125; return false; &#125;&#125; 새로운 Authentication Token 만들기 JsonAuthenticationFilter 에서 사용하기 위한 새로운 Authentication 생성 JsonAuthenticationToken.java public class JsonAuthenticationToken extends AbstractAuthenticationToken &#123; private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; private final Object principal; private Object credentials; public JsonAuthenticationToken(Object principal, Object credentials) &#123; super(null); this.principal = principal; this.credentials = credentials; setAuthenticated(false); &#125; public JsonAuthenticationToken(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(authorities); this.principal = principal; this.credentials = credentials; super.setAuthenticated(true); &#125; @Override public Object getCredentials() &#123; return this.credentials; &#125; @Override public Object getPrincipal() &#123; return this.principal; &#125; @Override public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException &#123; Assert.isTrue(!isAuthenticated, &quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;); super.setAuthenticated(false); &#125; @Override public void eraseCredentials() &#123; super.eraseCredentials(); this.credentials = null; &#125;&#125; JsonAuthenticationToken 객체 인증을 위한 AuthenticationProvider 생성 JsonAuthenticationToken 객체를 이용해 인증을 진행할 수 있도록 새로운 AuthenticationProvider 를 생성한다. supports 메소드에서 전달받은 Authentication 객체 타입이 JsonAuthenticationToken 인지 확인 authenticate 메소드에서 전달받은 Authentication 객체를 이용해 인증을 진행 한 후 새로운 JsonAuthenticationToken 객체 생성 JsonAuthenticationProvider.java @RequiredArgsConstructorpublic class JsonAuthenticationProvider implements AuthenticationProvider &#123; private final PasswordEncoder passwordEncoder; private final UserDetailsService userDetailsService; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; String username = authentication.getName(); String password = (String) authentication.getCredentials(); UserDetails loadUserByUsername = userDetailsService.loadUserByUsername(username); if(!passwordEncoder.matches(password, loadUserByUsername.getPassword()))&#123; throw new BadCredentialsException(&quot;Invalid password&quot;); &#125; return new JsonAuthenticationToken(loadUserByUsername, authentication.getCredentials(), loadUserByUsername.getAuthorities()); &#125; @Override public boolean supports(Class&lt;?&gt; authentication) &#123; return authentication.equals(JsonAuthenticationToken.class); &#125;&#125; 인증 성공 후 처리릉 위한 SuccessHandler 생성 AuthenticationSuccessHandler 를 구현해 인증에 성꽁하면 HttpStatus 200(OK) 를 반환하도록 한다. JsonAuthenticationSuccessHandler.java @RequiredArgsConstructorpublic class JsonAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; try &#123; response.setStatus(HttpStatus.OK.value()); &#125; catch (Exception e) &#123; throw new ServletException(&quot;inavalid username/password&quot;); &#125; &#125;&#125; Security Config 추가 하기로그인으로 Json 데이터가 왔을 때 인증을 진행하기 위해 새로 만든 JsonAuthenticationFilter , JsonAuthenticationProvider , JsonAuthenticationSuccessHandler 를 Bean으로 등록해 인증에서 사용할 수 있도록 한다. @Configuration@EnableWebSecurity@Order(0)@RequiredArgsConstructorpublic class JsonSecurityConfig extends WebSecurityConfigurerAdapter &#123; private final UserInfoRepository userInfoRepository; private final ObjectMapper objectMapper; private final JwtUtils jwtUtils; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth .authenticationProvider(authenticationProvider()) .userDetailsService(userDetailsService()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable(); http .addFilterBefore(jsonAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Bean public UserDetailsService userDetailsService() &#123; return new UserInfoService(userInfoRepository, passwordEncoder()); &#125; @Bean public AuthenticationProvider authenticationProvider() &#123; return new JsonAuthenticationProvider(passwordEncoder(), userDetailsService()); &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Bean public JsonAuthenticationSuccessHandler jsonAuthenticationSuccessHandler()&#123; return new JsonAuthenticationSuccessHandler(objectMapper, jwtUtils); &#125; @Bean public JsonAuthenticationFilter jsonAuthenticationFilter() throws Exception &#123; JsonAuthenticationFilter jsonAuthenticationFilter = new JsonAuthenticationFilter(); jsonAuthenticationFilter.setAuthenticationManager(authenticationManagerBean()); jsonAuthenticationFilter.setAuthenticationSuccessHandler(jsonAuthenticationSuccessHandler()); return jsonAuthenticationFilter; &#125;&#125;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"}],"tags":[]},{"title":"React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현","slug":"react/login/login-modal-05-back-signup","date":"2021-10-21T06:10:40.000Z","updated":"2024-11-23T16:46:04.326Z","comments":true,"path":"2021/10/21/react/login/login-modal-05-back-signup/","link":"","permalink":"https://ckck803.github.io/2021/10/21/react/login/login-modal-05-back-signup/","excerpt":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현회원 데이터를 저장할 UserInfo 정의회원 가입을 위해 사용자 id, username, email, password와 사용자 별로 권한을 관리하기 위한 UserInfo 객체를 관리하도록 정의 @Entity@NoArgsConstructor@AllArgsConstructor@Getter@Builderpublic class UserInfo &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String username; @Column(nullable = false) private String email; @Column(nullable = false) private String password; @Enumerated(EnumType.STRING) private UserRole userRole;&#125; User 권한 목록 권한은 3가지로 일반사용자를 위한 USER 권한, 수정&#x2F;변경 권한이 있는 MANAGER 권한과 관리자인 ADMIN 3가지 권한으로 분류 한다 public enum UserRole &#123; USER(&quot;ROLE_USER&quot;), MANAGER(&quot;ROLE_MANAGER&quot;), ADMIN(&quot;ROLE_ADMIN&quot;); private String value; UserRole(String value)&#123; this.value = value; &#125; public String getValue()&#123; return this.value; &#125;&#125; 사용자 이름과 Email을 이용해 사용자 정보를 가져올 수 있도록 메소드를 추가한다.","text":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현회원 데이터를 저장할 UserInfo 정의회원 가입을 위해 사용자 id, username, email, password와 사용자 별로 권한을 관리하기 위한 UserInfo 객체를 관리하도록 정의 @Entity@NoArgsConstructor@AllArgsConstructor@Getter@Builderpublic class UserInfo &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String username; @Column(nullable = false) private String email; @Column(nullable = false) private String password; @Enumerated(EnumType.STRING) private UserRole userRole;&#125; User 권한 목록 권한은 3가지로 일반사용자를 위한 USER 권한, 수정&#x2F;변경 권한이 있는 MANAGER 권한과 관리자인 ADMIN 3가지 권한으로 분류 한다 public enum UserRole &#123; USER(&quot;ROLE_USER&quot;), MANAGER(&quot;ROLE_MANAGER&quot;), ADMIN(&quot;ROLE_ADMIN&quot;); private String value; UserRole(String value)&#123; this.value = value; &#125; public String getValue()&#123; return this.value; &#125;&#125; 사용자 이름과 Email을 이용해 사용자 정보를 가져올 수 있도록 메소드를 추가한다. @Repositorypublic interface UserInfoRepository extends JpaRepository&lt;UserInfo, String&gt; &#123; Optional&lt;UserInfo&gt; findByUsername(String useranme); Optional&lt;UserInfo&gt; findByEmail(String email);&#125; 회원 가입을 위해 사용하는 DTO 객체를 정의한다. @Datapublic class UserInfoDto &#123; private String username; private String email; private String password;&#125; UserDetailsService 정의 UserDetailsService 에는 사용자 정보를 가져오기 위한 loadUserByUsername 만 있어 새로운 사용자를 저장하기 위해 UserDetailsService 를 상속한 UserInfoService 에 saveUserInfo 메소드를 추가했다 public interface UserInfoService extends UserDetailsService &#123; public UserInfo saveUserInfo(SignupDto signupDto);&#125; loadUserByUsername 메소드는 전달 받은 Email을 이용해 사용자 정보를 가져온 후 UserDetails 객체를 만들어 준다. saveUserInfo 메소드에서는 전달 받은 SignupDto 객체로부터 새로운 UserInfo 객체를 생성할 때 PasswordEncoder 를 이용해 Password를 암호화 한 뒤 저장한다. @RequiredArgsConstructorpublic class UserInfoServiceImpl implements UserInfoService &#123; private final UserInfoRepository userInfoRepository; private final PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException &#123; Optional&lt;UserInfo&gt; userInfoOptional = userInfoRepository.findByEmail(email); if(userInfoOptional.isPresent())&#123; UserInfo userInfo = userInfoOptional.get(); List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList(userInfo.getUserRole().getValue()); return new User(userInfo.getEmail(), userInfo.getPassword(), authorities); &#125;else&#123; return null; &#125; &#125; public UserInfo saveUserInfo(SignupDto signupDto)&#123; UserInfo userInfo = UserInfo .builder() .username(signupDto.getUsername()) .email(signupDto.getEmail()) .password(passwordEncoder.encode(signupDto.getPassword())) .userRole(UserRole.USER).build(); return userInfoRepository.save(userInfo); &#125;&#125; 회원 가입을 위한 Controller 추가@RestController@RequiredArgsConstructorpublic class UserInfoController &#123; private final UserInfoService userInfoService; @GetMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;Hello World&quot;; &#125; @PostMapping(&quot;/api/signup&quot;) public ResponseEntity signUp(@RequestBody UserInfoDto userInfoDto) &#123; UserInfo userInfo = UserInfo.builder().username(userInfoDto.getUsername()).email(userInfoDto.getEmail()) .password(userInfoDto.getPassword()).userRole(UserRole.USER).build(); UserInfo createdUser = userInfoService.saveUserInfo(userInfo); URI uri = ServletUriComponentsBuilder.fromCurrentContextPath().path(&quot;/&#123;id&#125;&quot;).buildAndExpand(createdUser.getId()) .toUri(); return ResponseEntity.created(uri).body(createdUser); &#125;&#125; Spring Security 설정하기configure(WebSecurity web) 를 이용해 정적 자원에 대한 접근이 가능하도록 하고, configure(HttpSecurity http) 를 이용해 개발 URL 별로 접근을 설정한다. 테스트를 진행하면서 Ajax를 이용해 Spring Security에 접그하기 위해서 CORS 문제가 발생하지 않도록 하기 위해 CORS에 대한 설정도 추가해 준다. @Configuration@EnableWebSecurity@Order(2)public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(WebSecurity web) &#123; web .ignoring() .requestMatchers(PathRequest.toStaticResources().atCommonLocations()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(&quot;/api/signup&quot;).permitAll() .anyRequest().authenticated(); http .csrf().disable() .cors().configurationSource(corsConfigurationSource()); http .formLogin().disable(); &#125; @Bean public CorsConfigurationSource corsConfigurationSource() &#123; CorsConfiguration configuration = new CorsConfiguration(); // configuration.addAllowedOrigin(&quot;*&quot;); configuration.addAllowedOriginPattern(&quot;*&quot;); configuration.addAllowedHeader(&quot;*&quot;); configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;, &quot;DELETE&quot;, &quot;PUT&quot;, &quot;PATCH&quot;)); configuration.setAllowCredentials(true); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, configuration); return source; &#125;&#125; Spring Security에 CORS를 적용하면서 발생했던 문제 java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value “*” since that cannot be set on the “Access-Control-Allow-Origin” response header. To allow credentials to a set of origins, list them explicitly or consider using “allowedOriginPatterns” instead. Spring Seurity에 CORS 설정을 진행하면서 위와 같음 문제가 계속 발생했다. 해당 원인에 대해 찾아보니 CorsConfiguration 에 대한 설정으로 setAllowCredentials(true) 와 addAllowedOrigin(“*”) 를 동시에 설정해서 발생하는 문제였다. 해결 방법은 addAllowedOrigin(“*”) 대신 addAllowedOriginPattern(“*”) 를 사용하면 문제가 해결 된다. 참조https://code-delivery.me/posts/2021-03-16/https://github.com/spring-projects/spring-framework/issues/26111","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"}],"tags":[]},{"title":"React 로그인 Modal 만들기 4 - 비동기 처리","slug":"react/login/login-modal-04-async","date":"2021-10-20T04:10:40.000Z","updated":"2024-11-23T16:46:04.397Z","comments":true,"path":"2021/10/20/react/login/login-modal-04-async/","link":"","permalink":"https://ckck803.github.io/2021/10/20/react/login/login-modal-04-async/","excerpt":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 4 - 비동기 처리import axios from &quot;axios&quot;;import React, &#123; useState, useCallback &#125; from &quot;react&quot;;import &#123; LoginBody, LoginFooter, LoginHeader, ModalBackGround, ModalBox,&#125; from &quot;../assets/css/login&quot;;const LoginTemplate = (&#123; open, close &#125;) =&gt; &#123; const [form, setForm] = useState(&#123; email: &quot;&quot;, password: &quot;&quot;, &#125;); const onChange = useCallback( (e) =&gt; &#123; setForm(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;, [form] ); const onClick = useCallback( (e) =&gt; &#123; axios .post(&quot;/api/login&quot;, form) .then((response) =&gt; &#123; console.log(response); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); &#125;, [form] ); return open ? ( &lt;ModalBackGround&gt; &lt;ModalBox&gt; &lt;LoginHeader&gt; 로그인 &lt;button className=&quot;close&quot; onClick=&#123;close&#125;&gt; &#123;&quot; &quot;&#125; &amp;times;&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/LoginHeader&gt; &lt;LoginBody className=&quot;login-body&quot;&gt; &lt;div&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;/LoginBody&gt; &lt;LoginFooter&gt; &lt;button onClick=&#123;onClick&#125;&gt;로그인&lt;/button&gt; &lt;/LoginFooter&gt; &lt;/ModalBox&gt; &lt;/ModalBackGround&gt; ) : null;&#125;;export default LoginTemplate; import React, &#123; useCallback, useState &#125; from &quot;react&quot;;import &#123; ModalBox &#125; from &quot;../assets/css/login&quot;;import axios from &quot;axios&quot;;import &#123; ModalBackGround, SignUpBody, SignUpFooter, SignUpHeader,&#125; from &quot;../assets/css/signup&quot;;const SignUpTemplate = (&#123; open, onChangeOpen &#125;) =&gt; &#123; const [form, setForm] = useState(&#123; username: &quot;&quot;, email: &quot;&quot;, password: &quot;&quot;, &#125;); const onChange = useCallback( (e) =&gt; &#123; setForm(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;, [form] ); const onClickSignUp = useCallback(() =&gt; &#123; axios.post(&quot;/api/signup&quot;, form).then((Response) =&gt; &#123; console.log(Response); &#125;); &#125;, [form]); return open ? ( &lt;ModalBackGround className=&quot;signup-modal-box&quot;&gt; &lt;ModalBox&gt; &lt;SignUpHeader&gt; 회원 가입 &lt;button className=&quot;close&quot; onClick=&#123;onChangeOpen&#125;&gt; &#123;&quot; &quot;&#125; &amp;times;&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/SignUpHeader&gt; &lt;SignUpBody&gt; &lt;div&gt; &lt;input type=&quot;username&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;이름&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;/SignUpBody&gt; &lt;SignUpFooter&gt; &lt;button onClick=&#123;onClickSignUp&#125;&gt;회원가입&lt;/button&gt; &lt;/SignUpFooter&gt; &lt;/ModalBox&gt; &lt;/ModalBackGround&gt; ) : null;&#125;;export default SignUpTemplate;","text":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 4 - 비동기 처리import axios from &quot;axios&quot;;import React, &#123; useState, useCallback &#125; from &quot;react&quot;;import &#123; LoginBody, LoginFooter, LoginHeader, ModalBackGround, ModalBox,&#125; from &quot;../assets/css/login&quot;;const LoginTemplate = (&#123; open, close &#125;) =&gt; &#123; const [form, setForm] = useState(&#123; email: &quot;&quot;, password: &quot;&quot;, &#125;); const onChange = useCallback( (e) =&gt; &#123; setForm(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;, [form] ); const onClick = useCallback( (e) =&gt; &#123; axios .post(&quot;/api/login&quot;, form) .then((response) =&gt; &#123; console.log(response); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); &#125;, [form] ); return open ? ( &lt;ModalBackGround&gt; &lt;ModalBox&gt; &lt;LoginHeader&gt; 로그인 &lt;button className=&quot;close&quot; onClick=&#123;close&#125;&gt; &#123;&quot; &quot;&#125; &amp;times;&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/LoginHeader&gt; &lt;LoginBody className=&quot;login-body&quot;&gt; &lt;div&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;/LoginBody&gt; &lt;LoginFooter&gt; &lt;button onClick=&#123;onClick&#125;&gt;로그인&lt;/button&gt; &lt;/LoginFooter&gt; &lt;/ModalBox&gt; &lt;/ModalBackGround&gt; ) : null;&#125;;export default LoginTemplate; import React, &#123; useCallback, useState &#125; from &quot;react&quot;;import &#123; ModalBox &#125; from &quot;../assets/css/login&quot;;import axios from &quot;axios&quot;;import &#123; ModalBackGround, SignUpBody, SignUpFooter, SignUpHeader,&#125; from &quot;../assets/css/signup&quot;;const SignUpTemplate = (&#123; open, onChangeOpen &#125;) =&gt; &#123; const [form, setForm] = useState(&#123; username: &quot;&quot;, email: &quot;&quot;, password: &quot;&quot;, &#125;); const onChange = useCallback( (e) =&gt; &#123; setForm(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;, [form] ); const onClickSignUp = useCallback(() =&gt; &#123; axios.post(&quot;/api/signup&quot;, form).then((Response) =&gt; &#123; console.log(Response); &#125;); &#125;, [form]); return open ? ( &lt;ModalBackGround className=&quot;signup-modal-box&quot;&gt; &lt;ModalBox&gt; &lt;SignUpHeader&gt; 회원 가입 &lt;button className=&quot;close&quot; onClick=&#123;onChangeOpen&#125;&gt; &#123;&quot; &quot;&#125; &amp;times;&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/SignUpHeader&gt; &lt;SignUpBody&gt; &lt;div&gt; &lt;input type=&quot;username&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;이름&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;/SignUpBody&gt; &lt;SignUpFooter&gt; &lt;button onClick=&#123;onClickSignUp&#125;&gt;회원가입&lt;/button&gt; &lt;/SignUpFooter&gt; &lt;/ModalBox&gt; &lt;/ModalBackGround&gt; ) : null;&#125;;export default SignUpTemplate;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"}],"tags":[]},{"title":"React 로그인 Modal 만들기 3 - 회원 가입","slug":"react/login/login-modal-03-signup","date":"2021-10-19T03:10:40.000Z","updated":"2024-11-23T16:46:04.036Z","comments":true,"path":"2021/10/19/react/login/login-modal-03-signup/","link":"","permalink":"https://ckck803.github.io/2021/10/19/react/login/login-modal-03-signup/","excerpt":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 3 - 회원 가입import styled, &#123; keyframes &#125; from &quot;styled-components&quot;;export const ModalFade = keyframes`&#123; from &#123; opacity: 0; margin-top: -50px; &#125; to &#123; opacity: 1; margin-top: 0; &#125;&#125;`;export const ModalBackGround = styled.div` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; animation: modal-bg-show 0.3s;`;export const ModalBox = styled.div` width: 90%; max-width: 400px; margin: 0 auto; border-radius: 0.3rem; background-color: #fff; animation: ModalFade 0.3s; overflow: hidden;`;export const SignUpHeader = styled.div` position: relative; padding: 16px 64px 16px 16px; background-color: #f1f1f1; font-weight: 700; &amp; &gt; button &#123; position: absolute; top: 15px; right: 15px; width: 30px; font-size: 21px; font-weight: 700; text-align: center; color: #999; border: 0; &#125;`;export const SignUpBody = styled.div` padding: 10px; &amp; &gt; div &#123; padding: 5px; display: flex; align-items: center; justify-content: center; &#125; &amp; &gt; div &gt; input &#123; padding-top: 5px; padding-bottom: 5px; padding-left: 15px; padding-right: 15px; width: 290px; height: 30px; font-size: 14px; border: 1px solid rgb(222, 226, 230); &#125;`;export const SignUpFooter = styled.div` border-top: 1px solid; padding: 7px 16px; text-align: right; &amp; &gt; button &#123; padding: 6px 12px; color: #fff; background-color: #6c757d; border-radius: 5px; font-size: 13px; &#125;`; import React, &#123; useCallback, useState &#125; from &quot;react&quot;;import &#123; ModalBox &#125; from &quot;../assets/css/login&quot;;import &#123; ModalBackGround, SignUpBody, SignUpFooter, SignUpHeader,&#125; from &quot;../assets/css/signup&quot;;const SignUpTemplate = (&#123; open, onChangeOpen &#125;) =&gt; &#123; const [form, setForm] = useState(&#123; username: &quot;&quot;, email: &quot;&quot;, password: &quot;&quot;, &#125;); const onChange = useCallback( (e) =&gt; &#123; setForm(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;, [form] ); return open ? ( &lt;ModalBackGround className=&quot;signup-modal-box&quot;&gt; &lt;ModalBox&gt; &lt;SignUpHeader&gt; 회원 가입 &lt;button className=&quot;close&quot; onClick=&#123;onChangeOpen&#125;&gt; &#123;&quot; &quot;&#125; &amp;times;&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/SignUpHeader&gt; &lt;SignUpBody&gt; &lt;div&gt; &lt;input type=&quot;username&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;이름&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;/SignUpBody&gt; &lt;SignUpFooter&gt; &lt;button onClick=&#123;onChangeOpen&#125;&gt;닫기&lt;/button&gt; &lt;/SignUpFooter&gt; &lt;/ModalBox&gt; &lt;/ModalBackGround&gt; ) : null;&#125;;export default SignUpTemplate;","text":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 3 - 회원 가입import styled, &#123; keyframes &#125; from &quot;styled-components&quot;;export const ModalFade = keyframes`&#123; from &#123; opacity: 0; margin-top: -50px; &#125; to &#123; opacity: 1; margin-top: 0; &#125;&#125;`;export const ModalBackGround = styled.div` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; animation: modal-bg-show 0.3s;`;export const ModalBox = styled.div` width: 90%; max-width: 400px; margin: 0 auto; border-radius: 0.3rem; background-color: #fff; animation: ModalFade 0.3s; overflow: hidden;`;export const SignUpHeader = styled.div` position: relative; padding: 16px 64px 16px 16px; background-color: #f1f1f1; font-weight: 700; &amp; &gt; button &#123; position: absolute; top: 15px; right: 15px; width: 30px; font-size: 21px; font-weight: 700; text-align: center; color: #999; border: 0; &#125;`;export const SignUpBody = styled.div` padding: 10px; &amp; &gt; div &#123; padding: 5px; display: flex; align-items: center; justify-content: center; &#125; &amp; &gt; div &gt; input &#123; padding-top: 5px; padding-bottom: 5px; padding-left: 15px; padding-right: 15px; width: 290px; height: 30px; font-size: 14px; border: 1px solid rgb(222, 226, 230); &#125;`;export const SignUpFooter = styled.div` border-top: 1px solid; padding: 7px 16px; text-align: right; &amp; &gt; button &#123; padding: 6px 12px; color: #fff; background-color: #6c757d; border-radius: 5px; font-size: 13px; &#125;`; import React, &#123; useCallback, useState &#125; from &quot;react&quot;;import &#123; ModalBox &#125; from &quot;../assets/css/login&quot;;import &#123; ModalBackGround, SignUpBody, SignUpFooter, SignUpHeader,&#125; from &quot;../assets/css/signup&quot;;const SignUpTemplate = (&#123; open, onChangeOpen &#125;) =&gt; &#123; const [form, setForm] = useState(&#123; username: &quot;&quot;, email: &quot;&quot;, password: &quot;&quot;, &#125;); const onChange = useCallback( (e) =&gt; &#123; setForm(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;, [form] ); return open ? ( &lt;ModalBackGround className=&quot;signup-modal-box&quot;&gt; &lt;ModalBox&gt; &lt;SignUpHeader&gt; 회원 가입 &lt;button className=&quot;close&quot; onClick=&#123;onChangeOpen&#125;&gt; &#123;&quot; &quot;&#125; &amp;times;&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/SignUpHeader&gt; &lt;SignUpBody&gt; &lt;div&gt; &lt;input type=&quot;username&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;이름&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;/SignUpBody&gt; &lt;SignUpFooter&gt; &lt;button onClick=&#123;onChangeOpen&#125;&gt;닫기&lt;/button&gt; &lt;/SignUpFooter&gt; &lt;/ModalBox&gt; &lt;/ModalBackGround&gt; ) : null;&#125;;export default SignUpTemplate;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"}],"tags":[]},{"title":"React 로그인 Modal 만들기 2 - styled-component 사용하기","slug":"react/login/login-modal-02-styled-component","date":"2021-10-18T02:10:40.000Z","updated":"2024-11-23T16:46:04.655Z","comments":true,"path":"2021/10/18/react/login/login-modal-02-styled-component/","link":"","permalink":"https://ckck803.github.io/2021/10/18/react/login/login-modal-02-styled-component/","excerpt":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 2 - styled-component 사용하기기존에 style 내용들을 css 파일로 관리해도 문제가 없으나, React에서는 style마저도 js파일로 관리할 수 있도록 지원해주는 다양한 프레임 워크들이 있다. js파일로 관리하게 되면 React의 여러 기능을 사용하기 좋기 때문에 기존에 작성해준 Login 관련 css 내용을 js 파일로 변경하려고 한다. import styled, &#123; keyframes &#125; from &quot;styled-components&quot;;export const ModalFade = keyframes`&#123; from &#123; opacity: 0; margin-top: -50px; &#125; to &#123; opacity: 1; margin-top: 0; &#125;&#125;`;export const ModalBackGround = styled.div` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center;`;export const ModalBox = styled.div` width: 90%; max-width: 400px; margin: 0 auto; border-radius: 0.3rem; background-color: #fff; animation: $&#123;ModalFade&#125; 0.5s; overflow: hidden;`;export const LoginHeader = styled.div` position: relative; padding: 16px 64px 16px 16px; background-color: #f1f1f1; font-weight: 700; &amp; &gt; button &#123; position: absolute; top: 15px; right: 15px; width: 30px; font-size: 21px; font-weight: 700; text-align: center; color: #999; border: 0; &#125;`;export const LoginBody = styled.div` padding: 10px; &amp; &gt; div &#123; padding: 5px; display: flex; align-items: center; justify-content: center; &#125; &amp; &gt; div &gt; input &#123; padding-top: 5px; padding-bottom: 5px; padding-left: 15px; padding-right: 15px; width: 290px; height: 30px; font-size: 14px; border: 1px solid rgb(222, 226, 230); &#125;`;export const LoginFooter = styled.div` border-top: 1px solid rgb(222, 226, 230); padding: 7px 16px; text-align: right; &amp; &gt; button &#123; padding: 6px 12px; color: #fff; background-color: #6c757d; border-radius: 5px; font-size: 13px; &#125;`; Styled-Component 적용하기import React, &#123; useState, useCallback &#125; from &quot;react&quot;;import &#123; LoginBody, LoginFooter, LoginHeader, ModalBackGround, ModalBox,&#125; from &quot;../assets/css/login&quot;;const LoginTemplate = (&#123; open, close &#125;) =&gt; &#123; const [form, setForm] = useState(&#123; email: &quot;&quot;, password: &quot;&quot;, &#125;); const onChange = useCallback( (e) =&gt; &#123; setForm(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;, [form] ); return open ? ( &lt;ModalBackGround&gt; &lt;ModalBox&gt; &lt;LoginHeader&gt; 로그인 &lt;button className=&quot;close&quot; onClick=&#123;close&#125;&gt; &#123;&quot; &quot;&#125; &amp;times;&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/LoginHeader&gt; &lt;LoginBody className=&quot;login-body&quot;&gt; &lt;div&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;/LoginBody&gt; &lt;LoginFooter&gt; &lt;button onClick=&#123;close&#125;&gt;닫기&lt;/button&gt; &lt;/LoginFooter&gt; &lt;/ModalBox&gt; &lt;/ModalBackGround&gt; ) : null;&#125;;export default LoginTemplate;","text":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 React 로그인 Modal 만들기 2 - styled-component 사용하기기존에 style 내용들을 css 파일로 관리해도 문제가 없으나, React에서는 style마저도 js파일로 관리할 수 있도록 지원해주는 다양한 프레임 워크들이 있다. js파일로 관리하게 되면 React의 여러 기능을 사용하기 좋기 때문에 기존에 작성해준 Login 관련 css 내용을 js 파일로 변경하려고 한다. import styled, &#123; keyframes &#125; from &quot;styled-components&quot;;export const ModalFade = keyframes`&#123; from &#123; opacity: 0; margin-top: -50px; &#125; to &#123; opacity: 1; margin-top: 0; &#125;&#125;`;export const ModalBackGround = styled.div` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center;`;export const ModalBox = styled.div` width: 90%; max-width: 400px; margin: 0 auto; border-radius: 0.3rem; background-color: #fff; animation: $&#123;ModalFade&#125; 0.5s; overflow: hidden;`;export const LoginHeader = styled.div` position: relative; padding: 16px 64px 16px 16px; background-color: #f1f1f1; font-weight: 700; &amp; &gt; button &#123; position: absolute; top: 15px; right: 15px; width: 30px; font-size: 21px; font-weight: 700; text-align: center; color: #999; border: 0; &#125;`;export const LoginBody = styled.div` padding: 10px; &amp; &gt; div &#123; padding: 5px; display: flex; align-items: center; justify-content: center; &#125; &amp; &gt; div &gt; input &#123; padding-top: 5px; padding-bottom: 5px; padding-left: 15px; padding-right: 15px; width: 290px; height: 30px; font-size: 14px; border: 1px solid rgb(222, 226, 230); &#125;`;export const LoginFooter = styled.div` border-top: 1px solid rgb(222, 226, 230); padding: 7px 16px; text-align: right; &amp; &gt; button &#123; padding: 6px 12px; color: #fff; background-color: #6c757d; border-radius: 5px; font-size: 13px; &#125;`; Styled-Component 적용하기import React, &#123; useState, useCallback &#125; from &quot;react&quot;;import &#123; LoginBody, LoginFooter, LoginHeader, ModalBackGround, ModalBox,&#125; from &quot;../assets/css/login&quot;;const LoginTemplate = (&#123; open, close &#125;) =&gt; &#123; const [form, setForm] = useState(&#123; email: &quot;&quot;, password: &quot;&quot;, &#125;); const onChange = useCallback( (e) =&gt; &#123; setForm(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;, [form] ); return open ? ( &lt;ModalBackGround&gt; &lt;ModalBox&gt; &lt;LoginHeader&gt; 로그인 &lt;button className=&quot;close&quot; onClick=&#123;close&#125;&gt; &#123;&quot; &quot;&#125; &amp;times;&#123;&quot; &quot;&#125; &lt;/button&gt; &lt;/LoginHeader&gt; &lt;LoginBody className=&quot;login-body&quot;&gt; &lt;div&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; &lt;/LoginBody&gt; &lt;LoginFooter&gt; &lt;button onClick=&#123;close&#125;&gt;닫기&lt;/button&gt; &lt;/LoginFooter&gt; &lt;/ModalBox&gt; &lt;/ModalBackGround&gt; ) : null;&#125;;export default LoginTemplate;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"}],"tags":[]},{"title":"React 로그인 Modal 만들기","slug":"react/login/login-modal-01-login","date":"2021-10-18T01:10:40.000Z","updated":"2024-11-23T16:46:04.256Z","comments":true,"path":"2021/10/18/react/login/login-modal-01-login/","link":"","permalink":"https://ckck803.github.io/2021/10/18/react/login/login-modal-01-login/","excerpt":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 로그인 Modal 만들기기존에 개인 프로젝트로 로그인 창을 만들게 되면 별도의 웹 페이지로 로그인 화면을 구현을 했다. 하지만 좀 더 깔끔하고 반응적인 방법을 찾다가 Modal에 대해 알게 됐고 Modal을 이용해 Login 화면을 구현해 보고자 한다. 로그인 컴포넌트 만들기가장 바깥 Wrapper는 로그인 버튼을 누른 상태와 누르지 않은 상태를 보여줘야 함으로 조건절을 이용해 classname을 변경하도록 설정한다. // Login 페이지가 열리면 modal-wrapper가 선택된다. &lt;div className=&#123;open ? &quot;modal-wrapper&quot; : null&#125;&gt; 내부 컴포넌트도 상태에 따라 보이거나 보이지 않게 상태를 변경해줄 필요가 있어 조건절을 통해 내부 컴포넌트를 가져올 수 있도록 설정한다. &#123;open ? ( &lt;div className=&quot;login-modal&quot;&gt; &lt;div className=&quot;login-header&quot;&gt;로그인&lt;/div&gt; &lt;div className=&quot;login-input&quot;&gt; &lt;div className=&quot;login-id&quot;&gt; &lt;input className=&quot;email&quot; type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChangeEmail&#125; /&gt; &lt;/div&gt; &lt;div className=&quot;login-password&quot;&gt; &lt;input className=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChangePassword&#125; /&gt; &lt;/div&gt; &lt;div className=&quot;close-login&quot;&gt; &lt;button className=&quot;close-button&quot; onClick=&#123;close&#125;&gt; 닫기 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;) : null&#125; LoginTemplate.js","text":"React 로그인 Modal 만들기 9 - Redux Saga 적용 React 로그인 Modal 만들기 8 - Redux 사용하기 React 로그인 Modal 만들기 7 - JWT 적용하기 React 로그인 Modal 만들기 6 - Login 구현 React 로그인 Modal 만들기 5 - 회원 가입 Back end 구현 React 로그인 Modal 만들기 4 - 비동기 처리 React 로그인 Modal 만들기 3 - 회원 가입 React 로그인 Modal 만들기 2 - styled-component 사용하기 React 로그인 Modal 만들기 로그인 Modal 만들기기존에 개인 프로젝트로 로그인 창을 만들게 되면 별도의 웹 페이지로 로그인 화면을 구현을 했다. 하지만 좀 더 깔끔하고 반응적인 방법을 찾다가 Modal에 대해 알게 됐고 Modal을 이용해 Login 화면을 구현해 보고자 한다. 로그인 컴포넌트 만들기가장 바깥 Wrapper는 로그인 버튼을 누른 상태와 누르지 않은 상태를 보여줘야 함으로 조건절을 이용해 classname을 변경하도록 설정한다. // Login 페이지가 열리면 modal-wrapper가 선택된다. &lt;div className=&#123;open ? &quot;modal-wrapper&quot; : null&#125;&gt; 내부 컴포넌트도 상태에 따라 보이거나 보이지 않게 상태를 변경해줄 필요가 있어 조건절을 통해 내부 컴포넌트를 가져올 수 있도록 설정한다. &#123;open ? ( &lt;div className=&quot;login-modal&quot;&gt; &lt;div className=&quot;login-header&quot;&gt;로그인&lt;/div&gt; &lt;div className=&quot;login-input&quot;&gt; &lt;div className=&quot;login-id&quot;&gt; &lt;input className=&quot;email&quot; type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChangeEmail&#125; /&gt; &lt;/div&gt; &lt;div className=&quot;login-password&quot;&gt; &lt;input className=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChangePassword&#125; /&gt; &lt;/div&gt; &lt;div className=&quot;close-login&quot;&gt; &lt;button className=&quot;close-button&quot; onClick=&#123;close&#125;&gt; 닫기 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;) : null&#125; LoginTemplate.js import React, &#123; useState, useCallback &#125; from &quot;react&quot;;import styled from &quot;styled-components&quot;;import &quot;../assets/css/modal.css&quot;;const LoginTemplate = (&#123; open, close &#125;) =&gt; &#123; const [email, setEmail] = useState(&quot;&quot;); const [password, setPassword] = useState(&quot;&quot;); const onChangeEmail = useCallback( (e) =&gt; &#123; setEmail(e.target.value); &#125;, [email] ); const onChangePassword = useCallback( (e) =&gt; &#123; setPassword(e.target.value); &#125;, [password] ); return ( // Login 페이지가 열리면 modal-wrapper가 선택된다. &lt;div className=&#123;open ? &quot;modal-wrapper&quot; : null&#125;&gt; &#123;open ? ( &lt;div className=&quot;login-modal&quot;&gt; &lt;div className=&quot;login-header&quot;&gt;로그인&lt;/div&gt; &lt;div className=&quot;login-input&quot;&gt; &lt;div className=&quot;login-id&quot;&gt; &lt;input className=&quot;email&quot; type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChangeEmail&#125; /&gt; &lt;/div&gt; &lt;div className=&quot;login-password&quot;&gt; &lt;input className=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChangePassword&#125; /&gt; &lt;/div&gt; &lt;div className=&quot;close-login&quot;&gt; &lt;button className=&quot;close-button&quot; onClick=&#123;close&#125;&gt; 닫기 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) : null&#125; &lt;/div&gt; );&#125;;export default LoginTemplate; 컴포넌트 스타일링 하기.modal-wrapper&#123; position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; animation: modal-bg-show .5s;&#125;.login-modal&#123; width: 90%; max-width: 400px; margin:0 auto; border-radius: .3rem; background-color: #fff; animation: modal-show .5s; overflow: hidden;&#125;.login-input&#123; padding-top:10px;&#125;.login-header&#123; position: relative; padding: 16px 64px 16px 16px; background-color: #f1f1f1; font-weight: 700;&#125;.login-id&#123; padding:10px; display: flex; align-items: center; justify-content: center;&#125;.login-password&#123; display: flex; align-items: center; justify-content: center; padding-bottom: 20px;&#125;.email&#123; padding-top:5px; padding-bottom:5px; padding-left: 15px; padding-right: 15px; width: 290px; height: 30px; font-size: 14px; border: 1px solid rgb(222, 226, 230);&#125;.password&#123; padding-top:5px; padding-bottom:5px; padding-left: 15px; padding-right: 15px; width: 290px; height: 30px; font-size: 14px; border: 1px solid rgb(222, 226, 230);&#125;.close-login&#123; border-top: 1px solid; padding: 12px 16px; text-align: right;&#125;.close-button&#123; padding: 6px 12px; color: #fff; background-color: #6c757d; border-radius: 5px; font-size: 13px;&#125;@keyframes modal-show &#123; from &#123; opacity: 0; margin-top: -50px; &#125; to &#123; opacity: 1; margin-top: 0; &#125;&#125;@keyframes modal-bg-show &#123; from &#123; opacity: 0; &#125; to &#123; opacity: 1; &#125;&#125; 작동 확인하기작성이 완료된 LoginTemplate를 갖고 메인 화면에서 보내는 open 상태에 따라 Login Modal이 잘 작동하는지 확인한다. App.js import &#123; useCallback, useState &#125; from &quot;react&quot;;import LoginTemplate from &quot;./components/LoginTemplate&quot;;// import &quot;./assets/css/modal.css&quot;;function App() &#123; const [open, setOpen] = useState(false); const onClickButton = useCallback(() =&gt; &#123; console.log(&quot;open login modal&quot;); setOpen(!open); &#125;, [open]); return ( &lt;div&gt; &lt;button onClick=&#123;onClickButton&#125;&gt;로그인 Modal Pop Up&lt;/button&gt; &lt;LoginTemplate open=&#123;open&#125; close=&#123;onClickButton&#125; /&gt; &lt;/div&gt; );&#125;export default App;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"}],"tags":[]},{"title":"Spring boot - MultipartFile 에서 발생하는 예외 처리","slug":"spring/spring-resource/multipart-exception","date":"2021-10-16T13:39:59.000Z","updated":"2024-02-26T15:39:14.776Z","comments":true,"path":"2021/10/16/spring/spring-resource/multipart-exception/","link":"","permalink":"https://ckck803.github.io/2021/10/16/spring/spring-resource/multipart-exception/","excerpt":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 MaxUploadSizeExceededException 예외MaxUploadSizeExceededException 예외가 발생하는 경우는 크게 두 가지가 있다. 첫 번째는 FileSizeLimitExceededException 예외가 발생했을 때 두 번째는 SizeLimitExceededException 예외가 발생했을 때다. FileSizeLimitExceededException 서버로 전송되는 각 파일 크기가 제한을 초과했을 때 발생하는 예외, 기본값은 1MB다.org.apache.tomcat.util.http.fileupload.impl.FileSizeLimitExceededException: The field file exceeds its maximum permitted size of 1048576 bytes. SizeLimitExceededException 서버로 전송되는 모든 파일 크기가 제한을 초과했을 때 발생하는 예외, 기본값은 10MB다.org.apache.tomcat.util.http.fileupload.impl.SizeLimitExceededException: the request was rejected because its size (29404104) exceeds the configured maximum (10485760)","text":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 MaxUploadSizeExceededException 예외MaxUploadSizeExceededException 예외가 발생하는 경우는 크게 두 가지가 있다. 첫 번째는 FileSizeLimitExceededException 예외가 발생했을 때 두 번째는 SizeLimitExceededException 예외가 발생했을 때다. FileSizeLimitExceededException 서버로 전송되는 각 파일 크기가 제한을 초과했을 때 발생하는 예외, 기본값은 1MB다.org.apache.tomcat.util.http.fileupload.impl.FileSizeLimitExceededException: The field file exceeds its maximum permitted size of 1048576 bytes. SizeLimitExceededException 서버로 전송되는 모든 파일 크기가 제한을 초과했을 때 발생하는 예외, 기본값은 10MB다.org.apache.tomcat.util.http.fileupload.impl.SizeLimitExceededException: the request was rejected because its size (29404104) exceeds the configured maximum (10485760) MaxUploadSizeExceededException 예외 해결하기Properties에 속성 추가MaxUploadSizeExceededException 예외를 해결하는 방법은 스프링 properties에 spring.servlet.multipart.max-file-size 값을 명시적으로 늘려주면 된다. spring.servlet.multipart.max-file-size=200MB SizeLimitExceededException 예외를 해결하는 방법은 스프링 properties에 spring.servlet.multipart.max-request-size 값을 명시적으로 늘려주면 된다. spring.servlet.multipart.max-request-size=200MB MultipartResolver 등록하기스프링 properties에 값을 추가하는 방식 외에도 MultipartResolver Bean을 등록해 MaxUploadSize값을 설정하는 방법이 있다. 의존성 추가// https://mvnrepository.com/artifact/commons-io/commons-ioimplementation group: &#x27;commons-io&#x27;, name: &#x27;commons-io&#x27;, version: &#x27;2.11.0&#x27;// https://mvnrepository.com/artifact/commons-fileupload/commons-fileuploadimplementation group: &#x27;commons-fileupload&#x27;, name: &#x27;commons-fileupload&#x27;, version: &#x27;1.4&#x27; MultipartResolver 는 setMaxUploadSize 메소드를 통해 모든 파일 크기에 대한 설정을 setMaxUploadSizePerFile 메소드를 통해 각각의 파일 크기에 대한 설정을 할 수 있다. 아무 설정도 안하면 Max갑이 없어 파일 크기에 제한이 없다. @SpringBootApplicationpublic class DemoMultipartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoMultipartApplication.class, args); &#125; @Bean public MultipartResolver multipartResolver() &#123; CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver(); multipartResolver.setMaxUploadSize(524288000); multipartResolver.setMaxUploadSizePerFile(52428800); return multipartResolver; &#125;&#125; 예외 처리ControllerAdvice 어노테이션을 이용한 예외 처리@ControllerAdvice@Slf4jpublic class FileExceptionControllerAdvice &#123; @ExceptionHandler(MaxUploadSizeExceededException.class) public ResponseEntity handleMaxSizeException(MaxUploadSizeExceededException exc, HttpServletRequest request, HttpServletResponse response) &#123; log.info(&quot;File size exceeds limit!&quot;); return ResponseEntity.notFound().build(); &#125;&#125; HandlerExceptionResolver 인터페이스 구현을 통한 예외처리@Component@Slf4jpublic class FileExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ModelAndView modelAndView = new ModelAndView(&quot;file&quot;); if (ex instanceof MaxUploadSizeExceededException) &#123; log.info(&quot;File size exceeds limit!&quot;); modelAndView.getModel().put(&quot;message&quot;, &quot;File size exceeds limit!&quot;); &#125; return modelAndView; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"},{"name":"File","slug":"Spring/Spring-Resource/File","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/File/"}],"tags":[]},{"title":"HttpClient 사용하기 - Multipart Parameter 보내기","slug":"java/http/java-httpclient-3","date":"2021-10-14T21:31:46.000Z","updated":"2024-02-18T16:19:54.527Z","comments":true,"path":"2021/10/15/java/http/java-httpclient-3/","link":"","permalink":"https://ckck803.github.io/2021/10/15/java/http/java-httpclient-3/","excerpt":"HttpClient 사용하기 HttpClient 사용하기 - Paramater 보내기 HttpClient 사용하기 - Multipart Parameter 보내기 HttpClient 사용하기 - Multipart Parameter 보내기 Client가 서버로 파일 을 전송하거나 한번에 여러개의 Form 데이터 를 보내기 위해 사용하는 방식이다. 이미지와 같은 Binary 데이터는 기존 application&#x2F;x-www-form-urlencoded 나 application&#x2F;json 과 같은 요청으로 적절치 않아 multipart&#x2F;form-data 형태의 데이터로 요청을 보낸다. application&#x2F;x-www-form-urlencoded 는 보내는 Paramater를 encoding 해서 전송한다. 데이터가 영숫자가 아닌 경우 3바이트로 표현하기 때문에 바이너리 파일을 전송할 경우 페이로드를 3배로 만들기 때문에 비효율 적이다. multipart&#x2F;form-data 의 경우는 전송한 모든 문자를 인코딩하지 않은 형태로 보낸다. 의존성 추가하기// https://mvnrepository.com/artifact/org.apache.httpcomponents/httpmimeimplementation group: &#x27;org.apache.httpcomponents&#x27;, name: &#x27;httpmime&#x27;, version: &#x27;4.3.4&#x27; MultipartEntityBuilder 를 이용해 HttpEntity 객체 생성 MultipartEntityBuilder 를 이용해 쉽게 Text나 파일을 (Key, Value) 형태로 Request Body 에 넣을 수 있다. Text를 보낼때는 addTextBody 메소드를 이용해 값을 넣어주고 이미지나 파일 데이터를 보낼 때는 addBinaryBody 메소드를 이용해 Binary 파일 을 넣어주고 Content Type 으로 MULTIPART_FORM_DATA 를 명시해준다.","text":"HttpClient 사용하기 HttpClient 사용하기 - Paramater 보내기 HttpClient 사용하기 - Multipart Parameter 보내기 HttpClient 사용하기 - Multipart Parameter 보내기 Client가 서버로 파일 을 전송하거나 한번에 여러개의 Form 데이터 를 보내기 위해 사용하는 방식이다. 이미지와 같은 Binary 데이터는 기존 application&#x2F;x-www-form-urlencoded 나 application&#x2F;json 과 같은 요청으로 적절치 않아 multipart&#x2F;form-data 형태의 데이터로 요청을 보낸다. application&#x2F;x-www-form-urlencoded 는 보내는 Paramater를 encoding 해서 전송한다. 데이터가 영숫자가 아닌 경우 3바이트로 표현하기 때문에 바이너리 파일을 전송할 경우 페이로드를 3배로 만들기 때문에 비효율 적이다. multipart&#x2F;form-data 의 경우는 전송한 모든 문자를 인코딩하지 않은 형태로 보낸다. 의존성 추가하기// https://mvnrepository.com/artifact/org.apache.httpcomponents/httpmimeimplementation group: &#x27;org.apache.httpcomponents&#x27;, name: &#x27;httpmime&#x27;, version: &#x27;4.3.4&#x27; MultipartEntityBuilder 를 이용해 HttpEntity 객체 생성 MultipartEntityBuilder 를 이용해 쉽게 Text나 파일을 (Key, Value) 형태로 Request Body 에 넣을 수 있다. Text를 보낼때는 addTextBody 메소드를 이용해 값을 넣어주고 이미지나 파일 데이터를 보낼 때는 addBinaryBody 메소드를 이용해 Binary 파일 을 넣어주고 Content Type 으로 MULTIPART_FORM_DATA 를 명시해준다. HttpEntity httpEntity = MultipartEntityBuilder.create() .addTextBody(&quot;name&quot;, &quot;Dongwoo&quot;) .addTextBody(&quot;nickname&quot;, &quot;Victor&quot;) .addBinaryBody(&quot;file&quot;, new File(&quot;/Users/dongwoo-yang/test.txt&quot;), ContentType.APPLICATION_OCTET_STREAM, &quot;test.txt&quot;) .build(); 전체 소스 코드public class JavaHttpClientMultipart &#123; public static void main(String[] args) throws IOException &#123; String url = &quot;http://localhost:8080/test/multipart&quot;; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(url); HttpEntity httpEntity = MultipartEntityBuilder.create() .addTextBody(&quot;name&quot;, &quot;Dongwoo&quot;) .addTextBody(&quot;nickname&quot;, &quot;Victor&quot;) .addBinaryBody(&quot;file&quot;, new File(&quot;/Users/dongwoo-yang/test.txt&quot;), ContentType.MULTIPART_FORM_DATA, &quot;test.txt&quot;) .build(); httpPost.setEntity(httpEntity); CloseableHttpResponse response = httpClient.execute(httpPost); System.out.println(&quot;=========================== start ============================&quot;); System.out.println(&quot;Status Code: &quot; + response.getStatusLine().getStatusCode()); System.out.println(&quot;============================ end =============================&quot;); httpClient.close(); &#125;&#125; Paramater 요청 받을 수 있는 Back-end 코드 Spring 에서는 Multipart 요청을 쉽게 처리하기 위해서 MultipartFile 클래스를 제공한다. MultipartFile 객체로부터 입력 스트립을 받아와 전송된 파일 내용을 읽어온다. @PostMapping(value =&quot;/test/multipart&quot;)public ResponseEntity testMultipart(MultipartFile file) throws Exception &#123; if(file == null)&#123; throw new Exception(); &#125; String line; BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream())); while((line = br.readLine()) != null)&#123; log.info(line); &#125; return ResponseEntity.ok().build();&#125; 참고http://tcpschool.com/html-tag-attrs/form-enctype","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"},{"name":"Rest","slug":"Programming/JAVA/Rest","permalink":"https://ckck803.github.io/categories/Programming/JAVA/Rest/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"HttpClient 사용하기 - Paramater 보내기","slug":"java/http/java-httpclient-2","date":"2021-10-14T20:31:46.000Z","updated":"2024-02-18T16:19:54.527Z","comments":true,"path":"2021/10/15/java/http/java-httpclient-2/","link":"","permalink":"https://ckck803.github.io/2021/10/15/java/http/java-httpclient-2/","excerpt":"HttpClient 사용하기 HttpClient 사용하기 - Paramater 보내기 HttpClient 사용하기 - Multipart Parameter 보내기 HttpClient 사용하기 - Paramater 보내기 Client가 서버로 요청과 함께 Paramater를 보내는 방법은 크게 Form 형태의 데이터를 보내는 방법과 JSON 형태의 데이터를 보내는 방법이 있다. 보통 Form 형태의 데이터는 (Key, Value) 형태의 데이터로 Http Body에 넣어서 보내고 JSON 형태의 데이터는 String 형태로 변환해 Http Body에 넣어서 보낸다. Form 형태의 데이터를 보낼 때 Header는 application&#x2F;x-www-form-urlencoded 로 요청을 보내고 JSON 형태의 데이터를 보낼 때 Header는 application&#x2F;json 로 요청을 보낸다. Paramater 요청 받을 수 있는 Back-end 코드/test/params 에 들어오는 Http 요청과 함께 오는 Paramater 내용을 찍어주는 로직을 작성해준다. Form 형태의 Paramater를 받을 때는 @RequestParam 을 이용해 데이터를 가져올 수 있다. @PostMapping(&quot;/test/params&quot;)public ResponseEntity testParams(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;nickname&quot;) String nickName)&#123; log.info(&quot;=========================== start ============================&quot;); log.info(&quot;Name : &quot; + name); log.info(&quot;Nickname : &quot; + nickName); log.info(&quot;============================ end =============================&quot;); return ResponseEntity.ok().build();&#125; 요청시 보내는 Paramater 작성 요청시 보내는 Paramater는 NameValuePair 객체를 이용해 (Key, Value) 형태로 값을 넣어준다. 작성이 완료된 NameValuePair 객체를 이용해 HttpEntity 객체를 생성한다. HttpEntity 객체를 요청 객체 Entity에 넣어서 Http 요청을 보내면 요청시 Paramater도 같이 전달 된다. UrlEncodedFormEntity 를 이용해 만들어진 Entity에 대한 요청은 ContentType 이 application&#x2F;x-www-form-urlencoded 으로 보내진다. List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;();params.add(new BasicNameValuePair(&quot;name&quot;, &quot;test&quot;));params.add(new BasicNameValuePair(&quot;nickname&quot;, &quot;victor&quot;));// NameValuePair 객체 이용해 HttpEntity 객체를 생성한다.HttpEntity entity = new UrlEncodedFormEntity(params);// 요청 객체에 Entity에 Paramater 넣어주기httpPost.setEntity(entity);","text":"HttpClient 사용하기 HttpClient 사용하기 - Paramater 보내기 HttpClient 사용하기 - Multipart Parameter 보내기 HttpClient 사용하기 - Paramater 보내기 Client가 서버로 요청과 함께 Paramater를 보내는 방법은 크게 Form 형태의 데이터를 보내는 방법과 JSON 형태의 데이터를 보내는 방법이 있다. 보통 Form 형태의 데이터는 (Key, Value) 형태의 데이터로 Http Body에 넣어서 보내고 JSON 형태의 데이터는 String 형태로 변환해 Http Body에 넣어서 보낸다. Form 형태의 데이터를 보낼 때 Header는 application&#x2F;x-www-form-urlencoded 로 요청을 보내고 JSON 형태의 데이터를 보낼 때 Header는 application&#x2F;json 로 요청을 보낸다. Paramater 요청 받을 수 있는 Back-end 코드/test/params 에 들어오는 Http 요청과 함께 오는 Paramater 내용을 찍어주는 로직을 작성해준다. Form 형태의 Paramater를 받을 때는 @RequestParam 을 이용해 데이터를 가져올 수 있다. @PostMapping(&quot;/test/params&quot;)public ResponseEntity testParams(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;nickname&quot;) String nickName)&#123; log.info(&quot;=========================== start ============================&quot;); log.info(&quot;Name : &quot; + name); log.info(&quot;Nickname : &quot; + nickName); log.info(&quot;============================ end =============================&quot;); return ResponseEntity.ok().build();&#125; 요청시 보내는 Paramater 작성 요청시 보내는 Paramater는 NameValuePair 객체를 이용해 (Key, Value) 형태로 값을 넣어준다. 작성이 완료된 NameValuePair 객체를 이용해 HttpEntity 객체를 생성한다. HttpEntity 객체를 요청 객체 Entity에 넣어서 Http 요청을 보내면 요청시 Paramater도 같이 전달 된다. UrlEncodedFormEntity 를 이용해 만들어진 Entity에 대한 요청은 ContentType 이 application&#x2F;x-www-form-urlencoded 으로 보내진다. List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;();params.add(new BasicNameValuePair(&quot;name&quot;, &quot;test&quot;));params.add(new BasicNameValuePair(&quot;nickname&quot;, &quot;victor&quot;));// NameValuePair 객체 이용해 HttpEntity 객체를 생성한다.HttpEntity entity = new UrlEncodedFormEntity(params);// 요청 객체에 Entity에 Paramater 넣어주기httpPost.setEntity(entity); 전체 소스 코드public class JavaHttpClientParam &#123; public static void main(String[] args) throws IOException &#123; BufferedReader br; CloseableHttpClient client = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/test/params&quot;); List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;(); params.add(new BasicNameValuePair(&quot;name&quot;, &quot;test&quot;)); params.add(new BasicNameValuePair(&quot;nickname&quot;, &quot;victor&quot;)); HttpEntity entity = new UrlEncodedFormEntity(params); httpPost.setEntity(entity); CloseableHttpResponse response = client.execute(httpPost); System.out.println(&quot;=========================== start ============================&quot;); System.out.println(&quot;Http Status Code : &quot; + response.getStatusLine().getStatusCode()); System.out.println(&quot;============================ end =============================&quot;); &#125;&#125; JSON 요청 보내기Paramater 요청 받을 수 있는 Back-end 코드 /test/json 에 들어오는 Http 요청과 함께 오는 JSON 내용을 찍어주는 로직을 작성해준다. JSON 형태의 Paramater를 받을 때는 @RequestBody 을 이용해 Request Body 내 데이터를 가져올 수 있다. @PostMapping(&quot;/test/json&quot;)public ResponseEntity testJsonParams(@RequestBody TestParam param)&#123; log.info(&quot;=========================== start ============================&quot;); log.info(&quot;Name : &quot; + param.getName()); log.info(&quot;Nickname : &quot; + param.getNickname()); log.info(&quot;============================ end =============================&quot;); return ResponseEntity.ok().build();&#125; name과 nickname을 JSON 형태의 요청으로 보내기 위해 해당 값들을 인자로 갖는 TestParam 클래스를 만들어 준다. class TestParam implements Serializable &#123; private String name; private String nickname; public TestParam(String name, String nickname)&#123; this.name = name; this.nickname = nickname; &#125;&#125; 객체를 String으로 변환하기 ObjectMapper 를 이용해 TestParam 객체를 String 으로 변환한다. 만들어진 String 값을 이용해 Entity 객체를 생성한 후 Request(요청) 객체 Entity 에 넣어준다. TestParam param = new TestParam(&quot;test&quot;, &quot;Victor&quot;);ObjectMapper objectMapper = new ObjectMapper();// 객체를 ObjectMapper 를 이용해 String으로 변환한 후 StringEntity 객체를 생성한다.StringEntity stringEntity = new StringEntity(objectMapper.writeValueAsString(param));// 요청 Entity에 넣어준다.httpPost.setEntity(stringEntity); ContentType 변경하기JSON 형태의 요청을 보내기 위해서는 요청 Header 내 Content-type 을 application&#x2F;json 로 설정해서 보내준다. httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;);httpPost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;);CloseableHttpResponse response = httpClient.execute(httpPost); 전체 소스 코드public class JavaHttpClientJson &#123; public static void main(String[] args) throws IOException &#123; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/test/json&quot;); TestParam param = new TestParam(&quot;test&quot;, &quot;Victor&quot;); ObjectMapper objectMapper = new ObjectMapper(); StringEntity stringEntity = new StringEntity(objectMapper.writeValueAsString(param)); httpPost.setEntity(stringEntity); httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;); httpPost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); CloseableHttpResponse response = httpClient.execute(httpPost); System.out.println(&quot;=========================== start ============================&quot;); System.out.println(objectMapper.writeValueAsString(param)); System.out.println(&quot;Http Status Code : &quot; + response.getStatusLine().getStatusCode()); System.out.println(&quot;============================ end =============================&quot;); &#125;&#125;class TestParam implements Serializable &#123; private String name; private String nickname; public TestParam(String name, String nickname)&#123; this.name = name; this.nickname = nickname; &#125; public String getName()&#123; return name; &#125; public String getNickname()&#123; return nickname; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"},{"name":"Rest","slug":"Programming/JAVA/Rest","permalink":"https://ckck803.github.io/categories/Programming/JAVA/Rest/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"HttpClient 사용하기","slug":"java/http/java-httpclient-1","date":"2021-10-14T19:31:46.000Z","updated":"2024-02-18T16:19:54.527Z","comments":true,"path":"2021/10/15/java/http/java-httpclient-1/","link":"","permalink":"https://ckck803.github.io/2021/10/15/java/http/java-httpclient-1/","excerpt":"HttpClient 사용하기 HttpClient 사용하기 - Paramater 보내기 HttpClient 사용하기 - Multipart Parameter 보내기 HttpClient 사용하기 HttpClient 는 Apache에서 제공하는 라이브러리로 HTTP 를 사용하는 통신에 손쉽게 자원을 요청하고 응답받을 수 있게 도와준다. // https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclientimplementation group: &#x27;org.apache.httpcomponents&#x27;, name: &#x27;httpclient&#x27;, version: &#x27;4.3.4&#x27; Back-end ControllerHttpClient 를 사용해 요청 테스트를 진행하기 위한 서버 Controller를 생성한다. @RestControllerpublic class HttpClientBackend &#123; @PostMapping(&quot;/hello&quot;) @CrossOrigin(origins = &quot;*&quot;, allowedHeaders = &quot;*&quot;) public String hello()&#123; return &quot;Hello World!&quot;; &#125;&#125; HttpClient 객체 가져오기","text":"HttpClient 사용하기 HttpClient 사용하기 - Paramater 보내기 HttpClient 사용하기 - Multipart Parameter 보내기 HttpClient 사용하기 HttpClient 는 Apache에서 제공하는 라이브러리로 HTTP 를 사용하는 통신에 손쉽게 자원을 요청하고 응답받을 수 있게 도와준다. // https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclientimplementation group: &#x27;org.apache.httpcomponents&#x27;, name: &#x27;httpclient&#x27;, version: &#x27;4.3.4&#x27; Back-end ControllerHttpClient 를 사용해 요청 테스트를 진행하기 위한 서버 Controller를 생성한다. @RestControllerpublic class HttpClientBackend &#123; @PostMapping(&quot;/hello&quot;) @CrossOrigin(origins = &quot;*&quot;, allowedHeaders = &quot;*&quot;) public String hello()&#123; return &quot;Hello World!&quot;; &#125;&#125; HttpClient 객체 가져오기 HttpClient 객체를 가저오는 방법은 HttpClients 클래스에서 제공하는 createDefault 메소드를 이용하는 방법과 HttpClientBuilder 를 이용한 방법이 있다. createDefault 내부를 보면 HttpClientBuilder 를 이용해 HttpClient 객체를 가져오기 때문에 사실상 똑같다. CloseableHttpClient client = HttpClients.createDefault();CloseableHttpClient client2 = HttpClientBuilder.create().build(); Post 요청을 위한 HttpPost 객체 생성 HttpPost를 이용해 Post 요청보내기 위한 요청 객체를 생성한다. 객체를 만들때 요청을 보내기 위한 요청 URL을 넣어준다. HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/hello&quot;); 요청 후 응답 객체 받아오기 HttpClient 객체의 execute 메소드를 이용해 서버 측으로 요청을 보낸다. execute 메소드의 매게변수로 생성한 요청 객체 (HttpGet, HttpPost, HttpPut, HttpPatch) 를 넣어준다. CloseableHttpResponse response = client.execute(httpPost); 응답 값 가져오기 응답 객체로부터 입력 스트림 을 가져와 값을 읽어온다. BufferedReader br = new BufferedReader(new InputStreamReader(response.getEntity().getContent())); 전체 소스 코드@SpringBootApplicationpublic class JavaHttpclientApplication &#123; public static void main(String[] args) throws IOException &#123; CloseableHttpClient client = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/hello&quot;); CloseableHttpResponse response = client.execute(httpPost); System.out.println(&quot;============================ body =============================&quot;); String inputLine; StringBuffer result = new StringBuffer(); BufferedReader br = new BufferedReader(new InputStreamReader(response.getEntity().getContent())); while ((inputLine = br.readLine()) != null) &#123; result.append(inputLine); &#125; System.out.println(result); System.out.println(&quot;============================ body =============================&quot;); br.close(); client.close(); &#125;&#125; HttpClient Fluent API 사용하기Fluent API 를 이용하면 조금더 쉽고 간편하고 직관적으로 HTTP 요청을 할 수 있다. 라이브러리 추가implementation group: &#x27;org.apache.httpcomponents&#x27;, name: &#x27;httpclient&#x27;, version: &#x27;4.3.4&#x27;// https://mvnrepository.com/artifact/org.apache.httpcomponents/fluent-hcimplementation group: &#x27;org.apache.httpcomponents&#x27;, name: &#x27;fluent-hc&#x27;, version: &#x27;4.3.4&#x27;&#125; 서버측에 요청하고 응답 받기Fluent API 에서 제공하는 Request 를 이용하면 요청 객체를 따로 생성할 필요 없이 간편하게 요청하고 실행해 응답값을 받아올 수 있다. HttpResponse response = Request .Post(&quot;http://localhost:8080/hello&quot;) .execute() .returnResponse(); 전체 소스 코드public class JavaHttpClientFluentApi &#123; public static void main(String[] args) throws IOException &#123; HttpResponse response = Request .Post(&quot;http://localhost:8080/hello&quot;) .execute() .returnResponse(); String line; StringBuilder stringBuilder = new StringBuilder(); BufferedReader br = new BufferedReader(new InputStreamReader(response.getEntity().getContent())); while((line = br.readLine()) != null)&#123; stringBuilder.append(line); &#125; System.out.println(&quot;=========================== start ============================&quot;); System.out.println(&quot;Status Code: &quot; + response.getStatusLine().getStatusCode()); System.out.println(&quot;Content: &quot; + stringBuilder.toString()); System.out.println(&quot;============================ end =============================&quot;); &#125;&#125; 참고 사이트https://www.baeldung.com/httpclient4","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"},{"name":"REST","slug":"Programming/JAVA/REST","permalink":"https://ckck803.github.io/categories/Programming/JAVA/REST/"}],"tags":[]},{"title":"Spring Boot @RequestMapping","slug":"spring/spring-framework/mvc/spring-mvc-02-requestmapping","date":"2021-10-12T16:05:00.000Z","updated":"2024-02-26T15:59:20.648Z","comments":true,"path":"2021/10/13/spring/spring-framework/mvc/spring-mvc-02-requestmapping/","link":"","permalink":"https://ckck803.github.io/2021/10/13/spring/spring-framework/mvc/spring-mvc-02-requestmapping/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot @RequestMapping 사용자 요청 받기RequestMapping 어노테이션을 사용해 해당 URL로 들어오는 사용자 요청을 처리할 수 있다. 이때, method를 명시하지 않을 경우 GET, POST, PUT, PATCH, DELETE 모든 method를 사용해 접근이 가능하므로, 특정 method에서만 요청을 받고 싶을 경우 method를 명시해줘야 한다. @RequestMapping(value = &quot;/hello-basic&quot;)public String helloBasic()&#123; log.info(&quot;helloBasic&quot;); return &quot;ok&quot;;&#125; @RequestMapping(value = &quot;/mapping-get-v1&quot;, method = RequestMethod.GET)public String mappingGetV1()&#123; log.info(&quot;helloBasic&quot;); return &quot;ok&quot;;&#125; GetMapping 어노테이션 사용하기@GetMapping(value = &quot;/mapping-get-v2&quot;)public String mappingGetV2()&#123; log.info(&quot;helloBasic&quot;); return &quot;ok&quot;;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot @RequestMapping 사용자 요청 받기RequestMapping 어노테이션을 사용해 해당 URL로 들어오는 사용자 요청을 처리할 수 있다. 이때, method를 명시하지 않을 경우 GET, POST, PUT, PATCH, DELETE 모든 method를 사용해 접근이 가능하므로, 특정 method에서만 요청을 받고 싶을 경우 method를 명시해줘야 한다. @RequestMapping(value = &quot;/hello-basic&quot;)public String helloBasic()&#123; log.info(&quot;helloBasic&quot;); return &quot;ok&quot;;&#125; @RequestMapping(value = &quot;/mapping-get-v1&quot;, method = RequestMethod.GET)public String mappingGetV1()&#123; log.info(&quot;helloBasic&quot;); return &quot;ok&quot;;&#125; GetMapping 어노테이션 사용하기@GetMapping(value = &quot;/mapping-get-v2&quot;)public String mappingGetV2()&#123; log.info(&quot;helloBasic&quot;); return &quot;ok&quot;;&#125; Path Variable 사용@GetMapping(&quot;/mapping/&#123;userId&#125;&quot;)public String mappingPath(@PathVariable(&quot;userId&quot;) String data) &#123; log.info(&quot;mappingPath userId=&#123;&#125;&quot;, data); return &quot;ok&quot;;&#125; /** * PathVariable 사용 다중 */@GetMapping(&quot;/mapping/users/&#123;userId&#125;/orders/&#123;orderId&#125;&quot;)public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) &#123; log.info(&quot;mappingPath userId=&#123;&#125;, orderId=&#123;&#125;&quot;, userId, orderId); return &quot;ok&quot;;&#125; 특정 미디어 타입 요청만 처리하고 싶을 경우consumes 을 이용해 /** * Content-Type 헤더 기반 추가 매핑 Media Type * consumes=&quot;application/json&quot; * consumes=&quot;!application/json&quot; * consumes=&quot;application/*&quot; * consumes=&quot;*\\/*&quot; * MediaType.APPLICATION_JSON_VALUE */@PostMapping(value = &quot;/mapping-consume&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)public String mappingConsumes() &#123; log.info(&quot;mappingConsumes&quot;); return &quot;ok&quot;;&#125; 특정 미디어 타입 응답을 만들고 싶을 경우Accept의 Media Type과 produces가 일치해야 사용할 수 있다. /*** Accept 헤더 기반 Media Type * produces = &quot;text/html&quot;* produces = &quot;!text/html&quot; * produces = &quot;text/*&quot;* produces = &quot;*\\/*&quot;*/@PostMapping(value = &quot;/mapping-produce&quot;, produces = MediaType.TEXT_HTML_VALUE)public String mappingProduces() &#123; log.info(&quot;mappingProduces&quot;); return &quot;ok&quot;;&#125; @RestController@Slf4jpublic class MappingController &#123; @RequestMapping(value = &quot;/hello-basic&quot;) public String helloBasic()&#123; log.info(&quot;helloBasic&quot;); return &quot;ok&quot;; &#125; @RequestMapping(value = &quot;/mapping-get-v1&quot;, method = RequestMethod.GET) public String mappingGetV1()&#123; log.info(&quot;helloBasic&quot;); return &quot;ok&quot;; &#125; @GetMapping(value = &quot;/mapping-get-v2&quot;) public String mappingGetV2()&#123; log.info(&quot;helloBasic&quot;); return &quot;ok&quot;; &#125; /** * PathVariable 사용 * 변수명이 같으면 생략 가능 * @PathVariable(&quot;userId&quot;) String userId -&gt; @PathVariable userId */ @GetMapping(&quot;/mapping/&#123;userId&#125;&quot;) public String mappingPath(@PathVariable(&quot;userId&quot;) String data) &#123; log.info(&quot;mappingPath userId=&#123;&#125;&quot;, data); return &quot;ok&quot;; &#125; /** * PathVariable 사용 다중 */ @GetMapping(&quot;/mapping/users/&#123;userId&#125;/orders/&#123;orderId&#125;&quot;) public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) &#123; log.info(&quot;mappingPath userId=&#123;&#125;, orderId=&#123;&#125;&quot;, userId, orderId); return &quot;ok&quot;; &#125; /** * 파라미터로 추가 매핑 * params=&quot;mode&quot;, * params=&quot;!mode&quot; * params=&quot;mode=debug&quot; * params=&quot;mode!=debug&quot; (! = ) * params = &#123;&quot;mode=debug&quot;,&quot;data=good&quot;&#125; */ @GetMapping(value = &quot;/mapping-param&quot;, params = &quot;mode=debug&quot;) public String mappingParam() &#123; log.info(&quot;mappingParam&quot;); return &quot;ok&quot;; &#125; /** *특정 헤더로 추가 매핑 * headers=&quot;mode&quot;, * headers=&quot;!mode&quot; * headers=&quot;mode=debug&quot; * headers=&quot;mode!=debug&quot; (! = ) */ @GetMapping(value = &quot;/mapping-header&quot;, headers = &quot;mode=debug&quot;) public String mappingHeader() &#123; log.info(&quot;mappingHeader&quot;); return &quot;ok&quot;; &#125; /** * Content-Type 헤더 기반 추가 매핑 Media Type * consumes=&quot;application/json&quot; * consumes=&quot;!application/json&quot; * consumes=&quot;application/*&quot; * consumes=&quot;*\\/*&quot; * MediaType.APPLICATION_JSON_VALUE */ @PostMapping(value = &quot;/mapping-consume&quot;, consumes = MediaType.APPLICATION_JSON_VALUE) public String mappingConsumes() &#123; log.info(&quot;mappingConsumes&quot;); return &quot;ok&quot;; &#125; /** * Accept 헤더 기반 Media Type * produces = &quot;text/html&quot; * produces = &quot;!text/html&quot; * produces = &quot;text/*&quot; * produces = &quot;*\\/*&quot; */ @PostMapping(value = &quot;/mapping-produce&quot;, produces = MediaType.TEXT_HTML_VALUE) public String mappingProduces() &#123; log.info(&quot;mappingProduces&quot;); return &quot;ok&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring MVC Request Life Cycle - ViewResolver","slug":"spring/spring-framework/lifecycle/spring-lifecycle-04-viewresolver","date":"2021-10-11T23:05:00.000Z","updated":"2024-02-26T15:56:50.418Z","comments":true,"path":"2021/10/12/spring/spring-framework/lifecycle/spring-lifecycle-04-viewresolver/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/lifecycle/spring-lifecycle-04-viewresolver/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter Spring MVC Request Life Cycle - ViewResolver 핸들러 어뎁터 호출 ViewResolver 호출 spring.mvc.view.prefix=/WEB-INF/views/spring.mvc.view.suffix=.jsp ViewResolver.java public interface ViewResolver &#123; @Nullable View resolveViewName(String viewName, Locale locale) throws Exception;&#125; 스프링 부투에서는 InternalResourceViewResolver 를 등록할때 spring.mvc.view.prefix, spring.mvc.view.suffix 설정 정보를 갖고와 등록해준다. public InternalResourceViewResolver(String prefix, String suffix) &#123; this(); setPrefix(prefix); setSuffix(suffix);&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter Spring MVC Request Life Cycle - ViewResolver 핸들러 어뎁터 호출 ViewResolver 호출 spring.mvc.view.prefix=/WEB-INF/views/spring.mvc.view.suffix=.jsp ViewResolver.java public interface ViewResolver &#123; @Nullable View resolveViewName(String viewName, Locale locale) throws Exception;&#125; 스프링 부투에서는 InternalResourceViewResolver 를 등록할때 spring.mvc.view.prefix, spring.mvc.view.suffix 설정 정보를 갖고와 등록해준다. public InternalResourceViewResolver(String prefix, String suffix) &#123; this(); setPrefix(prefix); setSuffix(suffix);&#125; InternalResourceViewResolver.java public class InternalResourceViewResolver extends UrlBasedViewResolver &#123; private static final boolean jstlPresent = ClassUtils.isPresent(&quot;javax.servlet.jsp.jstl.core.Config&quot;, InternalResourceViewResolver.class.getClassLoader()); @Nullable private Boolean alwaysInclude; public InternalResourceViewResolver() &#123; Class&lt;?&gt; viewClass = requiredViewClass(); if (InternalResourceView.class == viewClass &amp;&amp; jstlPresent) &#123; viewClass = JstlView.class; &#125; setViewClass(viewClass); &#125; public InternalResourceViewResolver(String prefix, String suffix) &#123; this(); setPrefix(prefix); setSuffix(suffix); &#125; public void setAlwaysInclude(boolean alwaysInclude) &#123; this.alwaysInclude = alwaysInclude; &#125; @Override protected Class&lt;?&gt; requiredViewClass() &#123; return InternalResourceView.class; &#125; @Override protected AbstractUrlBasedView instantiateView() &#123; return (getViewClass() == InternalResourceView.class ? new InternalResourceView() : (getViewClass() == JstlView.class ? new JstlView() : super.instantiateView())); &#125; @Override protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123; InternalResourceView view = (InternalResourceView) super.buildView(viewName); if (this.alwaysInclude != null) &#123; view.setAlwaysInclude(this.alwaysInclude); &#125; view.setPreventDispatchLoop(true); return view; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Framework","slug":"Spring/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/"},{"name":"lifecycle","slug":"Spring/Spring-Framework/lifecycle","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/lifecycle/"}],"tags":[]},{"title":"Spring MVC Request Life Cycle - HandlerAdapter","slug":"spring/spring-framework/lifecycle/spring-lifecycle-03-handleradapter","date":"2021-10-11T22:05:00.000Z","updated":"2024-02-26T15:56:45.373Z","comments":true,"path":"2021/10/12/spring/spring-framework/lifecycle/spring-lifecycle-03-handleradapter/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/lifecycle/spring-lifecycle-03-handleradapter/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter HandlerAdapter 살펴보기 HandlerAdapter 는 HandlerMapping 통해 찾은 Handler를 이용해 사용자 요청(Request)를 처리하는 역할을 한다. public interface HandlerAdapter &#123; // supports 메소드를 통해 HandlerAdapter 가 인자로 받은 handler를 지원하는지 확인한다. 보통 Handler에는 HandlerAdapter를 갖는다. boolean supports(Object handler); // handler를 이용해 사용자 Request를 처리한다. @Nullable ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; @Deprecated long getLastModified(HttpServletRequest request, Object handler);&#125; HandlerAdapter 구현체 AbstractHandlerMethodAdapter RequestMappingHandlerAdapter HandlerAdapter 지원 여부 확인하기 supports 메소드를 이용해 HandlerAdapter가 전달받은 Handler를 지원하는지 확인한다.","text":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter HandlerAdapter 살펴보기 HandlerAdapter 는 HandlerMapping 통해 찾은 Handler를 이용해 사용자 요청(Request)를 처리하는 역할을 한다. public interface HandlerAdapter &#123; // supports 메소드를 통해 HandlerAdapter 가 인자로 받은 handler를 지원하는지 확인한다. 보통 Handler에는 HandlerAdapter를 갖는다. boolean supports(Object handler); // handler를 이용해 사용자 Request를 처리한다. @Nullable ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; @Deprecated long getLastModified(HttpServletRequest request, Object handler);&#125; HandlerAdapter 구현체 AbstractHandlerMethodAdapter RequestMappingHandlerAdapter HandlerAdapter 지원 여부 확인하기 supports 메소드를 이용해 HandlerAdapter가 전달받은 Handler를 지원하는지 확인한다. AbstractHandlerMethodAdapter.java public final boolean supports(Object handler) &#123; return (handler instanceof HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));&#125; Handler를 이용해 Request(요청) 처리하기 HandlerAdapter 객체는 handle 메소드를 이용해 사용자 요청을 Handler 를 이용해 처리한 후 ModelAndView 객체를 반환한다. AbstractHandlerMethodAdapter.java @Override@Nullable public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod)handler);&#125; RequestMappingHandlerAdapter.java @Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; checkRequest(request); // Handler를 이용해 사용자 요청(Request)를 처리한 후 ModelAndView 객체를 반환 받는다. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No HttpSession available -&gt; no mutex necessary mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No synchronization on session demanded at all... mav = invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; prepareResponse(response); &#125; &#125; return mav;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Framework","slug":"Spring/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/"},{"name":"lifecycle","slug":"Spring/Spring-Framework/lifecycle","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/lifecycle/"}],"tags":[]},{"title":"Spring MVC Request Life Cycle - HandlerMapping","slug":"spring/spring-framework/lifecycle/spring-lifecycle-02-handlermapping","date":"2021-10-11T21:05:00.000Z","updated":"2024-02-26T15:56:41.093Z","comments":true,"path":"2021/10/12/spring/spring-framework/lifecycle/spring-lifecycle-02-handlermapping/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/lifecycle/spring-lifecycle-02-handlermapping/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter Spring MVC Request Life Cycle - HandlerMapping RequestMapping 어노테이션을 처리하는 Handler, Handler Adapter는 RequestMappingHandlerMapping, RequestMappingHandlerAdapter다 HandlerMapping 살펴보기 Request(요청)와 Request를 처리하기 위한 Handler의 Mapping 정보를 관리한다. HttpServletRequest 객체 Attribute에서 Handler의 정보를 가져올 수 있다. BEST_MATCHING_HANDLER_ATTRIBUTE 요청 URL과 가장 많이 일치하는 Handler를 가져온다. PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE 요청을 처리하기 위한 Handler의 URL을 가져온다. BEST_MATCHING_PATTERN_ATTRIBUTE 요청 URL과 가장 많이 일치하는 Handler Pattern(URL)을 가져온다. INTROSPECT_TYPE_LEVEL_MAPPING URI_TEMPLATE_VARIABLES_ATTRIBUTE 요청 URL에 포함된 PathVariable 정보를 가져온다. MATRIX_VARIABLES_ATTRIBUTE 요청 URL에 포함된 MATRIX 변수 정보를 가져온다. Matrix 변수를 사용하기 위해서는 WebMvcConfigurer 를 이용해 설정해줘야 한다. 반환 값은 MultiValueMap 형태의 데이터다. PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE HttpServletRequest 객체내 Attribute에서 Handler가 반환하는 Media Type 정보를 가져온다.","text":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter Spring MVC Request Life Cycle - HandlerMapping RequestMapping 어노테이션을 처리하는 Handler, Handler Adapter는 RequestMappingHandlerMapping, RequestMappingHandlerAdapter다 HandlerMapping 살펴보기 Request(요청)와 Request를 처리하기 위한 Handler의 Mapping 정보를 관리한다. HttpServletRequest 객체 Attribute에서 Handler의 정보를 가져올 수 있다. BEST_MATCHING_HANDLER_ATTRIBUTE 요청 URL과 가장 많이 일치하는 Handler를 가져온다. PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE 요청을 처리하기 위한 Handler의 URL을 가져온다. BEST_MATCHING_PATTERN_ATTRIBUTE 요청 URL과 가장 많이 일치하는 Handler Pattern(URL)을 가져온다. INTROSPECT_TYPE_LEVEL_MAPPING URI_TEMPLATE_VARIABLES_ATTRIBUTE 요청 URL에 포함된 PathVariable 정보를 가져온다. MATRIX_VARIABLES_ATTRIBUTE 요청 URL에 포함된 MATRIX 변수 정보를 가져온다. Matrix 변수를 사용하기 위해서는 WebMvcConfigurer 를 이용해 설정해줘야 한다. 반환 값은 MultiValueMap 형태의 데이터다. PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE HttpServletRequest 객체내 Attribute에서 Handler가 반환하는 Media Type 정보를 가져온다. Matrix 변수 사용하기 - https://www.baeldung.com/spring-mvc-matrix-variables HandlerMapping.java public interface HandlerMapping &#123; String BEST_MATCHING_HANDLER_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingHandler&quot;; @Deprecated String LOOKUP_PATH = HandlerMapping.class.getName() + &quot;.lookupPath&quot;; String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.pathWithinHandlerMapping&quot;; String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingPattern&quot;; String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &quot;.introspectTypeLevelMapping&quot;; String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.uriTemplateVariables&quot;; String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.matrixVariables&quot;; String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.producibleMediaTypes&quot;; default boolean usesPathPatterns() &#123; return false; &#125; // 요청에 대한 Handler 와 Interceptor를 포함하는 HandlerExecutionChain을 반환한다. // 만약 요청에 적절한 Handler가 없을 경우 null을 반환한다. @Nullable HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;&#125; 요청을 처리할 수 있는 Handler 가져오기 AbstractHandlerMapping 는 HandlerMapping 을 구현한 추상 클래스, 요청 경로와 Mapping된 Hanlder Interceptor 와 Default Hanlder 를 지원한다. Request를 처리하기 위한 Hander를 가져온다. AbstractHandlerMapping.java public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; // Request를 처리하기 위한 Handler를 가져온다. Object handler = getHandlerInternal(request); if (handler == null) &#123; handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; // Bean에 등록된 Handler를 가져온다. if (handler instanceof String) &#123; String handlerName = (String) handler; handler = obtainApplicationContext().getBean(handlerName); &#125; // Ensure presence of cached lookupPath for interceptors and others if (!ServletRequestPathUtils.hasCachedPath(request)) &#123; initLookupPath(request); &#125; HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Mapped to &quot; + handler); &#125; else if (logger.isDebugEnabled() &amp;&amp; !DispatcherType.ASYNC.equals(request.getDispatcherType())) &#123; logger.debug(&quot;Mapped to &quot; + executionChain.getHandler()); &#125; if (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123; CorsConfiguration config = getCorsConfiguration(handler, request); if (getCorsConfigurationSource() != null) &#123; CorsConfiguration globalConfig = getCorsConfigurationSource().getCorsConfiguration(request); config = (globalConfig != null ? globalConfig.combine(config) : config); &#125; if (config != null) &#123; config.validateAllowCredentials(); &#125; executionChain = getCorsHandlerExecutionChain(request, executionChain, config); &#125; return executionChain;&#125; AbstractHandlerMapping.java protected String initLookupPath(HttpServletRequest request) &#123; if (usesPathPatterns()) &#123; request.removeAttribute(UrlPathHelper.PATH_ATTRIBUTE); RequestPath requestPath = ServletRequestPathUtils.getParsedRequestPath(request); String lookupPath = requestPath.pathWithinApplication().value(); return UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath); &#125; else &#123; return getUrlPathHelper().resolveAndCacheLookupPath(request); &#125;&#125; AbstractHandlerMapping.java protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123; HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ? (HandlerExecutionChain) handler : new HandlerExecutionChain(handler)); for (HandlerInterceptor interceptor : this.adaptedInterceptors) &#123; if (interceptor instanceof MappedInterceptor) &#123; MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor; if (mappedInterceptor.matches(request)) &#123; chain.addInterceptor(mappedInterceptor.getInterceptor()); &#125; &#125; else &#123; chain.addInterceptor(interceptor); &#125; &#125; return chain;&#125; AbstractHandlerMethodMapping.java protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123; String lookupPath = initLookupPath(request); this.mappingRegistry.acquireReadLock(); try &#123; HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null); &#125; finally &#123; this.mappingRegistry.releaseReadLock(); &#125;&#125; AbstractHandlerMethodMapping.java @Nullableprotected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123; List&lt;Match&gt; matches = new ArrayList&lt;&gt;(); List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath); // 완전히 일치하는지 확인한다. if (directPathMatches != null) &#123; addMatchingMappings(directPathMatches, matches, request); &#125; // 요청 URL을 포함하는 Handler들이 있는지 확인한다. if (matches.isEmpty()) &#123; addMatchingMappings(this.mappingRegistry.getRegistrations().keySet(), matches, request); &#125; if (!matches.isEmpty()) &#123; Match bestMatch = matches.get(0); // 요청에 대한 Handler가 여러개 있는 경우 가장 많이 일치하는 Handler를 가져온다. if (matches.size() &gt; 1) &#123; Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request)); matches.sort(comparator); bestMatch = matches.get(0); if (logger.isTraceEnabled()) &#123; logger.trace(matches.size() + &quot; matching mappings: &quot; + matches); &#125; if (CorsUtils.isPreFlightRequest(request)) &#123; for (Match match : matches) &#123; if (match.hasCorsConfig()) &#123; return PREFLIGHT_AMBIGUOUS_MATCH; &#125; &#125; &#125; else &#123; Match secondBestMatch = matches.get(1); if (comparator.compare(bestMatch, secondBestMatch) == 0) &#123; Method m1 = bestMatch.getHandlerMethod().getMethod(); Method m2 = secondBestMatch.getHandlerMethod().getMethod(); String uri = request.getRequestURI(); throw new IllegalStateException( &quot;Ambiguous handler methods mapped for &#x27;&quot; + uri + &quot;&#x27;: &#123;&quot; + m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;); &#125; &#125; &#125; // Request 객체에 Handler를 BEST_MATCHING_HANDLER_ATTRIBUTE Key로 저장한다. request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.getHandlerMethod()); handleMatch(bestMatch.mapping, lookupPath, request); return bestMatch.getHandlerMethod(); &#125; else &#123; return handleNoMatch(this.mappingRegistry.getRegistrations().keySet(), lookupPath, request); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Framework","slug":"Spring/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/"},{"name":"lifecycle","slug":"Spring/Spring-Framework/lifecycle","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/lifecycle/"}],"tags":[]},{"title":"Spring MVC Request Life Cycle - DispatcherServlet","slug":"spring/spring-framework/lifecycle/spring-lifecycle-01-dispatcherservlet","date":"2021-10-11T20:05:00.000Z","updated":"2024-02-26T15:56:24.537Z","comments":true,"path":"2021/10/12/spring/spring-framework/lifecycle/spring-lifecycle-01-dispatcherservlet/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/lifecycle/spring-lifecycle-01-dispatcherservlet/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter DispatcherServlet 이란 사용자의 요청을 제일 먼저 받는 Front Controller, 스프링 MVC는 Front Controller 패턴 으로 구현돼 있다.DispatcherServlet도 HttpServlet을 상속 받고 Servlet으로 동작한다. 스프링 부트는 DispatcherServlet을 Servlet으로 자동으로 등록하면서 모든 경로(urlpattern &#x3D; “&#x2F;“) 에 대해 매핑한다. 사용자로 부터 들어오는 모든 요청을 제일 먼저 받아 적절한 Handler(Controller) 를 찾아 호출한다. 모든 요청은 DispatcherServlet을 거치기 때문에 모든 요청에 공통적인 작업 이 가능한다. 요청 흐름 서블릿이 호출 되면 HttpServlet에서 제공하는 service 메소드가 호출된다. 스프링 MVC는 DispatcherServlet의 부모인 FrameworkServlet 에서 service를 오버라이드 했다. FrameworkServlet service를 시작으로 여러 메소드를 호출되면서 DispatcherServlet의 doDispatch 메소드가 호출된다. DispatcherServlet 동작 과정 살펴보기","text":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter DispatcherServlet 이란 사용자의 요청을 제일 먼저 받는 Front Controller, 스프링 MVC는 Front Controller 패턴 으로 구현돼 있다.DispatcherServlet도 HttpServlet을 상속 받고 Servlet으로 동작한다. 스프링 부트는 DispatcherServlet을 Servlet으로 자동으로 등록하면서 모든 경로(urlpattern &#x3D; “&#x2F;“) 에 대해 매핑한다. 사용자로 부터 들어오는 모든 요청을 제일 먼저 받아 적절한 Handler(Controller) 를 찾아 호출한다. 모든 요청은 DispatcherServlet을 거치기 때문에 모든 요청에 공통적인 작업 이 가능한다. 요청 흐름 서블릿이 호출 되면 HttpServlet에서 제공하는 service 메소드가 호출된다. 스프링 MVC는 DispatcherServlet의 부모인 FrameworkServlet 에서 service를 오버라이드 했다. FrameworkServlet service를 시작으로 여러 메소드를 호출되면서 DispatcherServlet의 doDispatch 메소드가 호출된다. DispatcherServlet 동작 과정 살펴보기 Handler 조회 HandlerMapping을 이용해 요청에 매핑된 핸들러를 조회한다. 핸들러를 조회할 때 요청 URL을 이용해 많이 일치하는 순서대로 Handler들을 반환받는다. HandlerAdapter 조회 Handler를 실행할 수 있는 HandlerAdapter를 조회한다. HandlerInterceptor의 preHandler 메소드 실행 HandlerAdapter를 실행 HandlerAdapter는 요청을 처리할 수 있는 Handler를 실행시킨다. 처리 결과로 ModelAndView를 반환받는다. 반환된 ModelAndView 객체에 View가 없을 경우 RequestToViewNameTranslator를 이용해 적절한 View를 가져온다. HandlerInterceptor가 있다면 postHandler를 실행 DispatcherServlet 결과에 대한 후처리를 진행 예외에 대한 처리 View 렌더링 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 1. 현재 요청을 처리하기 위한 Handler(HandlerExecutionChain 객체)를 가져온다. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // 2. 현재 요청에 해당하는 HandlerAdapter를 가져온다. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 3. HandlerInterceptor가 있다면 preHandler를 실행시킨다. String method = request.getMethod(); boolean isGet = HttpMethod.GET.matches(method); if (isGet || HttpMethod.HEAD.matches(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 3. 등록된 인터셉터의 preHandle 메서드를 적용합니다. if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // 4. HandlerAdapter 객체를 이용해 Request를 Handler로 처리한 후 ModelAndView 객체를 반환 받는다. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; // 5. ModelAndView객체에 View name이 없을 경우 RequestToViewNameTranslator를 이용해 View name을 설정한다. applyDefaultViewName(processedRequest, mv); // 6. HandlerInterceptor가 있다면 postHandler를 실행시킨다. mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; // 7. DispatcherServlet 결과에 대한 후처리를 진행한다. // Handler 결과에서 예외가 떨어질 경우 예외처리를 진행하고 적절한 View가 있을 경우 Rendering을 진행한다. processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 1. 요청을 처리하기 위한 Handler 가져오기 getHandler 메소드는 DispatcherServlet이 가지고 있는 HandlerMapping 객체들 중에서 전달 받은 Request를 처리할 수 있는 Handler 객체를 가져온다. HandlerMapping 객체는 Request(요청)와 Request를 처리하기 위한 Handler의 Mapping 정보를 관리하는 관리하는 객체다. HandlerMapping 객체는 getHandler 메소드를 통해 Handler 와 HandlerInterceptor 를 갖고 있는 HandlerExecutionChain 객체를 가져온다. @Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null;&#125; 2. Handler를 사용하기 위한 HandlerAdapter 가져오기 getHandlerAdapter 메소드는 DispatcherServlet이 가지고 있는 HandlerAdapter 객체들 중에서 전달 받은 Handler를 지원 HandlerAdapter 객체를 가져온다. protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; // HandlerAdapter가 Handler를 지원하는지 확인한다. if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; throw new ServletException(&quot;No adapter for handler [&quot; + handler + &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);&#125; 3. ModelAndView 객체에 View 정보를 연결 ModelAndView 객체에 View가 없을 경우 RequestToViewNameTranslator 객체를 이용해 View를 얻어온다. RequestToViewNameTranslator 기본적인 구현체는 DefaultRequestToViewNameTranslator 가 있다. DefaultRequestToViewNameTranslator 는 요청 URL에 Prefix 와 Postfix 를 붙인 결과를 반환한다. private void applyDefaultViewName(HttpServletRequest request, @Nullable ModelAndView mv) throws Exception &#123; if (mv != null &amp;&amp; !mv.hasView()) &#123; String defaultViewName = getDefaultViewName(request); if (defaultViewName != null) &#123; mv.setViewName(defaultViewName); &#125; &#125;&#125; 반환 받은 View 객체가 null 일 경우 Controller의 반환 값이 null일 경우 DispatcherServlet에서 applyDefaultViewName 메소드를 통해 View를 가져온다. applyDefaultViewName 메소드의 기본 정책은 Request URL로부터 View name을 가져온다. // 아무것도 반환하지 않는 Controller@RequestMapping(&quot;/response/hello&quot;)public void responseViewV3(Model model)&#123; model.addAttribute(&quot;data&quot;, &quot;hello!&quot;);&#125; ModelAndView 객체내의 View 값이 null 인 것을 확인할 수 있다. 요청 URL을 이용해 View Name 을 가져온 것을 확인할 수 있다. 4. DispatcherServlet 결과에 대한 후 처리를 진행 processDispatchResult 메소드는 전달 받은 Exception 객체가 null이 아닐 경우 적절한 예외처리를 진행한다.ModelAndView 객체가 있을 경우 View or Model 데이터가 있는지 확인하고 문제가 없으면 View를 렌더링 한다. private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; // 예외가 있을 경우 예외처리를 진행한다. 1. ModelAndViewDefiningException, 2. ProcessHandlerException if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // 1. ModelAndView 객체가 비었는지 확인, 2. View or Model 데이터가 있는지 확인한다. if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // View Rendering을 호출한다. render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; View를 렌더링 한다. render 메소드에서는 ViewResolver를 이용해 View 객체를 가져온 후 View 객체를 렌더링 해준다. protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Determine locale for request and apply it to the response. Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale()); response.setLocale(locale); View view; String viewName = mv.getViewName(); if (viewName != null) &#123; // ViewResolver를 이용해 View 객체를 가져온다. view = resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException(&quot;Could not resolve view with name &#x27;&quot; + mv.getViewName() + &quot;&#x27; in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); &#125; &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); if (view == null) &#123; throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; + &quot;View object in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); &#125; &#125; // Delegate to the View object for rendering. if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Rendering view [&quot; + view + &quot;] &quot;); &#125; try &#123; if (mv.getStatus() != null) &#123; response.setStatus(mv.getStatus().value()); &#125; // View 객체를 렌더링 해준다. view.render(mv.getModelInternal(), request, response); &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Error rendering view [&quot; + view + &quot;]&quot;, ex); &#125; throw ex; &#125;&#125; resolveViewName 메소드는 viewName과 일치하는 View 객체를 가져온다. protected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception &#123; if (this.viewResolvers != null) &#123; for (ViewResolver viewResolver : this.viewResolvers) &#123; // viewName과 일치하는 View를 가져온다. View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; return view; &#125; &#125; &#125; return null;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Framework","slug":"Spring/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/"},{"name":"lifecycle","slug":"Spring/Spring-Framework/lifecycle","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/lifecycle/"}],"tags":[]},{"title":"Spring MVC - ArgumentResolver","slug":"spring/spring-framework/mvc/spring-mvc-11-argumentresolver","date":"2021-10-11T19:05:00.000Z","updated":"2024-02-26T16:00:29.114Z","comments":true,"path":"2021/10/12/spring/spring-framework/mvc/spring-mvc-11-argumentresolver/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/mvc/spring-mvc-11-argumentresolver/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging 참고 https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-%20arguments Spring Boot ArgumentResolver ArgumentResolver 를 통해 Spring 에서는 어노테이션 기반 Controller에 다양한 파라미터를 사용할 수 있다. 스프링에서 컨트롤러를 생성할 때 메소드 매게변수로 다양한 파라미터들을 넣을 수 있다. 메소드에 다양한 파라미터를 넣을 수 있도록 도움을 주는 게 바로 ArgumentResolver 다. HandlerMethodArgumentResolver.java HandlerMethodArgumentResolver 인터페이스를 구현함으로서 Controller 에서 넘어오는 Parameter 를 초기화 할 수 있다. supportsParameter 메소드를 통해 전달 받은 파라미터를 지원하는지 확인한 후 해당 파라미터를 지원하면 resolveArgument 를 통해 전달 받은 파리미터에 해당하는 객체를 생성한 후 Controller에 넘겨준다.","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging 참고 https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-%20arguments Spring Boot ArgumentResolver ArgumentResolver 를 통해 Spring 에서는 어노테이션 기반 Controller에 다양한 파라미터를 사용할 수 있다. 스프링에서 컨트롤러를 생성할 때 메소드 매게변수로 다양한 파라미터들을 넣을 수 있다. 메소드에 다양한 파라미터를 넣을 수 있도록 도움을 주는 게 바로 ArgumentResolver 다. HandlerMethodArgumentResolver.java HandlerMethodArgumentResolver 인터페이스를 구현함으로서 Controller 에서 넘어오는 Parameter 를 초기화 할 수 있다. supportsParameter 메소드를 통해 전달 받은 파라미터를 지원하는지 확인한 후 해당 파라미터를 지원하면 resolveArgument 를 통해 전달 받은 파리미터에 해당하는 객체를 생성한 후 Controller에 넘겨준다. public interface HandlerMethodArgumentResolver &#123; boolean supportsParameter(MethodParameter parameter); @Nullable Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;&#125; HttpEntityMethodProcessor.java HttpEntity, RequestEntity 객체를 초기화 하는 ArgumentResolver Parameter 의 타입이 HttpEntity, RequestEntity 인지 확인한다. public boolean supportsParameter(MethodParameter parameter) &#123; return HttpEntity.class == parameter.getParameterType() || RequestEntity.class == parameter.getParameterType();&#125; @Override@Nullablepublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws IOException, HttpMediaTypeNotSupportedException &#123; ServletServerHttpRequest inputMessage = createInputMessage(webRequest); Type paramType = getHttpEntityType(parameter); if (paramType == null) &#123; throw new IllegalArgumentException(&quot;HttpEntity parameter &#x27;&quot; + parameter.getParameterName() + &quot;&#x27; in method &quot; + parameter.getMethod() + &quot; is not parameterized&quot;); &#125; Object body = readWithMessageConverters(webRequest, parameter, paramType); if (RequestEntity.class == parameter.getParameterType()) &#123; // RequestEntity 객체를 반환한다. return new RequestEntity&lt;&gt;(body, inputMessage.getHeaders(), inputMessage.getMethod(), inputMessage.getURI()); &#125; else &#123; // HttpEntity 객체를 반환한다. return new HttpEntity&lt;&gt;(body, inputMessage.getHeaders()); &#125;&#125; AbstractMessageConverterMethodArgumentResolver.java@SuppressWarnings(&quot;unchecked&quot;)@Nullableprotected &lt;T&gt; Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123; MediaType contentType; boolean noContentType = false; try &#123; contentType = inputMessage.getHeaders().getContentType(); &#125; catch (InvalidMediaTypeException ex) &#123; throw new HttpMediaTypeNotSupportedException(ex.getMessage()); &#125; if (contentType == null) &#123; noContentType = true; contentType = MediaType.APPLICATION_OCTET_STREAM; &#125; Class&lt;?&gt; contextClass = parameter.getContainingClass(); Class&lt;T&gt; targetClass = (targetType instanceof Class ? (Class&lt;T&gt;) targetType : null); if (targetClass == null) &#123; ResolvableType resolvableType = ResolvableType.forMethodParameter(parameter); targetClass = (Class&lt;T&gt;) resolvableType.resolve(); &#125; HttpMethod httpMethod = (inputMessage instanceof HttpRequest ? ((HttpRequest) inputMessage).getMethod() : null); Object body = NO_VALUE; EmptyBodyCheckingHttpInputMessage message; try &#123; message = new EmptyBodyCheckingHttpInputMessage(inputMessage); for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123; Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(); GenericHttpMessageConverter&lt;?&gt; genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : null); if (genericConverter != null ? genericConverter.canRead(targetType, contextClass, contentType) : (targetClass != null &amp;&amp; converter.canRead(targetClass, contentType))) &#123; if (message.hasBody()) &#123; HttpInputMessage msgToUse = getAdvice().beforeBodyRead(message, parameter, targetType, converterType); body = (genericConverter != null ? genericConverter.read(targetType, contextClass, msgToUse) : ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse)); body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType); &#125; else &#123; body = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterType); &#125; break; &#125; &#125; &#125; catch (IOException ex) &#123; throw new HttpMessageNotReadableException(&quot;I/O error while reading input message&quot;, ex, inputMessage); &#125; if (body == NO_VALUE) &#123; if (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) || (noContentType &amp;&amp; !message.hasBody())) &#123; return null; &#125; throw new HttpMediaTypeNotSupportedException(contentType, getSupportedMediaTypes(targetClass != null ? targetClass : Object.class)); &#125; MediaType selectedContentType = contentType; Object theBody = body; LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123; String formatted = LogFormatUtils.formatValue(theBody, !traceOn); return &quot;Read \\&quot;&quot; + selectedContentType + &quot;\\&quot; to [&quot; + formatted + &quot;]&quot;; &#125;); return body;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Boot 응답 - 정적 리소스, 뷰 템플릿","slug":"spring/spring-framework/mvc/spring-mvc-08-responsestatic","date":"2021-10-11T17:05:00.000Z","updated":"2024-02-26T15:59:55.978Z","comments":true,"path":"2021/10/12/spring/spring-framework/mvc/spring-mvc-08-responsestatic/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/mvc/spring-mvc-08-responsestatic/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot 응답 - 정적 리소스, 뷰 템플릿@RequestMapping(&quot;/response-view-v1&quot;)public ModelAndView responseViewV1()&#123; ModelAndView mav = new ModelAndView(&quot;response/hello&quot;) .addObject(&quot;data&quot;, &quot;hello&quot;); return mav;&#125; String을 반환하는 경우뷰 리졸버를 통해 반환되는 문자열에 해당되는 뷰를 찾아 렌더링 해준다. @RequestMapping(&quot;/response-view-v2&quot;)public String responseViewV2(Model model)&#123; model.addAttribute(&quot;data&quot;, &quot;hello!&quot;); return &quot;response/hello&quot;;&#125; void를 반환하는 경우@RequestMapping(&quot;/response/hello&quot;)public void responseViewV3(Model model)&#123; model.addAttribute(&quot;data&quot;, &quot;hello!&quot;);&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot 응답 - 정적 리소스, 뷰 템플릿@RequestMapping(&quot;/response-view-v1&quot;)public ModelAndView responseViewV1()&#123; ModelAndView mav = new ModelAndView(&quot;response/hello&quot;) .addObject(&quot;data&quot;, &quot;hello&quot;); return mav;&#125; String을 반환하는 경우뷰 리졸버를 통해 반환되는 문자열에 해당되는 뷰를 찾아 렌더링 해준다. @RequestMapping(&quot;/response-view-v2&quot;)public String responseViewV2(Model model)&#123; model.addAttribute(&quot;data&quot;, &quot;hello!&quot;); return &quot;response/hello&quot;;&#125; void를 반환하는 경우@RequestMapping(&quot;/response/hello&quot;)public void responseViewV3(Model model)&#123; model.addAttribute(&quot;data&quot;, &quot;hello!&quot;);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력","slug":"spring/spring-framework/mvc/spring-mvc-09-httpresponse","date":"2021-10-11T17:05:00.000Z","updated":"2024-02-26T16:00:00.632Z","comments":true,"path":"2021/10/12/spring/spring-framework/mvc/spring-mvc-09-httpresponse/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/mvc/spring-mvc-09-httpresponse/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력@GetMapping(&quot;/response-body-string-v1&quot;)public void responseBodyV1(HttpServletResponse response) throws IOException &#123; response.getWriter().write(&quot;ok&quot;);&#125; @GetMapping(&quot;/response-body-string-v2&quot;)public ResponseEntity&lt;String&gt; responseBodyV2(HttpServletResponse response) &#123; return new ResponseEntity&lt;&gt;(&quot;ok&quot;, HttpStatus.OK);&#125; @ResponseBody@GetMapping(&quot;/response-body-string-v3&quot;)public String responseBodyV3(HttpServletResponse response) &#123; return &quot;ok&quot;;&#125; @GetMapping(&quot;/response-body-json-v1&quot;)public ResponseEntity&lt;HelloData&gt; responseBodyJsonV1() &#123; HelloData helloData = new HelloData(); helloData.setUsername(&quot;userA&quot;); helloData.setAge(20); return new ResponseEntity&lt;&gt;(helloData, HttpStatus.OK);&#125; @ResponseBody@ResponseStatus(HttpStatus.OK)@GetMapping(&quot;/response-body-json-v1&quot;)public HelloData responseBodyJsonV2() &#123; HelloData helloData = new HelloData(); helloData.setUsername(&quot;userA&quot;); helloData.setAge(20); return helloData;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력@GetMapping(&quot;/response-body-string-v1&quot;)public void responseBodyV1(HttpServletResponse response) throws IOException &#123; response.getWriter().write(&quot;ok&quot;);&#125; @GetMapping(&quot;/response-body-string-v2&quot;)public ResponseEntity&lt;String&gt; responseBodyV2(HttpServletResponse response) &#123; return new ResponseEntity&lt;&gt;(&quot;ok&quot;, HttpStatus.OK);&#125; @ResponseBody@GetMapping(&quot;/response-body-string-v3&quot;)public String responseBodyV3(HttpServletResponse response) &#123; return &quot;ok&quot;;&#125; @GetMapping(&quot;/response-body-json-v1&quot;)public ResponseEntity&lt;HelloData&gt; responseBodyJsonV1() &#123; HelloData helloData = new HelloData(); helloData.setUsername(&quot;userA&quot;); helloData.setAge(20); return new ResponseEntity&lt;&gt;(helloData, HttpStatus.OK);&#125; @ResponseBody@ResponseStatus(HttpStatus.OK)@GetMapping(&quot;/response-body-json-v1&quot;)public HelloData responseBodyJsonV2() &#123; HelloData helloData = new HelloData(); helloData.setUsername(&quot;userA&quot;); helloData.setAge(20); return helloData;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring MVC - HttpMessageConverter","slug":"spring/spring-framework/mvc/spring-mvc-10-messagecoverter","date":"2021-10-11T16:05:00.000Z","updated":"2024-02-26T16:00:15.837Z","comments":true,"path":"2021/10/12/spring/spring-framework/mvc/spring-mvc-10-messagecoverter/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/mvc/spring-mvc-10-messagecoverter/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring MVC - HttpMessageConverterHttpMessageConverter 는 HTTP 요청, 응답 둘다 사용된다. canRead, canWrite : 메시지 컨버터가 해당 클래스, 미디어 타입을 지원하는지 확인한다. read, write : 메시지 컨버터를 통해 메시지르 읽고 쓰는 기능 public interface HttpMessageConverter&lt;T&gt; &#123; boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType); boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType); List&lt;MediaType&gt; getSupportedMediaTypes(); default List&lt;MediaType&gt; getSupportedMediaTypes(Class&lt;?&gt; clazz) &#123; return (canRead(clazz, null) || canWrite(clazz, null) ? getSupportedMediaTypes() : Collections.emptyList()); &#125; T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException; void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;&#125; 스프링 부트 기본 메시지 컨버터 ByteArrayHttpMessageConverter StringHttpMessageConverter MappingJackson2HttpMessageConverter 스프링 부트는 다양한 메시지 컨버터를 제공하는데, 대상 클래스 타입과 미디어 타입 둘을 체크해 사용여부를 결정한다. 만약 해당되지 않으면 다음 메시지 컨버터로 넘어간다. ByteArrayHttpMessageConverter","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring MVC - HttpMessageConverterHttpMessageConverter 는 HTTP 요청, 응답 둘다 사용된다. canRead, canWrite : 메시지 컨버터가 해당 클래스, 미디어 타입을 지원하는지 확인한다. read, write : 메시지 컨버터를 통해 메시지르 읽고 쓰는 기능 public interface HttpMessageConverter&lt;T&gt; &#123; boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType); boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType); List&lt;MediaType&gt; getSupportedMediaTypes(); default List&lt;MediaType&gt; getSupportedMediaTypes(Class&lt;?&gt; clazz) &#123; return (canRead(clazz, null) || canWrite(clazz, null) ? getSupportedMediaTypes() : Collections.emptyList()); &#125; T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException; void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;&#125; 스프링 부트 기본 메시지 컨버터 ByteArrayHttpMessageConverter StringHttpMessageConverter MappingJackson2HttpMessageConverter 스프링 부트는 다양한 메시지 컨버터를 제공하는데, 대상 클래스 타입과 미디어 타입 둘을 체크해 사용여부를 결정한다. 만약 해당되지 않으면 다음 메시지 컨버터로 넘어간다. ByteArrayHttpMessageConverter byte[] 데이터를 처리하기 위한 Message Converter 클래스 타입 : byte[] 미디어 타입 : &#x2F; 요청 예시 : @ReqeustBody byte[] data 응답 예시 : @ResponseBody return byte[] 쓰기 미디어 타입 : application&#x2F;octet-stream StringHttpMessageConverter 문자로 데이터를 처리하기 위한 Message Converter 클래스 타입 : String 미디어 타입 : &#x2F; 요청 예시 : @RequestBody String data 응답 예시 : @ResponseBody return String 쓰기 미디어 타입 : text&#x2F;plain MappingJackson2HttpMessageConverter Json 데이터를 처리하기 위한 Message Converter 클래스 타입 : 객체 또는 HashMap 미디어 타입 : application&#x2F;json 요청 예시 : @RequestBody Hello data 응답 예시 : @ResponseBody return helloData 쓰기 미디어 타입 : application&#x2F;json HTTP 요청 데이터 읽기 HTTP 요청이 오면 컨트롤러에서 @RequestBody, HttpEntity 파라미터를 호출한다. 메시지 컨버터가 메시지를 읽을 수 있는지 확인하기 위해 canRead 메소드를 호출한다. 대상 클래스를 지원하는지 확인 HTTP 요청의 Content-Type을 지원하는지 확인 canRead 조건에 만족하면 read 메소드를 호출한다. HTTP 응답 데이터 보내기 컨트롤러에서 @ResponseBody, HttpEntity 로 값이 반환된다. 메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 canWrite 메소드를 호출한다. 대상 클래스를 지원하는지 확인 HTTP 요청의 Accept 미디어 타입을 지원하는지 확인 canWrite 조건에 만족하면 write 메소드를 호출해 HTTP 응답 메시지 바디에 데이터를 생성한다. public abstract class AbstractHttpMessageConverter&lt;T&gt; implements HttpMessageConverter&lt;T&gt; &#123; /** Logger available to subclasses. */ protected final Log logger = HttpLogging.forLogName(getClass()); private List&lt;MediaType&gt; supportedMediaTypes = Collections.emptyList(); @Nullable private Charset defaultCharset; protected AbstractHttpMessageConverter() &#123; &#125; protected AbstractHttpMessageConverter(MediaType supportedMediaType) &#123; setSupportedMediaTypes(Collections.singletonList(supportedMediaType)); &#125; protected AbstractHttpMessageConverter(MediaType... supportedMediaTypes) &#123; setSupportedMediaTypes(Arrays.asList(supportedMediaTypes)); &#125; protected AbstractHttpMessageConverter(Charset defaultCharset, MediaType... supportedMediaTypes) &#123; this.defaultCharset = defaultCharset; setSupportedMediaTypes(Arrays.asList(supportedMediaTypes)); &#125; public void setSupportedMediaTypes(List&lt;MediaType&gt; supportedMediaTypes) &#123; Assert.notEmpty(supportedMediaTypes, &quot;MediaType List must not be empty&quot;); this.supportedMediaTypes = new ArrayList&lt;&gt;(supportedMediaTypes); &#125; @Override public List&lt;MediaType&gt; getSupportedMediaTypes() &#123; return Collections.unmodifiableList(this.supportedMediaTypes); &#125; public void setDefaultCharset(@Nullable Charset defaultCharset) &#123; this.defaultCharset = defaultCharset; &#125; @Nullable public Charset getDefaultCharset() &#123; return this.defaultCharset; &#125; @Override public boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType) &#123; return supports(clazz) &amp;&amp; canRead(mediaType); &#125; protected boolean canRead(@Nullable MediaType mediaType) &#123; if (mediaType == null) &#123; return true; &#125; for (MediaType supportedMediaType : getSupportedMediaTypes()) &#123; if (supportedMediaType.includes(mediaType)) &#123; return true; &#125; &#125; return false; &#125; @Override public boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType) &#123; return supports(clazz) &amp;&amp; canWrite(mediaType); &#125; protected boolean canWrite(@Nullable MediaType mediaType) &#123; if (mediaType == null || MediaType.ALL.equalsTypeAndSubtype(mediaType)) &#123; return true; &#125; for (MediaType supportedMediaType : getSupportedMediaTypes()) &#123; if (supportedMediaType.isCompatibleWith(mediaType)) &#123; return true; &#125; &#125; return false; &#125; @Override public final T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; return readInternal(clazz, inputMessage); &#125; @Override public final void write(final T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; final HttpHeaders headers = outputMessage.getHeaders(); addDefaultHeaders(headers, t, contentType); if (outputMessage instanceof StreamingHttpOutputMessage) &#123; StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) outputMessage; streamingOutputMessage.setBody(outputStream -&gt; writeInternal(t, new HttpOutputMessage() &#123; @Override public OutputStream getBody() &#123; return outputStream; &#125; @Override public HttpHeaders getHeaders() &#123; return headers; &#125; &#125;)); &#125; else &#123; writeInternal(t, outputMessage); outputMessage.getBody().flush(); &#125; &#125; protected void addDefaultHeaders(HttpHeaders headers, T t, @Nullable MediaType contentType) throws IOException &#123; if (headers.getContentType() == null) &#123; MediaType contentTypeToUse = contentType; if (contentType == null || !contentType.isConcrete()) &#123; contentTypeToUse = getDefaultContentType(t); &#125; else if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) &#123; MediaType mediaType = getDefaultContentType(t); contentTypeToUse = (mediaType != null ? mediaType : contentTypeToUse); &#125; if (contentTypeToUse != null) &#123; if (contentTypeToUse.getCharset() == null) &#123; Charset defaultCharset = getDefaultCharset(); if (defaultCharset != null) &#123; contentTypeToUse = new MediaType(contentTypeToUse, defaultCharset); &#125; &#125; headers.setContentType(contentTypeToUse); &#125; &#125; if (headers.getContentLength() &lt; 0 &amp;&amp; !headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) &#123; Long contentLength = getContentLength(t, headers.getContentType()); if (contentLength != null) &#123; headers.setContentLength(contentLength); &#125; &#125; &#125; @Nullable protected MediaType getDefaultContentType(T t) throws IOException &#123; List&lt;MediaType&gt; mediaTypes = getSupportedMediaTypes(); return (!mediaTypes.isEmpty() ? mediaTypes.get(0) : null); &#125; @Nullable protected Long getContentLength(T t, @Nullable MediaType contentType) throws IOException &#123; return null; &#125; protected abstract boolean supports(Class&lt;?&gt; clazz); protected abstract T readInternal(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException; protected abstract void writeInternal(T t, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;&#125; public class ByteArrayHttpMessageConverter extends AbstractHttpMessageConverter&lt;byte[]&gt; &#123; /** * Create a new instance of the &#123;@code ByteArrayHttpMessageConverter&#125;. */ public ByteArrayHttpMessageConverter() &#123; super(MediaType.APPLICATION_OCTET_STREAM, MediaType.ALL); &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return byte[].class == clazz; &#125; @Override public byte[] readInternal(Class&lt;? extends byte[]&gt; clazz, HttpInputMessage inputMessage) throws IOException &#123; long contentLength = inputMessage.getHeaders().getContentLength(); ByteArrayOutputStream bos = new ByteArrayOutputStream( contentLength &gt;= 0 ? (int) contentLength : StreamUtils.BUFFER_SIZE); StreamUtils.copy(inputMessage.getBody(), bos); return bos.toByteArray(); &#125; @Override protected Long getContentLength(byte[] bytes, @Nullable MediaType contentType) &#123; return (long) bytes.length; &#125; @Override protected void writeInternal(byte[] bytes, HttpOutputMessage outputMessage) throws IOException &#123; StreamUtils.copy(bytes, outputMessage.getBody()); &#125;&#125; public class StringHttpMessageConverter extends AbstractHttpMessageConverter&lt;String&gt; &#123; private static final MediaType APPLICATION_PLUS_JSON = new MediaType(&quot;application&quot;, &quot;*+json&quot;); /** * The default charset used by the converter. */ public static final Charset DEFAULT_CHARSET = StandardCharsets.ISO_8859_1; @Nullable private volatile List&lt;Charset&gt; availableCharsets; private boolean writeAcceptCharset = false; /** * A default constructor that uses &#123;@code &quot;ISO-8859-1&quot;&#125; as the default charset. * * @see #StringHttpMessageConverter(Charset) */ public StringHttpMessageConverter() &#123; this(DEFAULT_CHARSET); &#125; /** * A constructor accepting a default charset to use if the requested content * type does not specify one. */ public StringHttpMessageConverter(Charset defaultCharset) &#123; super(defaultCharset, MediaType.TEXT_PLAIN, MediaType.ALL); &#125; /** * Whether the &#123;@code Accept-Charset&#125; header should be written to any outgoing * request sourced from the value of &#123;@link Charset#availableCharsets()&#125;. The * behavior is suppressed if the header has already been set. * &lt;p&gt; * As of 5.2, by default is set to &#123;@code false&#125;. */ public void setWriteAcceptCharset(boolean writeAcceptCharset) &#123; this.writeAcceptCharset = writeAcceptCharset; &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return String.class == clazz; &#125; @Override protected String readInternal(Class&lt;? extends String&gt; clazz, HttpInputMessage inputMessage) throws IOException &#123; Charset charset = getContentTypeCharset(inputMessage.getHeaders().getContentType()); return StreamUtils.copyToString(inputMessage.getBody(), charset); &#125; @Override protected Long getContentLength(String str, @Nullable MediaType contentType) &#123; Charset charset = getContentTypeCharset(contentType); return (long) str.getBytes(charset).length; &#125; @Override protected void addDefaultHeaders(HttpHeaders headers, String s, @Nullable MediaType type) throws IOException &#123; if (headers.getContentType() == null) &#123; if (type != null &amp;&amp; type.isConcrete() &amp;&amp; (type.isCompatibleWith(MediaType.APPLICATION_JSON) || type.isCompatibleWith(APPLICATION_PLUS_JSON))) &#123; // Prevent charset parameter for JSON.. headers.setContentType(type); &#125; &#125; super.addDefaultHeaders(headers, s, type); &#125; @Override protected void writeInternal(String str, HttpOutputMessage outputMessage) throws IOException &#123; HttpHeaders headers = outputMessage.getHeaders(); if (this.writeAcceptCharset &amp;&amp; headers.get(HttpHeaders.ACCEPT_CHARSET) == null) &#123; headers.setAcceptCharset(getAcceptedCharsets()); &#125; Charset charset = getContentTypeCharset(headers.getContentType()); StreamUtils.copy(str, charset, outputMessage.getBody()); &#125; /** * Return the list of supported &#123;@link Charset Charsets&#125;. * &lt;p&gt; * By default, returns &#123;@link Charset#availableCharsets()&#125;. Can be overridden in * subclasses. * * @return the list of accepted charsets */ protected List&lt;Charset&gt; getAcceptedCharsets() &#123; List&lt;Charset&gt; charsets = this.availableCharsets; if (charsets == null) &#123; charsets = new ArrayList&lt;&gt;(Charset.availableCharsets().values()); this.availableCharsets = charsets; &#125; return charsets; &#125; private Charset getContentTypeCharset(@Nullable MediaType contentType) &#123; if (contentType != null) &#123; Charset charset = contentType.getCharset(); if (charset != null) &#123; return charset; &#125; else if (contentType.isCompatibleWith(MediaType.APPLICATION_JSON) || contentType.isCompatibleWith(APPLICATION_PLUS_JSON)) &#123; // Matching to AbstractJackson2HttpMessageConverter#DEFAULT_CHARSET return StandardCharsets.UTF_8; &#125; &#125; Charset charset = getDefaultCharset(); Assert.state(charset != null, &quot;No default charset&quot;); return charset; &#125;&#125; public class MappingJackson2HttpMessageConverter extends AbstractJackson2HttpMessageConverter &#123; @Nullable private String jsonPrefix; /** * Construct a new &#123;@link MappingJackson2HttpMessageConverter&#125; using default * configuration provided by &#123;@link Jackson2ObjectMapperBuilder&#125;. */ public MappingJackson2HttpMessageConverter() &#123; this(Jackson2ObjectMapperBuilder.json().build()); &#125; /** * Construct a new &#123;@link MappingJackson2HttpMessageConverter&#125; with a custom * &#123;@link ObjectMapper&#125;. You can use &#123;@link Jackson2ObjectMapperBuilder&#125; to * build it easily. * * @see Jackson2ObjectMapperBuilder#json() */ public MappingJackson2HttpMessageConverter(ObjectMapper objectMapper) &#123; super(objectMapper, MediaType.APPLICATION_JSON, new MediaType(&quot;application&quot;, &quot;*+json&quot;)); &#125; /** * Specify a custom prefix to use for this view&#x27;s JSON output. Default is none. * * @see #setPrefixJson */ public void setJsonPrefix(String jsonPrefix) &#123; this.jsonPrefix = jsonPrefix; &#125; /** * Indicate whether the JSON output by this view should be prefixed with &quot;)]&#125;&#x27;, * &quot;. Default is false. * &lt;p&gt; * Prefixing the JSON string in this manner is used to help prevent JSON * Hijacking. The prefix renders the string syntactically invalid as a script so * that it cannot be hijacked. This prefix should be stripped before parsing the * string as JSON. * * @see #setJsonPrefix */ public void setPrefixJson(boolean prefixJson) &#123; this.jsonPrefix = (prefixJson ? &quot;)]&#125;&#x27;, &quot; : null); &#125; @Override protected void writePrefix(JsonGenerator generator, Object object) throws IOException &#123; if (this.jsonPrefix != null) &#123; generator.writeRaw(this.jsonPrefix); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Boot RequestMappingHandlerAdapter","slug":"spring/spring-framework/mvc/spring-mvc-12-RequestMappingHandlerAdapter","date":"2021-10-11T16:05:00.000Z","updated":"2024-02-26T16:01:10.559Z","comments":true,"path":"2021/10/12/spring/spring-framework/mvc/spring-mvc-12-RequestMappingHandlerAdapter/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/mvc/spring-mvc-12-RequestMappingHandlerAdapter/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; private static final boolean shouldIgnoreXml = SpringProperties.getFlag(&quot;spring.xml.ignore&quot;); public static final MethodFilter INIT_BINDER_METHODS = (method) -&gt; &#123; return AnnotatedElementUtils.hasAnnotation(method, InitBinder.class); &#125;; public static final MethodFilter MODEL_ATTRIBUTE_METHODS = (method) -&gt; &#123; return !AnnotatedElementUtils.hasAnnotation(method, RequestMapping.class) &amp;&amp; AnnotatedElementUtils.hasAnnotation(method, ModelAttribute.class); &#125;; @Nullable private List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers; @Nullable private HandlerMethodArgumentResolverComposite argumentResolvers; @Nullable private HandlerMethodArgumentResolverComposite initBinderArgumentResolvers; @Nullable private List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers; @Nullable private HandlerMethodReturnValueHandlerComposite returnValueHandlers; @Nullable private List&lt;ModelAndViewResolver&gt; modelAndViewResolvers; private ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager(); private List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList(4); private final List&lt;Object&gt; requestResponseBodyAdvice = new ArrayList(); @Nullable private WebBindingInitializer webBindingInitializer; private AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(&quot;MvcAsync&quot;); @Nullable private Long asyncRequestTimeout; private CallableProcessingInterceptor[] callableInterceptors = new CallableProcessingInterceptor[0]; private DeferredResultProcessingInterceptor[] deferredResultInterceptors = new DeferredResultProcessingInterceptor[0]; private ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance(); private boolean ignoreDefaultModelOnRedirect = false; private int cacheSecondsForSessionAttributeHandlers = 0; private boolean synchronizeOnSession = false; private SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore(); private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer(); @Nullable private ConfigurableBeanFactory beanFactory; private final Map&lt;Class&lt;?&gt;, SessionAttributesHandler&gt; sessionAttributesHandlerCache = new ConcurrentHashMap(64); private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; initBinderCache = new ConcurrentHashMap(64); private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; initBinderAdviceCache = new LinkedHashMap(); private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; modelAttributeCache = new ConcurrentHashMap(64); private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; modelAttributeAdviceCache = new LinkedHashMap(); public RequestMappingHandlerAdapter() &#123; this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(new StringHttpMessageConverter()); if (!shouldIgnoreXml) &#123; try &#123; this.messageConverters.add(new SourceHttpMessageConverter()); &#125; catch (Error var2) &#123; &#125; &#125; this.messageConverters.add(new AllEncompassingFormHttpMessageConverter()); &#125; public void setCustomArgumentResolvers(@Nullable List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; this.customArgumentResolvers = argumentResolvers; &#125; @Nullable public List&lt;HandlerMethodArgumentResolver&gt; getCustomArgumentResolvers() &#123; return this.customArgumentResolvers; &#125; public void setArgumentResolvers(@Nullable List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; if (argumentResolvers == null) &#123; this.argumentResolvers = null; &#125; else &#123; this.argumentResolvers = new HandlerMethodArgumentResolverComposite(); this.argumentResolvers.addResolvers(argumentResolvers); &#125; &#125; @Nullable public List&lt;HandlerMethodArgumentResolver&gt; getArgumentResolvers() &#123; return this.argumentResolvers != null ? this.argumentResolvers.getResolvers() : null; &#125; public void setInitBinderArgumentResolvers(@Nullable List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; if (argumentResolvers == null) &#123; this.initBinderArgumentResolvers = null; &#125; else &#123; this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite(); this.initBinderArgumentResolvers.addResolvers(argumentResolvers); &#125; &#125; @Nullable public List&lt;HandlerMethodArgumentResolver&gt; getInitBinderArgumentResolvers() &#123; return this.initBinderArgumentResolvers != null ? this.initBinderArgumentResolvers.getResolvers() : null; &#125; public void setCustomReturnValueHandlers(@Nullable List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) &#123; this.customReturnValueHandlers = returnValueHandlers; &#125; @Nullable public List&lt;HandlerMethodReturnValueHandler&gt; getCustomReturnValueHandlers() &#123; return this.customReturnValueHandlers; &#125; public void setReturnValueHandlers(@Nullable List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) &#123; if (returnValueHandlers == null) &#123; this.returnValueHandlers = null; &#125; else &#123; this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite(); this.returnValueHandlers.addHandlers(returnValueHandlers); &#125; &#125; @Nullable public List&lt;HandlerMethodReturnValueHandler&gt; getReturnValueHandlers() &#123; return this.returnValueHandlers != null ? this.returnValueHandlers.getHandlers() : null; &#125; public void setModelAndViewResolvers(@Nullable List&lt;ModelAndViewResolver&gt; modelAndViewResolvers) &#123; this.modelAndViewResolvers = modelAndViewResolvers; &#125; @Nullable public List&lt;ModelAndViewResolver&gt; getModelAndViewResolvers() &#123; return this.modelAndViewResolvers; &#125; public void setContentNegotiationManager(ContentNegotiationManager contentNegotiationManager) &#123; this.contentNegotiationManager = contentNegotiationManager; &#125; public void setMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) &#123; this.messageConverters = messageConverters; &#125; public List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123; return this.messageConverters; &#125; public void setRequestBodyAdvice(@Nullable List&lt;RequestBodyAdvice&gt; requestBodyAdvice) &#123; if (requestBodyAdvice != null) &#123; this.requestResponseBodyAdvice.addAll(requestBodyAdvice); &#125; &#125; public void setResponseBodyAdvice(@Nullable List&lt;ResponseBodyAdvice&lt;?&gt;&gt; responseBodyAdvice) &#123; if (responseBodyAdvice != null) &#123; this.requestResponseBodyAdvice.addAll(responseBodyAdvice); &#125; &#125; public void setWebBindingInitializer(@Nullable WebBindingInitializer webBindingInitializer) &#123; this.webBindingInitializer = webBindingInitializer; &#125; @Nullable public WebBindingInitializer getWebBindingInitializer() &#123; return this.webBindingInitializer; &#125; public void setTaskExecutor(AsyncTaskExecutor taskExecutor) &#123; this.taskExecutor = taskExecutor; &#125; public void setAsyncRequestTimeout(long timeout) &#123; this.asyncRequestTimeout = timeout; &#125; public void setCallableInterceptors(List&lt;CallableProcessingInterceptor&gt; interceptors) &#123; this.callableInterceptors = (CallableProcessingInterceptor[])interceptors.toArray(new CallableProcessingInterceptor[0]); &#125; public void setDeferredResultInterceptors(List&lt;DeferredResultProcessingInterceptor&gt; interceptors) &#123; this.deferredResultInterceptors = (DeferredResultProcessingInterceptor[])interceptors.toArray(new DeferredResultProcessingInterceptor[0]); &#125; public void setReactiveAdapterRegistry(ReactiveAdapterRegistry reactiveAdapterRegistry) &#123; this.reactiveAdapterRegistry = reactiveAdapterRegistry; &#125; public ReactiveAdapterRegistry getReactiveAdapterRegistry() &#123; return this.reactiveAdapterRegistry; &#125; public void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) &#123; this.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect; &#125; public void setSessionAttributeStore(SessionAttributeStore sessionAttributeStore) &#123; this.sessionAttributeStore = sessionAttributeStore; &#125; public void setCacheSecondsForSessionAttributeHandlers(int cacheSecondsForSessionAttributeHandlers) &#123; this.cacheSecondsForSessionAttributeHandlers = cacheSecondsForSessionAttributeHandlers; &#125; public void setSynchronizeOnSession(boolean synchronizeOnSession) &#123; this.synchronizeOnSession = synchronizeOnSession; &#125; public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) &#123; this.parameterNameDiscoverer = parameterNameDiscoverer; &#125; public void setBeanFactory(BeanFactory beanFactory) &#123; if (beanFactory instanceof ConfigurableBeanFactory) &#123; this.beanFactory = (ConfigurableBeanFactory)beanFactory; &#125; &#125; @Nullable protected ConfigurableBeanFactory getBeanFactory() &#123; return this.beanFactory; &#125; public void afterPropertiesSet() &#123; this.initControllerAdviceCache(); List handlers; if (this.argumentResolvers == null) &#123; handlers = this.getDefaultArgumentResolvers(); this.argumentResolvers = (new HandlerMethodArgumentResolverComposite()).addResolvers(handlers); &#125; if (this.initBinderArgumentResolvers == null) &#123; handlers = this.getDefaultInitBinderArgumentResolvers(); this.initBinderArgumentResolvers = (new HandlerMethodArgumentResolverComposite()).addResolvers(handlers); &#125; if (this.returnValueHandlers == null) &#123; handlers = this.getDefaultReturnValueHandlers(); this.returnValueHandlers = (new HandlerMethodReturnValueHandlerComposite()).addHandlers(handlers); &#125; &#125; private void initControllerAdviceCache() &#123; if (this.getApplicationContext() != null) &#123; List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(this.getApplicationContext()); List&lt;Object&gt; requestResponseBodyAdviceBeans = new ArrayList(); Iterator var3 = adviceBeans.iterator(); while(var3.hasNext()) &#123; ControllerAdviceBean adviceBean = (ControllerAdviceBean)var3.next(); Class&lt;?&gt; beanType = adviceBean.getBeanType(); if (beanType == null) &#123; throw new IllegalStateException(&quot;Unresolvable type for ControllerAdviceBean: &quot; + adviceBean); &#125; Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS); if (!attrMethods.isEmpty()) &#123; this.modelAttributeAdviceCache.put(adviceBean, attrMethods); &#125; Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS); if (!binderMethods.isEmpty()) &#123; this.initBinderAdviceCache.put(adviceBean, binderMethods); &#125; if (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123; requestResponseBodyAdviceBeans.add(adviceBean); &#125; &#125; if (!requestResponseBodyAdviceBeans.isEmpty()) &#123; this.requestResponseBodyAdvice.addAll(0, requestResponseBodyAdviceBeans); &#125; if (this.logger.isDebugEnabled()) &#123; int modelSize = this.modelAttributeAdviceCache.size(); int binderSize = this.initBinderAdviceCache.size(); int reqCount = this.getBodyAdviceCount(RequestBodyAdvice.class); int resCount = this.getBodyAdviceCount(ResponseBodyAdvice.class); if (modelSize == 0 &amp;&amp; binderSize == 0 &amp;&amp; reqCount == 0 &amp;&amp; resCount == 0) &#123; this.logger.debug(&quot;ControllerAdvice beans: none&quot;); &#125; else &#123; this.logger.debug(&quot;ControllerAdvice beans: &quot; + modelSize + &quot; @ModelAttribute, &quot; + binderSize + &quot; @InitBinder, &quot; + reqCount + &quot; RequestBodyAdvice, &quot; + resCount + &quot; ResponseBodyAdvice&quot;); &#125; &#125; &#125; &#125; private int getBodyAdviceCount(Class&lt;?&gt; adviceType) &#123; List&lt;Object&gt; advice = this.requestResponseBodyAdvice; return RequestBodyAdvice.class.isAssignableFrom(adviceType) ? RequestResponseBodyAdviceChain.getAdviceByType(advice, RequestBodyAdvice.class).size() : RequestResponseBodyAdviceChain.getAdviceByType(advice, ResponseBodyAdvice.class).size(); &#125; private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList(30); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new PathVariableMethodArgumentResolver()); resolvers.add(new PathVariableMapMethodArgumentResolver()); resolvers.add(new MatrixVariableMethodArgumentResolver()); resolvers.add(new MatrixVariableMapMethodArgumentResolver()); resolvers.add(new ServletModelAttributeMethodProcessor(false)); resolvers.add(new RequestResponseBodyMethodProcessor(this.getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestPartMethodArgumentResolver(this.getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestHeaderMethodArgumentResolver(this.getBeanFactory())); resolvers.add(new RequestHeaderMapMethodArgumentResolver()); resolvers.add(new ServletCookieValueMethodArgumentResolver(this.getBeanFactory())); resolvers.add(new ExpressionValueMethodArgumentResolver(this.getBeanFactory())); resolvers.add(new SessionAttributeMethodArgumentResolver()); resolvers.add(new RequestAttributeMethodArgumentResolver()); resolvers.add(new ServletRequestMethodArgumentResolver()); resolvers.add(new ServletResponseMethodArgumentResolver()); resolvers.add(new HttpEntityMethodProcessor(this.getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RedirectAttributesMethodArgumentResolver()); resolvers.add(new ModelMethodProcessor()); resolvers.add(new MapMethodProcessor()); resolvers.add(new ErrorsMethodArgumentResolver()); resolvers.add(new SessionStatusMethodArgumentResolver()); resolvers.add(new UriComponentsBuilderMethodArgumentResolver()); if (KotlinDetector.isKotlinPresent()) &#123; resolvers.add(new ContinuationHandlerMethodArgumentResolver()); &#125; if (this.getCustomArgumentResolvers() != null) &#123; resolvers.addAll(this.getCustomArgumentResolvers()); &#125; resolvers.add(new PrincipalMethodArgumentResolver()); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), true)); resolvers.add(new ServletModelAttributeMethodProcessor(true)); return resolvers; &#125; private List&lt;HandlerMethodArgumentResolver&gt; getDefaultInitBinderArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList(20); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new PathVariableMethodArgumentResolver()); resolvers.add(new PathVariableMapMethodArgumentResolver()); resolvers.add(new MatrixVariableMethodArgumentResolver()); resolvers.add(new MatrixVariableMapMethodArgumentResolver()); resolvers.add(new ExpressionValueMethodArgumentResolver(this.getBeanFactory())); resolvers.add(new SessionAttributeMethodArgumentResolver()); resolvers.add(new RequestAttributeMethodArgumentResolver()); resolvers.add(new ServletRequestMethodArgumentResolver()); resolvers.add(new ServletResponseMethodArgumentResolver()); if (this.getCustomArgumentResolvers() != null) &#123; resolvers.addAll(this.getCustomArgumentResolvers()); &#125; resolvers.add(new PrincipalMethodArgumentResolver()); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), true)); return resolvers; &#125; private List&lt;HandlerMethodReturnValueHandler&gt; getDefaultReturnValueHandlers() &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = new ArrayList(20); handlers.add(new ModelAndViewMethodReturnValueHandler()); handlers.add(new ModelMethodProcessor()); handlers.add(new ViewMethodReturnValueHandler()); handlers.add(new ResponseBodyEmitterReturnValueHandler(this.getMessageConverters(), this.reactiveAdapterRegistry, this.taskExecutor, this.contentNegotiationManager)); handlers.add(new StreamingResponseBodyReturnValueHandler()); handlers.add(new HttpEntityMethodProcessor(this.getMessageConverters(), this.contentNegotiationManager, this.requestResponseBodyAdvice)); handlers.add(new HttpHeadersReturnValueHandler()); handlers.add(new CallableMethodReturnValueHandler()); handlers.add(new DeferredResultMethodReturnValueHandler()); handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory)); handlers.add(new ServletModelAttributeMethodProcessor(false)); handlers.add(new RequestResponseBodyMethodProcessor(this.getMessageConverters(), this.contentNegotiationManager, this.requestResponseBodyAdvice)); handlers.add(new ViewNameMethodReturnValueHandler()); handlers.add(new MapMethodProcessor()); if (this.getCustomReturnValueHandlers() != null) &#123; handlers.addAll(this.getCustomReturnValueHandlers()); &#125; if (!CollectionUtils.isEmpty(this.getModelAndViewResolvers())) &#123; handlers.add(new ModelAndViewResolverMethodReturnValueHandler(this.getModelAndViewResolvers())); &#125; else &#123; handlers.add(new ServletModelAttributeMethodProcessor(true)); &#125; return handlers; &#125; protected boolean supportsInternal(HandlerMethod handlerMethod) &#123; return true; &#125; protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; this.checkRequest(request); ModelAndView mav; if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized(mutex) &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(&quot;Cache-Control&quot;)) &#123; if (this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; this.applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; this.prepareResponse(response); &#125; &#125; return mav; &#125; protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) &#123; return -1L; &#125; private SessionAttributesHandler getSessionAttributesHandler(HandlerMethod handlerMethod) &#123; return (SessionAttributesHandler)this.sessionAttributesHandlerCache.computeIfAbsent(handlerMethod.getBeanType(), (type) -&gt; &#123; return new SessionAttributesHandler(type, this.sessionAttributeStore); &#125;); &#125; @Nullable protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); Object result; try &#123; WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod); ModelFactory modelFactory = this.getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = this.createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); LogFormatUtils.traceDebug(this.logger, (traceOn) -&gt; &#123; String formatted = LogFormatUtils.formatValue(result, !traceOn); return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;; &#125;); invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; invocableMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]); if (!asyncManager.isConcurrentHandlingStarted()) &#123; ModelAndView var15 = this.getModelAndView(mavContainer, modelFactory, webRequest); return var15; &#125; result = null; &#125; finally &#123; webRequest.requestCompleted(); &#125; return (ModelAndView)result; &#125; protected ServletInvocableHandlerMethod createInvocableHandlerMethod(HandlerMethod handlerMethod) &#123; return new ServletInvocableHandlerMethod(handlerMethod); &#125; private ModelFactory getModelFactory(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) &#123; SessionAttributesHandler sessionAttrHandler = this.getSessionAttributesHandler(handlerMethod); Class&lt;?&gt; handlerType = handlerMethod.getBeanType(); Set&lt;Method&gt; methods = (Set)this.modelAttributeCache.get(handlerType); if (methods == null) &#123; methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS); this.modelAttributeCache.put(handlerType, methods); &#125; List&lt;InvocableHandlerMethod&gt; attrMethods = new ArrayList(); this.modelAttributeAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123; if (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123; Object bean = controllerAdviceBean.resolveBean(); Iterator var7 = methodSet.iterator(); while(var7.hasNext()) &#123; Method method = (Method)var7.next(); attrMethods.add(this.createModelAttributeMethod(binderFactory, bean, method)); &#125; &#125; &#125;); Iterator var7 = methods.iterator(); while(var7.hasNext()) &#123; Method method = (Method)var7.next(); Object bean = handlerMethod.getBean(); attrMethods.add(this.createModelAttributeMethod(binderFactory, bean, method)); &#125; return new ModelFactory(attrMethods, binderFactory, sessionAttrHandler); &#125; private InvocableHandlerMethod createModelAttributeMethod(WebDataBinderFactory factory, Object bean, Method method) &#123; InvocableHandlerMethod attrMethod = new InvocableHandlerMethod(bean, method); if (this.argumentResolvers != null) &#123; attrMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; attrMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); attrMethod.setDataBinderFactory(factory); return attrMethod; &#125; private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception &#123; Class&lt;?&gt; handlerType = handlerMethod.getBeanType(); Set&lt;Method&gt; methods = (Set)this.initBinderCache.get(handlerType); if (methods == null) &#123; methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS); this.initBinderCache.put(handlerType, methods); &#125; List&lt;InvocableHandlerMethod&gt; initBinderMethods = new ArrayList(); this.initBinderAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123; if (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123; Object bean = controllerAdviceBean.resolveBean(); Iterator var6 = methodSet.iterator(); while(var6.hasNext()) &#123; Method method = (Method)var6.next(); initBinderMethods.add(this.createInitBinderMethod(bean, method)); &#125; &#125; &#125;); Iterator var5 = methods.iterator(); while(var5.hasNext()) &#123; Method method = (Method)var5.next(); Object bean = handlerMethod.getBean(); initBinderMethods.add(this.createInitBinderMethod(bean, method)); &#125; return this.createDataBinderFactory(initBinderMethods); &#125; private InvocableHandlerMethod createInitBinderMethod(Object bean, Method method) &#123; InvocableHandlerMethod binderMethod = new InvocableHandlerMethod(bean, method); if (this.initBinderArgumentResolvers != null) &#123; binderMethod.setHandlerMethodArgumentResolvers(this.initBinderArgumentResolvers); &#125; binderMethod.setDataBinderFactory(new DefaultDataBinderFactory(this.webBindingInitializer)); binderMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); return binderMethod; &#125; protected InitBinderDataBinderFactory createDataBinderFactory(List&lt;InvocableHandlerMethod&gt; binderMethods) throws Exception &#123; return new ServletRequestDataBinderFactory(binderMethods, this.getWebBindingInitializer()); &#125; @Nullable private ModelAndView getModelAndView(ModelAndViewContainer mavContainer, ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception &#123; modelFactory.updateModel(webRequest, mavContainer); if (mavContainer.isRequestHandled()) &#123; return null; &#125; else &#123; ModelMap model = mavContainer.getModel(); ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus()); if (!mavContainer.isViewReference()) &#123; mav.setView((View)mavContainer.getView()); &#125; if (model instanceof RedirectAttributes) &#123; Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes)model).getFlashAttributes(); HttpServletRequest request = (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class); if (request != null) &#123; RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes); &#125; &#125; return mav; &#125; &#125;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; private static final boolean shouldIgnoreXml = SpringProperties.getFlag(&quot;spring.xml.ignore&quot;); public static final MethodFilter INIT_BINDER_METHODS = (method) -&gt; &#123; return AnnotatedElementUtils.hasAnnotation(method, InitBinder.class); &#125;; public static final MethodFilter MODEL_ATTRIBUTE_METHODS = (method) -&gt; &#123; return !AnnotatedElementUtils.hasAnnotation(method, RequestMapping.class) &amp;&amp; AnnotatedElementUtils.hasAnnotation(method, ModelAttribute.class); &#125;; @Nullable private List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers; @Nullable private HandlerMethodArgumentResolverComposite argumentResolvers; @Nullable private HandlerMethodArgumentResolverComposite initBinderArgumentResolvers; @Nullable private List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers; @Nullable private HandlerMethodReturnValueHandlerComposite returnValueHandlers; @Nullable private List&lt;ModelAndViewResolver&gt; modelAndViewResolvers; private ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager(); private List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList(4); private final List&lt;Object&gt; requestResponseBodyAdvice = new ArrayList(); @Nullable private WebBindingInitializer webBindingInitializer; private AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(&quot;MvcAsync&quot;); @Nullable private Long asyncRequestTimeout; private CallableProcessingInterceptor[] callableInterceptors = new CallableProcessingInterceptor[0]; private DeferredResultProcessingInterceptor[] deferredResultInterceptors = new DeferredResultProcessingInterceptor[0]; private ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance(); private boolean ignoreDefaultModelOnRedirect = false; private int cacheSecondsForSessionAttributeHandlers = 0; private boolean synchronizeOnSession = false; private SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore(); private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer(); @Nullable private ConfigurableBeanFactory beanFactory; private final Map&lt;Class&lt;?&gt;, SessionAttributesHandler&gt; sessionAttributesHandlerCache = new ConcurrentHashMap(64); private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; initBinderCache = new ConcurrentHashMap(64); private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; initBinderAdviceCache = new LinkedHashMap(); private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; modelAttributeCache = new ConcurrentHashMap(64); private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; modelAttributeAdviceCache = new LinkedHashMap(); public RequestMappingHandlerAdapter() &#123; this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(new StringHttpMessageConverter()); if (!shouldIgnoreXml) &#123; try &#123; this.messageConverters.add(new SourceHttpMessageConverter()); &#125; catch (Error var2) &#123; &#125; &#125; this.messageConverters.add(new AllEncompassingFormHttpMessageConverter()); &#125; public void setCustomArgumentResolvers(@Nullable List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; this.customArgumentResolvers = argumentResolvers; &#125; @Nullable public List&lt;HandlerMethodArgumentResolver&gt; getCustomArgumentResolvers() &#123; return this.customArgumentResolvers; &#125; public void setArgumentResolvers(@Nullable List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; if (argumentResolvers == null) &#123; this.argumentResolvers = null; &#125; else &#123; this.argumentResolvers = new HandlerMethodArgumentResolverComposite(); this.argumentResolvers.addResolvers(argumentResolvers); &#125; &#125; @Nullable public List&lt;HandlerMethodArgumentResolver&gt; getArgumentResolvers() &#123; return this.argumentResolvers != null ? this.argumentResolvers.getResolvers() : null; &#125; public void setInitBinderArgumentResolvers(@Nullable List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; if (argumentResolvers == null) &#123; this.initBinderArgumentResolvers = null; &#125; else &#123; this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite(); this.initBinderArgumentResolvers.addResolvers(argumentResolvers); &#125; &#125; @Nullable public List&lt;HandlerMethodArgumentResolver&gt; getInitBinderArgumentResolvers() &#123; return this.initBinderArgumentResolvers != null ? this.initBinderArgumentResolvers.getResolvers() : null; &#125; public void setCustomReturnValueHandlers(@Nullable List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) &#123; this.customReturnValueHandlers = returnValueHandlers; &#125; @Nullable public List&lt;HandlerMethodReturnValueHandler&gt; getCustomReturnValueHandlers() &#123; return this.customReturnValueHandlers; &#125; public void setReturnValueHandlers(@Nullable List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) &#123; if (returnValueHandlers == null) &#123; this.returnValueHandlers = null; &#125; else &#123; this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite(); this.returnValueHandlers.addHandlers(returnValueHandlers); &#125; &#125; @Nullable public List&lt;HandlerMethodReturnValueHandler&gt; getReturnValueHandlers() &#123; return this.returnValueHandlers != null ? this.returnValueHandlers.getHandlers() : null; &#125; public void setModelAndViewResolvers(@Nullable List&lt;ModelAndViewResolver&gt; modelAndViewResolvers) &#123; this.modelAndViewResolvers = modelAndViewResolvers; &#125; @Nullable public List&lt;ModelAndViewResolver&gt; getModelAndViewResolvers() &#123; return this.modelAndViewResolvers; &#125; public void setContentNegotiationManager(ContentNegotiationManager contentNegotiationManager) &#123; this.contentNegotiationManager = contentNegotiationManager; &#125; public void setMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) &#123; this.messageConverters = messageConverters; &#125; public List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123; return this.messageConverters; &#125; public void setRequestBodyAdvice(@Nullable List&lt;RequestBodyAdvice&gt; requestBodyAdvice) &#123; if (requestBodyAdvice != null) &#123; this.requestResponseBodyAdvice.addAll(requestBodyAdvice); &#125; &#125; public void setResponseBodyAdvice(@Nullable List&lt;ResponseBodyAdvice&lt;?&gt;&gt; responseBodyAdvice) &#123; if (responseBodyAdvice != null) &#123; this.requestResponseBodyAdvice.addAll(responseBodyAdvice); &#125; &#125; public void setWebBindingInitializer(@Nullable WebBindingInitializer webBindingInitializer) &#123; this.webBindingInitializer = webBindingInitializer; &#125; @Nullable public WebBindingInitializer getWebBindingInitializer() &#123; return this.webBindingInitializer; &#125; public void setTaskExecutor(AsyncTaskExecutor taskExecutor) &#123; this.taskExecutor = taskExecutor; &#125; public void setAsyncRequestTimeout(long timeout) &#123; this.asyncRequestTimeout = timeout; &#125; public void setCallableInterceptors(List&lt;CallableProcessingInterceptor&gt; interceptors) &#123; this.callableInterceptors = (CallableProcessingInterceptor[])interceptors.toArray(new CallableProcessingInterceptor[0]); &#125; public void setDeferredResultInterceptors(List&lt;DeferredResultProcessingInterceptor&gt; interceptors) &#123; this.deferredResultInterceptors = (DeferredResultProcessingInterceptor[])interceptors.toArray(new DeferredResultProcessingInterceptor[0]); &#125; public void setReactiveAdapterRegistry(ReactiveAdapterRegistry reactiveAdapterRegistry) &#123; this.reactiveAdapterRegistry = reactiveAdapterRegistry; &#125; public ReactiveAdapterRegistry getReactiveAdapterRegistry() &#123; return this.reactiveAdapterRegistry; &#125; public void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) &#123; this.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect; &#125; public void setSessionAttributeStore(SessionAttributeStore sessionAttributeStore) &#123; this.sessionAttributeStore = sessionAttributeStore; &#125; public void setCacheSecondsForSessionAttributeHandlers(int cacheSecondsForSessionAttributeHandlers) &#123; this.cacheSecondsForSessionAttributeHandlers = cacheSecondsForSessionAttributeHandlers; &#125; public void setSynchronizeOnSession(boolean synchronizeOnSession) &#123; this.synchronizeOnSession = synchronizeOnSession; &#125; public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) &#123; this.parameterNameDiscoverer = parameterNameDiscoverer; &#125; public void setBeanFactory(BeanFactory beanFactory) &#123; if (beanFactory instanceof ConfigurableBeanFactory) &#123; this.beanFactory = (ConfigurableBeanFactory)beanFactory; &#125; &#125; @Nullable protected ConfigurableBeanFactory getBeanFactory() &#123; return this.beanFactory; &#125; public void afterPropertiesSet() &#123; this.initControllerAdviceCache(); List handlers; if (this.argumentResolvers == null) &#123; handlers = this.getDefaultArgumentResolvers(); this.argumentResolvers = (new HandlerMethodArgumentResolverComposite()).addResolvers(handlers); &#125; if (this.initBinderArgumentResolvers == null) &#123; handlers = this.getDefaultInitBinderArgumentResolvers(); this.initBinderArgumentResolvers = (new HandlerMethodArgumentResolverComposite()).addResolvers(handlers); &#125; if (this.returnValueHandlers == null) &#123; handlers = this.getDefaultReturnValueHandlers(); this.returnValueHandlers = (new HandlerMethodReturnValueHandlerComposite()).addHandlers(handlers); &#125; &#125; private void initControllerAdviceCache() &#123; if (this.getApplicationContext() != null) &#123; List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(this.getApplicationContext()); List&lt;Object&gt; requestResponseBodyAdviceBeans = new ArrayList(); Iterator var3 = adviceBeans.iterator(); while(var3.hasNext()) &#123; ControllerAdviceBean adviceBean = (ControllerAdviceBean)var3.next(); Class&lt;?&gt; beanType = adviceBean.getBeanType(); if (beanType == null) &#123; throw new IllegalStateException(&quot;Unresolvable type for ControllerAdviceBean: &quot; + adviceBean); &#125; Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS); if (!attrMethods.isEmpty()) &#123; this.modelAttributeAdviceCache.put(adviceBean, attrMethods); &#125; Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS); if (!binderMethods.isEmpty()) &#123; this.initBinderAdviceCache.put(adviceBean, binderMethods); &#125; if (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123; requestResponseBodyAdviceBeans.add(adviceBean); &#125; &#125; if (!requestResponseBodyAdviceBeans.isEmpty()) &#123; this.requestResponseBodyAdvice.addAll(0, requestResponseBodyAdviceBeans); &#125; if (this.logger.isDebugEnabled()) &#123; int modelSize = this.modelAttributeAdviceCache.size(); int binderSize = this.initBinderAdviceCache.size(); int reqCount = this.getBodyAdviceCount(RequestBodyAdvice.class); int resCount = this.getBodyAdviceCount(ResponseBodyAdvice.class); if (modelSize == 0 &amp;&amp; binderSize == 0 &amp;&amp; reqCount == 0 &amp;&amp; resCount == 0) &#123; this.logger.debug(&quot;ControllerAdvice beans: none&quot;); &#125; else &#123; this.logger.debug(&quot;ControllerAdvice beans: &quot; + modelSize + &quot; @ModelAttribute, &quot; + binderSize + &quot; @InitBinder, &quot; + reqCount + &quot; RequestBodyAdvice, &quot; + resCount + &quot; ResponseBodyAdvice&quot;); &#125; &#125; &#125; &#125; private int getBodyAdviceCount(Class&lt;?&gt; adviceType) &#123; List&lt;Object&gt; advice = this.requestResponseBodyAdvice; return RequestBodyAdvice.class.isAssignableFrom(adviceType) ? RequestResponseBodyAdviceChain.getAdviceByType(advice, RequestBodyAdvice.class).size() : RequestResponseBodyAdviceChain.getAdviceByType(advice, ResponseBodyAdvice.class).size(); &#125; private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList(30); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new PathVariableMethodArgumentResolver()); resolvers.add(new PathVariableMapMethodArgumentResolver()); resolvers.add(new MatrixVariableMethodArgumentResolver()); resolvers.add(new MatrixVariableMapMethodArgumentResolver()); resolvers.add(new ServletModelAttributeMethodProcessor(false)); resolvers.add(new RequestResponseBodyMethodProcessor(this.getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestPartMethodArgumentResolver(this.getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestHeaderMethodArgumentResolver(this.getBeanFactory())); resolvers.add(new RequestHeaderMapMethodArgumentResolver()); resolvers.add(new ServletCookieValueMethodArgumentResolver(this.getBeanFactory())); resolvers.add(new ExpressionValueMethodArgumentResolver(this.getBeanFactory())); resolvers.add(new SessionAttributeMethodArgumentResolver()); resolvers.add(new RequestAttributeMethodArgumentResolver()); resolvers.add(new ServletRequestMethodArgumentResolver()); resolvers.add(new ServletResponseMethodArgumentResolver()); resolvers.add(new HttpEntityMethodProcessor(this.getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RedirectAttributesMethodArgumentResolver()); resolvers.add(new ModelMethodProcessor()); resolvers.add(new MapMethodProcessor()); resolvers.add(new ErrorsMethodArgumentResolver()); resolvers.add(new SessionStatusMethodArgumentResolver()); resolvers.add(new UriComponentsBuilderMethodArgumentResolver()); if (KotlinDetector.isKotlinPresent()) &#123; resolvers.add(new ContinuationHandlerMethodArgumentResolver()); &#125; if (this.getCustomArgumentResolvers() != null) &#123; resolvers.addAll(this.getCustomArgumentResolvers()); &#125; resolvers.add(new PrincipalMethodArgumentResolver()); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), true)); resolvers.add(new ServletModelAttributeMethodProcessor(true)); return resolvers; &#125; private List&lt;HandlerMethodArgumentResolver&gt; getDefaultInitBinderArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList(20); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new PathVariableMethodArgumentResolver()); resolvers.add(new PathVariableMapMethodArgumentResolver()); resolvers.add(new MatrixVariableMethodArgumentResolver()); resolvers.add(new MatrixVariableMapMethodArgumentResolver()); resolvers.add(new ExpressionValueMethodArgumentResolver(this.getBeanFactory())); resolvers.add(new SessionAttributeMethodArgumentResolver()); resolvers.add(new RequestAttributeMethodArgumentResolver()); resolvers.add(new ServletRequestMethodArgumentResolver()); resolvers.add(new ServletResponseMethodArgumentResolver()); if (this.getCustomArgumentResolvers() != null) &#123; resolvers.addAll(this.getCustomArgumentResolvers()); &#125; resolvers.add(new PrincipalMethodArgumentResolver()); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), true)); return resolvers; &#125; private List&lt;HandlerMethodReturnValueHandler&gt; getDefaultReturnValueHandlers() &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = new ArrayList(20); handlers.add(new ModelAndViewMethodReturnValueHandler()); handlers.add(new ModelMethodProcessor()); handlers.add(new ViewMethodReturnValueHandler()); handlers.add(new ResponseBodyEmitterReturnValueHandler(this.getMessageConverters(), this.reactiveAdapterRegistry, this.taskExecutor, this.contentNegotiationManager)); handlers.add(new StreamingResponseBodyReturnValueHandler()); handlers.add(new HttpEntityMethodProcessor(this.getMessageConverters(), this.contentNegotiationManager, this.requestResponseBodyAdvice)); handlers.add(new HttpHeadersReturnValueHandler()); handlers.add(new CallableMethodReturnValueHandler()); handlers.add(new DeferredResultMethodReturnValueHandler()); handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory)); handlers.add(new ServletModelAttributeMethodProcessor(false)); handlers.add(new RequestResponseBodyMethodProcessor(this.getMessageConverters(), this.contentNegotiationManager, this.requestResponseBodyAdvice)); handlers.add(new ViewNameMethodReturnValueHandler()); handlers.add(new MapMethodProcessor()); if (this.getCustomReturnValueHandlers() != null) &#123; handlers.addAll(this.getCustomReturnValueHandlers()); &#125; if (!CollectionUtils.isEmpty(this.getModelAndViewResolvers())) &#123; handlers.add(new ModelAndViewResolverMethodReturnValueHandler(this.getModelAndViewResolvers())); &#125; else &#123; handlers.add(new ServletModelAttributeMethodProcessor(true)); &#125; return handlers; &#125; protected boolean supportsInternal(HandlerMethod handlerMethod) &#123; return true; &#125; protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; this.checkRequest(request); ModelAndView mav; if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized(mutex) &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(&quot;Cache-Control&quot;)) &#123; if (this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; this.applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; this.prepareResponse(response); &#125; &#125; return mav; &#125; protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) &#123; return -1L; &#125; private SessionAttributesHandler getSessionAttributesHandler(HandlerMethod handlerMethod) &#123; return (SessionAttributesHandler)this.sessionAttributesHandlerCache.computeIfAbsent(handlerMethod.getBeanType(), (type) -&gt; &#123; return new SessionAttributesHandler(type, this.sessionAttributeStore); &#125;); &#125; @Nullable protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); Object result; try &#123; WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod); ModelFactory modelFactory = this.getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = this.createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); LogFormatUtils.traceDebug(this.logger, (traceOn) -&gt; &#123; String formatted = LogFormatUtils.formatValue(result, !traceOn); return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;; &#125;); invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; invocableMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]); if (!asyncManager.isConcurrentHandlingStarted()) &#123; ModelAndView var15 = this.getModelAndView(mavContainer, modelFactory, webRequest); return var15; &#125; result = null; &#125; finally &#123; webRequest.requestCompleted(); &#125; return (ModelAndView)result; &#125; protected ServletInvocableHandlerMethod createInvocableHandlerMethod(HandlerMethod handlerMethod) &#123; return new ServletInvocableHandlerMethod(handlerMethod); &#125; private ModelFactory getModelFactory(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) &#123; SessionAttributesHandler sessionAttrHandler = this.getSessionAttributesHandler(handlerMethod); Class&lt;?&gt; handlerType = handlerMethod.getBeanType(); Set&lt;Method&gt; methods = (Set)this.modelAttributeCache.get(handlerType); if (methods == null) &#123; methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS); this.modelAttributeCache.put(handlerType, methods); &#125; List&lt;InvocableHandlerMethod&gt; attrMethods = new ArrayList(); this.modelAttributeAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123; if (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123; Object bean = controllerAdviceBean.resolveBean(); Iterator var7 = methodSet.iterator(); while(var7.hasNext()) &#123; Method method = (Method)var7.next(); attrMethods.add(this.createModelAttributeMethod(binderFactory, bean, method)); &#125; &#125; &#125;); Iterator var7 = methods.iterator(); while(var7.hasNext()) &#123; Method method = (Method)var7.next(); Object bean = handlerMethod.getBean(); attrMethods.add(this.createModelAttributeMethod(binderFactory, bean, method)); &#125; return new ModelFactory(attrMethods, binderFactory, sessionAttrHandler); &#125; private InvocableHandlerMethod createModelAttributeMethod(WebDataBinderFactory factory, Object bean, Method method) &#123; InvocableHandlerMethod attrMethod = new InvocableHandlerMethod(bean, method); if (this.argumentResolvers != null) &#123; attrMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; attrMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); attrMethod.setDataBinderFactory(factory); return attrMethod; &#125; private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception &#123; Class&lt;?&gt; handlerType = handlerMethod.getBeanType(); Set&lt;Method&gt; methods = (Set)this.initBinderCache.get(handlerType); if (methods == null) &#123; methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS); this.initBinderCache.put(handlerType, methods); &#125; List&lt;InvocableHandlerMethod&gt; initBinderMethods = new ArrayList(); this.initBinderAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123; if (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123; Object bean = controllerAdviceBean.resolveBean(); Iterator var6 = methodSet.iterator(); while(var6.hasNext()) &#123; Method method = (Method)var6.next(); initBinderMethods.add(this.createInitBinderMethod(bean, method)); &#125; &#125; &#125;); Iterator var5 = methods.iterator(); while(var5.hasNext()) &#123; Method method = (Method)var5.next(); Object bean = handlerMethod.getBean(); initBinderMethods.add(this.createInitBinderMethod(bean, method)); &#125; return this.createDataBinderFactory(initBinderMethods); &#125; private InvocableHandlerMethod createInitBinderMethod(Object bean, Method method) &#123; InvocableHandlerMethod binderMethod = new InvocableHandlerMethod(bean, method); if (this.initBinderArgumentResolvers != null) &#123; binderMethod.setHandlerMethodArgumentResolvers(this.initBinderArgumentResolvers); &#125; binderMethod.setDataBinderFactory(new DefaultDataBinderFactory(this.webBindingInitializer)); binderMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); return binderMethod; &#125; protected InitBinderDataBinderFactory createDataBinderFactory(List&lt;InvocableHandlerMethod&gt; binderMethods) throws Exception &#123; return new ServletRequestDataBinderFactory(binderMethods, this.getWebBindingInitializer()); &#125; @Nullable private ModelAndView getModelAndView(ModelAndViewContainer mavContainer, ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception &#123; modelFactory.updateModel(webRequest, mavContainer); if (mavContainer.isRequestHandled()) &#123; return null; &#125; else &#123; ModelMap model = mavContainer.getModel(); ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus()); if (!mavContainer.isViewReference()) &#123; mav.setView((View)mavContainer.getView()); &#125; if (model instanceof RedirectAttributes) &#123; Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes)model).getFlashAttributes(); HttpServletRequest request = (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class); if (request != null) &#123; RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes); &#125; &#125; return mav; &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Boot ReturnValueHandler","slug":"spring/spring-framework/mvc/spring-mvc-13-ReturnValueHandler","date":"2021-10-11T16:05:00.000Z","updated":"2024-02-26T16:01:41.272Z","comments":true,"path":"2021/10/12/spring/spring-framework/mvc/spring-mvc-13-ReturnValueHandler/","link":"","permalink":"https://ckck803.github.io/2021/10/12/spring/spring-framework/mvc/spring-mvc-13-ReturnValueHandler/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot ReturnValueHandlerpublic interface HandlerMethodReturnValueHandler &#123; boolean supportsReturnType(MethodParameter returnType); void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot ReturnValueHandlerpublic interface HandlerMethodReturnValueHandler &#123; boolean supportsReturnType(MethodParameter returnType); void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring MVC Request Life Cycle - Filter","slug":"spring/spring-framework/lifecycle/spring-lifecycle-request-lifecycle-filter","date":"2021-10-11T13:39:59.000Z","updated":"2024-02-26T15:57:00.891Z","comments":true,"path":"2021/10/11/spring/spring-framework/lifecycle/spring-lifecycle-request-lifecycle-filter/","link":"","permalink":"https://ckck803.github.io/2021/10/11/spring/spring-framework/lifecycle/spring-lifecycle-request-lifecycle-filter/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter Filter Filter는 Spring Context 이전에 실행되기 때문에 Spring자체와는 무관하며 Web Application에 등록이 된다. 요청이 DispatcherServlet에 도착하기 전에 처리를 하거나 요청이 끝나고 응답할 때 마지막으로 처리를 하는 역할을 한다. 주로 인코딩, 요청에 대한 인증, 권한 체크 와 같은 요청에 대한 전역적인 처리를 할 때 사용한다. Filter 인터페이스 init 필터 인스턴스 초기화 doFilter 실제 로직 처리(Filter Chain을 따라 다을 Filter로 움직인다.) destroy 필터 인스턴스 종료 public interface Filter &#123; public default void init(FilterConfig filterConfig) throws ServletException &#123;&#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public default void destroy() &#123;&#125;&#125; Filter Chain Filter는 Client와 Servlet사이에 존재해 Client가 보내는 요청정보를 가공해 Servlet으로 보내고 Servelt이 보내는 응답정보를 가공해 Client에게 전달하는 역할을 한다. Filter는 일반적인 경우 1개가 존재하지만 여러개의 필터를 모아 Filter Chain을 형성할 수 있다.","text":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter Filter Filter는 Spring Context 이전에 실행되기 때문에 Spring자체와는 무관하며 Web Application에 등록이 된다. 요청이 DispatcherServlet에 도착하기 전에 처리를 하거나 요청이 끝나고 응답할 때 마지막으로 처리를 하는 역할을 한다. 주로 인코딩, 요청에 대한 인증, 권한 체크 와 같은 요청에 대한 전역적인 처리를 할 때 사용한다. Filter 인터페이스 init 필터 인스턴스 초기화 doFilter 실제 로직 처리(Filter Chain을 따라 다을 Filter로 움직인다.) destroy 필터 인스턴스 종료 public interface Filter &#123; public default void init(FilterConfig filterConfig) throws ServletException &#123;&#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public default void destroy() &#123;&#125;&#125; Filter Chain Filter는 Client와 Servlet사이에 존재해 Client가 보내는 요청정보를 가공해 Servlet으로 보내고 Servelt이 보내는 응답정보를 가공해 Client에게 전달하는 역할을 한다. Filter는 일반적인 경우 1개가 존재하지만 여러개의 필터를 모아 Filter Chain을 형성할 수 있다. Login Filter 생성하기@Slf4jpublic class LoginFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; log.info(&quot;log filter init&quot;); Filter.super.init(filterConfig); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; log.info(&quot;log filter doFilter&quot;); HttpServletRequest httpRequest = (HttpServletRequest) request; String requestURI = httpRequest.getRequestURI(); String uuid = UUID.randomUUID().toString(); try&#123; log.info(&quot;REQUEST [&#123;&#125;][&#123;&#125;]&quot;, uuid, request); chain.doFilter(request, response); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; log.info(&quot;RESPONSE [&#123;&#125;][&#123;&#125;]&quot;, uuid, requestURI); &#125; &#125; @Override public void destroy() &#123; log.info(&quot;log filter destroy&quot;); Filter.super.destroy(); &#125;&#125; Filter 등록하기스프링 부트에서는 내장 톰캣을 가지고 있어 자바코드로 Filter를 Java Code를 이용해 손 쉽게 등록할 수 있다. FilterRegistrationBean 객체를 생성해 만드러준 Filter 를 Bean 으로 등록한다. @Configurationpublic class WebConfig &#123; @Bean public FilterRegistrationBean logFilter()&#123; FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;Filter&gt;(); filterRegistrationBean.setFilter(new LoginFilter()); filterRegistrationBean.setOrder(1); filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean; &#125;&#125; @Slf4jpublic class LoginCheckFilter implements Filter &#123; private static final String[] whitelist = &#123;&quot;/&quot;, &quot;/members/add&quot;, &quot;/login&quot;, &quot;/logout&quot;, &quot;/css/*&quot;&#125;; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpRequest = (HttpServletRequest) request; String requestURI = httpRequest.getRequestURI(); HttpServletResponse httpResponse = (HttpServletResponse) response; try &#123; log.info(&quot;인증 체크 필터 시작 &#123;&#125;&quot;, requestURI); if (isLoginCheckPath(requestURI)) &#123; log.info(&quot;인증 체크 로직 실행 &#123;&#125;&quot;, requestURI); HttpSession session = httpRequest.getSession(false); if (session == null || session.getAttribute(SessionConst.LOGIN_MEMBER) == null) &#123; log.info(&quot;미인증 사용자 요청 &#123;&#125;&quot;, requestURI); //로그인으로 redirect httpResponse.sendRedirect(&quot;/login?redirectURL=&quot; + requestURI); return; &#125; &#125; chain.doFilter(request, response); &#125; catch (Exception e) &#123; throw e; //예외 로깅 가능 하지만, 톰캣까지 예외를 보내주어야 함 &#125; finally &#123; log.info(&quot;인증 체크 필터 종료 &#123;&#125; &quot;, requestURI); &#125; &#125; /** * 화이트 리스트의 경우 인증 체크X */ private boolean isLoginCheckPath(String requestURI) &#123; return !PatternMatchUtils.simpleMatch(whitelist, requestURI); &#125;&#125; @Configurationpublic class WebConfig &#123; @Bean public FilterRegistrationBean logFilter()&#123; FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;(); filterRegistrationBean.setFilter(new LoginFilter()); filterRegistrationBean.setOrder(1); filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean; &#125; @Bean public FilterRegistrationBean logCheckFilter()&#123; FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;(); filterRegistrationBean.setFilter(new LoginCheckFilter()); filterRegistrationBean.setOrder(2); filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean; &#125;&#125; 로그인 후 Redirect 해주기@PostMapping(&quot;/login&quot;)public String loginV4(@Valid @ModelAttribute LoginForm form , BindingResult bindingResult , HttpServletRequest request , @RequestParam(defaultValue = &quot;/&quot;) String redirectURL)&#123; log.info(&quot;Request Params : &#123;&#125;&quot;, form); if(bindingResult.hasErrors())&#123; return &quot;login/loginForm&quot;; &#125; Member loginMember = loginService.login(form.getLoginId(), form.getPassword()); if(loginMember == null)&#123; bindingResult.reject(&quot;loginFail&quot;, &quot;아이디 또는 비밀번호가 맞지 않습니다.&quot;); return &quot;login/loginForm&quot;; &#125; // 로그인 설공 처리 TODO // 세션이 있으면 있는 세션 반환, 없으면 신규 세션을 생성 HttpSession session = request.getSession(); // 세션에 로그인 회원 정보를 보관 session.setAttribute(SessionConst.LOGIN_MEMBER, loginMember); return &quot;redirect:&quot; + redirectURL;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Framework","slug":"Spring/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/"},{"name":"lifecycle","slug":"Spring/Spring-Framework/lifecycle","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/lifecycle/"}],"tags":[]},{"title":"Spring Boot 요청 메시지 - JSON","slug":"spring/spring-framework/mvc/spring-mvc-07-requestjson","date":"2021-10-10T17:05:00.000Z","updated":"2024-02-26T15:59:52.044Z","comments":true,"path":"2021/10/11/spring/spring-framework/mvc/spring-mvc-07-requestjson/","link":"","permalink":"https://ckck803.github.io/2021/10/11/spring/spring-framework/mvc/spring-mvc-07-requestjson/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot 요청 메시지 - JSON@PostMapping(&quot;/request-body-json-v1&quot;)public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; ServletInputStream inputStream = request.getInputStream(); String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody=&#123;&#125;&quot;, messageBody); HelloData helloData = objectMapper.readValue(messageBody, HelloData.class); log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, helloData.getUsername(), helloData.getAge()); response.getWriter().write(&quot;ok&quot;);&#125; RequestBody 어노테이션 사용하기RequestParam 어노테이션과 다르게 RequestBody 어노테이션은 생략하면 안된다. @ResponseBody@PostMapping(&quot;/request-body-json-v2&quot;)public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException &#123; log.info(&quot;messageBody=&#123;&#125;&quot;, messageBody); HelloData helloData = objectMapper.readValue(messageBody, HelloData.class); log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, helloData.getUsername(), helloData.getAge()); return &quot;ok&quot;;&#125; DTO 사용하기@ResponseBody@PostMapping(&quot;/request-body-json-v3&quot;)public String requestBodyJsonV3(@RequestBody HelloData helloData) throws IOException &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, helloData.getUsername(), helloData.getAge()); return &quot;ok&quot;;&#125; @ResponseBody@PostMapping(&quot;/request-body-json-v4&quot;)public String requestBodyJsonV4(HttpEntity&lt;HelloData&gt; data) throws IOException &#123; HelloData body = data.getBody(); log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, body.getUsername(), body.getAge()); return &quot;ok&quot;;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot 요청 메시지 - JSON@PostMapping(&quot;/request-body-json-v1&quot;)public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; ServletInputStream inputStream = request.getInputStream(); String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody=&#123;&#125;&quot;, messageBody); HelloData helloData = objectMapper.readValue(messageBody, HelloData.class); log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, helloData.getUsername(), helloData.getAge()); response.getWriter().write(&quot;ok&quot;);&#125; RequestBody 어노테이션 사용하기RequestParam 어노테이션과 다르게 RequestBody 어노테이션은 생략하면 안된다. @ResponseBody@PostMapping(&quot;/request-body-json-v2&quot;)public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException &#123; log.info(&quot;messageBody=&#123;&#125;&quot;, messageBody); HelloData helloData = objectMapper.readValue(messageBody, HelloData.class); log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, helloData.getUsername(), helloData.getAge()); return &quot;ok&quot;;&#125; DTO 사용하기@ResponseBody@PostMapping(&quot;/request-body-json-v3&quot;)public String requestBodyJsonV3(@RequestBody HelloData helloData) throws IOException &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, helloData.getUsername(), helloData.getAge()); return &quot;ok&quot;;&#125; @ResponseBody@PostMapping(&quot;/request-body-json-v4&quot;)public String requestBodyJsonV4(HttpEntity&lt;HelloData&gt; data) throws IOException &#123; HelloData body = data.getBody(); log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, body.getUsername(), body.getAge()); return &quot;ok&quot;;&#125; @ResponseBody@PostMapping(&quot;/request-body-json-v5&quot;)public HelloData requestBodyJsonV5(@RequestBody HelloData data) throws IOException &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, data.getUsername(), data.getAge()); return data;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Boot 요청 메시지 - Text","slug":"spring/spring-framework/mvc/spring-mvc-06-requesttext","date":"2021-10-10T17:05:00.000Z","updated":"2024-02-26T15:59:47.412Z","comments":true,"path":"2021/10/11/spring/spring-framework/mvc/spring-mvc-06-requesttext/","link":"","permalink":"https://ckck803.github.io/2021/10/11/spring/spring-framework/mvc/spring-mvc-06-requesttext/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot 요청 메시지@PostMapping(&quot;/request-body-string-v1&quot;)public void requestBodyString(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; ServletInputStream inputStream = request.getInputStream(); String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody = &#123;&#125;&quot;, messageBody); response.getWriter().write(&quot;ok&quot;);&#125; @PostMapping(&quot;/request-body-string-v2&quot;)public void requestBodyStringV2(InputStream inputStream, Writer responseWriter) throws IOException &#123; String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody = &#123;&#125;&quot;, messageBody); responseWriter.write(&quot;ok&quot;);&#125; HttpEntity 사용하기@PostMapping(&quot;/request-body-string-v3&quot;)public HttpEntity&lt;String&gt; requestBodyStringV3(HttpEntity&lt;String&gt; httpEntity) throws IOException &#123; String messageBody = httpEntity.getBody(); log.info(&quot;messageBody = &#123;&#125;&quot;, messageBody); return new HttpEntity&lt;&gt;(&quot;ok&quot;);&#125; RequestBody, ResponseBody 어노테이션 사용하기@ResponseBody@PostMapping(&quot;/request-body-string-v4&quot;)public String requestBodyStringV4(@RequestBody String messageBody) throws IOException &#123; log.info(&quot;messageBody = &#123;&#125;&quot;, messageBody); return &quot;ok&quot;;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot 요청 메시지@PostMapping(&quot;/request-body-string-v1&quot;)public void requestBodyString(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; ServletInputStream inputStream = request.getInputStream(); String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody = &#123;&#125;&quot;, messageBody); response.getWriter().write(&quot;ok&quot;);&#125; @PostMapping(&quot;/request-body-string-v2&quot;)public void requestBodyStringV2(InputStream inputStream, Writer responseWriter) throws IOException &#123; String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody = &#123;&#125;&quot;, messageBody); responseWriter.write(&quot;ok&quot;);&#125; HttpEntity 사용하기@PostMapping(&quot;/request-body-string-v3&quot;)public HttpEntity&lt;String&gt; requestBodyStringV3(HttpEntity&lt;String&gt; httpEntity) throws IOException &#123; String messageBody = httpEntity.getBody(); log.info(&quot;messageBody = &#123;&#125;&quot;, messageBody); return new HttpEntity&lt;&gt;(&quot;ok&quot;);&#125; RequestBody, ResponseBody 어노테이션 사용하기@ResponseBody@PostMapping(&quot;/request-body-string-v4&quot;)public String requestBodyStringV4(@RequestBody String messageBody) throws IOException &#123; log.info(&quot;messageBody = &#123;&#125;&quot;, messageBody); return &quot;ok&quot;;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Boot Logging","slug":"spring/spring-framework/mvc/spring-mvc-01-logging","date":"2021-10-10T16:05:00.000Z","updated":"2024-02-26T15:58:59.598Z","comments":true,"path":"2021/10/11/spring/spring-framework/mvc/spring-mvc-01-logging/","link":"","permalink":"https://ckck803.github.io/2021/10/11/spring/spring-framework/mvc/spring-mvc-01-logging/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot Logging로그 선언 방법 private final Logger log &#x3D; LoggerFactory.getLogger(getClass()); private static final Logger log &#x3D; LoggerFactory.getLogger(xxx.class); @slf4j &#x2F;&#x2F; Lombok에서 제공하는 Log 기능 사용 log.trace(&quot;info log = &#123;&#125;&quot;, name);log.debug(&quot;info log = &#123;&#125;&quot;, name);log.info(&quot;info log = &#123;&#125;&quot;, name);log.warn(&quot;info log = &#123;&#125;&quot;, name);log.error(&quot;info log = &#123;&#125;&quot;, name); logging.level.com.example.springmvc=trace @Slf4j@RestControllerpublic class LogTestController &#123;// private final Logger log = LoggerFactory.getLogger(getClass()); @RequestMapping(&quot;/log-test&quot;) public String logTest()&#123; String name = &quot;Spring&quot;; System.out.println(&quot;name = &quot; + name); log.trace(&quot;info log = &#123;&#125;&quot;, name); log.debug(&quot;info log = &#123;&#125;&quot;, name); log.info(&quot;info log = &#123;&#125;&quot;, name); log.warn(&quot;info log = &#123;&#125;&quot;, name); log.error(&quot;info log = &#123;&#125;&quot;, name); return &quot;ok&quot;; &#125;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot Logging로그 선언 방법 private final Logger log &#x3D; LoggerFactory.getLogger(getClass()); private static final Logger log &#x3D; LoggerFactory.getLogger(xxx.class); @slf4j &#x2F;&#x2F; Lombok에서 제공하는 Log 기능 사용 log.trace(&quot;info log = &#123;&#125;&quot;, name);log.debug(&quot;info log = &#123;&#125;&quot;, name);log.info(&quot;info log = &#123;&#125;&quot;, name);log.warn(&quot;info log = &#123;&#125;&quot;, name);log.error(&quot;info log = &#123;&#125;&quot;, name); logging.level.com.example.springmvc=trace @Slf4j@RestControllerpublic class LogTestController &#123;// private final Logger log = LoggerFactory.getLogger(getClass()); @RequestMapping(&quot;/log-test&quot;) public String logTest()&#123; String name = &quot;Spring&quot;; System.out.println(&quot;name = &quot; + name); log.trace(&quot;info log = &#123;&#125;&quot;, name); log.debug(&quot;info log = &#123;&#125;&quot;, name); log.info(&quot;info log = &#123;&#125;&quot;, name); log.warn(&quot;info log = &#123;&#125;&quot;, name); log.error(&quot;info log = &#123;&#125;&quot;, name); return &quot;ok&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Boot API 예시","slug":"spring/spring-framework/mvc/spring-mvc-03-api-method","date":"2021-10-10T16:05:00.000Z","updated":"2024-02-26T15:59:29.248Z","comments":true,"path":"2021/10/11/spring/spring-framework/mvc/spring-mvc-03-api-method/","link":"","permalink":"https://ckck803.github.io/2021/10/11/spring/spring-framework/mvc/spring-mvc-03-api-method/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot API 예시@RestController@RequestMapping(&quot;/mapping/users&quot;)public class MappingClassController &#123; @GetMapping public String user()&#123; return &quot;get users&quot;; &#125; @PostMapping public String addUser()&#123; return &quot;post user&quot;; &#125; @GetMapping(&quot;/&#123;userId&#125;&quot;) public String findUser(@PathVariable String userId)&#123; return &quot;get suerId = &quot; + userId; &#125; @PatchMapping(&quot;/&#123;userId&#125;&quot;) public String updateUser(@PathVariable String userId)&#123; return &quot;update userId = &quot; + userId; &#125; @DeleteMapping(&quot;/&#123;userId&#125;&quot;) public String deleteUser(@PathVariable String userId)&#123; return &quot;delete userId = &quot; + userId; &#125;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot API 예시@RestController@RequestMapping(&quot;/mapping/users&quot;)public class MappingClassController &#123; @GetMapping public String user()&#123; return &quot;get users&quot;; &#125; @PostMapping public String addUser()&#123; return &quot;post user&quot;; &#125; @GetMapping(&quot;/&#123;userId&#125;&quot;) public String findUser(@PathVariable String userId)&#123; return &quot;get suerId = &quot; + userId; &#125; @PatchMapping(&quot;/&#123;userId&#125;&quot;) public String updateUser(@PathVariable String userId)&#123; return &quot;update userId = &quot; + userId; &#125; @DeleteMapping(&quot;/&#123;userId&#125;&quot;) public String deleteUser(@PathVariable String userId)&#123; return &quot;delete userId = &quot; + userId; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Boot 기본 헤더 조회","slug":"spring/spring-framework/mvc/spring-mvc-04","date":"2021-10-10T16:05:00.000Z","updated":"2024-02-26T15:59:37.530Z","comments":true,"path":"2021/10/11/spring/spring-framework/mvc/spring-mvc-04/","link":"","permalink":"https://ckck803.github.io/2021/10/11/spring/spring-framework/mvc/spring-mvc-04/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging 기본 헤더 조회Controller 사용 가능한 파리미터 목록\u001c @Slf4j@RestControllerpublic class RequestHeaderController &#123; @RequestMapping(&quot;/headers&quot;) public String headers(HttpServletRequest request, HttpServletResponse response, HttpMethod httpMethod, Locale locale, @RequestHeader MultiValueMap&lt;String, String&gt; headerMap, @RequestHeader(&quot;host&quot;) String host, @CookieValue(value = &quot;myCookie&quot;, required = false) String cookie) &#123; log.info(&quot;request=&#123;&#125;&quot;, request); log.info(&quot;response=&#123;&#125;&quot;, response); log.info(&quot;httpMethod=&#123;&#125;&quot;, httpMethod); log.info(&quot;locale=&#123;&#125;&quot;, locale); log.info(&quot;headerMap=&#123;&#125;&quot;, headerMap); log.info(&quot;header host=&#123;&#125;&quot;, host); log.info(&quot;myCookie=&#123;&#125;&quot;, cookie); return &quot;ok&quot;; &#125;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging 기본 헤더 조회Controller 사용 가능한 파리미터 목록\u001c @Slf4j@RestControllerpublic class RequestHeaderController &#123; @RequestMapping(&quot;/headers&quot;) public String headers(HttpServletRequest request, HttpServletResponse response, HttpMethod httpMethod, Locale locale, @RequestHeader MultiValueMap&lt;String, String&gt; headerMap, @RequestHeader(&quot;host&quot;) String host, @CookieValue(value = &quot;myCookie&quot;, required = false) String cookie) &#123; log.info(&quot;request=&#123;&#125;&quot;, request); log.info(&quot;response=&#123;&#125;&quot;, response); log.info(&quot;httpMethod=&#123;&#125;&quot;, httpMethod); log.info(&quot;locale=&#123;&#125;&quot;, locale); log.info(&quot;headerMap=&#123;&#125;&quot;, headerMap); log.info(&quot;header host=&#123;&#125;&quot;, host); log.info(&quot;myCookie=&#123;&#125;&quot;, cookie); return &quot;ok&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Boot 쿼리 파라미터, HTML Form","slug":"spring/spring-framework/mvc/spring-mvc-05-queryparameter","date":"2021-10-10T16:05:00.000Z","updated":"2024-02-26T15:59:42.221Z","comments":true,"path":"2021/10/11/spring/spring-framework/mvc/spring-mvc-05-queryparameter/","link":"","permalink":"https://ckck803.github.io/2021/10/11/spring/spring-framework/mvc/spring-mvc-05-queryparameter/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot 쿼리 파라미터, HTML Form&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/request-param-v1&quot; method=&quot;post&quot;&gt; username: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; age: &lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;전송&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; HttpServletRequest 객체 내 메소드 사용하기@Slf4j@RestControllerpublic class RequestParamController &#123; @RequestMapping(&quot;/request-param-v1&quot;) public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String username = request.getParameter(&quot;username&quot;); int age = Integer.parseInt(request.getParameter(&quot;age&quot;)); log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, username, age); response.getWriter().write(&quot;ok&quot;); &#125;&#125; RequestParam 어노테이션 사용하기@RequestMapping(&quot;/request-param-v2&quot;)@ResponseBodypublic String requestParamV2( @RequestParam(&quot;username&quot;) String memberName, @RequestParam(&quot;age&quot;) int memberAge) &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, memberName, memberAge); return &quot;ok&quot;;&#125; @RequestMapping(&quot;/request-param-v3&quot;)@ResponseBodypublic String requestParamV3( @RequestParam String username, @RequestParam int age) &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, username, age ); return &quot;ok&quot;;&#125; @RequestMapping(&quot;/request-param-v4&quot;)@ResponseBodypublic String requestParamV4(String username, int age) &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, username, age ); return &quot;ok&quot;;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC - HttpMessageConverter Spring Boot Http 응답 - HTTP API, Message Body에 직접 입력 Spring Boot 응답 - 정적 리소스, 뷰 템플릿 Spring Boot 요청 메시지 - JSON Spring Boot 요청 메시지 - Text Spring Boot 쿼리 파라미터, HTML Form Spring Boot 기본 헤더 조회 Spring Boot API 예시 Spring Boot @RequestMapping Spring Boot Logging Spring Boot 쿼리 파라미터, HTML Form&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/request-param-v1&quot; method=&quot;post&quot;&gt; username: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; age: &lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;전송&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; HttpServletRequest 객체 내 메소드 사용하기@Slf4j@RestControllerpublic class RequestParamController &#123; @RequestMapping(&quot;/request-param-v1&quot;) public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String username = request.getParameter(&quot;username&quot;); int age = Integer.parseInt(request.getParameter(&quot;age&quot;)); log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, username, age); response.getWriter().write(&quot;ok&quot;); &#125;&#125; RequestParam 어노테이션 사용하기@RequestMapping(&quot;/request-param-v2&quot;)@ResponseBodypublic String requestParamV2( @RequestParam(&quot;username&quot;) String memberName, @RequestParam(&quot;age&quot;) int memberAge) &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, memberName, memberAge); return &quot;ok&quot;;&#125; @RequestMapping(&quot;/request-param-v3&quot;)@ResponseBodypublic String requestParamV3( @RequestParam String username, @RequestParam int age) &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, username, age ); return &quot;ok&quot;;&#125; @RequestMapping(&quot;/request-param-v4&quot;)@ResponseBodypublic String requestParamV4(String username, int age) &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, username, age ); return &quot;ok&quot;;&#125; @RequestMapping(&quot;/request-param-required&quot;)@ResponseBodypublic String requestParamV5( @RequestParam(required = true) String username, @RequestParam(required = false) Integer age) &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, username, age ); return &quot;ok&quot;;&#125; @RequestMapping(&quot;/request-param-default&quot;)@ResponseBodypublic String requestParamDefault( @RequestParam(required = true, defaultValue = &quot;guest&quot;) String username, @RequestParam(required = false, defaultValue = &quot;-1&quot;) Integer age) &#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, username, age ); return &quot;ok&quot;;&#125; @RequestMapping(&quot;/request-param-map&quot;)@ResponseBodypublic String requestParamMap(@RequestParam Map&lt;String, Object&gt; paramMap)&#123; log.info(&quot;username=&#123;&#125;, age=&#123;&#125;&quot;, paramMap.get(&quot;username&quot;), paramMap.get(&quot;age&quot;)); return &quot;ok&quot;;&#125; DTO 이용하기@Datapublic class HelloData &#123; private String username; private int age;&#125; @ResponseBody@RequestMapping(&quot;/model-attribute-v1&quot;)public String modelAttributeV1(@RequestParam String username, @RequestParam int age)&#123; HelloData helloData = new HelloData(); helloData.setUsername(username); helloData.setAge(age); log.info(&quot;username = &#123;&#125;, age = &#123;&#125;&quot;, helloData.getUsername(), helloData.getAge()); log.info(&quot;helloData=&#123;&#125;&quot;, helloData); return &quot;ok&quot;;&#125; ModelAttribute 어노테이션 이용하기@ResponseBody@RequestMapping(&quot;/model-attribute-v2&quot;)public String modelAttributeV2(@ModelAttribute HelloData helloData)&#123; log.info(&quot;username = &#123;&#125;, age = &#123;&#125;&quot;, helloData.getUsername(), helloData.getAge()); log.info(&quot;helloData=&#123;&#125;&quot;, helloData); return &quot;ok&quot;;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring Security - AuthenticationProvider","slug":"spring/spring-security/security/authentication/authenticationprovider","date":"2021-10-08T00:25:35.000Z","updated":"2024-02-26T16:25:10.810Z","comments":true,"path":"2021/10/08/spring/spring-security/security/authentication/authenticationprovider/","link":"","permalink":"https://ckck803.github.io/2021/10/08/spring/spring-security/security/authentication/authenticationprovider/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture Spring Security - AuthenticationProviderAuthenticationProvider.java AuthenticationManager로 부터 인증을 위임받아 실제로 인증을 진행하는 객체, AuthenticationProvider의 구현체로는 AbstractUserDetailsAuthenticationProvider 와 DaoAuthenticationProvider 가 존재한다. AuthenticationProvider 의 인증 과정 전달받는 authentication 에서 username을 가져온 뒤 DB에서 해당 하는 유저 정보를 가져온다. 인증을 진행하기 전 DB로부터 가져온 UserDetails 객체에 대한 유효성 검사를 진행한다. 전달 받은 Authentication 객체내의 Credential 정보와 UserDetails 객체의 Password와 값이 일치하는지 확인한다. username에 대한하는 UserDetails 객체를 못 찾을 경우 UsernameNotFoundException 예외를 던지고 Credentials가 Password와 다를 경우 BadCredentialsException 예외를 던진다. 인증 후 다시한번 UserDetails 객체의 유효성 검사를 진행하고, 캐시에 UserDetails 객체를 저장한다. 새로운 Authentication 객체를 만들어 반환한다.","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture Spring Security - AuthenticationProviderAuthenticationProvider.java AuthenticationManager로 부터 인증을 위임받아 실제로 인증을 진행하는 객체, AuthenticationProvider의 구현체로는 AbstractUserDetailsAuthenticationProvider 와 DaoAuthenticationProvider 가 존재한다. AuthenticationProvider 의 인증 과정 전달받는 authentication 에서 username을 가져온 뒤 DB에서 해당 하는 유저 정보를 가져온다. 인증을 진행하기 전 DB로부터 가져온 UserDetails 객체에 대한 유효성 검사를 진행한다. 전달 받은 Authentication 객체내의 Credential 정보와 UserDetails 객체의 Password와 값이 일치하는지 확인한다. username에 대한하는 UserDetails 객체를 못 찾을 경우 UsernameNotFoundException 예외를 던지고 Credentials가 Password와 다를 경우 BadCredentialsException 예외를 던진다. 인증 후 다시한번 UserDetails 객체의 유효성 검사를 진행하고, 캐시에 UserDetails 객체를 저장한다. 새로운 Authentication 객체를 만들어 반환한다. public interface AuthenticationProvider &#123; Authentication authenticate(Authentication authentication) throws AuthenticationException; boolean supports(Class&lt;?&gt; authentication);&#125; UserDetails를 이용해 검증하는 AbstractUserDetailsAuthenticationProvider AbstractUserDetailsAuthenticationProvider 클래스는 AuthenticationProvider를 구현한 클래스다. AbstractUserDetailsAuthenticationProvider 클래스는 전달 받은 Authentication 객체와 기존에 저장된 UserDetails 객체를 이용해 인증을 진행하는 로직이 구현 돼 있다. AbstractUserDetailsAuthenticationProvider.java @Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;, &quot;Only UsernamePasswordAuthenticationToken is supported&quot;)); String username = determineUsername(authentication); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (UsernameNotFoundException ex) &#123; this.logger.debug(&quot;Failed to find user &#x27;&quot; + username + &quot;&#x27;&quot;); if (!this.hideUserNotFoundExceptions) &#123; throw ex; &#125; throw new BadCredentialsException(this.messages .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); &#125; Assert.notNull(user, &quot;retrieveUser returned null - a violation of the interface contract&quot;); &#125; // UserDetails 객체에 대한 상태를 체크한다. try &#123; this.preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (AuthenticationException ex) &#123; if (!cacheWasUsed) &#123; throw ex; &#125; cacheWasUsed = false; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); this.preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; this.postAuthenticationChecks.check(user); if (!cacheWasUsed) &#123; this.userCache.putUserInCache(user); &#125; Object principalToReturn = user; if (this.forcePrincipalAsString) &#123; principalToReturn = user.getUsername(); &#125; return createSuccessAuthentication(principalToReturn, authentication, user);&#125; 인증 후 새로운 인증 객체 반환AbstractUserDetailsAuthenticationProvider.java protected Authentication createSuccessAuthentication(Object principal, Authentication authentication, UserDetails user) &#123; UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(principal, authentication.getCredentials(), this.authoritiesMapper.mapAuthorities(user.getAuthorities())); result.setDetails(authentication.getDetails()); this.logger.debug(&quot;Authenticated user&quot;); return result;&#125; DB에 저장된 User 정보를 가져오기 위한 DaoAuthenticationProvider DaoAuthenticationProvider 클래스는 AbstractUserDetailsAuthenticationProvider 를 상속해 구현한 클래스다. DaoAuthenticationProvider 클래스에는 주로 DB로부터 User 정보를 조회 및 가져온 User 정보를 검증하는 로직이 구현 돼 있다. DB에 저장된 User 정보 가져오기DaoAuthenticationProvider.java @Overrideprotected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; prepareTimingAttackProtection(); // username을 이용해 사용자 정보를 가져온다. try &#123; UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); if (loadedUser == null) &#123; throw new InternalAuthenticationServiceException( &quot;UserDetailsService returned null, which is an interface contract violation&quot;); &#125; return loadedUser; &#125; catch (UsernameNotFoundException ex) &#123; mitigateAgainstTimingAttack(authentication); throw ex; &#125; catch (InternalAuthenticationServiceException ex) &#123; throw ex; &#125; catch (Exception ex) &#123; throw new InternalAuthenticationServiceException(ex.getMessage(), ex); &#125;&#125; Authentication 객체의 Credentials 정보와 UserDetails 객체의 비밀번호가 일치하는지 검증DaoAuthenticationProvider.java protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; if (authentication.getCredentials() == null) &#123; this.logger.debug(&quot;Failed to authenticate since no credentials provided&quot;); throw new BadCredentialsException(this.messages .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); &#125; String presentedPassword = authentication.getCredentials().toString(); if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123; this.logger.debug(&quot;Failed to authenticate since password does not match stored value&quot;); throw new BadCredentialsException(this.messages .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); &#125;&#125; UserDetailsChecker 객체를 이용한 UserDetails 객체에 대한 검증 UserDetailsChecker 객체는 DB로부터 혹은 캐시에 저장된 UserDetails 객체에 대한 유효성을 검증한다. DefaultPreAuthenticationChecks.java private class DefaultPreAuthenticationChecks implements UserDetailsChecker &#123; @Override // 계정이 잠겼는지, 사용가능한지, 만료됐는지 확인한다. public void check(UserDetails user) &#123; if (!user.isAccountNonLocked()) &#123; AbstractUserDetailsAuthenticationProvider.this.logger .debug(&quot;Failed to authenticate since user account is locked&quot;); throw new LockedException(AbstractUserDetailsAuthenticationProvider.this.messages .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.locked&quot;, &quot;User account is locked&quot;)); &#125; if (!user.isEnabled()) &#123; AbstractUserDetailsAuthenticationProvider.this.logger .debug(&quot;Failed to authenticate since user account is disabled&quot;); throw new DisabledException(AbstractUserDetailsAuthenticationProvider.this.messages .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.disabled&quot;, &quot;User is disabled&quot;)); &#125; if (!user.isAccountNonExpired()) &#123; AbstractUserDetailsAuthenticationProvider.this.logger .debug(&quot;Failed to authenticate since user account has expired&quot;); throw new AccountExpiredException(AbstractUserDetailsAuthenticationProvider.this.messages .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.expired&quot;, &quot;User account has expired&quot;)); &#125; &#125;&#125; 인증 전 Authentication 객체인증 전 Authenticatin 객체내의 principal에는 username이 credentials는 password가 들어있고, 인증 유무를 나타내는 authenticated 값이 false로 나타나 있다. 인증 후 Authentication 객체인증을 진행한 후 인증 전과 다르게 Authenticatin 객체의 principal에는 UserDeails 를 구현한 객체가 들어갔고 authenticated 값이 true가 됐다. 최종적으로 반환 될 때는 Authenticatin 객체에서 credentials를 지우고 반환한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"인증 과정","slug":"Spring/Spring-Security/인증-과정","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95/"}],"tags":[]},{"title":"Spring Security - AuthenticationManager","slug":"spring/spring-security/security/authentication/authenticationManager","date":"2021-10-07T14:25:35.000Z","updated":"2024-02-26T16:25:06.361Z","comments":true,"path":"2021/10/07/spring/spring-security/security/authentication/authenticationManager/","link":"","permalink":"https://ckck803.github.io/2021/10/07/spring/spring-security/security/authentication/authenticationManager/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture Spring Security - AuthenticationManager AuthenticationManager 는 인증을 진행하는 AuthenticationProvider 객체들을 관리하는 객체다. AuthenticationManager 는 AuthenticationProvider 에 인증을 위임하는 형태로 인증을 진행한다. public interface AuthenticationManager &#123; Authentication authenticate(Authentication authentication) throws AuthenticationException;&#125; ProviderManager AuthenticationManager의 가장 대표적인 구현체","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture Spring Security - AuthenticationManager AuthenticationManager 는 인증을 진행하는 AuthenticationProvider 객체들을 관리하는 객체다. AuthenticationManager 는 AuthenticationProvider 에 인증을 위임하는 형태로 인증을 진행한다. public interface AuthenticationManager &#123; Authentication authenticate(Authentication authentication) throws AuthenticationException;&#125; ProviderManager AuthenticationManager의 가장 대표적인 구현체 ProviderManager hierarchy각 ProviderManager 에는 여러개의 AuthenticationProvider 객체들이 있다. 만약 현재의 ProviderManager에 인증을 처리할 AuthenticationProvider 객체가 없을 경우 Parent ProviderManager로 이동하게 된다. Parent ProviderManager 역시 AuthenticationProvider 객체들이 존재한다. 여기서의 Parent는 상속 개념이 아니라 field값으로 parent를 가지고 있다. ProviderManager를 통한 인증 진행 ProviderManager 객체는 인증을 직접 진행하는 하지 않는다. 대신, 인증을 위한 다양한 AuthenticationProvider 객체들을 가지고 있고 AuthenticationProvider 객체에게 인증을 위임하는 형태로 인증을 진행한다. ProviderManager에서 인증을 처리할 AuthenticationProvider 객체를 가져온다. 가져온 AuthenticationProvider를 이용해 Authentication객체 인증을 진행 인증이 완료 되면 새로운 Authentication 객체가 생성된다. 현재 적절한 AuthenticationProvider 객체가 없다면 부모 ProviderManager로 이동해 인증을 시도한다. 인증에 실패한 경우에는 ProviderNotFoundException 예외를 던진다. Authentication 객체로 부터 Credentials 정보를 지우고 생성된 Authentication 객체를 반환한다. ProviderManager.java @Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); Authentication result = null; Authentication parentResult = null; // 인증을 진행하기 위한 AuthenticationProvider를 가져온다. for (AuthenticationProvider provider : getProviders()) &#123; // AuthenticationProvider가 Authentication 객체 인증을 지원하는지 확인 if (!provider.supports(toTest)) &#123; continue; &#125; try &#123; // AuthenticationProvider 객체를 이용해 인증을 진행한다. result = provider.authenticate(authentication); if (result != null) &#123; // 기존의 Authentication 객체와 result를 이용해 새로운 Authentication 객체를 생성 copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException | InternalAuthenticationServiceException ex) &#123; prepareException(ex, authentication); throw ex; &#125; catch (AuthenticationException ex) &#123; lastException = ex; &#125; &#125; // 인증을 진행하기 위한 적절한 AuthenticationProvider 객체 없고 Parent AuthenticationProvider 객체가 존재하는 경우 // Parent AuthenticationProvider 로 이동해 인증을 진행한다. if (result == null &amp;&amp; this.parent != null) &#123; try &#123; parentResult = this.parent.authenticate(authentication); result = parentResult; &#125; catch (ProviderNotFoundException ex) &#123; &#125; catch (AuthenticationException ex) &#123; parentException = ex; lastException = ex; &#125; &#125; if (result != null) &#123; if (this.eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) &#123; // 인증을 완료한 후에 Authentication 객체에서 Credentials와 같은 민감한 정보를 지운다. ((CredentialsContainer) result).eraseCredentials(); &#125; if (parentResult == null) &#123; this.eventPublisher.publishAuthenticationSuccess(result); &#125; // 인증이 완료된 Authentication 객체를 반환한다. return result; &#125; // 인증이 실패 했을 경우 ProviderNotFoundException 예외를 던진다. if (lastException == null) &#123; lastException = new ProviderNotFoundException(this.messages.getMessage(&quot;ProviderManager.providerNotFound&quot;, new Object[] &#123; toTest.getName() &#125;, &quot;No AuthenticationProvider found for &#123;0&#125;&quot;)); &#125; if (parentException == null) &#123; prepareException(lastException, authentication); &#125; throw lastException;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"인증 과정","slug":"Spring/Spring-Security/인증-과정","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95/"}],"tags":[]},{"title":"Spring Security - SecurityContextHolder 와 SecurityContext","slug":"spring/spring-security/security/authentication/securitycontext","date":"2021-10-07T14:25:35.000Z","updated":"2024-02-26T16:25:14.824Z","comments":true,"path":"2021/10/07/spring/spring-security/security/authentication/securitycontext/","link":"","permalink":"https://ckck803.github.io/2021/10/07/spring/spring-security/security/authentication/securitycontext/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture Spring Security - SecurityContextHolder 와 SecurityContext 인증을 진행하면서 생성된 Authentication 객체는 SecurityContext 객체 내에 저장된다. 저장된 Authentication 객체를 저장하고 가져오기 위해서 SecurityContext는 getAuthentication 메소드와 setAuthentication 메소드를 제공한다. SecurityContext.java public interface SecurityContext extends Serializable &#123; Authentication getAuthentication(); void setAuthentication(Authentication authentication);&#125;","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture Spring Security - SecurityContextHolder 와 SecurityContext 인증을 진행하면서 생성된 Authentication 객체는 SecurityContext 객체 내에 저장된다. 저장된 Authentication 객체를 저장하고 가져오기 위해서 SecurityContext는 getAuthentication 메소드와 setAuthentication 메소드를 제공한다. SecurityContext.java public interface SecurityContext extends Serializable &#123; Authentication getAuthentication(); void setAuthentication(Authentication authentication);&#125; SecurityContext 인터페이스의 대표적인 구현체로는 SecurityContextImpl 클래스가 있다. SecutiryContextHolder SecurityContext를 ThreadLocal에 저장하기 위한 객체 SecurityContextHolder 내에는 ThreadLocal 객체를 가지고 있고, 이 ThreadLocal 객체에 SecurityContext 객체를 저장한다. SecurityContextHolder 가 ThreadLocal 에 SecurityContext 를 저장하는 전략은 3가지가 있다. | | MODE_THREADLOCAL 한 스레드당 securityContext를 저장하고 접근이 가능하다 MODE_INHERITABLETHREADLOCAL 메인 스레드와 자식 스레드에서 동일한 SecurityContext를 갖고 접근이 가능하다 MODE_GLOBAL 응용 프로그램내에서 단 하나의 SecurityContext를 저장하고 모두 접근이 가능하다. SecurityContextHolder는 ThreadLocal에 SecurityContext 객체를 저장하거나 가져오기 위해 setContext 메소드와 getContext 메소드를 제공한다. // SecurityContext 객체를 ThreadLocal에 저장한다.SecurityContextHolder.setContext(securityContext);// ThreadLocal에 저장된 SecurityContext 객체를 가져온다.SecurityContext securityContext = SecurityContextHolder.getContext(); SecurityContextHolder 내에는 SecurityContextHolderStrategy 객체를 가진다. 바로 이 SecurityContextHolderStrategy 기본 구현체로 ThreadLocalSecurityContextHolderStrategy 가 있고 해당 객체내에 ThreadLocal 객체가 존재한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"인증 과정","slug":"Spring/Spring-Security/인증-과정","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95/"}],"tags":[]},{"title":"Spring Security - Authentication 객체","slug":"spring/spring-security/security/authentication/authentication","date":"2021-10-07T13:25:35.000Z","updated":"2024-02-26T16:24:59.341Z","comments":true,"path":"2021/10/07/spring/spring-security/security/authentication/authentication/","link":"","permalink":"https://ckck803.github.io/2021/10/07/spring/spring-security/security/authentication/authentication/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture Spring Security - Authentication 객체 Authentication 객체 내에는 자원에 접근하기 위한 대상의 정보와 권한 정보가 들어가 있다. Authentication 객체의 대표적인 구현 클래스는 AbstractAuthenticationToken 클래스와 UsernamePasswordAuthenticationToken 가 있다. 인증을 진행하면서 생성된 Authentication 객체는 SecurityContext 객체에 저장된다. Authentication 객체 내에 Principal, Credentials, GrantedAuthority 가 있다. Principal Object 타입으로 보통은 User ID가 들어가거나 UserDetails가 들어가게 된다. Credentials Object 타입으로 보통은 User Password가 들어가 있다. GrantedAuthority 접근 권한 목록들을 가지고 있다. public interface Authentication extends Principal, Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); Object getCredentials(); Object getDetails(); Object getPrincipal(); boolean isAuthenticated(); void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;&#125;","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 참고 https://spring.io/guides/topicals/spring-security-architecture Spring Security - Authentication 객체 Authentication 객체 내에는 자원에 접근하기 위한 대상의 정보와 권한 정보가 들어가 있다. Authentication 객체의 대표적인 구현 클래스는 AbstractAuthenticationToken 클래스와 UsernamePasswordAuthenticationToken 가 있다. 인증을 진행하면서 생성된 Authentication 객체는 SecurityContext 객체에 저장된다. Authentication 객체 내에 Principal, Credentials, GrantedAuthority 가 있다. Principal Object 타입으로 보통은 User ID가 들어가거나 UserDetails가 들어가게 된다. Credentials Object 타입으로 보통은 User Password가 들어가 있다. GrantedAuthority 접근 권한 목록들을 가지고 있다. public interface Authentication extends Principal, Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); Object getCredentials(); Object getDetails(); Object getPrincipal(); boolean isAuthenticated(); void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;&#125; AbstractAuthenticationToken AbstractAuthenticationToken는 Authentication 권한 여부와 인증 여부를 관리하기 위해 구현된 추상 클래스다. GrantedAuthority 목록 정보를 담기 위한 Object 객체, authenticated 플래그 세 필드를 갖고 있다. AbstractAuthenticationToken.java public abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer &#123; private final Collection&lt;GrantedAuthority&gt; authorities; private Object details; private boolean authenticated = false; public AbstractAuthenticationToken(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123;...&#125; @Override public Collection&lt;GrantedAuthority&gt; getAuthorities() &#123;...&#125; @Override public String getName() &#123;...&#125; @Override public boolean isAuthenticated() &#123;...&#125; @Override public void setAuthenticated(boolean authenticated) &#123;...&#125; @Override public Object getDetails() &#123;...&#125; public void setDetails(Object details) &#123;...&#125; @Override public void eraseCredentials() &#123;...&#125; private void eraseSecret(Object secret) &#123;...&#125; @Override public boolean equals(Object obj) &#123;...&#125; @Override public int hashCode() &#123;...&#125; @Override public String toString() &#123;...&#125;&#125; UsernamePasswordAuthenticationToken username 과 password 를 이용해 만들어진 Authentication 구현 클래스 Object 객체인 principal Object 객체인 credentials 두 필드를 갖고 있고, 보통 principal 필드에는 UserDetails, AuthenticatedPrincipal 객체가 credentials 필드에는 CredentialsContainer 객체가 들어간다. UsernamePasswordAuthenticationToken.java public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken &#123; private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; private final Object principal; private Object credentials; public UsernamePasswordAuthenticationToken(Object principal, Object credentials) &#123; super(null); this.principal = principal; this.credentials = credentials; setAuthenticated(false); &#125; public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(authorities); this.principal = principal; this.credentials = credentials; super.setAuthenticated(true); &#125; @Override public Object getCredentials() &#123; return this.credentials; &#125; @Override public Object getPrincipal() &#123; return this.principal; &#125; @Override public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException &#123; Assert.isTrue(!isAuthenticated, &quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;); super.setAuthenticated(false); &#125; @Override public void eraseCredentials() &#123; super.eraseCredentials(); this.credentials = null; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"인증 과정","slug":"Spring/Spring-Security/인증-과정","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95/"}],"tags":[]},{"title":"Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer","slug":"spring/spring-security/security/configure/rememberme","date":"2021-10-07T13:25:35.000Z","updated":"2024-02-26T16:26:46.554Z","comments":true,"path":"2021/10/07/spring/spring-security/security/configure/rememberme/","link":"","permalink":"https://ckck803.github.io/2021/10/07/spring/spring-security/security/configure/rememberme/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 Remember Me와 관련된 인증 API rememberMeParameter 쿠키의 파라미터명을 지정한다. 체크박스의 이름(parameter)과 remember-me의 파라미터 명은 일치 시켜줘야 한다. tokenValiditySeconds 쿠키의 만료시간을 설정한다. useSecureCookie Cookie 에 보안 설정을 할 때 사용하는 Flag HTTPS 환경에서만 사용할 수 있다. userDetailsService remember-me 를 이용한 인증 진행시 시스템의 사용자 계정을 조회할 때 사용하는 class 를 지정한다. tokenRepository Remember Me Token 저장소를 설정한다. 기본은 TokenBasedRememberMeServices 를 사용하기 때문에 Cookie 에 저장하는 방식이다. 기본 구현체는 InMemoryTokenRepositoryImpl 와 JdbcTokenRepositoryImpl 로 저장소를 명시해주면 PersistentTokenBasedRememberMeServices 를 사용한다. key Remember Me Authentication 객체 유효성을 확인하기 위한 Key 값을 설정한다. String Hash 비교를 통해 인증 유효성을 확인한다. alwaysRemember Remember Me 기능이 활성화되지 않아도 항상 실행하는 Flag 사용자의 Session이 생성되었고 Session이 인증 객체를 담고 있다는 것이다. RememberMeConfigurerpublic RememberMeConfigurer&lt;H&gt; tokenValiditySeconds(int tokenValiditySeconds) &#123; this.tokenValiditySeconds = tokenValiditySeconds; return this;&#125;public RememberMeConfigurer&lt;H&gt; useSecureCookie(boolean useSecureCookie) &#123; this.useSecureCookie = useSecureCookie; return this;&#125;public RememberMeConfigurer&lt;H&gt; userDetailsService(UserDetailsService userDetailsService) &#123; this.userDetailsService = userDetailsService; return this;&#125;public RememberMeConfigurer&lt;H&gt; tokenRepository(PersistentTokenRepository tokenRepository) &#123; this.tokenRepository = tokenRepository; return this;&#125;public RememberMeConfigurer&lt;H&gt; key(String key) &#123; this.key = key; return this;&#125;public RememberMeConfigurer&lt;H&gt; rememberMeParameter(String rememberMeParameter) &#123; this.rememberMeParameter = rememberMeParameter; return this;&#125;public RememberMeConfigurer&lt;H&gt; rememberMeCookieName(String rememberMeCookieName) &#123; this.rememberMeCookieName = rememberMeCookieName; return this;&#125;public RememberMeConfigurer&lt;H&gt; rememberMeCookieDomain(String rememberMeCookieDomain) &#123; this.rememberMeCookieDomain = rememberMeCookieDomain; return this;&#125;public RememberMeConfigurer&lt;H&gt; authenticationSuccessHandler( AuthenticationSuccessHandler authenticationSuccessHandler) &#123; this.authenticationSuccessHandler = authenticationSuccessHandler; return this;&#125;public RememberMeConfigurer&lt;H&gt; rememberMeServices(RememberMeServices rememberMeServices) &#123; this.rememberMeServices = rememberMeServices; return this;&#125;public RememberMeConfigurer&lt;H&gt; alwaysRemember(boolean alwaysRemember) &#123; this.alwaysRemember = alwaysRemember; return this;&#125;","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 Remember Me와 관련된 인증 API rememberMeParameter 쿠키의 파라미터명을 지정한다. 체크박스의 이름(parameter)과 remember-me의 파라미터 명은 일치 시켜줘야 한다. tokenValiditySeconds 쿠키의 만료시간을 설정한다. useSecureCookie Cookie 에 보안 설정을 할 때 사용하는 Flag HTTPS 환경에서만 사용할 수 있다. userDetailsService remember-me 를 이용한 인증 진행시 시스템의 사용자 계정을 조회할 때 사용하는 class 를 지정한다. tokenRepository Remember Me Token 저장소를 설정한다. 기본은 TokenBasedRememberMeServices 를 사용하기 때문에 Cookie 에 저장하는 방식이다. 기본 구현체는 InMemoryTokenRepositoryImpl 와 JdbcTokenRepositoryImpl 로 저장소를 명시해주면 PersistentTokenBasedRememberMeServices 를 사용한다. key Remember Me Authentication 객체 유효성을 확인하기 위한 Key 값을 설정한다. String Hash 비교를 통해 인증 유효성을 확인한다. alwaysRemember Remember Me 기능이 활성화되지 않아도 항상 실행하는 Flag 사용자의 Session이 생성되었고 Session이 인증 객체를 담고 있다는 것이다. RememberMeConfigurerpublic RememberMeConfigurer&lt;H&gt; tokenValiditySeconds(int tokenValiditySeconds) &#123; this.tokenValiditySeconds = tokenValiditySeconds; return this;&#125;public RememberMeConfigurer&lt;H&gt; useSecureCookie(boolean useSecureCookie) &#123; this.useSecureCookie = useSecureCookie; return this;&#125;public RememberMeConfigurer&lt;H&gt; userDetailsService(UserDetailsService userDetailsService) &#123; this.userDetailsService = userDetailsService; return this;&#125;public RememberMeConfigurer&lt;H&gt; tokenRepository(PersistentTokenRepository tokenRepository) &#123; this.tokenRepository = tokenRepository; return this;&#125;public RememberMeConfigurer&lt;H&gt; key(String key) &#123; this.key = key; return this;&#125;public RememberMeConfigurer&lt;H&gt; rememberMeParameter(String rememberMeParameter) &#123; this.rememberMeParameter = rememberMeParameter; return this;&#125;public RememberMeConfigurer&lt;H&gt; rememberMeCookieName(String rememberMeCookieName) &#123; this.rememberMeCookieName = rememberMeCookieName; return this;&#125;public RememberMeConfigurer&lt;H&gt; rememberMeCookieDomain(String rememberMeCookieDomain) &#123; this.rememberMeCookieDomain = rememberMeCookieDomain; return this;&#125;public RememberMeConfigurer&lt;H&gt; authenticationSuccessHandler( AuthenticationSuccessHandler authenticationSuccessHandler) &#123; this.authenticationSuccessHandler = authenticationSuccessHandler; return this;&#125;public RememberMeConfigurer&lt;H&gt; rememberMeServices(RememberMeServices rememberMeServices) &#123; this.rememberMeServices = rememberMeServices; return this;&#125;public RememberMeConfigurer&lt;H&gt; alwaysRemember(boolean alwaysRemember) &#123; this.alwaysRemember = alwaysRemember; return this;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Security","slug":"Spring/Spring-Security/Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Security/"},{"name":"Config","slug":"Spring/Spring-Security/Security/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Security/Config/"}],"tags":[]},{"title":"네트워크 - HTTP Status Code","slug":"computer-science/network/http/http-status-code","date":"2021-10-04T01:39:59.000Z","updated":"2024-02-18T16:19:54.518Z","comments":true,"path":"2021/10/04/computer-science/network/http/http-status-code/","link":"","permalink":"https://ckck803.github.io/2021/10/04/computer-science/network/http/http-status-code/","excerpt":"HTTP Status Code1xx (Information) - 정보성 상태 코드 Http Status Code는 HTTP&#x2F;1.1 에서 도입된 상태 코드 2xx (Successful) - 성공 상태 코드 코드 설명 200 : OK 요청 성공했음을 나타낸다. 201 : Created 요청이 성공하고 새로운 리소스가 생성됐음을 나타낸다. 202 : Accepted 요청은 성공했으나 서버가 아직 작업을 진행하지 않은 상태를 나타낸다. 204 : No Content 요청이 성공했고 Server에서 Client로 보낼 데이터가 없는 상태를 나타낸다. 3xx (Redirection) - 리다이렉션 상태 코드 코드 설명 300 : Multiple Choices 리소스의 URI가 영구적으로 이동 301 : Moved Permanently 302 : Found 303 : See Other 304 : Not Modified 307 : Temporary Redirect 308 : Permanent Redirect 4xx (Client Error) - 클라이언트 오류","text":"HTTP Status Code1xx (Information) - 정보성 상태 코드 Http Status Code는 HTTP&#x2F;1.1 에서 도입된 상태 코드 2xx (Successful) - 성공 상태 코드 코드 설명 200 : OK 요청 성공했음을 나타낸다. 201 : Created 요청이 성공하고 새로운 리소스가 생성됐음을 나타낸다. 202 : Accepted 요청은 성공했으나 서버가 아직 작업을 진행하지 않은 상태를 나타낸다. 204 : No Content 요청이 성공했고 Server에서 Client로 보낼 데이터가 없는 상태를 나타낸다. 3xx (Redirection) - 리다이렉션 상태 코드 코드 설명 300 : Multiple Choices 리소스의 URI가 영구적으로 이동 301 : Moved Permanently 302 : Found 303 : See Other 304 : Not Modified 307 : Temporary Redirect 308 : Permanent Redirect 4xx (Client Error) - 클라이언트 오류 코드 설명 400 : Bad Request 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없는 상태를 나타낸다. 401 : Unauthorized 클라이언트가 해당 리소스에 접근하기 위해서는 인증이 필요함을 나타낸다. 403 : Forbidded 클라리언트가 해당 리소스에 접근하기 위해서는 권한이 필요함을 나타낸다.(인가) 404 : Not Found 클라이언트가 요청한 리소스가 서버에서 찾을 수 없음을 나타낸다. 5xx (Server Error) - 서버 오류 코드 설명 500 : Internal Server Error 503 : Service Unavailable","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"HTTP","slug":"CS/Network/HTTP","permalink":"https://ckck803.github.io/categories/CS/Network/HTTP/"}],"tags":[]},{"title":"Spring MVC Request Life Cycle - Interceptor","slug":"spring/spring-framework/lifecycle/spring-lifecycle-06-interceptor","date":"2021-10-04T01:39:59.000Z","updated":"2024-02-26T15:56:54.971Z","comments":true,"path":"2021/10/04/spring/spring-framework/lifecycle/spring-lifecycle-06-interceptor/","link":"","permalink":"https://ckck803.github.io/2021/10/04/spring/spring-framework/lifecycle/spring-lifecycle-06-interceptor/","excerpt":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter Interceptor 스프링 Interceptor 는 Handler(Controller) 호출 전, 후에 사용자 요청 및 응답을 가로채 특정 로직을 수행하는 역할을 한다. DispatcherServlet 이후에 동작한다. 스프링 Filter 처럼 Request, Response 객체를 다른 객체로 변경하는 것이 불가능 하다. Interceptor 는 Request, Response 객체를 넘겨주는 방식으로 진행하지 않고, boolean 값을 반환하는 형태로 로직 수행 Interceptor 인터페이스 preHandle Handler 호출 전에 실행된다. HttpServletRequest 객체를 이용해 preHandle 이 true 를 반환하면 다음으로 진행하고, false 면 진행하지 않는다. postHandle Handler 호출 후에 실행된다. afterCompletion View 가 렌더링 된 이후에 호출된다. public interface HandlerInterceptor &#123; default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125;","text":"목차 Spring MVC - ArgumentResolver Spring MVC Request Life Cycle - ViewResolver Spring MVC Request Life Cycle - HandlerAdapter Spring MVC Request Life Cycle - HandlerMapping Spring MVC Request Life Cycle - DispatcherServlet Spring MVC Request Life Cycle - Interceptor Spring MVC Request Life Cycle - Filter Interceptor 스프링 Interceptor 는 Handler(Controller) 호출 전, 후에 사용자 요청 및 응답을 가로채 특정 로직을 수행하는 역할을 한다. DispatcherServlet 이후에 동작한다. 스프링 Filter 처럼 Request, Response 객체를 다른 객체로 변경하는 것이 불가능 하다. Interceptor 는 Request, Response 객체를 넘겨주는 방식으로 진행하지 않고, boolean 값을 반환하는 형태로 로직 수행 Interceptor 인터페이스 preHandle Handler 호출 전에 실행된다. HttpServletRequest 객체를 이용해 preHandle 이 true 를 반환하면 다음으로 진행하고, false 면 진행하지 않는다. postHandle Handler 호출 후에 실행된다. afterCompletion View 가 렌더링 된 이후에 호출된다. public interface HandlerInterceptor &#123; default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125; Interceptor 예외 Handler(Controller) 실행 중간에 예외가 발생하게 되면 postHandler 는 호출되지 않고, 던져진 예외는 afterCompletion 에 전달된다. preHandler 의 경우 Handler 수행 전에 실행되므로 Handler 예외와는 상관이 없다. postHandler 의 경우 Handler 예외 발생시 로직이 수행되지 않으므로 예외 발생 상황과 관계없이 Handler 실행 후 작업을 진행하고 싶으면 afterCompletion 메소드를 이용하도록 한다. afterCompletion 에 전달된 예외는 로직을 수행한 후 Filter 에도 전달된다. 요청 로그 남기기@Slf4jpublic class LogInterceptor implements HandlerInterceptor &#123; public static final String LOGIN_ID = &quot;loginId&quot;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestURI = request.getRequestURI(); String uuid = UUID.randomUUID().toString(); request.setAttribute(LOGIN_ID, uuid); if(handler instanceof HandlerMethod)&#123; HandlerMethod hm = (HandlerMethod) handler;// 호출할 컨트롤러의 메소드의 모든 정보가 포함돼 있다. &#125; log.info(&quot;REQUEST [&#123;&#125;][&#123;&#125;][&#123;&#125;]&quot;, uuid, requestURI, handler); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;postHandle [&#123;&#125;]&quot;, modelAndView); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; String requestURI = request.getRequestURI(); String loginId = (String) request.getAttribute(LOGIN_ID); log.info(&quot;RESPONSE [&#123;&#125;][&#123;&#125;][&#123;&#125;]&quot;, loginId, requestURI, handler); if(ex != null)&#123; log.error(&quot;afterCompletion error!!&quot;, ex); &#125; &#125;&#125; Interceptor 등록하기스프링 MVC 설정을 위한 WebMvcConfigurer 인터페이스는 Interceptor 를 등록하기 위한 addInterceptors 메소드를 제공한다. InterceptorRegistry 객체에 새로 만든 Interceptor 와 설정 정보를 넣어주면 적용된다. @Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LogInterceptor()) .order(1) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/css/**&quot;, &quot;/*.ico&quot;, &quot;/error&quot;); &#125;&#125; 로그인 Check Interceptor 작성하기@Slf4jpublic class LoginCheckInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestURI = request.getRequestURI(); log.info(&quot;인증 체크 인터셉터 실행 &#123;&#125;&quot;, requestURI); HttpSession httpSession = request.getSession(); if(httpSession == null || httpSession.getAttribute(SessionConst.LOGIN_MEMBER) == null)&#123; log.info(&quot;미 인증 사용자 요청&quot;); // 로그인으로 redirect response.sendRedirect(&quot;/login?redirectURL=&quot;+requestURI); return false; &#125; return true; &#125;&#125; Interceptor 등록하기@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LogInterceptor()) .order(1) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/css/**&quot;, &quot;/*.ico&quot;, &quot;/error&quot;); registry.addInterceptor(new LoginCheckInterceptor()) .order(2) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/&quot;, &quot;/members/add&quot;, &quot;/login&quot;, &quot;/logout&quot;, &quot;/css/**&quot;, &quot;/*.ico&quot;, &quot;/error&quot;); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Framework","slug":"Spring/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/"},{"name":"lifecycle","slug":"Spring/Spring-Framework/lifecycle","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/lifecycle/"}],"tags":[]},{"title":"Spring boot - HttpSession 사용하기","slug":"spring/spring-framework/session/springboot-session-02","date":"2021-10-03T14:39:59.000Z","updated":"2024-04-10T09:38:43.520Z","comments":true,"path":"2021/10/03/spring/spring-framework/session/springboot-session-02/","link":"","permalink":"https://ckck803.github.io/2021/10/03/spring/spring-framework/session/springboot-session-02/","excerpt":"목차 Spring boot - HttpSession 사용하기 Spring boot - 직접 Session Storage 구현하기 Spring boot - Cookie 사용하기 Spring boot Session 사용하기 2 request.getSession(true) HttpSession 이 존재하면 HttpSession 을 반환하고 존재하지 않으면 새로운 Session 을 반환한다. request.getSession(false) HttpSession 이 존재하면 현재 HttpSession 을 반한하고 존재하지 않으면 null 을 반환한다. @PostMapping(&quot;/login&quot;)public String loginV3(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletRequest request)&#123; log.info(&quot;Request Params : &#123;&#125;&quot;, form); if(bindingResult.hasErrors())&#123; return &quot;login/loginForm&quot;; &#125; Member loginMember = loginService.login(form.getLoginId(), form.getPassword()); if(loginMember == null)&#123; bindingResult.reject(&quot;loginFail&quot;, &quot;아이디 또는 비밀번호가 맞지 않습니다.&quot;); return &quot;login/loginForm&quot;; &#125; // 로그인 설공 처리 TODO // 세션이 있으면 있는 세션 반환, 없으면 신규 세션을 생성 HttpSession session = request.getSession(); // 세션에 로그인 회원 정보를 보관 session.setAttribute(SessionConst.LOGIN_MEMBER, loginMember); return &quot;redirect:/&quot;;&#125; @PostMapping(&quot;/logout&quot;)public String logoutV3(HttpServletRequest request)&#123; HttpSession session = request.getSession(false); if(session != null)&#123; session.invalidate(); &#125; return &quot;redirect:/&quot;;&#125; @GetMapping(&quot;/&quot;)public String homeLoginV3(HttpServletRequest request, Model model)&#123; HttpSession session = request.getSession(false); if(session == null)&#123; return &quot;home&quot;; &#125; Member LoginMember = (Member) session.getAttribute(SessionConst.LOGIN_MEMBER); // 세션에 회원 데이터가 없으면 home if(LoginMember == null)&#123; return &quot;home&quot;; &#125; // 세션이 유지되 로그인으로 이동 model.addAttribute(&quot;member&quot;, LoginMember); return &quot;loginHome&quot;;&#125; 스프링에서 지원하는 Session 기능 사용하기@GetMapping(&quot;/&quot;)public String homeLoginV3Spring( @SessionAttribute(name = SessionConst.LOGIN_MEMBER, required = false) Member loginMember, Model model)&#123; // 세션에 회원 데이터가 없으면 home if(loginMember == null)&#123; return &quot;home&quot;; &#125; // 세션이 유지되 로그인으로 이동 model.addAttribute(&quot;member&quot;, loginMember); return &quot;loginHome&quot;;&#125;","text":"목차 Spring boot - HttpSession 사용하기 Spring boot - 직접 Session Storage 구현하기 Spring boot - Cookie 사용하기 Spring boot Session 사용하기 2 request.getSession(true) HttpSession 이 존재하면 HttpSession 을 반환하고 존재하지 않으면 새로운 Session 을 반환한다. request.getSession(false) HttpSession 이 존재하면 현재 HttpSession 을 반한하고 존재하지 않으면 null 을 반환한다. @PostMapping(&quot;/login&quot;)public String loginV3(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletRequest request)&#123; log.info(&quot;Request Params : &#123;&#125;&quot;, form); if(bindingResult.hasErrors())&#123; return &quot;login/loginForm&quot;; &#125; Member loginMember = loginService.login(form.getLoginId(), form.getPassword()); if(loginMember == null)&#123; bindingResult.reject(&quot;loginFail&quot;, &quot;아이디 또는 비밀번호가 맞지 않습니다.&quot;); return &quot;login/loginForm&quot;; &#125; // 로그인 설공 처리 TODO // 세션이 있으면 있는 세션 반환, 없으면 신규 세션을 생성 HttpSession session = request.getSession(); // 세션에 로그인 회원 정보를 보관 session.setAttribute(SessionConst.LOGIN_MEMBER, loginMember); return &quot;redirect:/&quot;;&#125; @PostMapping(&quot;/logout&quot;)public String logoutV3(HttpServletRequest request)&#123; HttpSession session = request.getSession(false); if(session != null)&#123; session.invalidate(); &#125; return &quot;redirect:/&quot;;&#125; @GetMapping(&quot;/&quot;)public String homeLoginV3(HttpServletRequest request, Model model)&#123; HttpSession session = request.getSession(false); if(session == null)&#123; return &quot;home&quot;; &#125; Member LoginMember = (Member) session.getAttribute(SessionConst.LOGIN_MEMBER); // 세션에 회원 데이터가 없으면 home if(LoginMember == null)&#123; return &quot;home&quot;; &#125; // 세션이 유지되 로그인으로 이동 model.addAttribute(&quot;member&quot;, LoginMember); return &quot;loginHome&quot;;&#125; 스프링에서 지원하는 Session 기능 사용하기@GetMapping(&quot;/&quot;)public String homeLoginV3Spring( @SessionAttribute(name = SessionConst.LOGIN_MEMBER, required = false) Member loginMember, Model model)&#123; // 세션에 회원 데이터가 없으면 home if(loginMember == null)&#123; return &quot;home&quot;; &#125; // 세션이 유지되 로그인으로 이동 model.addAttribute(&quot;member&quot;, loginMember); return &quot;loginHome&quot;;&#125; Tracking Mode 끄기@Slf4j@RestControllerpublic class SessionInfoController &#123; @GetMapping(&quot;/session-info&quot;) public String sessionInfo(HttpServletRequest request)&#123; HttpSession session = request.getSession(false); if(session == null)&#123; return &quot;세션이 없습니다.&quot;; &#125; session.getAttributeNames() .asIterator() .forEachRemaining(name -&gt; log.info(&quot;session name = &#123;&#125;, value = &#123;&#125;&quot;, name, session.getAttribute(name))); log.info(&quot;sessionId = &#123;&#125;&quot;, session.getId()); log.info(&quot;getMaxInactiveInterval = &#123;&#125;&quot;, session.getMaxInactiveInterval()); log.info(&quot;creationTime = &#123;&#125;&quot;, new Date(session.getCreationTime())); log.info(&quot;lastAccessedTime = &#123;&#125;&quot;, new Date(session.getLastAccessedTime())); log.info(&quot;isNew = &#123;&#125;&quot;, session.isNew()); return &quot;세션 출력&quot;; &#125;&#125; Session Timeout 설정하기server.servlet.session.timeout=1800 session.setMaxInactiveInterval(1800); //1800초","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring boot - 직접 Session Storage 구현하기","slug":"spring/spring-framework/session/springboot-session-01","date":"2021-10-03T13:39:59.000Z","updated":"2024-03-27T16:14:14.981Z","comments":true,"path":"2021/10/03/spring/spring-framework/session/springboot-session-01/","link":"","permalink":"https://ckck803.github.io/2021/10/03/spring/spring-framework/session/springboot-session-01/","excerpt":"목차 Spring boot - HttpSession 사용하기 Spring boot - 직접 Session Storage 구현하기 Spring boot - Cookie 사용하기 직접 만든 Session 사용하기@Componentpublic class SessionManager &#123; public static final String SESSION_COOKIE_NAME = &quot;mySessionId&quot;; private Map&lt;String, Object&gt; sessionStore = new ConcurrentHashMap&lt;&gt;(); public void createSession(Object value, HttpServletResponse response)&#123; // Session id를 상성하고 값을 Session에 저장 String sessionId = UUID.randomUUID().toString(); // Session Store 에 새로운 Session 정보를 저장한다. // Session 은 Key Value 형태로 데이터를 저장 sessionStore.put(sessionId, value); // 쿠키 생성 // Session Id 를 Cookie 에 넣어 전달한다. Cookie mySessionCookie = new Cookie(SESSION_COOKIE_NAME, sessionId); response.addCookie(mySessionCookie); &#125; public Object getSession(HttpServletRequest request)&#123; // Request 에서 Session Id 를 가져온다. Cookie sessionCookie = findCookie(request, SESSION_COOKIE_NAME); if(sessionCookie == null)&#123; return null; &#125; // Session Store 에 저장된 Session 정보를 가져온다. return sessionStore.get(sessionCookie.getValue()); &#125; public void expire(HttpServletRequest request)&#123; Cookie sessionCookie = findCookie(request, SESSION_COOKIE_NAME); if(sessionCookie != null)&#123; sessionStore.remove(sessionCookie.getValue()); &#125; &#125; public Cookie findCookie(HttpServletRequest request, String cookieName)&#123; if(request.getCookies() == null)&#123; return null; &#125; return Arrays.stream(request.getCookies()) .filter(cookie -&gt; cookie.getName().equals(cookieName)) .findAny() .orElse(null); &#125;&#125; @PostMapping(&quot;/login&quot;)public String login(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletResponse response)&#123; log.info(&quot;Request Params : &#123;&#125;&quot;, form); if(bindingResult.hasErrors())&#123; return &quot;login/loginForm&quot;; &#125; Member loginMember = loginService.login(form.getLoginId(), form.getPassword()); if(loginMember == null)&#123; bindingResult.reject(&quot;loginFail&quot;, &quot;아이디 또는 비밀번호가 맞지 않습니다.&quot;); return &quot;login/loginForm&quot;; &#125; // 로그인 설공 처리 TODO // 쿠키 사용하기 // 쿠키에 시간 정보를 주지 않으면 세선 쿠(브라우저 종료시 모두 종료) Cookie cookie = new Cookie(&quot;memberId&quot;, String.valueOf(loginMember.getId())); response.addCookie(cookie); return &quot;redirect:/&quot;;&#125; Testclass SessionManagerTest &#123; SessionManager sessionManager = new SessionManager(); @Test void SessionTest()&#123; // 세션 생성 MockHttpServletResponse response = new MockHttpServletResponse(); Member member = new Member(); sessionManager.createSession(member, response); // 요청에 응답 쿠키 저장 MockHttpServletRequest request = new MockHttpServletRequest(); request.setCookies(response.getCookies()); // 세션 조회 Object result = sessionManager.getSession(request); assertThat(result).isEqualTo(member); // 세션 만료 sessionManager.expire(request); Object expired = sessionManager.getSession(request); assertThat(expired).isNull(); &#125;&#125; @PostMapping(&quot;/login&quot;)public String loginV2(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletResponse response)&#123; log.info(&quot;Request Params : &#123;&#125;&quot;, form); if(bindingResult.hasErrors())&#123; return &quot;login/loginForm&quot;; &#125; Member loginMember = loginService.login(form.getLoginId(), form.getPassword()); if(loginMember == null)&#123; bindingResult.reject(&quot;loginFail&quot;, &quot;아이디 또는 비밀번호가 맞지 않습니다.&quot;); return &quot;login/loginForm&quot;; &#125; // 로그인 설공 처리 TODO // 세션 관리자를 통해 세션을 생성하고, 회원 데이터 보관 // 쿠키에 시간 정보를 주지 않으면 세션 쿠키(브라주어 종료시 모두 종료) sessionManager.createSession(loginMember, response); return &quot;redirect:/&quot;;&#125; @PostMapping(&quot;/logout&quot;)public String logoutV2(HttpServletRequest request)&#123; sessionManager.expire(request); return &quot;redirect:/&quot;;&#125;","text":"목차 Spring boot - HttpSession 사용하기 Spring boot - 직접 Session Storage 구현하기 Spring boot - Cookie 사용하기 직접 만든 Session 사용하기@Componentpublic class SessionManager &#123; public static final String SESSION_COOKIE_NAME = &quot;mySessionId&quot;; private Map&lt;String, Object&gt; sessionStore = new ConcurrentHashMap&lt;&gt;(); public void createSession(Object value, HttpServletResponse response)&#123; // Session id를 상성하고 값을 Session에 저장 String sessionId = UUID.randomUUID().toString(); // Session Store 에 새로운 Session 정보를 저장한다. // Session 은 Key Value 형태로 데이터를 저장 sessionStore.put(sessionId, value); // 쿠키 생성 // Session Id 를 Cookie 에 넣어 전달한다. Cookie mySessionCookie = new Cookie(SESSION_COOKIE_NAME, sessionId); response.addCookie(mySessionCookie); &#125; public Object getSession(HttpServletRequest request)&#123; // Request 에서 Session Id 를 가져온다. Cookie sessionCookie = findCookie(request, SESSION_COOKIE_NAME); if(sessionCookie == null)&#123; return null; &#125; // Session Store 에 저장된 Session 정보를 가져온다. return sessionStore.get(sessionCookie.getValue()); &#125; public void expire(HttpServletRequest request)&#123; Cookie sessionCookie = findCookie(request, SESSION_COOKIE_NAME); if(sessionCookie != null)&#123; sessionStore.remove(sessionCookie.getValue()); &#125; &#125; public Cookie findCookie(HttpServletRequest request, String cookieName)&#123; if(request.getCookies() == null)&#123; return null; &#125; return Arrays.stream(request.getCookies()) .filter(cookie -&gt; cookie.getName().equals(cookieName)) .findAny() .orElse(null); &#125;&#125; @PostMapping(&quot;/login&quot;)public String login(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletResponse response)&#123; log.info(&quot;Request Params : &#123;&#125;&quot;, form); if(bindingResult.hasErrors())&#123; return &quot;login/loginForm&quot;; &#125; Member loginMember = loginService.login(form.getLoginId(), form.getPassword()); if(loginMember == null)&#123; bindingResult.reject(&quot;loginFail&quot;, &quot;아이디 또는 비밀번호가 맞지 않습니다.&quot;); return &quot;login/loginForm&quot;; &#125; // 로그인 설공 처리 TODO // 쿠키 사용하기 // 쿠키에 시간 정보를 주지 않으면 세선 쿠(브라우저 종료시 모두 종료) Cookie cookie = new Cookie(&quot;memberId&quot;, String.valueOf(loginMember.getId())); response.addCookie(cookie); return &quot;redirect:/&quot;;&#125; Testclass SessionManagerTest &#123; SessionManager sessionManager = new SessionManager(); @Test void SessionTest()&#123; // 세션 생성 MockHttpServletResponse response = new MockHttpServletResponse(); Member member = new Member(); sessionManager.createSession(member, response); // 요청에 응답 쿠키 저장 MockHttpServletRequest request = new MockHttpServletRequest(); request.setCookies(response.getCookies()); // 세션 조회 Object result = sessionManager.getSession(request); assertThat(result).isEqualTo(member); // 세션 만료 sessionManager.expire(request); Object expired = sessionManager.getSession(request); assertThat(expired).isNull(); &#125;&#125; @PostMapping(&quot;/login&quot;)public String loginV2(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletResponse response)&#123; log.info(&quot;Request Params : &#123;&#125;&quot;, form); if(bindingResult.hasErrors())&#123; return &quot;login/loginForm&quot;; &#125; Member loginMember = loginService.login(form.getLoginId(), form.getPassword()); if(loginMember == null)&#123; bindingResult.reject(&quot;loginFail&quot;, &quot;아이디 또는 비밀번호가 맞지 않습니다.&quot;); return &quot;login/loginForm&quot;; &#125; // 로그인 설공 처리 TODO // 세션 관리자를 통해 세션을 생성하고, 회원 데이터 보관 // 쿠키에 시간 정보를 주지 않으면 세션 쿠키(브라주어 종료시 모두 종료) sessionManager.createSession(loginMember, response); return &quot;redirect:/&quot;;&#125; @PostMapping(&quot;/logout&quot;)public String logoutV2(HttpServletRequest request)&#123; sessionManager.expire(request); return &quot;redirect:/&quot;;&#125; @GetMapping(&quot;/&quot;)public String homeLoginV2(HttpServletRequest request, Model model)&#123; // 세션 관리자에 저장된 회원 정보를 조회 Member member = (Member) sessionManager.getSession(request); // 로그인 if(member == null)&#123; return &quot;home&quot; &#125; model.addAttribute(&quot;member&quot;, member); return &quot;loginHome&quot;;&#125; No newline at end of file","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"}],"tags":[]},{"title":"Spring boot - Cookie 사용하기","slug":"spring/spring-framework/cookie/springboot-cookie","date":"2021-10-03T01:39:59.000Z","updated":"2024-03-27T16:12:18.940Z","comments":true,"path":"2021/10/03/spring/spring-framework/cookie/springboot-cookie/","link":"","permalink":"https://ckck803.github.io/2021/10/03/spring/spring-framework/cookie/springboot-cookie/","excerpt":"목차 Spring boot - HttpSession 사용하기 Spring boot - 직접 Session Storage 구현하기 Spring boot - Cookie 사용하기 쿠키 생성스프링에서 쿠키는 Cookie 를 이용해 쉽게 생성할 수 있습니다. 생성한 쿠키를 Client 로 전달하기 위해 컨트롤러 메소드 파라미터로 HttpServletResponse 객체를 추가한 후 HttpServletResponse 객체에 생성한 쿠키를 넣어줍니다. @GetMapping(&quot;/cookie/create&quot;)public ResponseEntity&lt;String&gt; helloCookie(HttpServletResponse httpServletResponse) &#123; Cookie cookie = new Cookie(&quot;helloCookie&quot;, URLEncoder.encode(&quot;Hello world&quot;, StandardCharsets.UTF_8)); httpServletResponse.addCookie(cookie); return ResponseEntity.ok().body(&quot;Create Cookie&quot;);&#125; 쿠키 생성 테스트@Testvoid CookieTest() throws Exception &#123; ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/cookie/create&quot;)) .andExpect(status().isOk()) .andExpect(cookie().exists(&quot;helloCookie&quot;)) .andExpect(cookie().value(&quot;helloCookie&quot;, &quot;Hello+world&quot;)) .andDo(print());&#125; TestRestTemplate 을 이용해 어플리케이션에 대한 컨트롤러 테스트를 진행합니다. Client 로 전달된 쿠키는 Response Header 에서 확인할 수 있습니다. @LocalServerPortprivate int port;@Autowiredprivate TestRestTemplate restTemplate;@Testvoid helloCookie() &#123; String url = &quot;http://localhost:&quot; + port + &quot;/cookie/create&quot;; // 테스트할 엔드포인트 URL // REST API 호출 ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class); // 응답 헤더에서 쿠키 정보 가져오기 HttpHeaders headers = response.getHeaders(); List&lt;String&gt; cookies = headers.get(HttpHeaders.SET_COOKIE); assertThat(response.getBody()).isEqualTo(&quot;Create Cookie&quot;); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); for (String cookie : cookies) &#123; System.out.println(&quot;cookie = &quot; + cookie); assertThat(cookie.contains(&quot;helloCookie&quot;)).isTrue(); &#125;&#125;","text":"목차 Spring boot - HttpSession 사용하기 Spring boot - 직접 Session Storage 구현하기 Spring boot - Cookie 사용하기 쿠키 생성스프링에서 쿠키는 Cookie 를 이용해 쉽게 생성할 수 있습니다. 생성한 쿠키를 Client 로 전달하기 위해 컨트롤러 메소드 파라미터로 HttpServletResponse 객체를 추가한 후 HttpServletResponse 객체에 생성한 쿠키를 넣어줍니다. @GetMapping(&quot;/cookie/create&quot;)public ResponseEntity&lt;String&gt; helloCookie(HttpServletResponse httpServletResponse) &#123; Cookie cookie = new Cookie(&quot;helloCookie&quot;, URLEncoder.encode(&quot;Hello world&quot;, StandardCharsets.UTF_8)); httpServletResponse.addCookie(cookie); return ResponseEntity.ok().body(&quot;Create Cookie&quot;);&#125; 쿠키 생성 테스트@Testvoid CookieTest() throws Exception &#123; ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/cookie/create&quot;)) .andExpect(status().isOk()) .andExpect(cookie().exists(&quot;helloCookie&quot;)) .andExpect(cookie().value(&quot;helloCookie&quot;, &quot;Hello+world&quot;)) .andDo(print());&#125; TestRestTemplate 을 이용해 어플리케이션에 대한 컨트롤러 테스트를 진행합니다. Client 로 전달된 쿠키는 Response Header 에서 확인할 수 있습니다. @LocalServerPortprivate int port;@Autowiredprivate TestRestTemplate restTemplate;@Testvoid helloCookie() &#123; String url = &quot;http://localhost:&quot; + port + &quot;/cookie/create&quot;; // 테스트할 엔드포인트 URL // REST API 호출 ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class); // 응답 헤더에서 쿠키 정보 가져오기 HttpHeaders headers = response.getHeaders(); List&lt;String&gt; cookies = headers.get(HttpHeaders.SET_COOKIE); assertThat(response.getBody()).isEqualTo(&quot;Create Cookie&quot;); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); for (String cookie : cookies) &#123; System.out.println(&quot;cookie = &quot; + cookie); assertThat(cookie.contains(&quot;helloCookie&quot;)).isTrue(); &#125;&#125; 쿠키 삭제쿠키를 지우는 방법은 setMaxAge 메소드를 이용해 쿠키 시간을 없애면 된다. @GetMapping(&quot;/cookie/delete&quot;)public ResponseEntity&lt;String&gt; deleteCookie(HttpServletResponse httpServletResponse) &#123; Cookie cookie = new Cookie(&quot;helloCookie&quot;, null); // 쿠키 시간을 없애면 Client 에서 자동적으로 쿠키를 삭제합니다. cookie.setMaxAge(0); httpServletResponse.addCookie(cookie); return ResponseEntity.ok().body(&quot;Delete Cookie&quot;);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Framework","slug":"Spring/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/"},{"name":"lifecycle","slug":"Spring/Spring-Framework/lifecycle","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/lifecycle/"}],"tags":[]},{"title":"백준 14592 - 연구소","slug":"algorithm/baekjoon/BFS/14592-연구소","date":"2021-09-26T02:53:25.000Z","updated":"2024-02-18T16:19:54.509Z","comments":true,"path":"2021/09/26/algorithm/baekjoon/BFS/14592-연구소/","link":"","permalink":"https://ckck803.github.io/2021/09/26/algorithm/baekjoon/BFS/14592-%EC%97%B0%EA%B5%AC%EC%86%8C/","excerpt":"백준 14592 - 연구소https://www.acmicpc.net/problem/14592 문제풀이해당 문제에서는 3가지 입력 N, M, 지도 모양이 주어진다. N : 세로 크기 M : 가로 크기 지도 정보 지도 내 상태는 3가지 상태가 존재한다. 0 : 빈칸 1 : 벽 2 : 바이러스 알고리즘 실행계획은 다음과 같이 진행한다. 벽을 세운다. 바이러스 확산 시킨다. 바이러스 영역을 확인한다.","text":"백준 14592 - 연구소https://www.acmicpc.net/problem/14592 문제풀이해당 문제에서는 3가지 입력 N, M, 지도 모양이 주어진다. N : 세로 크기 M : 가로 크기 지도 정보 지도 내 상태는 3가지 상태가 존재한다. 0 : 빈칸 1 : 벽 2 : 바이러스 알고리즘 실행계획은 다음과 같이 진행한다. 벽을 세운다. 바이러스 확산 시킨다. 바이러스 영역을 확인한다. 이 문제에서는 3가지 벽을 어떻게 세울지가 관건이다. 다행이 지도의 크기는 최대 8*8을 갖고 지도의 벽을 세울 경우의 수는 64C3의 경우의 수를 갖는다. 지도의 벽을 세우는 경우의 수 * 지도 탐색의 시간 복잡도를 계산하면 최대 260만의 시간 복잡도를 갖게 되므로 브루트 포스 방식으로 벽을 세워서 확인해도 충분히 시간내에 해결할 수 있다. 전체 소스 코드import java.io.*;import java.util.*;public class Main &#123; public static int maxValue = 0; public static int[] dy = &#123; 1, -1, 0, 0 &#125;; public static int[] dx = &#123; 0, 0, 1, -1 &#125;; public static void findVirus(int N, int M, int[][] lab) &#123; int count = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (lab[i][j] == 0) &#123; count++; &#125; &#125; &#125; if (count &gt; maxValue) &#123; maxValue = count; &#125; &#125; public static void bfs(int N, int M, int[][] lab) &#123; Queue&lt;int[]&gt; q = new LinkedList(); boolean[][] check = new boolean[N][M]; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (lab[i][j] == 2) &#123; check[i][j] = true; q.add(new int[] &#123; i, j &#125;); &#125; &#125; &#125; while (!q.isEmpty()) &#123; int[] front = q.remove(); int cntY = front[0]; int cntX = front[1]; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &gt; ny || ny &gt;= N || 0 &gt; nx || nx &gt;= M) &#123; continue; &#125; if (lab[ny][nx] == 0 &amp;&amp; check[ny][nx] == false) &#123; lab[ny][nx] = 2; check[ny][nx] = true; q.add(new int[] &#123; ny, nx &#125;); &#125; &#125; &#125; &#125; public static void copyLab(int[][] copiedLab, int[][] lab, int N, int M) &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; copiedLab[i][j] = lab[i][j]; &#125; &#125; &#125; public static void makeWall(int N, int M, int[][] lab, int depth) &#123; if (depth == 3) &#123; int[][] copiedLab = new int[N][M]; copyLab(copiedLab, lab, N, M); bfs(N, M, lab); findVirus(N, M, lab); copyLab(lab, copiedLab, N, M); return; &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (lab[i][j] != 0) &#123; continue; &#125; lab[i][j] = 1; makeWall(N, M, lab, depth + 1); lab[i][j] = 0; &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] inputs = br.readLine().split(&quot; &quot;); int N, M; N = Integer.parseInt(inputs[0]); M = Integer.parseInt(inputs[1]); int[][] lab = new int[N][M]; for (int i = 0; i &lt; N; i++) &#123; inputs = br.readLine().split(&quot; &quot;); for (int j = 0; j &lt; M; j++) &#123; lab[i][j] = Integer.parseInt(inputs[j]); &#125; &#125; makeWall(N, M, lab, 0); System.out.println(maxValue); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"}]},{"title":"백준 1158 - 요세푸스 문제","slug":"algorithm/baekjoon/자료구조/리스트/1158-요세푸스문제","date":"2021-09-26T01:53:25.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2021/09/26/algorithm/baekjoon/자료구조/리스트/1158-요세푸스문제/","link":"","permalink":"https://ckck803.github.io/2021/09/26/algorithm/baekjoon/%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9/%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3/1158-%EC%9A%94%EC%84%B8%ED%91%B8%EC%8A%A4%EB%AC%B8%EC%A0%9C/","excerpt":"백준 1158 - 요세푸스 문제https://www.acmicpc.net/problem/1158 문제 풀이해당 문제에서는 두가지 입력 N, K가 주어진다. N : 사람 수 K : 원에서 사람이 제거되는 간격 N, K의 최대 5000 이므로, 최대 O(N^2)의 시간복잡도내에서 문제를 해결해야 한다. 전체 소스 코드import java.io.*;import java.util.*;public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] arguments = br.readLine().split(&quot; &quot;); int N, K; N = Integer.parseInt(arguments[0]); K = Integer.parseInt(arguments[1]); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) &#123; list.add(i + 1); &#125; int index = 0; StringBuilder sb = new StringBuilder(); sb.append(&quot;&lt;&quot;); // 사람을 간격에 맞게 하나씩 제거해준다. while (list.size() &gt; 1) &#123; index += K - 1; index %= list.size(); int removedValue = list.remove(index); sb.append(Integer.toString(removedValue)); sb.append(&quot;, &quot;); &#125; // 마지막 숫자를 제거한다. index += K - 1; index %= list.size(); int removedValue = list.remove(index); sb.append(Integer.toString(removedValue)); sb.append(&quot;&gt;&quot;); System.out.println(sb.toString()); br.close(); &#125;&#125;","text":"백준 1158 - 요세푸스 문제https://www.acmicpc.net/problem/1158 문제 풀이해당 문제에서는 두가지 입력 N, K가 주어진다. N : 사람 수 K : 원에서 사람이 제거되는 간격 N, K의 최대 5000 이므로, 최대 O(N^2)의 시간복잡도내에서 문제를 해결해야 한다. 전체 소스 코드import java.io.*;import java.util.*;public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] arguments = br.readLine().split(&quot; &quot;); int N, K; N = Integer.parseInt(arguments[0]); K = Integer.parseInt(arguments[1]); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) &#123; list.add(i + 1); &#125; int index = 0; StringBuilder sb = new StringBuilder(); sb.append(&quot;&lt;&quot;); // 사람을 간격에 맞게 하나씩 제거해준다. while (list.size() &gt; 1) &#123; index += K - 1; index %= list.size(); int removedValue = list.remove(index); sb.append(Integer.toString(removedValue)); sb.append(&quot;, &quot;); &#125; // 마지막 숫자를 제거한다. index += K - 1; index %= list.size(); int removedValue = list.remove(index); sb.append(Integer.toString(removedValue)); sb.append(&quot;&gt;&quot;); System.out.println(sb.toString()); br.close(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"자료구조","slug":"Programming/Beakjoon/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"List","slug":"Programming/Beakjoon/자료구조/List","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/List/"}],"tags":[{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"}]},{"title":"Spring boot - Resource 추상화","slug":"spring/spring-resource/resource","date":"2021-09-20T14:39:59.000Z","updated":"2024-02-26T15:39:46.762Z","comments":true,"path":"2021/09/20/spring/spring-resource/resource/","link":"","permalink":"https://ckck803.github.io/2021/09/20/spring/spring-resource/resource/","excerpt":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 Spring boot Resource 추상화https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html Resource 는 java.net.URL 을 추상화 해 스프링 프레임워크에서 Low-Level에 있는 자원에 쉽게 접근할 수 있도록 지원한다 ClassPath를 기준으로 리소스를 가져오는 기능의 부재 ServletContext를 기준으로 상대 경로를 읽어오는 기능의 부재 Resource.java public interface Resource extends InputStreamSource &#123; boolean exists(); URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; @Nullable String getFilename(); String getDescription(); default boolean isReadable() &#123; return exists(); &#125; default boolean isOpen() &#123; return false; &#125; default boolean isFile() &#123; return false; &#125; default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(getInputStream()); &#125;&#125; Resource 구현체","text":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 Spring boot Resource 추상화https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html Resource 는 java.net.URL 을 추상화 해 스프링 프레임워크에서 Low-Level에 있는 자원에 쉽게 접근할 수 있도록 지원한다 ClassPath를 기준으로 리소스를 가져오는 기능의 부재 ServletContext를 기준으로 상대 경로를 읽어오는 기능의 부재 Resource.java public interface Resource extends InputStreamSource &#123; boolean exists(); URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; @Nullable String getFilename(); String getDescription(); default boolean isReadable() &#123; return exists(); &#125; default boolean isOpen() &#123; return false; &#125; default boolean isFile() &#123; return false; &#125; default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(getInputStream()); &#125;&#125; Resource 구현체 UrlResource ClassPathResource FileSystemResource ServletContextResource UrlResource URL을 기준으로 리소스를 읽어들이고, 자원에 접근하는 방식에 따라 Prefix 를 붙인다. File System의 경우 file: Prefix를 이용 Http 를 이용해 자원에 접근할 경우 http: Prefix를 이용 FTP 를 이용해 자원에 접근할 경우 ftp: Prefix를 이용 ClassPathResource Class Loader를 사용해 classpath 를 기준으로 리소스를 읽어들이는 방식 FileSystemResource FileSystemResourceLoader 를 사용해 File System에서 리소스를 읽어들이는 방식 ServletContextResource 웹 어플리케이션 루트에서 상대 경로로 리소스를 찾는다. Spring Boot 에서 지원하는 내장형 톰캣에서는 기본 Context Path가 지정 돼 있지 않다. 코드를 통해 확인하기Resource 객체 보내기ClassPathResource 를 이용해 /src/test/resource 에 저장된 testFile.txt 파일을 가져와 서버쪽으로 보내는 코드를 작성했다. @Testpublic void uploadTest() throws IOException &#123; // ClassPathResource 를 이용해 testFile.txt 파일을 읽어온다. ClassPathResource resource = new ClassPathResource(&quot;testFile.txt&quot;); File file = resource.getFile(); MultiValueMap multiValueMap = new LinkedMultiValueMap(); multiValueMap.add(&quot;file&quot;, resource); // 파일을 보내기 위해 Http Header Content Type을 MULTIPART_FORM_DATA 로 설정해준다. HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); // HttpEntity 에 Resource 객체를 갖고 있는 MultiValueMap 객체를 넣어준다. HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; httpEntity = new HttpEntity(multiValueMap, headers); String requestURL = &quot;http://localhost:&quot; + randomServerPort + &quot;/file/upload&quot;; ResponseEntity&lt;String&gt; responseEntity = this.testRestTemplate.exchange(requestURL, HttpMethod.POST, httpEntity, new ParameterizedTypeReference&lt;String&gt;() &#123; &#125;); assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.CREATED); assertThat(responseEntity.getBody()).isEqualTo(&quot;File Upload Success&quot;);&#125; Resource 객체 반환하기두 번째 예시로 MultipartFile 객체를 받아 리소스를 가져온 후 해당 리소스를 다시 반환하는 로직을 작성했다. @PostMapping(&quot;/file/upload2&quot;)public ResponseEntity&lt;Resource&gt; upload2(@RequestParam(&quot;file&quot;) MultipartFile multipartFile) throws IOException &#123; if(multipartFile.isEmpty())&#123; log.info(&quot;File is empty&quot;); &#125; // MultipartFile 객체에 저장된 Resource 객체를 가져온다. Resource resource = multipartFile.getResource(); // Http Header 에 contentDisposition 옵션을 추가해준다. ContentDisposition contentDisposition = ContentDisposition.builder(&quot;attachment&quot;) .filename(multipartFile.getOriginalFilename()) .build(); HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.setContentDisposition(contentDisposition); return ResponseEntity.ok() .headers(httpHeaders) .body(resource);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"},{"name":"File","slug":"Spring/Spring-Resource/File","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/File/"}],"tags":[]},{"title":"Spring boot - 파일 다운로드 서비스 구현하기","slug":"spring/spring-resource/file-upload-4","date":"2021-09-19T22:39:59.000Z","updated":"2024-02-26T15:38:52.287Z","comments":true,"path":"2021/09/20/spring/spring-resource/file-upload-4/","link":"","permalink":"https://ckck803.github.io/2021/09/20/spring/spring-resource/file-upload-4/","excerpt":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 파일 다운로드서버에 저장된 파일을 다운 받기 위해서는 Response 해더에 Content-Disposition 정보가 필요합니다. String contentDisposition = &quot;attachment; filename=\\&quot;&quot; + encodedUploadFileName + &quot;\\&quot;&quot;; Resource 객체로 업로드된 파일을 전송한다. UrlResource 객체를 이용해 특정 경로에 저장된 Resource 를 가져온 후 ResponseEntity 의 Body에 넣어서 반환한다. @GetMapping(&quot;/attach/&#123;itemId&#125;&quot;)public ResponseEntity&lt;Resource&gt; downloadAttach(@PathVariable Long itemId) throws MalformedURLException &#123; Item item = itemRepository.findById(itemId); String storeFileName = item.getAttachFile().getStoreFileName(); String uploadFileName = item.getAttachFile().getUploadFileName(); UrlResource resource = new UrlResource(&quot;file:&quot; + fileStore.getFullPath(storeFileName)); log.info(&quot;uploadFileName=&#123;&#125;&quot;, uploadFileName); String encodedUploadFileName = UriUtils.encode(uploadFileName, StandardCharsets.UTF_8); String contentDisposition = &quot;attachment; filename=\\&quot;&quot; + encodedUploadFileName + &quot;\\&quot;&quot;; return ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, contentDisposition) .body(resource);&#125; 전체 코드@Slf4j@Controller@RequiredArgsConstructorpublic class ItemController &#123; private final ItemRepository itemRepository; private final FileStore fileStore; @GetMapping(&quot;/items/new&quot;) public String newItem(@ModelAttribute ItemForm form) &#123; return &quot;item-form&quot;; &#125; @PostMapping(&quot;/items/new&quot;) public String saveItem(@ModelAttribute ItemForm form, RedirectAttributes redirectAttributes) throws IOException &#123; UploadFile attachFile = fileStore.storeFile(form.getAttachFile()); List&lt;UploadFile&gt; storeImageFiles = fileStore.storeFiles(form.getImageFiles()); //데이터베이스에 저장 Item item = new Item(); item.setItemName(form.getItemName()); item.setAttachFile(attachFile); item.setImageFiles(storeImageFiles); itemRepository.save(item); redirectAttributes.addAttribute(&quot;itemId&quot;, item.getId()); return &quot;redirect:/items/&#123;itemId&#125;&quot;; &#125; @GetMapping(&quot;/items/&#123;id&#125;&quot;) public String items(@PathVariable Long id, Model model) &#123; Item item = itemRepository.findById(id); model.addAttribute(&quot;item&quot;, item); return &quot;item-view&quot;; &#125; @ResponseBody @GetMapping(&quot;/images/&#123;filename&#125;&quot;) public Resource downloadImage(@PathVariable String filename) throws MalformedURLException &#123; return new UrlResource(&quot;file:&quot; + fileStore.getFullPath(filename)); &#125; @GetMapping(&quot;/attach/&#123;itemId&#125;&quot;) public ResponseEntity&lt;Resource&gt; downloadAttach(@PathVariable Long itemId) throws MalformedURLException &#123; Item item = itemRepository.findById(itemId); String storeFileName = item.getAttachFile().getStoreFileName(); String uploadFileName = item.getAttachFile().getUploadFileName(); UrlResource resource = new UrlResource(&quot;file:&quot; + fileStore.getFullPath(storeFileName)); log.info(&quot;uploadFileName=&#123;&#125;&quot;, uploadFileName); String encodedUploadFileName = UriUtils.encode(uploadFileName, StandardCharsets.UTF_8); String contentDisposition = &quot;attachment; filename=\\&quot;&quot; + encodedUploadFileName + &quot;\\&quot;&quot;; return ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, contentDisposition) .body(resource); &#125;&#125;","text":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 파일 다운로드서버에 저장된 파일을 다운 받기 위해서는 Response 해더에 Content-Disposition 정보가 필요합니다. String contentDisposition = &quot;attachment; filename=\\&quot;&quot; + encodedUploadFileName + &quot;\\&quot;&quot;; Resource 객체로 업로드된 파일을 전송한다. UrlResource 객체를 이용해 특정 경로에 저장된 Resource 를 가져온 후 ResponseEntity 의 Body에 넣어서 반환한다. @GetMapping(&quot;/attach/&#123;itemId&#125;&quot;)public ResponseEntity&lt;Resource&gt; downloadAttach(@PathVariable Long itemId) throws MalformedURLException &#123; Item item = itemRepository.findById(itemId); String storeFileName = item.getAttachFile().getStoreFileName(); String uploadFileName = item.getAttachFile().getUploadFileName(); UrlResource resource = new UrlResource(&quot;file:&quot; + fileStore.getFullPath(storeFileName)); log.info(&quot;uploadFileName=&#123;&#125;&quot;, uploadFileName); String encodedUploadFileName = UriUtils.encode(uploadFileName, StandardCharsets.UTF_8); String contentDisposition = &quot;attachment; filename=\\&quot;&quot; + encodedUploadFileName + &quot;\\&quot;&quot;; return ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, contentDisposition) .body(resource);&#125; 전체 코드@Slf4j@Controller@RequiredArgsConstructorpublic class ItemController &#123; private final ItemRepository itemRepository; private final FileStore fileStore; @GetMapping(&quot;/items/new&quot;) public String newItem(@ModelAttribute ItemForm form) &#123; return &quot;item-form&quot;; &#125; @PostMapping(&quot;/items/new&quot;) public String saveItem(@ModelAttribute ItemForm form, RedirectAttributes redirectAttributes) throws IOException &#123; UploadFile attachFile = fileStore.storeFile(form.getAttachFile()); List&lt;UploadFile&gt; storeImageFiles = fileStore.storeFiles(form.getImageFiles()); //데이터베이스에 저장 Item item = new Item(); item.setItemName(form.getItemName()); item.setAttachFile(attachFile); item.setImageFiles(storeImageFiles); itemRepository.save(item); redirectAttributes.addAttribute(&quot;itemId&quot;, item.getId()); return &quot;redirect:/items/&#123;itemId&#125;&quot;; &#125; @GetMapping(&quot;/items/&#123;id&#125;&quot;) public String items(@PathVariable Long id, Model model) &#123; Item item = itemRepository.findById(id); model.addAttribute(&quot;item&quot;, item); return &quot;item-view&quot;; &#125; @ResponseBody @GetMapping(&quot;/images/&#123;filename&#125;&quot;) public Resource downloadImage(@PathVariable String filename) throws MalformedURLException &#123; return new UrlResource(&quot;file:&quot; + fileStore.getFullPath(filename)); &#125; @GetMapping(&quot;/attach/&#123;itemId&#125;&quot;) public ResponseEntity&lt;Resource&gt; downloadAttach(@PathVariable Long itemId) throws MalformedURLException &#123; Item item = itemRepository.findById(itemId); String storeFileName = item.getAttachFile().getStoreFileName(); String uploadFileName = item.getAttachFile().getUploadFileName(); UrlResource resource = new UrlResource(&quot;file:&quot; + fileStore.getFullPath(storeFileName)); log.info(&quot;uploadFileName=&#123;&#125;&quot;, uploadFileName); String encodedUploadFileName = UriUtils.encode(uploadFileName, StandardCharsets.UTF_8); String contentDisposition = &quot;attachment; filename=\\&quot;&quot; + encodedUploadFileName + &quot;\\&quot;&quot;; return ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, contentDisposition) .body(resource); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"},{"name":"File","slug":"Spring/Spring-Resource/File","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/File/"}],"tags":[]},{"title":"Spring Cloud - 33. Order Kafka Producer","slug":"spring/spring-cloud/kafka/spring-cloud-33","date":"2021-09-19T18:31:31.000Z","updated":"2024-02-26T15:34:29.891Z","comments":true,"path":"2021/09/20/spring/spring-cloud/kafka/spring-cloud-33/","link":"","permalink":"https://ckck803.github.io/2021/09/20/spring/spring-cloud/kafka/spring-cloud-33/","excerpt":"목차 Spring Cloud - 33. Order Kafka Producer Spring Cloud - 32. kafka-mariadb 연결 Spring Cloud - 31. Kafka Topic 적용 Order Kafka Producer@RestController@RequestMapping(&quot;/order-service/&quot;)@RequiredArgsConstructorpublic class OrderController &#123; private final OrderService orderService; private final KafkaProducer kafkaProducer; private final OrderProducer orderProducer; @PostMapping(value = &quot;/&#123;userId&#125;/orders&quot;) public ResponseEntity&lt;ResponseOrder&gt; createOrder(@PathVariable(&quot;userId&quot;) String userId, @RequestBody RequestOrder orderDetails)&#123; ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); OrderDto orderDto = modelMapper.map(orderDetails, OrderDto.class); orderDto.setUserId(userId); orderDto.setOrderId(UUID.randomUUID().toString()); orderDto.setTotalPrice(orderDetails.getQty() * orderDetails.getUnitPrice()); ResponseOrder returnValue = modelMapper.map(orderDto, ResponseOrder.class); kafkaProducer.send(&quot;example-order-topic&quot;, orderDto); orderProducer.send(&quot;orders&quot;, orderDto); return ResponseEntity.status(HttpStatus.CREATED).body(returnValue); &#125; @GetMapping(value = &quot;/&#123;userId&#125;/orders&quot;) public ResponseEntity&lt;List&lt;ResponseOrder&gt;&gt; getOrder(@PathVariable(&quot;userId&quot;) String userId)&#123; Iterable&lt;OrderEntity&gt; orderList = orderService.getOrdersByUserId(userId); List&lt;ResponseOrder&gt; result = new ArrayList&lt;&gt;(); orderList.forEach(v -&gt; &#123; result.add(new ModelMapper().map(v, ResponseOrder.class)); &#125;); return ResponseEntity.status(HttpStatus.OK).body(result); &#125;&#125; @Service@Slf4j@RequiredArgsConstructorpublic class OrderProducer &#123; private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; public OrderDto send(String topic, OrderDto orderDto)&#123; ObjectMapper mapper = new ObjectMapper(); String jsonInString = &quot;&quot;; try&#123; jsonInString = mapper.writeValueAsString(orderDto); &#125;catch (JsonProcessingException ex)&#123; ex.printStackTrace(); &#125; kafkaTemplate.send(topic, jsonInString); log.info(&quot;Kafka Producer sent data from the Order microservice: &quot; + orderDto); return orderDto; &#125;&#125; @Data@Builderpublic class Scheme &#123; private String type; private List&lt;Field&gt; fields; private boolean optional; private String name;&#125; @Data@AllArgsConstructorpublic class Field &#123; private String type; private boolean optional; private String field;&#125; @Data@Builderpublic class Payload &#123; private String order_id; private String user_id; private String product_id; private int qty; private int unit_price; private int total_price;&#125; @Data@AllArgsConstructorpublic class KafkaOrderDto implements Serializable &#123; private Scheme scheme; private Payload payload;&#125;","text":"목차 Spring Cloud - 33. Order Kafka Producer Spring Cloud - 32. kafka-mariadb 연결 Spring Cloud - 31. Kafka Topic 적용 Order Kafka Producer@RestController@RequestMapping(&quot;/order-service/&quot;)@RequiredArgsConstructorpublic class OrderController &#123; private final OrderService orderService; private final KafkaProducer kafkaProducer; private final OrderProducer orderProducer; @PostMapping(value = &quot;/&#123;userId&#125;/orders&quot;) public ResponseEntity&lt;ResponseOrder&gt; createOrder(@PathVariable(&quot;userId&quot;) String userId, @RequestBody RequestOrder orderDetails)&#123; ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); OrderDto orderDto = modelMapper.map(orderDetails, OrderDto.class); orderDto.setUserId(userId); orderDto.setOrderId(UUID.randomUUID().toString()); orderDto.setTotalPrice(orderDetails.getQty() * orderDetails.getUnitPrice()); ResponseOrder returnValue = modelMapper.map(orderDto, ResponseOrder.class); kafkaProducer.send(&quot;example-order-topic&quot;, orderDto); orderProducer.send(&quot;orders&quot;, orderDto); return ResponseEntity.status(HttpStatus.CREATED).body(returnValue); &#125; @GetMapping(value = &quot;/&#123;userId&#125;/orders&quot;) public ResponseEntity&lt;List&lt;ResponseOrder&gt;&gt; getOrder(@PathVariable(&quot;userId&quot;) String userId)&#123; Iterable&lt;OrderEntity&gt; orderList = orderService.getOrdersByUserId(userId); List&lt;ResponseOrder&gt; result = new ArrayList&lt;&gt;(); orderList.forEach(v -&gt; &#123; result.add(new ModelMapper().map(v, ResponseOrder.class)); &#125;); return ResponseEntity.status(HttpStatus.OK).body(result); &#125;&#125; @Service@Slf4j@RequiredArgsConstructorpublic class OrderProducer &#123; private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; public OrderDto send(String topic, OrderDto orderDto)&#123; ObjectMapper mapper = new ObjectMapper(); String jsonInString = &quot;&quot;; try&#123; jsonInString = mapper.writeValueAsString(orderDto); &#125;catch (JsonProcessingException ex)&#123; ex.printStackTrace(); &#125; kafkaTemplate.send(topic, jsonInString); log.info(&quot;Kafka Producer sent data from the Order microservice: &quot; + orderDto); return orderDto; &#125;&#125; @Data@Builderpublic class Scheme &#123; private String type; private List&lt;Field&gt; fields; private boolean optional; private String name;&#125; @Data@AllArgsConstructorpublic class Field &#123; private String type; private boolean optional; private String field;&#125; @Data@Builderpublic class Payload &#123; private String order_id; private String user_id; private String product_id; private int qty; private int unit_price; private int total_price;&#125; @Data@AllArgsConstructorpublic class KafkaOrderDto implements Serializable &#123; private Scheme scheme; private Payload payload;&#125; @Service@Slf4j@RequiredArgsConstructorpublic class OrderProducer &#123; private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; List&lt;Field&gt; fields = Arrays.asList( new Field(&quot;String&quot;, true, &quot;order_id&quot;) , new Field(&quot;String&quot;, true, &quot;user_id&quot;) , new Field(&quot;String&quot;, true, &quot;product_id&quot;) , new Field(&quot;int32&quot;, true, &quot;qty&quot;) , new Field(&quot;int32&quot;, true, &quot;unit_price&quot;) , new Field(&quot;int32&quot;, true, &quot;total_price&quot;) ); Scheme scheme = Scheme.builder() .type(&quot;struct&quot;) .fields(fields) .optional(false) .name(&quot;orders&quot;) .build(); public OrderDto send(String topic, OrderDto orderDto)&#123; Payload payload = Payload.builder() .order_id(orderDto.getOrderId()) .user_id(orderDto.getUserId()) .product_id(orderDto.getProductId()) .qty(orderDto.getQty()) .unit_price(orderDto.getUnitPrice()) .total_price(orderDto.getTotalPrice()) .build(); KafkaOrderDto kafkaOrderDto = new KafkaOrderDto(scheme, payload); ObjectMapper mapper = new ObjectMapper(); String jsonInString = &quot;&quot;; try&#123; jsonInString = mapper.writeValueAsString(orderDto); &#125;catch (JsonProcessingException ex)&#123; ex.printStackTrace(); &#125; kafkaTemplate.send(topic, jsonInString); log.info(&quot;Kafka Producer sent data from the Order microservice: &quot; + orderDto); return orderDto; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Kafka","slug":"Spring/Spring-Cloud/Kafka","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Kafka/"}],"tags":[]},{"title":"Spring Cloud - 32. kafka-mariadb 연결","slug":"spring/spring-cloud/kafka/spring-cloud-32","date":"2021-09-19T17:31:31.000Z","updated":"2024-02-26T15:34:21.872Z","comments":true,"path":"2021/09/20/spring/spring-cloud/kafka/spring-cloud-32/","link":"","permalink":"https://ckck803.github.io/2021/09/20/spring/spring-cloud/kafka/spring-cloud-32/","excerpt":"목차 Spring Cloud - 33. Order Kafka Producer Spring Cloud - 32. kafka-mariadb 연결 Spring Cloud - 31. Kafka Topic 적용 Config// https://mvnrepository.com/artifact/org.mariadb.jdbc/mariadb-java-clientimplementation &#x27;org.mariadb.jdbc:mariadb-java-client&#x27; create table users( id int auto_increment primary key, user_id varchar(20), pwd varchar(20), name varchar(20), created_at datetime default NOW()); Kafka Connect 설치curl -O http://packages.confluent.io/archive/5.5/confluent-community-5.5.2-2.12.tar.gz curl -O http://packages.confluent.io/archive/6.1/confluent-community-6.1.0.tar.gz tar xvf confluent-community-6.1.0.tar.gz","text":"목차 Spring Cloud - 33. Order Kafka Producer Spring Cloud - 32. kafka-mariadb 연결 Spring Cloud - 31. Kafka Topic 적용 Config// https://mvnrepository.com/artifact/org.mariadb.jdbc/mariadb-java-clientimplementation &#x27;org.mariadb.jdbc:mariadb-java-client&#x27; create table users( id int auto_increment primary key, user_id varchar(20), pwd varchar(20), name varchar(20), created_at datetime default NOW()); Kafka Connect 설치curl -O http://packages.confluent.io/archive/5.5/confluent-community-5.5.2-2.12.tar.gz curl -O http://packages.confluent.io/archive/6.1/confluent-community-6.1.0.tar.gz tar xvf confluent-community-6.1.0.tar.gz cd $KAFKA_CONNECT_HOME Kafka Connect 실행./bin/connect-distributed ./etc/kafka/connect-distributed.properties JDBC Connector 설치- https://docs.confluent.io/5.5.1/connect/kafka-connect-jdbc/index.html - confluentinc-kafka-connect-jdbc-10.0.1.zip etc/kafka/connect-distributed.properties 파일 마지막에 아래 plugin 정보 추가- plugin.path=[confluentinc-kafka-connect-jdbc-10.0.1 폴더] JdbcSourceConnector에서 MariaDB 사용하기 위해 mariadb 드라이버 복사./share/java/kafka/ 폴더에 mariadb-java-client-2.7.2.jar 파일 복사 echo &#x27;&#123; &quot;name&quot; : &quot;my-source-connect&quot;, &quot;config&quot; : &#123; &quot;connector.class&quot; : &quot;io.confluent.connect.jdbc.JdbcSourceConnector&quot;, &quot;connection.url&quot;:&quot;jdbc:mysql://localhost:3306/mydb&quot;, &quot;connection.user&quot;:&quot;root&quot;, &quot;connection.password&quot;:&quot;test1357&quot;, &quot;mode&quot;: &quot;incrementing&quot;, &quot;incrementing.column.name&quot; : &quot;id&quot;, &quot;table.whitelist&quot;:&quot;users&quot;, &quot;topic.prefix&quot; : &quot;my_topic_&quot;, &quot;tasks.max&quot; : &quot;1&quot; &#125;&#125;&#x27; | curl -X POST -d @- http://localhost:8083/connectors --header &quot;content-Type:application/json&quot; echo &#x27;&#123; &quot;name&quot; : &quot;my-sink-connect&quot;, &quot;config&quot; : &#123; &quot;connector.class&quot; : &quot;io.confluent.connect.jdbc.JdbcSinkConnector&quot;, &quot;connection.url&quot;:&quot;jdbc:mysql://localhost:3306/mydb&quot;, &quot;connection.user&quot;:&quot;root&quot;, &quot;connection.password&quot;:&quot;1234&quot;, &quot;auto.create&quot;:&quot;true&quot;, &quot;auto.evolve&quot;:&quot;true&quot;, &quot;delete.enabled&quot;:&quot;false&quot;, &quot;tasks.max&quot;:&quot;1&quot;, &quot;topics&quot;:&quot;my_topic_users&quot; &#125;&#125;&#x27;| curl -X POST -d @- http://localhost:8083/connectors --header &quot;content-Type:application/json&quot; ERROR WorkerSinkTask&#123;id=my-sink-connect-0&#125; Error converting message value in topic &#x27;my_topic_users&#x27; partition 0 at offset 37 and timestamp 1620840246979: Converting byte[] to Kafka Connect data failed due to serialization error: (org.apache.kafka.connect.runtime.WorkerSinkTask:547)org.apache.kafka.connect.errors.DataException: Converting byte[] to Kafka Connect data failed due to serialization error: at org.apache.kafka.connect.json.JsonConverter.toConnectData(JsonConverter.java:366) at org.apache.kafka.connect.storage.Converter.toConnectData(Converter.java:87) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertValue(WorkerSinkTask.java:545) at org.apache.kafka.connect.runtime.WorkerSinkTask.lambda$convertAndTransformRecord$1(WorkerSinkTask.java:501) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execAndRetry(RetryWithToleranceOperator.java:156) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execAndHandleError(RetryWithToleranceOperator.java:190) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execute(RetryWithToleranceOperator.java:132) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertAndTransformRecord(WorkerSinkTask.java:501) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertMessages(WorkerSinkTask.java:478) at org.apache.kafka.connect.runtime.WorkerSinkTask.poll(WorkerSinkTask.java:328) at org.apache.kafka.connect.runtime.WorkerSinkTask.iteration(WorkerSinkTask.java:232) at org.apache.kafka.connect.runtime.WorkerSinkTask.execute(WorkerSinkTask.java:201) at org.apache.kafka.connect.runtime.WorkerTask.doRun(WorkerTask.java:185) at org.apache.kafka.connect.runtime.WorkerTask.run(WorkerTask.java:234) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.lang.Thread.run(Thread.java:834)Caused by: org.apache.kafka.common.errors.SerializationException: com.fasterxml.jackson.core.io.JsonEOFException: Unexpected end-of-input: expected close marker for Object (start marker at [Source: (byte[])&quot;&#123;&quot;; line: 1, column: 1]) at [Source: (byte[])&quot;&#123;&quot;; line: 1, column: 2]Caused by: com.fasterxml.jackson.core.io.JsonEOFException: Unexpected end-of-input: expected close marker for Object (start marker at [Source: (byte[])&quot;&#123;&quot;; line: 1, column: 1]) at [Source: (byte[])&quot;&#123;&quot;; line: 1, column: 2] at com.fasterxml.jackson.core.base.ParserMinimalBase._reportInvalidEOF(ParserMinimalBase.java:664) at com.fasterxml.jackson.core.base.ParserBase._handleEOF(ParserBase.java:486) at com.fasterxml.jackson.core.base.ParserBase._eofAsNextChar(ParserBase.java:498) at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._skipWSOrEnd(UTF8StreamJsonParser.java:2961) at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextFieldName(UTF8StreamJsonParser.java:989) at com.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer.deserializeObject(JsonNodeDeserializer.java:249) at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:68) at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:15) at com.fasterxml.jackson.databind.ObjectMapper._readTreeAndClose(ObjectMapper.java:4270) at com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:2734) at org.apache.kafka.connect.json.JsonDeserializer.deserialize(JsonDeserializer.java:64) at org.apache.kafka.connect.json.JsonConverter.toConnectData(JsonConverter.java:364) at org.apache.kafka.connect.storage.Converter.toConnectData(Converter.java:87) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertValue(WorkerSinkTask.java:545) at org.apache.kafka.connect.runtime.WorkerSinkTask.lambda$convertAndTransformRecord$1(WorkerSinkTask.java:501) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execAndRetry(RetryWithToleranceOperator.java:156) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execAndHandleError(RetryWithToleranceOperator.java:190) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execute(RetryWithToleranceOperator.java:132) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertAndTransformRecord(WorkerSinkTask.java:501) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertMessages(WorkerSinkTask.java:478) at org.apache.kafka.connect.runtime.WorkerSinkTask.poll(WorkerSinkTask.java:328) at org.apache.kafka.connect.runtime.WorkerSinkTask.iteration(WorkerSinkTask.java:232) at org.apache.kafka.connect.runtime.WorkerSinkTask.execute(WorkerSinkTask.java:201) at org.apache.kafka.connect.runtime.WorkerTask.doRun(WorkerTask.java:185) at org.apache.kafka.connect.runtime.WorkerTask.run(WorkerTask.java:234) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.lang.Thread.run(Thread.java:834) [2021-05-13 02:24:07,986] ERROR WorkerSinkTask&#123;id=my-sink-connect-0&#125; Task threw an uncaught and unrecoverable exception. Task is being killed and will not recover until manually restarted (org.apache.kafka.connect.runtime.WorkerTask:187)org.apache.kafka.connect.errors.ConnectException: Tolerance exceeded in error handler at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execAndHandleError(RetryWithToleranceOperator.java:206) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execute(RetryWithToleranceOperator.java:132) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertAndTransformRecord(WorkerSinkTask.java:501) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertMessages(WorkerSinkTask.java:478) at org.apache.kafka.connect.runtime.WorkerSinkTask.poll(WorkerSinkTask.java:328) at org.apache.kafka.connect.runtime.WorkerSinkTask.iteration(WorkerSinkTask.java:232) at org.apache.kafka.connect.runtime.WorkerSinkTask.execute(WorkerSinkTask.java:201) at org.apache.kafka.connect.runtime.WorkerTask.doRun(WorkerTask.java:185) at org.apache.kafka.connect.runtime.WorkerTask.run(WorkerTask.java:234) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.lang.Thread.run(Thread.java:834)Caused by: org.apache.kafka.connect.errors.DataException: Converting byte[] to Kafka Connect data failed due to serialization error: at org.apache.kafka.connect.json.JsonConverter.toConnectData(JsonConverter.java:366) at org.apache.kafka.connect.storage.Converter.toConnectData(Converter.java:87) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertValue(WorkerSinkTask.java:545) at org.apache.kafka.connect.runtime.WorkerSinkTask.lambda$convertAndTransformRecord$1(WorkerSinkTask.java:501) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execAndRetry(RetryWithToleranceOperator.java:156) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execAndHandleError(RetryWithToleranceOperator.java:190) ... 13 moreCaused by: org.apache.kafka.common.errors.SerializationException: com.fasterxml.jackson.core.io.JsonEOFException: Unexpected end-of-input: expected close marker for Object (start marker at [Source: (byte[])&quot;&#123;&quot;; line: 1, column: 1]) at [Source: (byte[])&quot;&#123;&quot;; line: 1, column: 2]Caused by: com.fasterxml.jackson.core.io.JsonEOFException: Unexpected end-of-input: expected close marker for Object (start marker at [Source: (byte[])&quot;&#123;&quot;; line: 1, column: 1]) at [Source: (byte[])&quot;&#123;&quot;; line: 1, column: 2] at com.fasterxml.jackson.core.base.ParserMinimalBase._reportInvalidEOF(ParserMinimalBase.java:664) at com.fasterxml.jackson.core.base.ParserBase._handleEOF(ParserBase.java:486) at com.fasterxml.jackson.core.base.ParserBase._eofAsNextChar(ParserBase.java:498) at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._skipWSOrEnd(UTF8StreamJsonParser.java:2961) at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextFieldName(UTF8StreamJsonParser.java:989) at com.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer.deserializeObject(JsonNodeDeserializer.java:249) at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:68) at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:15) at com.fasterxml.jackson.databind.ObjectMapper._readTreeAndClose(ObjectMapper.java:4270) at com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:2734) at org.apache.kafka.connect.json.JsonDeserializer.deserialize(JsonDeserializer.java:64) at org.apache.kafka.connect.json.JsonConverter.toConnectData(JsonConverter.java:364) at org.apache.kafka.connect.storage.Converter.toConnectData(Converter.java:87) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertValue(WorkerSinkTask.java:545) at org.apache.kafka.connect.runtime.WorkerSinkTask.lambda$convertAndTransformRecord$1(WorkerSinkTask.java:501) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execAndRetry(RetryWithToleranceOperator.java:156) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execAndHandleError(RetryWithToleranceOperator.java:190) at org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator.execute(RetryWithToleranceOperator.java:132) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertAndTransformRecord(WorkerSinkTask.java:501) at org.apache.kafka.connect.runtime.WorkerSinkTask.convertMessages(WorkerSinkTask.java:478) at org.apache.kafka.connect.runtime.WorkerSinkTask.poll(WorkerSinkTask.java:328) at org.apache.kafka.connect.runtime.WorkerSinkTask.iteration(WorkerSinkTask.java:232) at org.apache.kafka.connect.runtime.WorkerSinkTask.execute(WorkerSinkTask.java:201) at org.apache.kafka.connect.runtime.WorkerTask.doRun(WorkerTask.java:185) at org.apache.kafka.connect.runtime.WorkerTask.run(WorkerTask.java:234) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.lang.Thread.run(Thread.java:834)","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Kafka","slug":"Spring/Spring-Cloud/Kafka","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Kafka/"}],"tags":[]},{"title":"Spring Cloud - 31. Kafka Topic 적용","slug":"spring/spring-cloud/kafka/spring-cloud-31","date":"2021-09-19T16:31:31.000Z","updated":"2024-02-26T15:34:11.213Z","comments":true,"path":"2021/09/20/spring/spring-cloud/kafka/spring-cloud-31/","link":"","permalink":"https://ckck803.github.io/2021/09/20/spring/spring-cloud/kafka/spring-cloud-31/","excerpt":"목차 Spring Cloud - 33. Order Kafka Producer Spring Cloud - 32. kafka-mariadb 연결 Spring Cloud - 31. Kafka Topic 적용 Catalog Service// https://mvnrepository.com/artifact/org.springframework.kafka/spring-kafkaimplementation &#x27;org.springframework.kafka:spring-kafka&#x27; @EnableKafka@Configurationpublic class KafkaConsumerConfig &#123; @Bean public ConsumerFactory&lt;String, String&gt; consumerFactory()&#123; Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;(); properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;127.0.0.1:9092&quot;); properties.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;consumerGroupId&quot;); properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return new DefaultKafkaConsumerFactory&lt;&gt;(properties); &#125; @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory()&#123; ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); kafkaListenerContainerFactory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); kafkaListenerContainerFactory.setConsumerFactory(consumerFactory()); return kafkaListenerContainerFactory; &#125;&#125; Order Service@Configurationpublic class KafkaProducerConfig &#123; @Bean public ProducerFactory&lt;String, String&gt; producerFactory()&#123; Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;(); configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;127.0.0.1:9092&quot;); configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); return new DefaultKafkaProducerFactory&lt;&gt;(configProps); &#125; @Bean public KafkaTemplate&lt;String, String&gt; kafkaTemplate()&#123; return new KafkaTemplate&lt;&gt;(producerFactory()); &#125;&#125; @Service@Slf4j@RequiredArgsConstructorpublic class KafkaProducer &#123; private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; public OrderDto send(String kafkaTopic, OrderDto orderDto)&#123; ObjectMapper mapper = new ObjectMapper(); String jsonInString = &quot;&quot;; try&#123; jsonInString = mapper.writeValueAsString(orderDto); &#125;catch (JsonProcessingException e)&#123; e.printStackTrace(); &#125; kafkaTemplate.send(kafkaTopic, jsonInString); log.info(&quot;Kafka Producer send data from the Order microservice: &quot; + orderDto); return orderDto; &#125;&#125;","text":"목차 Spring Cloud - 33. Order Kafka Producer Spring Cloud - 32. kafka-mariadb 연결 Spring Cloud - 31. Kafka Topic 적용 Catalog Service// https://mvnrepository.com/artifact/org.springframework.kafka/spring-kafkaimplementation &#x27;org.springframework.kafka:spring-kafka&#x27; @EnableKafka@Configurationpublic class KafkaConsumerConfig &#123; @Bean public ConsumerFactory&lt;String, String&gt; consumerFactory()&#123; Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;(); properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;127.0.0.1:9092&quot;); properties.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;consumerGroupId&quot;); properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return new DefaultKafkaConsumerFactory&lt;&gt;(properties); &#125; @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory()&#123; ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); kafkaListenerContainerFactory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); kafkaListenerContainerFactory.setConsumerFactory(consumerFactory()); return kafkaListenerContainerFactory; &#125;&#125; Order Service@Configurationpublic class KafkaProducerConfig &#123; @Bean public ProducerFactory&lt;String, String&gt; producerFactory()&#123; Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;(); configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;127.0.0.1:9092&quot;); configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); return new DefaultKafkaProducerFactory&lt;&gt;(configProps); &#125; @Bean public KafkaTemplate&lt;String, String&gt; kafkaTemplate()&#123; return new KafkaTemplate&lt;&gt;(producerFactory()); &#125;&#125; @Service@Slf4j@RequiredArgsConstructorpublic class KafkaProducer &#123; private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; public OrderDto send(String kafkaTopic, OrderDto orderDto)&#123; ObjectMapper mapper = new ObjectMapper(); String jsonInString = &quot;&quot;; try&#123; jsonInString = mapper.writeValueAsString(orderDto); &#125;catch (JsonProcessingException e)&#123; e.printStackTrace(); &#125; kafkaTemplate.send(kafkaTopic, jsonInString); log.info(&quot;Kafka Producer send data from the Order microservice: &quot; + orderDto); return orderDto; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Kafka","slug":"Spring/Spring-Cloud/Kafka","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Kafka/"}],"tags":[]},{"title":"Spring Cloud - 30. Micro Service간 통신 ErrorDecoder 구현","slug":"spring/spring-cloud/feign-client/spring-cloud-30","date":"2021-09-19T15:31:31.000Z","updated":"2024-02-26T15:33:00.331Z","comments":true,"path":"2021/09/20/spring/spring-cloud/feign-client/spring-cloud-30/","link":"","permalink":"https://ckck803.github.io/2021/09/20/spring/spring-cloud/feign-client/spring-cloud-30/","excerpt":"목차 Spring Cloud - 30. Micro Service간 통신 ErrorDecoder 구현 Spring Cloud - 29. Micro Service간 통신 Feign client 예외 처리 Spring Cloud - 28. Micro Service간 통신 Feign client Spring Cloud - 27. Micro Service간 통신 ErrorDecoder 구현public class FeignErrorDecoder implements ErrorDecoder &#123; @Override public Exception decode(String methodKey, Response response) &#123; switch (response.status()) &#123; case 400: break; case 404: if (methodKey.contains(&quot;getOrders&quot;)) &#123; return new ResponseStatusException(HttpStatus.valueOf(response.status()) , &quot;User&#x27;s orders is empty.&quot;); &#125; break; default: return new Exception(response.reason()); &#125; return null; &#125;&#125; @SpringBootApplication@EnableDiscoveryClient@EnableFeignClients@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125; @Bean public Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125; @Bean public FeignErrorDecoder getFeignErrorDecoder()&#123; return new FeignErrorDecoder(); &#125;&#125; token: expiration_time: 84600000 secret: user_token_native_application_changedgateway: ip: 192.168.123.106order_service: url: http://ORDER-SERVICE/order-service/%s/orders exception: orders_is_empty: User&#x27;s orders is empty. @Component@RequiredArgsConstructorpublic class FeignErrorDecoder implements ErrorDecoder &#123; private final Environment env; @Override public Exception decode(String methodKey, Response response) &#123; switch (response.status()) &#123; case 400: break; case 404: if (methodKey.contains(&quot;getOrders&quot;)) &#123; return new ResponseStatusException(HttpStatus.valueOf(response.status()) , env.getProperty(&quot;order_service.exception.orders_is_empty&quot;)); &#125; break; default: return new Exception(response.reason()); &#125; return null; &#125;&#125;","text":"목차 Spring Cloud - 30. Micro Service간 통신 ErrorDecoder 구현 Spring Cloud - 29. Micro Service간 통신 Feign client 예외 처리 Spring Cloud - 28. Micro Service간 통신 Feign client Spring Cloud - 27. Micro Service간 통신 ErrorDecoder 구현public class FeignErrorDecoder implements ErrorDecoder &#123; @Override public Exception decode(String methodKey, Response response) &#123; switch (response.status()) &#123; case 400: break; case 404: if (methodKey.contains(&quot;getOrders&quot;)) &#123; return new ResponseStatusException(HttpStatus.valueOf(response.status()) , &quot;User&#x27;s orders is empty.&quot;); &#125; break; default: return new Exception(response.reason()); &#125; return null; &#125;&#125; @SpringBootApplication@EnableDiscoveryClient@EnableFeignClients@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125; @Bean public Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125; @Bean public FeignErrorDecoder getFeignErrorDecoder()&#123; return new FeignErrorDecoder(); &#125;&#125; token: expiration_time: 84600000 secret: user_token_native_application_changedgateway: ip: 192.168.123.106order_service: url: http://ORDER-SERVICE/order-service/%s/orders exception: orders_is_empty: User&#x27;s orders is empty. @Component@RequiredArgsConstructorpublic class FeignErrorDecoder implements ErrorDecoder &#123; private final Environment env; @Override public Exception decode(String methodKey, Response response) &#123; switch (response.status()) &#123; case 400: break; case 404: if (methodKey.contains(&quot;getOrders&quot;)) &#123; return new ResponseStatusException(HttpStatus.valueOf(response.status()) , env.getProperty(&quot;order_service.exception.orders_is_empty&quot;)); &#125; break; default: return new Exception(response.reason()); &#125; return null; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Feign Client","slug":"Spring/Spring-Cloud/Feign-Client","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Feign-Client/"}],"tags":[]},{"title":"Spring boot - 파일 업로드 서비스 구현하기","slug":"spring/spring-resource/file-upload-3","date":"2021-09-19T14:39:59.000Z","updated":"2024-02-26T15:38:48.070Z","comments":true,"path":"2021/09/19/spring/spring-resource/file-upload-3/","link":"","permalink":"https://ckck803.github.io/2021/09/19/spring/spring-resource/file-upload-3/","excerpt":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 DTO 생성하기@Datapublic class Item &#123; private Long id; private String itemName; private UploadFile attachFile; // 여러개의 이미지 파일을 입력하기 위한 List private List&lt;UploadFile&gt; imageFiles;&#125; 파일을 업로드 할때 중복된 이름을 가진 파일이 있을 경우 해당 파일로 업데이트 되는 문제가 발생합니다. 이를 해결하기 위해 파일을 저장할때는 다름 이름으로 저장하고 원래 파일이름을 별도로 저장합니다. 저장된 파일이름과 매핑되는 원래 파일 이름을 가져올 수 있도록 UploadFile 객체를 생성합니다. @Datapublic class UploadFile &#123; private String uploadFileName; private String storeFileName; public UploadFile(String uploadFileName, String storeFileName) &#123; this.uploadFileName = uploadFileName; this.storeFileName = storeFileName; &#125;&#125; 파일 저장 - 서비스 구현파일에서 확장자 추출하기","text":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 DTO 생성하기@Datapublic class Item &#123; private Long id; private String itemName; private UploadFile attachFile; // 여러개의 이미지 파일을 입력하기 위한 List private List&lt;UploadFile&gt; imageFiles;&#125; 파일을 업로드 할때 중복된 이름을 가진 파일이 있을 경우 해당 파일로 업데이트 되는 문제가 발생합니다. 이를 해결하기 위해 파일을 저장할때는 다름 이름으로 저장하고 원래 파일이름을 별도로 저장합니다. 저장된 파일이름과 매핑되는 원래 파일 이름을 가져올 수 있도록 UploadFile 객체를 생성합니다. @Datapublic class UploadFile &#123; private String uploadFileName; private String storeFileName; public UploadFile(String uploadFileName, String storeFileName) &#123; this.uploadFileName = uploadFileName; this.storeFileName = storeFileName; &#125;&#125; 파일 저장 - 서비스 구현파일에서 확장자 추출하기String 객체에서 lastIndexOf 메소드를 이용해 확장자명이 시작되는 위치를 가져온 후 substring 메소드를 이용해 추출한다. private String extractExt(String originalFilename) &#123; int pos = originalFilename.lastIndexOf(&quot;.&quot;); return originalFilename.substring(pos + 1);&#125; UUID에 파일 확장자 추가전송된 파일명을 사용할 경우 중복이 일어날시 파일이 업데이트가 되는 문제가 발생하기 때문에 파일마다 고유한 이름 값을 가질 수 있도록 UUID 를 사용해 유니크한 값을 갖도록 변경한 후 extractExt 메소드를 통해 추출된 확장자를 붙여준다. private String createStoreFileName(String originalFilename) &#123; String ext = extractExt(originalFilename); String uuid = UUID.randomUUID().toString(); return uuid + &quot;.&quot; + ext;&#125; MultipartFile 객체를 이용한 파일 저장MultipartFile 객체를 이용해 파일을 저장하기 위해서는 다음과 같은 메소드를 사용합니다. getOriginalFilename() 파일 명을 가져오는 메소드 transferTo(File file) MultipartFile 내 데이터를 전달받은 File 객체에 저장한다. public UploadFile storeFile(MultipartFile multipartFile) throws IOException &#123; if (multipartFile.isEmpty()) &#123; return null; &#125; String originalFilename = multipartFile.getOriginalFilename(); String storeFileName = createStoreFileName(originalFilename); multipartFile.transferTo(new File(getFullPath(storeFileName))); return new UploadFile(originalFilename, storeFileName);&#125; 여러개 파일 저장하기여러개의 파일을 저장하기 위해서는 List 객체를 이용해 MultipartFile 객체들을 받아온 후 반복문을 통해 파일을 저장합니다. public List&lt;UploadFile&gt; storeFiles(List&lt;MultipartFile&gt; multipartFiles) throws IOException &#123; List&lt;UploadFile&gt; storeFileResult = new ArrayList&lt;&gt;(); for (MultipartFile multipartFile : multipartFiles) &#123; if (!multipartFile.isEmpty()) &#123; storeFileResult.add(storeFile(multipartFile)); &#125; &#125; return storeFileResult;&#125; 전체 소스 코드@Componentpublic class FileStore &#123; @Value(&quot;$&#123;file.dir&#125;&quot;) private String fileDir; public String getFullPath(String filename) &#123; return fileDir + filename; &#125; public List&lt;UploadFile&gt; storeFiles(List&lt;MultipartFile&gt; multipartFiles) throws IOException &#123; List&lt;UploadFile&gt; storeFileResult = new ArrayList&lt;&gt;(); for (MultipartFile multipartFile : multipartFiles) &#123; if (!multipartFile.isEmpty()) &#123; storeFileResult.add(storeFile(multipartFile)); &#125; &#125; return storeFileResult; &#125; public UploadFile storeFile(MultipartFile multipartFile) throws IOException &#123; if (multipartFile.isEmpty()) &#123; return null; &#125; String originalFilename = multipartFile.getOriginalFilename(); String storeFileName = createStoreFileName(originalFilename); multipartFile.transferTo(new File(getFullPath(storeFileName))); return new UploadFile(originalFilename, storeFileName); &#125; private String createStoreFileName(String originalFilename) &#123; String ext = extractExt(originalFilename); String uuid = UUID.randomUUID().toString(); return uuid + &quot;.&quot; + ext; &#125; private String extractExt(String originalFilename) &#123; int pos = originalFilename.lastIndexOf(&quot;.&quot;); return originalFilename.substring(pos + 1); &#125;&#125; Controller 구현DTO 생성@Datapublic class ItemForm &#123; private Long itemId; private String itemName; private MultipartFile attachFile; private List&lt;MultipartFile&gt; imageFiles;&#125; 파일 저장@PostMapping(&quot;/items/new&quot;)public String saveItem(@ModelAttribute ItemForm form, RedirectAttributes redirectAttributes) throws IOException &#123; UploadFile attachFile = fileStore.storeFile(form.getAttachFile()); // Request 객체에서 받아온 MultipartFile 객체들을 가져와 저장한다. List&lt;UploadFile&gt; storeImageFiles = fileStore.storeFiles(form.getImageFiles()); //데이터베이스에 저장 Item item = new Item(); item.setItemName(form.getItemName()); item.setAttachFile(attachFile); item.setImageFiles(storeImageFiles); itemRepository.save(item); redirectAttributes.addAttribute(&quot;itemId&quot;, item.getId()); return &quot;redirect:/items/&#123;itemId&#125;&quot;;&#125; 저장된 파일들 보여주기 위한 Controller@GetMapping(&quot;/items/&#123;id&#125;&quot;)public String items(@PathVariable Long id, Model model) &#123; Item item = itemRepository.findById(id); model.addAttribute(&quot;item&quot;, item); return &quot;item-view&quot;;&#125; UrlResource 를 통해 서버에 저장된 파일 보여주기@ResponseBody@GetMapping(&quot;/images/&#123;filename&#125;&quot;)public Resource downloadImage(@PathVariable String filename) throws MalformedURLException &#123; return new UrlResource(&quot;file:&quot; + fileStore.getFullPath(filename));&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"},{"name":"File","slug":"Spring/Spring-Resource/File","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/File/"}],"tags":[]},{"title":"Spring boot - MultipartFile 를 이용한 파일 업로드","slug":"spring/spring-resource/multipart","date":"2021-09-19T13:39:59.000Z","updated":"2024-02-26T15:39:20.087Z","comments":true,"path":"2021/09/19/spring/spring-resource/multipart/","link":"","permalink":"https://ckck803.github.io/2021/09/19/spring/spring-resource/multipart/","excerpt":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 MultipartFile 인터페이스 multipart&#x2F;form-data 요청을 처리하기 위해 만들어진 객체 Spring 에서는 멀티파트 요청을 처리 하기 위해 MultipartFile 객체를 제공합니다. public interface MultipartFile extends InputStreamSource &#123; // 전달 받은 Parameter Key값을 가져온다. String getName(); // 파일 명을 가져온다. @Nullable String getOriginalFilename(); // 파일의 ContentType을 가져온다. // pdf 파일의 경우 application/pdf, mp4 파일의 경우 video/mp4, png 파일의 경우 image/png @Nullable String getContentType(); // 전달 받은 Parameter Value값이 비어 있는지 확인한다. boolean isEmpty(); // 전달 받은 파일의 크기를 가져온다. // 파일은 byte 단위로 표시된다. long getSize(); byte[] getBytes() throws IOException; // 전달 받은 파일을 읽기 위한 InputStream을 가져온다. @Override InputStream getInputStream() throws IOException; // MultipartFile 객체를 이용해 Resource(MultipartFileResource) 객체를 반환 받는다. default Resource getResource() &#123; return new MultipartFileResource(this); &#125; // MultipartFile 내 데이터를 전달받은 File 객체에 저장한다. // 한번만 호출이 가능한 메소드다. void transferTo(File dest) throws IOException, IllegalStateException; // MultipartFile 내 데이터를 전달받은 Path 객체에 저장한다. default void transferTo(Path dest) throws IOException, IllegalStateException &#123; FileCopyUtils.copy(getInputStream(), Files.newOutputStream(dest)); &#125;&#125; 파일 업로드 구현파일 업로드를 위한 Controller 구현 multipart&#x2F;form-data 요청은 Form 형식으로 요청이 오기 때문에 RequestBody 어노테이션이 아니라 RequestParam 어노테이션을 이용해 데이터를 받는다.","text":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 MultipartFile 인터페이스 multipart&#x2F;form-data 요청을 처리하기 위해 만들어진 객체 Spring 에서는 멀티파트 요청을 처리 하기 위해 MultipartFile 객체를 제공합니다. public interface MultipartFile extends InputStreamSource &#123; // 전달 받은 Parameter Key값을 가져온다. String getName(); // 파일 명을 가져온다. @Nullable String getOriginalFilename(); // 파일의 ContentType을 가져온다. // pdf 파일의 경우 application/pdf, mp4 파일의 경우 video/mp4, png 파일의 경우 image/png @Nullable String getContentType(); // 전달 받은 Parameter Value값이 비어 있는지 확인한다. boolean isEmpty(); // 전달 받은 파일의 크기를 가져온다. // 파일은 byte 단위로 표시된다. long getSize(); byte[] getBytes() throws IOException; // 전달 받은 파일을 읽기 위한 InputStream을 가져온다. @Override InputStream getInputStream() throws IOException; // MultipartFile 객체를 이용해 Resource(MultipartFileResource) 객체를 반환 받는다. default Resource getResource() &#123; return new MultipartFileResource(this); &#125; // MultipartFile 내 데이터를 전달받은 File 객체에 저장한다. // 한번만 호출이 가능한 메소드다. void transferTo(File dest) throws IOException, IllegalStateException; // MultipartFile 내 데이터를 전달받은 Path 객체에 저장한다. default void transferTo(Path dest) throws IOException, IllegalStateException &#123; FileCopyUtils.copy(getInputStream(), Files.newOutputStream(dest)); &#125;&#125; 파일 업로드 구현파일 업로드를 위한 Controller 구현 multipart&#x2F;form-data 요청은 Form 형식으로 요청이 오기 때문에 RequestBody 어노테이션이 아니라 RequestParam 어노테이션을 이용해 데이터를 받는다. @RestController@Slf4jpublic class FileController &#123; String filePath = &quot;/Users/dongwoo-yang/spring-file/&quot;; @PostMapping(&quot;/file/upload&quot;) public ResponseEntity upload(@RequestParam(&quot;file&quot;) MultipartFile multipartFile, HttpServletRequest request) throws IOException, URISyntaxException &#123; if(multipartFile.isEmpty())&#123; log.info(&quot;File is empty&quot;); &#125; log.info(&quot;multipartFile.getName() : &#123;&#125;&quot;, multipartFile.getName()); log.info(&quot;multipartFile.getOriginalFilename() : &#123;&#125;&quot;, multipartFile.getOriginalFilename()); log.info(&quot;multipartFile.getContentType() : &#123;&#125;&quot;, multipartFile.getContentType()); log.info(&quot;multipartFile.getSize() : &#123;&#125;&quot;, multipartFile.getSize()); log.info(&quot;multipartFile.getResource() : &#123;&#125;&quot;, multipartFile.getResource()); String fullFilename = multipartFile.getOriginalFilename(); int lastIndex = fullFilename.lastIndexOf(&quot;.&quot;); String filename = fullFilename.substring(0, lastIndex); String ext = fullFilename.substring(lastIndex + 1); // 새로운 파일 이름 생성 String newName = UUID.randomUUID() + &quot;.&quot; + ext; String uploadPath = filePath + newName; // File 객체를 이용해 저장 // multipartFile.transferTo(new File(uploadPath)); // Path 객체를 이용해 저장 multipartFile.transferTo(Paths.get(uploadPath)); URI uri = new URI(request.getRequestURI()); return ResponseEntity.created(uri).body(&quot;File Upload Success&quot;); &#125;&#125; File Upload 테스트 코드 작성파일을 RestTemplate으로 전달할 때는 MultiValueMap 에 담아 전송한다. MultiValueMap 에 들어가는 데이터 형으로는 File 객체가 아니라 Resource 객체를 던져 줘야 mulipart&#x2F;form-data 형태로 전송이 된다. 이거 때문에 진짜 한참 찾아 다녔다. @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)class FileControllerTest &#123; @Autowired private TestRestTemplate testRestTemplate; @LocalServerPort int randomServerPort; @Test public void uploadTest() throws IOException &#123; ClassPathResource resource = new ClassPathResource(&quot;testFile.txt&quot;); File file = resource.getFile(); MultiValueMap multiValueMap = new LinkedMultiValueMap(); multiValueMap.add(&quot;file&quot;, resource); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; httpEntity = new HttpEntity(multiValueMap, headers); String requestURL = &quot;http://localhost:&quot; + randomServerPort + &quot;/file/upload&quot;; ResponseEntity&lt;String&gt; responseEntity = this.testRestTemplate.exchange(requestURL, HttpMethod.POST, httpEntity, new ParameterizedTypeReference&lt;String&gt;() &#123; &#125;); assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.CREATED); assertThat(responseEntity.getBody()).isEqualTo(&quot;File Upload Success&quot;); &#125;&#125; 이미지 파일 Upload PDF 파일 Upload Mp4 파일 upload","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"},{"name":"File","slug":"Spring/Spring-Resource/File","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/File/"}],"tags":[]},{"title":"Spring Cloud - 29. Micro Service간 통신 Feign client 예외 처리","slug":"spring/spring-cloud/feign-client/spring-cloud-29","date":"2021-09-19T00:31:31.000Z","updated":"2024-02-26T15:33:05.743Z","comments":true,"path":"2021/09/19/spring/spring-cloud/feign-client/spring-cloud-29/","link":"","permalink":"https://ckck803.github.io/2021/09/19/spring/spring-cloud/feign-client/spring-cloud-29/","excerpt":"목차 Spring Cloud - 30. Micro Service간 통신 ErrorDecoder 구현 Spring Cloud - 29. Micro Service간 통신 Feign client 예외 처리 Spring Cloud - 28. Micro Service간 통신 Feign client Spring Cloud - 27. Micro Service간 통신 User serviceserver: port: 0spring: application: name: user-service h2: console: enabled: true settings: web-allow-others: true datasource: username: sa password: driver-class-name: org.h2.Driver url: jdbc:h2:mem:testdb rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guesteureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekagreeting: message: Welcome to the Simple E-commerce.management: endpoints: web: exposure: include: refresh, health, beans, busrefreshlogging: level: com.example.userservice.client: DEBUG#token:# expiration_time: 84600000# secret: user_token @SpringBootApplication@EnableDiscoveryClient@EnableFeignClients@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125; @Bean public Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; @Overridepublic UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orderList = null; try &#123; orderList = orderServiceClient.getOrders(userId); &#125; catch (FeignException ex) &#123; log.error(ex.getMessage()); &#125; userDto.setOrders(orderList); return userDto;&#125;","text":"목차 Spring Cloud - 30. Micro Service간 통신 ErrorDecoder 구현 Spring Cloud - 29. Micro Service간 통신 Feign client 예외 처리 Spring Cloud - 28. Micro Service간 통신 Feign client Spring Cloud - 27. Micro Service간 통신 User serviceserver: port: 0spring: application: name: user-service h2: console: enabled: true settings: web-allow-others: true datasource: username: sa password: driver-class-name: org.h2.Driver url: jdbc:h2:mem:testdb rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guesteureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekagreeting: message: Welcome to the Simple E-commerce.management: endpoints: web: exposure: include: refresh, health, beans, busrefreshlogging: level: com.example.userservice.client: DEBUG#token:# expiration_time: 84600000# secret: user_token @SpringBootApplication@EnableDiscoveryClient@EnableFeignClients@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125; @Bean public Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; @Overridepublic UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orderList = null; try &#123; orderList = orderServiceClient.getOrders(userId); &#125; catch (FeignException ex) &#123; log.error(ex.getMessage()); &#125; userDto.setOrders(orderList); return userDto;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Feign Client","slug":"Spring/Spring-Cloud/Feign-Client","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Feign-Client/"}],"tags":[]},{"title":"Spring Cloud - 28. Micro Service간 통신 Feign client","slug":"spring/spring-cloud/feign-client/spring-cloud-28","date":"2021-09-18T23:31:31.000Z","updated":"2024-02-26T15:32:35.804Z","comments":true,"path":"2021/09/19/spring/spring-cloud/feign-client/spring-cloud-28/","link":"","permalink":"https://ckck803.github.io/2021/09/19/spring/spring-cloud/feign-client/spring-cloud-28/","excerpt":"목차 Spring Cloud - 30. Micro Service간 통신 ErrorDecoder 구현 Spring Cloud - 29. Micro Service간 통신 Feign client 예외 처리 Spring Cloud - 28. Micro Service간 통신 Feign client Spring Cloud - 27. Micro Service간 통신 User service// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeignimplementation &#x27;org.springframework.cloud:spring-cloud-starter-openfeign&#x27; @SpringBootApplication@EnableDiscoveryClient@EnableFeignClients@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; FeignClient의 name속성에 들어가는 값은 eureka 서버에 등록 돼 있는 Application 이름이다. @FeignClient(name = &quot;order-service&quot;)public interface OrderServiceClient &#123; @GetMapping(&quot;/order-service/&#123;userId&#125;/orders&quot;) List&lt;ResponseOrder&gt; getOrders(@PathVariable String userId);&#125; @Overridepublic UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orderList = orderServiceClient.getOrders(userId); userDto.setOrders(orderList); return userDto;&#125;","text":"목차 Spring Cloud - 30. Micro Service간 통신 ErrorDecoder 구현 Spring Cloud - 29. Micro Service간 통신 Feign client 예외 처리 Spring Cloud - 28. Micro Service간 통신 Feign client Spring Cloud - 27. Micro Service간 통신 User service// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeignimplementation &#x27;org.springframework.cloud:spring-cloud-starter-openfeign&#x27; @SpringBootApplication@EnableDiscoveryClient@EnableFeignClients@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; FeignClient의 name속성에 들어가는 값은 eureka 서버에 등록 돼 있는 Application 이름이다. @FeignClient(name = &quot;order-service&quot;)public interface OrderServiceClient &#123; @GetMapping(&quot;/order-service/&#123;userId&#125;/orders&quot;) List&lt;ResponseOrder&gt; getOrders(@PathVariable String userId);&#125; @Overridepublic UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orderList = orderServiceClient.getOrders(userId); userDto.setOrders(orderList); return userDto;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Feign Client","slug":"Spring/Spring-Cloud/Feign-Client","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Feign-Client/"}],"tags":[]},{"title":"Spring Cloud - 27. Micro Service간 통신","slug":"spring/spring-cloud/feign-client/spring-cloud-27","date":"2021-09-18T18:31:31.000Z","updated":"2024-02-26T15:32:20.478Z","comments":true,"path":"2021/09/19/spring/spring-cloud/feign-client/spring-cloud-27/","link":"","permalink":"https://ckck803.github.io/2021/09/19/spring/spring-cloud/feign-client/spring-cloud-27/","excerpt":"목차 Spring Cloud - 30. Micro Service간 통신 ErrorDecoder 구현 Spring Cloud - 29. Micro Service간 통신 Feign client 예외 처리 Spring Cloud - 28. Micro Service간 통신 Feign client Spring Cloud - 27. Micro Service간 통신 User Service@SpringBootApplication@EnableDiscoveryClient@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; @Overridepublic UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); // List&lt;ResponseOrder&gt; orders = new ArrayList&lt;&gt;(); // userDto.setOrders(orders); String orderUrl = String.format(env.getProperty(&quot;order_service.url&quot;), userId); ResponseEntity&lt;List&lt;ResponseOrder&gt;&gt; orderListResponse = restTemplate.exchange(orderUrl , HttpMethod.GET , null , new ParameterizedTypeReference&lt;List&lt;ResponseOrder&gt;&gt;() &#123;&#125;); List&lt;ResponseOrder&gt; orderList = orderListResponse.getBody(); userDto.setOrders(orderList); return userDto;&#125; application.ymltoken: expiration_time: 84600000 secret: user_token_native_application_changedgateway: ip: 192.168.123.106order_service: url: http://127.0.0.1:8080/order-service/%s/orders token: expiration_time: 84600000 secret: user_token_native_application_changedgateway: ip: 192.168.123.106order_service: url: http://ORDER-SERVICE/order-service/%s/orders @SpringBootApplication@EnableDiscoveryClient@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125;","text":"목차 Spring Cloud - 30. Micro Service간 통신 ErrorDecoder 구현 Spring Cloud - 29. Micro Service간 통신 Feign client 예외 처리 Spring Cloud - 28. Micro Service간 통신 Feign client Spring Cloud - 27. Micro Service간 통신 User Service@SpringBootApplication@EnableDiscoveryClient@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; @Overridepublic UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); // List&lt;ResponseOrder&gt; orders = new ArrayList&lt;&gt;(); // userDto.setOrders(orders); String orderUrl = String.format(env.getProperty(&quot;order_service.url&quot;), userId); ResponseEntity&lt;List&lt;ResponseOrder&gt;&gt; orderListResponse = restTemplate.exchange(orderUrl , HttpMethod.GET , null , new ParameterizedTypeReference&lt;List&lt;ResponseOrder&gt;&gt;() &#123;&#125;); List&lt;ResponseOrder&gt; orderList = orderListResponse.getBody(); userDto.setOrders(orderList); return userDto;&#125; application.ymltoken: expiration_time: 84600000 secret: user_token_native_application_changedgateway: ip: 192.168.123.106order_service: url: http://127.0.0.1:8080/order-service/%s/orders token: expiration_time: 84600000 secret: user_token_native_application_changedgateway: ip: 192.168.123.106order_service: url: http://ORDER-SERVICE/order-service/%s/orders @SpringBootApplication@EnableDiscoveryClient@Slf4jpublic class UserServiceApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(UserServiceApplication.class, args); &#125; @Bean public BCryptPasswordEncoder passwordEncoder() throws UnknownHostException &#123; return new BCryptPasswordEncoder(); &#125; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 26. Spring Cloud Bus","slug":"spring/spring-cloud/spring-cloud-26","date":"2021-09-18T17:31:31.000Z","updated":"2024-02-26T15:36:16.369Z","comments":true,"path":"2021/09/19/spring/spring-cloud/spring-cloud-26/","link":"","permalink":"https://ckck803.github.io/2021/09/19/spring/spring-cloud/spring-cloud-26/","excerpt":"Config Server// https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuatorimplementation &#x27;org.springframework.boot:spring-boot-starter-actuator&#x27; // https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-bus-amqpimplementation &#x27;org.springframework.cloud:spring-cloud-starter-bus-amqp&#x27; Users Microservice// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-bus-amqpimplementation &#x27;org.springframework.cloud:spring-cloud-starter-bus-amqp&#x27; Gateway Service// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-bus-amqpimplementation &#x27;org.springframework.cloud:spring-cloud-starter-bus-amqp&#x27; Config Serverserver: port: 8888spring: application: name: config-service profiles: active: native cloud: config: server: native: search-locations: file://$&#123;user.home&#125;/dev/study/Spring-Cloud/gateway/git-local-repository rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guestmanagement: endpoints: web: exposure: include: health, busrefresh#spring:# application:# name: config-service# cloud:# config:# server:# git:# uri: https://github.com/ckck803/spring-cloud-config## uri: file:///Users/dongwoo-yang/dev/study/Spring-Cloud/gateway/git-local-repository User Service","text":"Config Server// https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuatorimplementation &#x27;org.springframework.boot:spring-boot-starter-actuator&#x27; // https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-bus-amqpimplementation &#x27;org.springframework.cloud:spring-cloud-starter-bus-amqp&#x27; Users Microservice// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-bus-amqpimplementation &#x27;org.springframework.cloud:spring-cloud-starter-bus-amqp&#x27; Gateway Service// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-bus-amqpimplementation &#x27;org.springframework.cloud:spring-cloud-starter-bus-amqp&#x27; Config Serverserver: port: 8888spring: application: name: config-service profiles: active: native cloud: config: server: native: search-locations: file://$&#123;user.home&#125;/dev/study/Spring-Cloud/gateway/git-local-repository rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guestmanagement: endpoints: web: exposure: include: health, busrefresh#spring:# application:# name: config-service# cloud:# config:# server:# git:# uri: https://github.com/ckck803/spring-cloud-config## uri: file:///Users/dongwoo-yang/dev/study/Spring-Cloud/gateway/git-local-repository User Serviceserver: port: 0spring: application: name: user-service h2: console: enabled: true settings: web-allow-others: true datasource: username: sa password: driver-class-name: org.h2.Driver url: jdbc:h2:mem:testdb rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guesteureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekagreeting: message: Welcome to the Simple E-commerce.management: endpoints: web: exposure: include: refresh, health, beans, busrefresh#token:# expiration_time: 84600000# secret: user_token spring: cloud: config: uri: http://127.0.0.1:8888 name: config-server# profiles:# active: dev#spring:# cloud:# config:# uri: http://127.0.0.1:8888# name: ecommerce# profiles:# active: dev gateway serviceserver: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes: - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/login - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/users - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/** - Method=GET filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - AuthorizationHeaderFilter - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/actuator/** - Method=GET, POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: catalog-service uri: lb://CATALOG-SERVICE predicates: - Path=/catalog-service/** filters: - CustomFilter - id: order-service uri: lb://ORDER-SERVICE predicates: - Path=/order-service/** filters: - CustomFilter rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guesttoken: secret: user_tokenmanagement: endpoints: web: exposure: include: refresh, health, beans, httptrace, busrefresh spring: cloud: config: uri: http://127.0.0.1:8888 name: config-server# profiles:# active: dev#spring:# cloud:# config:# uri: http://127.0.0.1:8888# name: ecommerce# profiles:# active: dev","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 25. Spring Cloud Config Native","slug":"spring/spring-cloud/config/spring-cloud-25","date":"2021-09-18T16:31:31.000Z","updated":"2024-02-26T15:32:03.865Z","comments":true,"path":"2021/09/19/spring/spring-cloud/config/spring-cloud-25/","link":"","permalink":"https://ckck803.github.io/2021/09/19/spring/spring-cloud/config/spring-cloud-25/","excerpt":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor server: port: 8888spring: application: name: config-service profiles: active: native cloud: config: server: native: search-locations: file://$&#123;user.home&#125;/dev/study/Spring-Cloud/gateway/git-local-repository#spring:# application:# name: config-service# cloud:# config:# server:# git:# uri: https://github.com/ckck803/spring-cloud-config## uri: file:///Users/dongwoo-yang/dev/study/Spring-Cloud/gateway/git-local-repository","text":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor server: port: 8888spring: application: name: config-service profiles: active: native cloud: config: server: native: search-locations: file://$&#123;user.home&#125;/dev/study/Spring-Cloud/gateway/git-local-repository#spring:# application:# name: config-service# cloud:# config:# server:# git:# uri: https://github.com/ckck803/spring-cloud-config## uri: file:///Users/dongwoo-yang/dev/study/Spring-Cloud/gateway/git-local-repository","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Config","slug":"Spring/Spring-Cloud/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Config/"}],"tags":[]},{"title":"Spring Cloud - 24. Client Service 에서 Config Server 연동하기","slug":"spring/spring-cloud/config/spring-cloud-24","date":"2021-09-18T15:31:31.000Z","updated":"2024-02-26T15:31:56.139Z","comments":true,"path":"2021/09/19/spring/spring-cloud/config/spring-cloud-24/","link":"","permalink":"https://ckck803.github.io/2021/09/19/spring/spring-cloud/config/spring-cloud-24/","excerpt":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor Client Service 에서 Config Server 로부터 Config 파일 읽어오기// 외부 Config를 가져오기 위한 Dependency 설정implementation &#x27;org.springframework.cloud:spring-cloud-config-server&#x27;implementation &#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27; spring: cloud: config: uri: http://127.0.0.1:8888 name: ecommerce profiles: active: dev spring: cloud: config: uri: http://127.0.0.1:8888 name: ecommerce profiles: active: prod","text":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor Client Service 에서 Config Server 로부터 Config 파일 읽어오기// 외부 Config를 가져오기 위한 Dependency 설정implementation &#x27;org.springframework.cloud:spring-cloud-config-server&#x27;implementation &#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27; spring: cloud: config: uri: http://127.0.0.1:8888 name: ecommerce profiles: active: dev spring: cloud: config: uri: http://127.0.0.1:8888 name: ecommerce profiles: active: prod","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Config","slug":"Spring/Spring-Cloud/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Config/"}],"tags":[]},{"title":"Spring boot - 파일 업로드 2","slug":"spring/spring-resource/file-upload-2","date":"2021-09-18T14:39:59.000Z","updated":"2024-02-26T15:38:38.382Z","comments":true,"path":"2021/09/18/spring/spring-resource/file-upload-2/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-resource/file-upload-2/","excerpt":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 Spring boot 파일 업로드 2 getHeaderNames() part Type으로 전달된 데이터의 모든 해더 이름을 가져온다. getHeader(headerName) getHeader메소드에 헤더 이름을 넘겨주면 해더 이름이 갖는 요청의 모든 해더 정보를 가져온다. getSubmittedFileName() 파일 명을 가져오기 위한 메소드 getInputStream() Part에 저장된 데이터를 가져오기 위한 메소드 write(filepath) write 메소드에 파일이 저장될 File Path를 입력하면 해당 경로에 파일이 저장하는 메소드 Collection&lt;Part&gt; parts = request.getParts();log.info(&quot;parts=&#123;&#125;&quot;, parts);for (Part part : parts) &#123; log.info(&quot;==== PART ====&quot;); log.info(&quot;name=&#123;&#125;&quot;, part.getName()); Collection&lt;String&gt; headerNames = part.getHeaderNames(); for (String headerName : headerNames) &#123; log.info(&quot;header &#123;&#125;: &#123;&#125;&quot;, headerName, part.getHeader(headerName)); &#125; //편의 메서드 //content-disposition; filename log.info(&quot;submittedFilename=&#123;&#125;&quot;, part.getSubmittedFileName()); log.info(&quot;size=&#123;&#125;&quot;, part.getSize()); //part body size //데이터 읽기 InputStream inputStream = part.getInputStream(); String body = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;body=&#123;&#125;&quot;, body); //파일에 저장하기 if (StringUtils.hasText(part.getSubmittedFileName())) &#123; String fullPath = fileDir + part.getSubmittedFileName(); log.info(&quot;파일 저장 fullPath=&#123;&#125;&quot;, fullPath); part.write(fullPath); &#125;&#125; @Slf4j@Controller@RequestMapping(&quot;/servlet/v2&quot;)public class ServletUploadControllerV2 &#123; @Value(&quot;$&#123;file.dir&#125;&quot;) private String fileDir; @GetMapping(&quot;/upload&quot;) public String newFile() &#123; return &quot;upload-form&quot;; &#125; @PostMapping(&quot;/upload&quot;) public String saveFileV1(HttpServletRequest request) throws ServletException, IOException &#123; log.info(&quot;request=&#123;&#125;&quot;, request); String itemName = request.getParameter(&quot;itemName&quot;); log.info(&quot;itemName=&#123;&#125;&quot;, itemName); Collection&lt;Part&gt; parts = request.getParts(); log.info(&quot;parts=&#123;&#125;&quot;, parts); for (Part part : parts) &#123; log.info(&quot;==== PART ====&quot;); log.info(&quot;name=&#123;&#125;&quot;, part.getName()); Collection&lt;String&gt; headerNames = part.getHeaderNames(); for (String headerName : headerNames) &#123; log.info(&quot;header &#123;&#125;: &#123;&#125;&quot;, headerName, part.getHeader(headerName)); &#125; //편의 메서드 //content-disposition; filename log.info(&quot;submittedFilename=&#123;&#125;&quot;, part.getSubmittedFileName()); log.info(&quot;size=&#123;&#125;&quot;, part.getSize()); //part body size //데이터 읽기 InputStream inputStream = part.getInputStream(); String body = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;body=&#123;&#125;&quot;, body); //파일에 저장하기 if (StringUtils.hasText(part.getSubmittedFileName())) &#123; String fullPath = fileDir + part.getSubmittedFileName(); log.info(&quot;파일 저장 fullPath=&#123;&#125;&quot;, fullPath); part.write(fullPath); &#125; &#125; return &quot;upload-form&quot;; &#125;&#125;","text":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 Spring boot 파일 업로드 2 getHeaderNames() part Type으로 전달된 데이터의 모든 해더 이름을 가져온다. getHeader(headerName) getHeader메소드에 헤더 이름을 넘겨주면 해더 이름이 갖는 요청의 모든 해더 정보를 가져온다. getSubmittedFileName() 파일 명을 가져오기 위한 메소드 getInputStream() Part에 저장된 데이터를 가져오기 위한 메소드 write(filepath) write 메소드에 파일이 저장될 File Path를 입력하면 해당 경로에 파일이 저장하는 메소드 Collection&lt;Part&gt; parts = request.getParts();log.info(&quot;parts=&#123;&#125;&quot;, parts);for (Part part : parts) &#123; log.info(&quot;==== PART ====&quot;); log.info(&quot;name=&#123;&#125;&quot;, part.getName()); Collection&lt;String&gt; headerNames = part.getHeaderNames(); for (String headerName : headerNames) &#123; log.info(&quot;header &#123;&#125;: &#123;&#125;&quot;, headerName, part.getHeader(headerName)); &#125; //편의 메서드 //content-disposition; filename log.info(&quot;submittedFilename=&#123;&#125;&quot;, part.getSubmittedFileName()); log.info(&quot;size=&#123;&#125;&quot;, part.getSize()); //part body size //데이터 읽기 InputStream inputStream = part.getInputStream(); String body = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;body=&#123;&#125;&quot;, body); //파일에 저장하기 if (StringUtils.hasText(part.getSubmittedFileName())) &#123; String fullPath = fileDir + part.getSubmittedFileName(); log.info(&quot;파일 저장 fullPath=&#123;&#125;&quot;, fullPath); part.write(fullPath); &#125;&#125; @Slf4j@Controller@RequestMapping(&quot;/servlet/v2&quot;)public class ServletUploadControllerV2 &#123; @Value(&quot;$&#123;file.dir&#125;&quot;) private String fileDir; @GetMapping(&quot;/upload&quot;) public String newFile() &#123; return &quot;upload-form&quot;; &#125; @PostMapping(&quot;/upload&quot;) public String saveFileV1(HttpServletRequest request) throws ServletException, IOException &#123; log.info(&quot;request=&#123;&#125;&quot;, request); String itemName = request.getParameter(&quot;itemName&quot;); log.info(&quot;itemName=&#123;&#125;&quot;, itemName); Collection&lt;Part&gt; parts = request.getParts(); log.info(&quot;parts=&#123;&#125;&quot;, parts); for (Part part : parts) &#123; log.info(&quot;==== PART ====&quot;); log.info(&quot;name=&#123;&#125;&quot;, part.getName()); Collection&lt;String&gt; headerNames = part.getHeaderNames(); for (String headerName : headerNames) &#123; log.info(&quot;header &#123;&#125;: &#123;&#125;&quot;, headerName, part.getHeader(headerName)); &#125; //편의 메서드 //content-disposition; filename log.info(&quot;submittedFilename=&#123;&#125;&quot;, part.getSubmittedFileName()); log.info(&quot;size=&#123;&#125;&quot;, part.getSize()); //part body size //데이터 읽기 InputStream inputStream = part.getInputStream(); String body = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;body=&#123;&#125;&quot;, body); //파일에 저장하기 if (StringUtils.hasText(part.getSubmittedFileName())) &#123; String fullPath = fileDir + part.getSubmittedFileName(); log.info(&quot;파일 저장 fullPath=&#123;&#125;&quot;, fullPath); part.write(fullPath); &#125; &#125; return &quot;upload-form&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"},{"name":"File","slug":"Spring/Spring-Resource/File","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/File/"}],"tags":[]},{"title":"Spring Cloud - 23. Spring Cloud Config Server 만들기","slug":"spring/spring-cloud/config/spring-cloud-23","date":"2021-09-18T14:31:31.000Z","updated":"2024-02-26T15:31:47.256Z","comments":true,"path":"2021/09/18/spring/spring-cloud/config/spring-cloud-23/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/config/spring-cloud-23/","excerpt":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor Spring Cloud Config Server 의존성 추가// 외부 Config를 가져오기 위한 Dependency 설정implementation &#x27;org.springframework.cloud:spring-cloud-config-server&#x27;implementation &#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27; Config Server 만들기@EnableConfigServer 어노테이션을 추가하여 Config Server를 만들어 준다. @SpringBootApplication@EnableConfigServerpublic class ConfigServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServiceApplication.class, args); &#125;&#125; Config 파일 읽어오기Config 파일 위치에 따라서 Spring Cloud Config Server 에서 Config 파일을 읽어오는 방식이 달라진다.","text":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor Spring Cloud Config Server 의존성 추가// 외부 Config를 가져오기 위한 Dependency 설정implementation &#x27;org.springframework.cloud:spring-cloud-config-server&#x27;implementation &#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27; Config Server 만들기@EnableConfigServer 어노테이션을 추가하여 Config Server를 만들어 준다. @SpringBootApplication@EnableConfigServerpublic class ConfigServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServiceApplication.class, args); &#125;&#125; Config 파일 읽어오기Config 파일 위치에 따라서 Spring Cloud Config Server 에서 Config 파일을 읽어오는 방식이 달라진다. Local 에 저장된 Config 파일 읽어오기server: port:8888spring: application: name: config-service cloud: config: server: git: uri: file:///Users/dongwoo-yang/dev/study/Spring-Cloud/gateway/git-local-repository server: port: 8888spring: application: name: config-service profiles: active: native cloud: config: server: native: search-locations: file://$&#123;user.home&#125;/dev/study/Spring-Cloud/gateway/git-local-repository Git Repository 로 부터 Config 파일 읽어오기server: port: 8888spring: application: name: config-service cloud: config: server: git: uri: https://github.com/ckck803/spring-cloud-config Git Privagte Repository 로 부터 Config 파일 읽어오기 username, password 를 이용한 인증 spring: cloud: config: server: git: uri: https://github.com/spring-cloud-samples/config-repo username: trolley password: strongpassword ssh key 를 이용한 인증 spring: cloud: config: server: git: uri: git@gitserver.com:team/repo1.git ignoreLocalSshSettings: true hostKey: someHostKey # hostKey 가 없을 경우 사용할 필요가 없음 hostKeyAlgorithm: ssh-rsa # hostKey 가 없을 경우 사용할 필요가 없음 privateKey: | -----BEGIN RSA PRIVATE KEY----- MIIEpgIBAAKCAQEAx4UbaDzY5xjW6hc9jwN0mX33XpTDVW9WqHp5AKaRbtAC3DqX IXFMPgw3K45jxRb93f8tv9vL3rD9CUG1Gv4FM+o7ds7FRES5RTjv2RT/JVNJCoqF .... -----END RSA PRIVATE KEY-----","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Config","slug":"Spring/Spring-Cloud/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Config/"}],"tags":[]},{"title":"Spring boot - Part 객체를 이용한 파일 업로드","slug":"spring/spring-resource/part","date":"2021-09-18T13:39:59.000Z","updated":"2024-02-26T15:40:23.053Z","comments":true,"path":"2021/09/18/spring/spring-resource/part/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-resource/part/","excerpt":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 Spring boot 파일 업로드Form 태그에 enctype 옵션으로 multipart/form-data 를 명시하면 파일을 보낼 수 있다. &lt;form th:action method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;py-5 text-center&quot;&gt; &lt;h2&gt;상품 등록 폼&lt;/h2&gt; &lt;/div&gt; &lt;h4 class=&quot;mb-3&quot;&gt;상품 입력&lt;/h4&gt; &lt;form th:action method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;ul&gt; &lt;li&gt;상품명 &lt;input type=&quot;text&quot; name=&quot;itemName&quot;&gt;&lt;/li&gt; &lt;li&gt;파일&lt;input type=&quot;file&quot; name=&quot;file&quot; &gt;&lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt; Part 인터페이스Servlet 에서는 HTTP 멀티파트 요청을 처리하기 위해 Part 인터페이스를 제공합니다. getHeaderNames() part Type으로 전달된 데이터의 모든 해더 이름을 가져온다. getContentType() 파일의 ContentType을 가져온다. getHeader(headerName) getHeader메소드에 헤더 이름을 넘겨주면 해더 이름이 갖는 요청의 모든 해더 정보를 가져온다. getSubmittedFileName() 파일 명을 가져오기 위한 메소드 getInputStream() Part에 저장된 데이터를 가져오기 위한 메소드 write(filepath) write 메소드에 파일이 저장될 File Path를 입력하면 해당 경로에 파일이 저장하는 메소드","text":"목차 Spring boot - StreamingResponseBody Spring boot - ResourceRegion Spring boot - 파일 다운로드 서비스 구현하기 Spring boot - 파일 업로드 서비스 구현하기 Spring boot - Resource 추상화 Spring boot - MultipartFile 에서 발생하는 예외 처리 Spring boot - MultipartFile 를 이용한 파일 업로드 Spring boot - Part 객체를 이용한 파일 업로드 Spring boot 파일 업로드Form 태그에 enctype 옵션으로 multipart/form-data 를 명시하면 파일을 보낼 수 있다. &lt;form th:action method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;py-5 text-center&quot;&gt; &lt;h2&gt;상품 등록 폼&lt;/h2&gt; &lt;/div&gt; &lt;h4 class=&quot;mb-3&quot;&gt;상품 입력&lt;/h4&gt; &lt;form th:action method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;ul&gt; &lt;li&gt;상품명 &lt;input type=&quot;text&quot; name=&quot;itemName&quot;&gt;&lt;/li&gt; &lt;li&gt;파일&lt;input type=&quot;file&quot; name=&quot;file&quot; &gt;&lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt; Part 인터페이스Servlet 에서는 HTTP 멀티파트 요청을 처리하기 위해 Part 인터페이스를 제공합니다. getHeaderNames() part Type으로 전달된 데이터의 모든 해더 이름을 가져온다. getContentType() 파일의 ContentType을 가져온다. getHeader(headerName) getHeader메소드에 헤더 이름을 넘겨주면 해더 이름이 갖는 요청의 모든 해더 정보를 가져온다. getSubmittedFileName() 파일 명을 가져오기 위한 메소드 getInputStream() Part에 저장된 데이터를 가져오기 위한 메소드 write(filepath) write 메소드에 파일이 저장될 File Path를 입력하면 해당 경로에 파일이 저장하는 메소드 public interface Part &#123; InputStream getInputStream() throws IOException; String getContentType(); String getName(); String getSubmittedFileName(); long getSize(); void write(String var1) throws IOException; void delete() throws IOException; String getHeader(String var1); Collection&lt;String&gt; getHeaders(String var1); Collection&lt;String&gt; getHeaderNames();&#125; Request 객체내 파일 정보 가져오기HttpServletRequest 객체내 getParts 메소드를 통해 Part 객체들을 얻어올 수 있다. public String saveFileV1(HttpServletRequest request) throws ServletException, IOException&#123; ... Collection&lt;Part&gt; parts = request.getParts(); @Slf4j@Controller@RequestMapping(&quot;/servlet/v1&quot;)public class ServletUploadControllerV1 &#123; @GetMapping(&quot;upload&quot;) public String newFile()&#123; return &quot;upload-form&quot;; &#125; @PostMapping(&quot;upload&quot;) public String saveFileV1(HttpServletRequest request) throws ServletException, IOException&#123; log.info(&quot;request=&#123;&#125;&quot;, request); String itemName = request.getParameter(&quot;itemName&quot;); log.info(&quot;itemName=&#123;&#125;&quot;, itemName); Collection&lt;Part&gt; parts = request.getParts(); log.info(&quot;parts=&#123;&#125;&quot;, parts); return &quot;upload-form&quot;; &#125;&#125; Part 객체를 통해 파일 정보 가져오기Collection&lt;Part&gt; parts = request.getParts();log.info(&quot;parts=&#123;&#125;&quot;, parts);for (Part part : parts) &#123; log.info(&quot;==== PART ====&quot;); log.info(&quot;name=&#123;&#125;&quot;, part.getName()); Collection&lt;String&gt; headerNames = part.getHeaderNames(); for (String headerName : headerNames) &#123; log.info(&quot;header &#123;&#125;: &#123;&#125;&quot;, headerName, part.getHeader(headerName)); &#125; //편의 메서드 //content-disposition; filename log.info(&quot;submittedFilename=&#123;&#125;&quot;, part.getSubmittedFileName()); log.info(&quot;size=&#123;&#125;&quot;, part.getSize()); //part body size //데이터 읽기 InputStream inputStream = part.getInputStream(); String body = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;body=&#123;&#125;&quot;, body); //파일에 저장하기 if (StringUtils.hasText(part.getSubmittedFileName())) &#123; String fullPath = fileDir + part.getSubmittedFileName(); log.info(&quot;파일 저장 fullPath=&#123;&#125;&quot;, fullPath); part.write(fullPath); &#125;&#125; @Slf4j@Controller@RequestMapping(&quot;/servlet/v2&quot;)public class ServletUploadControllerV2 &#123; @Value(&quot;$&#123;file.dir&#125;&quot;) private String fileDir; @GetMapping(&quot;/upload&quot;) public String newFile() &#123; return &quot;upload-form&quot;; &#125; @PostMapping(&quot;/upload&quot;) public String saveFileV1(HttpServletRequest request) throws ServletException, IOException &#123; log.info(&quot;request=&#123;&#125;&quot;, request); String itemName = request.getParameter(&quot;itemName&quot;); log.info(&quot;itemName=&#123;&#125;&quot;, itemName); Collection&lt;Part&gt; parts = request.getParts(); log.info(&quot;parts=&#123;&#125;&quot;, parts); for (Part part : parts) &#123; log.info(&quot;==== PART ====&quot;); log.info(&quot;name=&#123;&#125;&quot;, part.getName()); Collection&lt;String&gt; headerNames = part.getHeaderNames(); for (String headerName : headerNames) &#123; log.info(&quot;header &#123;&#125;: &#123;&#125;&quot;, headerName, part.getHeader(headerName)); &#125; //편의 메서드 //content-disposition; filename log.info(&quot;submittedFilename=&#123;&#125;&quot;, part.getSubmittedFileName()); log.info(&quot;size=&#123;&#125;&quot;, part.getSize()); //part body size //데이터 읽기 InputStream inputStream = part.getInputStream(); String body = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;body=&#123;&#125;&quot;, body); //파일에 저장하기 if (StringUtils.hasText(part.getSubmittedFileName())) &#123; String fullPath = fileDir + part.getSubmittedFileName(); log.info(&quot;파일 저장 fullPath=&#123;&#125;&quot;, fullPath); part.write(fullPath); &#125; &#125; return &quot;upload-form&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"},{"name":"File","slug":"Spring/Spring-Resource/File","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/File/"}],"tags":[]},{"title":"Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2","slug":"spring/spring-cloud/config/spring-cloud-22","date":"2021-09-18T13:31:31.000Z","updated":"2024-02-26T15:31:41.219Z","comments":true,"path":"2021/09/18/spring/spring-cloud/config/spring-cloud-22/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/config/spring-cloud-22/","excerpt":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor Spring Cloud로 개발하는 마이크로서비스 애플리케이션 22 - Spring Cloud Config 연동 Actuator 2// 외부 Config를 가져오기 위한 Dependency 설정implementation &#x27;org.springframework.cloud:spring-cloud-starter-config&#x27;implementation &#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27;// https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuatorimplementation &#x27;org.springframework.boot:spring-boot-starter-actuator&#x27; spring: cloud: config: uri: http://127.0.0.1:8888 name: ecommerce @SpringBootApplicationpublic class ApigatewayServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ApigatewayServiceApplication.class, args); &#125; @Bean public HttpTraceRepository httpTraceRepository()&#123; return new InMemoryHttpTraceRepository(); &#125;&#125; server: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes:# - id: user-service# uri: lb://USER-SERVICE# predicates:# - Path=/user-service/**# filters:# - CustomFilter - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/login - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/users - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/** - Method=GET filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - AuthorizationHeaderFilter - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/actuator/** - Method=GET, POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: catalog-service uri: lb://CATALOG-SERVICE predicates: - Path=/catalog-service/** filters: - CustomFilter - id: order-service uri: lb://ORDER-SERVICE predicates: - Path=/order-service/** filters: - CustomFiltertoken: secret: user_tokenmanagement: endpoints: web: exposure: include: refresh, health, beans, httptrace","text":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor Spring Cloud로 개발하는 마이크로서비스 애플리케이션 22 - Spring Cloud Config 연동 Actuator 2// 외부 Config를 가져오기 위한 Dependency 설정implementation &#x27;org.springframework.cloud:spring-cloud-starter-config&#x27;implementation &#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27;// https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuatorimplementation &#x27;org.springframework.boot:spring-boot-starter-actuator&#x27; spring: cloud: config: uri: http://127.0.0.1:8888 name: ecommerce @SpringBootApplicationpublic class ApigatewayServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ApigatewayServiceApplication.class, args); &#125; @Bean public HttpTraceRepository httpTraceRepository()&#123; return new InMemoryHttpTraceRepository(); &#125;&#125; server: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes:# - id: user-service# uri: lb://USER-SERVICE# predicates:# - Path=/user-service/**# filters:# - CustomFilter - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/login - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/users - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/** - Method=GET filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - AuthorizationHeaderFilter - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/actuator/** - Method=GET, POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: catalog-service uri: lb://CATALOG-SERVICE predicates: - Path=/catalog-service/** filters: - CustomFilter - id: order-service uri: lb://ORDER-SERVICE predicates: - Path=/order-service/** filters: - CustomFiltertoken: secret: user_tokenmanagement: endpoints: web: exposure: include: refresh, health, beans, httptrace","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Config","slug":"Spring/Spring-Cloud/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Config/"}],"tags":[]},{"title":"Spring Cloud - 21. Spring Cloud Config 연동 Actuactor","slug":"spring/spring-cloud/config/spring-cloud-21","date":"2021-09-18T12:31:31.000Z","updated":"2024-02-26T15:31:16.190Z","comments":true,"path":"2021/09/18/spring/spring-cloud/config/spring-cloud-21/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/config/spring-cloud-21/","excerpt":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor 참고 https://www.baeldung.com/spring-cloud-config-without-git https://mangkyu.tistory.com/253 Spring Cloud Config ServerSpring Cloud Config Server 의존성 추가// 외부 Config를 가져오기 위한 Dependency 설정implementation &#x27;org.springframework.cloud:spring-cloud-config-server&#x27;implementation &#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27; /&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties @EnableConfigServer 어노테이션을 추가하여 Config Server를 만들어 준다.","text":"목차 Spring Cloud - 25. Spring Cloud Config Native Spring Cloud - 24. Client Service 에서 Config Server 연동하기 Spring Cloud - 23. Spring Cloud Config Server 만들기 Spring Cloud - 22. Spring Cloud Config 연동 Actuator 2 Spring Cloud - 21. Spring Cloud Config 연동 Actuactor 참고 https://www.baeldung.com/spring-cloud-config-without-git https://mangkyu.tistory.com/253 Spring Cloud Config ServerSpring Cloud Config Server 의존성 추가// 외부 Config를 가져오기 위한 Dependency 설정implementation &#x27;org.springframework.cloud:spring-cloud-config-server&#x27;implementation &#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27; /&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties @EnableConfigServer 어노테이션을 추가하여 Config Server를 만들어 준다. @SpringBootApplication@EnableConfigServerpublic class ConfigServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServiceApplication.class, args); &#125;&#125; server: port: 8888spring: application: name: config-service cloud: config: server: git: uri: file:///Users/dongwoo-yang/dev/study/Spring-Cloud/gateway/git-local-repository default-label: master spring: cloud: config: uri: http://127.0.0.1:8888 name: ecommerce @RestControllerpublic class UserController &#123; private Environment env; private UserService userService; private Greeting greeting; public UserController(Environment env, UserService userService) &#123; this.env = env; this.userService = userService; &#125; @GetMapping(&quot;/health_check&quot;) public String status() &#123; return String.format(&quot;It&#x27;s Working in User Service&quot; + &quot;, Port(local.server.port) = &quot; + env.getProperty(&quot;local.server.port&quot;) + &quot;\\n&quot; + &quot;, Port(server.port) = &quot; + env.getProperty(&quot;server.port&quot;) + &quot;\\n&quot; + &quot;, token secret = &quot; + env.getProperty(&quot;token.secret&quot;) + &quot;\\n&quot; + &quot;, token expiration time = &quot; + env.getProperty(&quot;token.expiration_time&quot;)); &#125; @GetMapping(&quot;/welcome&quot;) public String welcome() &#123; return env.getProperty(&quot;greeting.message&quot;); &#125; @GetMapping(&quot;/welcome_value&quot;) public String welcomeValue() &#123; return greeting.getMessage(); &#125; @PostMapping(&quot;/users&quot;) public ResponseEntity createUser(@RequestBody RequestUser user) &#123; ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); UserDto userDto = modelMapper.map(user, UserDto.class); userService.createUser(userDto); ResponseUser responseUser = modelMapper.map(userDto, ResponseUser.class); return ResponseEntity.status(HttpStatus.CREATED).body(responseUser); &#125; @GetMapping(&quot;/users&quot;) public ResponseEntity&lt;List&lt;ResponseUser&gt;&gt; getUsers() &#123; Iterable&lt;UserEntity&gt; userList = userService.getUserByAll(); List&lt;ResponseUser&gt; result = new ArrayList&lt;&gt;(); userList.forEach(v -&gt; &#123; result.add(new ModelMapper().map(v, ResponseUser.class)); &#125;); return ResponseEntity.status(HttpStatus.OK).body(result); &#125; @GetMapping(&quot;/users/&#123;userId&#125;&quot;) public ResponseEntity&lt;ResponseUser&gt; getUsers(@PathVariable(&quot;userId&quot;) String userId) &#123; UserDto userDto = userService.getUserByUserId(userId); ResponseUser returnValue = new ModelMapper().map(userDto, ResponseUser.class); return ResponseEntity.status(HttpStatus.OK).body(returnValue); &#125;&#125; Spring Cloud Config Client// https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuatorimplementation &#x27;org.springframework.boot:spring-boot-starter-actuator&#x27; server: port: 0spring: application: name: user-service h2: console: enabled: true settings: web-allow-others: true datasource: username: sa password: driver-class-name: org.h2.Driver url: jdbc:h2:mem:testdbeureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekagreeting: message: Welcome to the Simple E-commerce.management: endpoints: web: exposure: include: refresh, health, beans#token:# expiration_time: 84600000# secret: user_token","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Config","slug":"Spring/Spring-Cloud/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Config/"}],"tags":[]},{"title":"Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가","slug":"spring/spring-cloud/spring-cloud-20","date":"2021-09-18T11:31:31.000Z","updated":"2024-02-26T15:36:10.833Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-20/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-20/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice AuthorizationHeaderFilter 추가@Component@Slf4jpublic class AuthorizationHeaderFilter extends AbstractGatewayFilterFactory&lt;AuthorizationHeaderFilter.Config&gt; &#123; private Environment env; public AuthorizationHeaderFilter(Environment env)&#123; super(Config.class); this.env = env; &#125; // login -&gt; token -&gt; users (with token) -&gt; header(include token) @Override public GatewayFilter apply(Config config) &#123; return ((exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); if(!request.getHeaders().containsKey(HttpHeaders.AUTHORIZATION))&#123; return onError(exchange, &quot;No Authorization Header&quot;, HttpStatus.UNAUTHORIZED); &#125; String authorizationHeader = request.getHeaders().get(HttpHeaders.AUTHORIZATION).get(0); String jwt = authorizationHeader.replace(&quot;Bearer &quot;, &quot;&quot;); if(!isJwtValid(jwt))&#123; return onError(exchange, &quot;JWT token is not valid&quot;, HttpStatus.UNAUTHORIZED); &#125; return chain.filter(exchange); &#125;); &#125; private boolean isJwtValid(String jwt)&#123; boolean returnValue = true; String subject = null; String key = env.getProperty(&quot;token.secret&quot;); try &#123; subject = Jwts.parser() .setSigningKey(env.getProperty(&quot;token.secret&quot;)) .parseClaimsJws(jwt).getBody() .getSubject(); &#125; catch (Exception ex)&#123; returnValue = false; &#125; if(subject == null || subject.isEmpty())&#123; returnValue = false; &#125; return returnValue; &#125; private Mono&lt;Void&gt; onError(ServerWebExchange exchange, String error, HttpStatus httpStatus) &#123; ServerHttpResponse response = exchange.getResponse(); response.setStatusCode(httpStatus); log.error(error); return response.setComplete(); &#125; public static class Config&#123; &#125;&#125; // https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api implementation group: &#x27;javax.xml.bind&#x27;, name: &#x27;jaxb-api&#x27;, version: &#x27;2.3.1&#x27; server: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes:# - id: user-service# uri: lb://USER-SERVICE# predicates:# - Path=/user-service/**# filters:# - CustomFilter - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/login - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/users - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/** - Method=GET filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - AuthorizationHeaderFilter - id: catalog-service uri: lb://CATALOG-SERVICE predicates: - Path=/catalog-service/** filters: - CustomFilter - id: order-service uri: lb://ORDER-SERVICE predicates: - Path=/order-service/** filters: - CustomFiltertoken: secret: user_token","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice AuthorizationHeaderFilter 추가@Component@Slf4jpublic class AuthorizationHeaderFilter extends AbstractGatewayFilterFactory&lt;AuthorizationHeaderFilter.Config&gt; &#123; private Environment env; public AuthorizationHeaderFilter(Environment env)&#123; super(Config.class); this.env = env; &#125; // login -&gt; token -&gt; users (with token) -&gt; header(include token) @Override public GatewayFilter apply(Config config) &#123; return ((exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); if(!request.getHeaders().containsKey(HttpHeaders.AUTHORIZATION))&#123; return onError(exchange, &quot;No Authorization Header&quot;, HttpStatus.UNAUTHORIZED); &#125; String authorizationHeader = request.getHeaders().get(HttpHeaders.AUTHORIZATION).get(0); String jwt = authorizationHeader.replace(&quot;Bearer &quot;, &quot;&quot;); if(!isJwtValid(jwt))&#123; return onError(exchange, &quot;JWT token is not valid&quot;, HttpStatus.UNAUTHORIZED); &#125; return chain.filter(exchange); &#125;); &#125; private boolean isJwtValid(String jwt)&#123; boolean returnValue = true; String subject = null; String key = env.getProperty(&quot;token.secret&quot;); try &#123; subject = Jwts.parser() .setSigningKey(env.getProperty(&quot;token.secret&quot;)) .parseClaimsJws(jwt).getBody() .getSubject(); &#125; catch (Exception ex)&#123; returnValue = false; &#125; if(subject == null || subject.isEmpty())&#123; returnValue = false; &#125; return returnValue; &#125; private Mono&lt;Void&gt; onError(ServerWebExchange exchange, String error, HttpStatus httpStatus) &#123; ServerHttpResponse response = exchange.getResponse(); response.setStatusCode(httpStatus); log.error(error); return response.setComplete(); &#125; public static class Config&#123; &#125;&#125; // https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api implementation group: &#x27;javax.xml.bind&#x27;, name: &#x27;jaxb-api&#x27;, version: &#x27;2.3.1&#x27; server: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes:# - id: user-service# uri: lb://USER-SERVICE# predicates:# - Path=/user-service/**# filters:# - CustomFilter - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/login - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/users - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/** - Method=GET filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - AuthorizationHeaderFilter - id: catalog-service uri: lb://CATALOG-SERVICE predicates: - Path=/catalog-service/** filters: - CustomFilter - id: order-service uri: lb://ORDER-SERVICE predicates: - Path=/order-service/** filters: - CustomFiltertoken: secret: user_token","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 19. Users Microservice JWT 생성","slug":"spring/spring-cloud/spring-cloud-19","date":"2021-09-18T10:31:31.000Z","updated":"2024-02-26T15:36:07.096Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-19/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-19/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice JWT 생성// https://mvnrepository.com/artifact/io.jsonwebtoken/jjwtimplementation group: &#x27;io.jsonwebtoken&#x27;, name: &#x27;jjwt&#x27;, version: &#x27;0.9.1&#x27; @Slf4jpublic class AuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123; private UserService userService; private Environment env; public AuthenticationFilter(AuthenticationManager authenticationManager, UserService userService, Environment env)&#123; super.setAuthenticationManager( authenticationManager); this.userService = userService; this.env = env; &#125; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; try &#123; RequestLogin creds = new ObjectMapper().readValue(request.getInputStream(), RequestLogin.class); Authentication token = new UsernamePasswordAuthenticationToken(creds.getEmail(), creds.getPassword(), new ArrayList&lt;&gt;()); return getAuthenticationManager().authenticate(token); &#125; catch (IOException e)&#123; throw new RuntimeException(e); &#125; &#125; @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; String username = ((User)authResult.getPrincipal()).getUsername(); UserDto userDetails = userService.getUserDetailsByEmail(username); String token = Jwts.builder() .setSubject(userDetails.getUserId()) .setExpiration(new Date(System.currentTimeMillis() + Long.parseLong(env.getProperty(&quot;token.expiration_time&quot;)))) .signWith(SignatureAlgorithm.HS512, env.getProperty(&quot;token.secret&quot;)) .compact(); response.addHeader(&quot;token&quot;, token); response.addHeader(&quot;userId&quot;, userDetails.getUserId()); &#125;&#125;","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice JWT 생성// https://mvnrepository.com/artifact/io.jsonwebtoken/jjwtimplementation group: &#x27;io.jsonwebtoken&#x27;, name: &#x27;jjwt&#x27;, version: &#x27;0.9.1&#x27; @Slf4jpublic class AuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123; private UserService userService; private Environment env; public AuthenticationFilter(AuthenticationManager authenticationManager, UserService userService, Environment env)&#123; super.setAuthenticationManager( authenticationManager); this.userService = userService; this.env = env; &#125; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; try &#123; RequestLogin creds = new ObjectMapper().readValue(request.getInputStream(), RequestLogin.class); Authentication token = new UsernamePasswordAuthenticationToken(creds.getEmail(), creds.getPassword(), new ArrayList&lt;&gt;()); return getAuthenticationManager().authenticate(token); &#125; catch (IOException e)&#123; throw new RuntimeException(e); &#125; &#125; @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; String username = ((User)authResult.getPrincipal()).getUsername(); UserDto userDetails = userService.getUserDetailsByEmail(username); String token = Jwts.builder() .setSubject(userDetails.getUserId()) .setExpiration(new Date(System.currentTimeMillis() + Long.parseLong(env.getProperty(&quot;token.expiration_time&quot;)))) .signWith(SignatureAlgorithm.HS512, env.getProperty(&quot;token.secret&quot;)) .compact(); response.addHeader(&quot;token&quot;, token); response.addHeader(&quot;userId&quot;, userDetails.getUserId()); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 18. Users Microservice 로그인 성공 처리","slug":"spring/spring-cloud/spring-cloud-18","date":"2021-09-18T09:31:31.000Z","updated":"2024-02-26T15:36:03.107Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-18/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-18/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice 로그인 성공 처리@Slf4jpublic class AuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123; private UserService userService; private Environment env; public AuthenticationFilter(AuthenticationManager authenticationManager, UserService userService, Environment env)&#123; super(authenticationManager); this.userService = userService; this.env = env; &#125; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; try &#123; RequestLogin creds = new ObjectMapper().readValue(request.getInputStream(), RequestLogin.class); Authentication token = new UsernamePasswordAuthenticationToken(creds.getEmail(), creds.getPassword(), new ArrayList&lt;&gt;()); return getAuthenticationManager().authenticate(token); &#125; catch (IOException e)&#123; throw new RuntimeException(e); &#125; &#125; @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; String username = ((User)authResult.getPrincipal()).getUsername(); UserDto userDetails = userService.getUserDetailsByEmail(username); &#125;&#125; @Configuration@EnableWebSecuritypublic class WebSecurity extends WebSecurityConfigurerAdapter &#123; private Environment env; private UserService userService; private BCryptPasswordEncoder bCryptPasswordEncoder; public WebSecurity(Environment evn, UserService userService, BCryptPasswordEncoder bCryptPasswordEncoder)&#123; this.env = env; this.userService = userService; this.bCryptPasswordEncoder = bCryptPasswordEncoder; &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService).passwordEncoder(bCryptPasswordEncoder); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable(); http.authorizeRequests().antMatchers(&quot;/users/**&quot;) .hasIpAddress(&quot;192.168.0.2&quot;) .and() .addFilter(getAuthenticationFilter()); http.headers().frameOptions().disable(); &#125; private AuthenticationFilter getAuthenticationFilter() throws Exception&#123; AuthenticationFilter authenticationFilter = new AuthenticationFilter(authenticationManager(), userService, env); return authenticationFilter; &#125;&#125; public interface UserService extends UserDetailsService &#123; UserDto createUser(UserDto userDto); UserDto getUserByUserId(String userId); Iterable&lt;UserEntity&gt; getUserByAll(); UserDto getUserDetailsByEmail(String username);&#125; @Servicepublic class UserServiceImpl implements UserService &#123; UserRepository userRepository; BCryptPasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserEntity userEntity = userRepository.findByEmail(username); if (userEntity == null) &#123; throw new UsernameNotFoundException(username); &#125; return new User(userEntity.getEmail() , userEntity.getEncryptedPwd() , true , true , true , true , new ArrayList&lt;&gt;()); &#125; public UserServiceImpl(UserRepository userRepository, BCryptPasswordEncoder passwordEncoder) &#123; this.userRepository = userRepository; this.passwordEncoder = passwordEncoder; &#125; @Override public UserDto createUser(UserDto userDto) &#123; userDto.setUserId(UUID.randomUUID().toString()); ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); UserEntity userEntity = modelMapper.map(userDto, UserEntity.class); userEntity.setEncryptedPwd(passwordEncoder.encode(userDto.getPwd())); userRepository.save(userEntity); UserDto returnUserDto = modelMapper.map(userEntity, UserDto.class); return returnUserDto; &#125; @Override public UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orders = new ArrayList&lt;&gt;(); userDto.setOrders(orders); return userDto; &#125; @Override public Iterable&lt;UserEntity&gt; getUserByAll() &#123; return userRepository.findAll(); &#125; @Override public UserDto getUserDetailsByEmail(String email) &#123; UserEntity userEntity = userRepository.findByEmail(email); if(userEntity == null)&#123; throw new UsernameNotFoundException(email); &#125; UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); return userDto; &#125;&#125;","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice 로그인 성공 처리@Slf4jpublic class AuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123; private UserService userService; private Environment env; public AuthenticationFilter(AuthenticationManager authenticationManager, UserService userService, Environment env)&#123; super(authenticationManager); this.userService = userService; this.env = env; &#125; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; try &#123; RequestLogin creds = new ObjectMapper().readValue(request.getInputStream(), RequestLogin.class); Authentication token = new UsernamePasswordAuthenticationToken(creds.getEmail(), creds.getPassword(), new ArrayList&lt;&gt;()); return getAuthenticationManager().authenticate(token); &#125; catch (IOException e)&#123; throw new RuntimeException(e); &#125; &#125; @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; String username = ((User)authResult.getPrincipal()).getUsername(); UserDto userDetails = userService.getUserDetailsByEmail(username); &#125;&#125; @Configuration@EnableWebSecuritypublic class WebSecurity extends WebSecurityConfigurerAdapter &#123; private Environment env; private UserService userService; private BCryptPasswordEncoder bCryptPasswordEncoder; public WebSecurity(Environment evn, UserService userService, BCryptPasswordEncoder bCryptPasswordEncoder)&#123; this.env = env; this.userService = userService; this.bCryptPasswordEncoder = bCryptPasswordEncoder; &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService).passwordEncoder(bCryptPasswordEncoder); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable(); http.authorizeRequests().antMatchers(&quot;/users/**&quot;) .hasIpAddress(&quot;192.168.0.2&quot;) .and() .addFilter(getAuthenticationFilter()); http.headers().frameOptions().disable(); &#125; private AuthenticationFilter getAuthenticationFilter() throws Exception&#123; AuthenticationFilter authenticationFilter = new AuthenticationFilter(authenticationManager(), userService, env); return authenticationFilter; &#125;&#125; public interface UserService extends UserDetailsService &#123; UserDto createUser(UserDto userDto); UserDto getUserByUserId(String userId); Iterable&lt;UserEntity&gt; getUserByAll(); UserDto getUserDetailsByEmail(String username);&#125; @Servicepublic class UserServiceImpl implements UserService &#123; UserRepository userRepository; BCryptPasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserEntity userEntity = userRepository.findByEmail(username); if (userEntity == null) &#123; throw new UsernameNotFoundException(username); &#125; return new User(userEntity.getEmail() , userEntity.getEncryptedPwd() , true , true , true , true , new ArrayList&lt;&gt;()); &#125; public UserServiceImpl(UserRepository userRepository, BCryptPasswordEncoder passwordEncoder) &#123; this.userRepository = userRepository; this.passwordEncoder = passwordEncoder; &#125; @Override public UserDto createUser(UserDto userDto) &#123; userDto.setUserId(UUID.randomUUID().toString()); ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); UserEntity userEntity = modelMapper.map(userDto, UserEntity.class); userEntity.setEncryptedPwd(passwordEncoder.encode(userDto.getPwd())); userRepository.save(userEntity); UserDto returnUserDto = modelMapper.map(userEntity, UserDto.class); return returnUserDto; &#125; @Override public UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orders = new ArrayList&lt;&gt;(); userDto.setOrders(orders); return userDto; &#125; @Override public Iterable&lt;UserEntity&gt; getUserByAll() &#123; return userRepository.findAll(); &#125; @Override public UserDto getUserDetailsByEmail(String email) &#123; UserEntity userEntity = userRepository.findByEmail(email); if(userEntity == null)&#123; throw new UsernameNotFoundException(email); &#125; UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); return userDto; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 17. Users Microservice Routes 정보 변경","slug":"spring/spring-cloud/spring-cloud-17","date":"2021-09-18T08:31:31.000Z","updated":"2024-02-26T15:35:58.167Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-17/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-17/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice Routes 정보 변경server: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes:# - id: user-service# uri: lb://USER-SERVICE# predicates:# - Path=/user-service/**# filters:# - CustomFilter - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/login - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/users - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/** - Method=GET filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: catalog-service uri: lb://CATALOG-SERVICE predicates: - Path=/catalog-service/** filters: - CustomFilter - id: order-service uri: lb://ORDER-SERVICE predicates: - Path=/order-service/** filters: - CustomFilter","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice Routes 정보 변경server: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes:# - id: user-service# uri: lb://USER-SERVICE# predicates:# - Path=/user-service/**# filters:# - CustomFilter - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/login - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/users - Method=POST filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/** - Method=GET filters: - RemoveRequestHeader=Cookie - RewritePath=/user-service/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; - id: catalog-service uri: lb://CATALOG-SERVICE predicates: - Path=/catalog-service/** filters: - CustomFilter - id: order-service uri: lb://ORDER-SERVICE predicates: - Path=/order-service/** filters: - CustomFilter","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 16. Users Microservice loadUserByUsername() 구현","slug":"spring/spring-cloud/spring-cloud-16","date":"2021-09-18T07:31:31.000Z","updated":"2024-02-26T15:35:54.610Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-16/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-16/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice loadUserByUsername() 구현public interface UserService extends UserDetailsService &#123; UserDto createUser(UserDto userDto); UserDto getUserByUserId(String userId); Iterable&lt;UserEntity&gt; getUserByAll();&#125; public interface UserRepository extends CrudRepository&lt;UserEntity, Long&gt; &#123; UserEntity findByUserId(String userId); UserEntity findByEmail(String username);&#125; @Servicepublic class UserServiceImpl implements UserService &#123; UserRepository userRepository; BCryptPasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserEntity userEntity = userRepository.findByEmail(username); if (UserEntity == null) &#123; throw new UsernameNotFoundException(username); &#125; return new User(userEntity.getEmail() , userEntity.getEncryptedPwd() , true , true , true , true , new ArrayList&lt;&gt;()); &#125; public UserServiceImpl(UserRepository userRepository, BCryptPasswordEncoder passwordEncoder) &#123; this.userRepository = userRepository; this.passwordEncoder = passwordEncoder; &#125; @Override public UserDto createUser(UserDto userDto) &#123; userDto.setUserId(UUID.randomUUID().toString()); ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); UserEntity userEntity = modelMapper.map(userDto, UserEntity.class); userEntity.setEncryptedPwd(passwordEncoder.encode(userDto.getPwd())); userRepository.save(userEntity); UserDto returnUserDto = modelMapper.map(userEntity, UserDto.class); return returnUserDto; &#125; @Override public UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orders = new ArrayList&lt;&gt;(); userDto.setOrders(orders); return userDto; &#125; @Override public Iterable&lt;UserEntity&gt; getUserByAll() &#123; return userRepository.findAll(); &#125;&#125; @Configuration@EnableWebSecuritypublic class WebSecurity extends WebSecurityConfigurerAdapter &#123; private Environment env; private UserService userService; private BCryptPasswordEncoder bCryptPasswordEncoder; public WebSecurity(Environment evn, UserService userService, BCryptPasswordEncoder bCryptPasswordEncoder)&#123; this.env = env; this.userService = userService; this.bCryptPasswordEncoder = bCryptPasswordEncoder; &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService).passwordEncoder(bCryptPasswordEncoder); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable(); http.authorizeRequests().antMatchers(&quot;/users/**&quot;) .hasIpAddress(&quot;192.168.0.2&quot;) .and() .addFilter(getAuthenticationFilter()); http.headers().frameOptions().disable(); &#125; private AuthenticationFilter getAuthenticationFilter() throws Exception&#123; AuthenticationFilter authenticationFilter = new AuthenticationFilter(); authenticationFilter.setAuthenticationManager(authenticationManager()); return authenticationFilter; &#125; @Bean public BCryptPasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125;","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice loadUserByUsername() 구현public interface UserService extends UserDetailsService &#123; UserDto createUser(UserDto userDto); UserDto getUserByUserId(String userId); Iterable&lt;UserEntity&gt; getUserByAll();&#125; public interface UserRepository extends CrudRepository&lt;UserEntity, Long&gt; &#123; UserEntity findByUserId(String userId); UserEntity findByEmail(String username);&#125; @Servicepublic class UserServiceImpl implements UserService &#123; UserRepository userRepository; BCryptPasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserEntity userEntity = userRepository.findByEmail(username); if (UserEntity == null) &#123; throw new UsernameNotFoundException(username); &#125; return new User(userEntity.getEmail() , userEntity.getEncryptedPwd() , true , true , true , true , new ArrayList&lt;&gt;()); &#125; public UserServiceImpl(UserRepository userRepository, BCryptPasswordEncoder passwordEncoder) &#123; this.userRepository = userRepository; this.passwordEncoder = passwordEncoder; &#125; @Override public UserDto createUser(UserDto userDto) &#123; userDto.setUserId(UUID.randomUUID().toString()); ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); UserEntity userEntity = modelMapper.map(userDto, UserEntity.class); userEntity.setEncryptedPwd(passwordEncoder.encode(userDto.getPwd())); userRepository.save(userEntity); UserDto returnUserDto = modelMapper.map(userEntity, UserDto.class); return returnUserDto; &#125; @Override public UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orders = new ArrayList&lt;&gt;(); userDto.setOrders(orders); return userDto; &#125; @Override public Iterable&lt;UserEntity&gt; getUserByAll() &#123; return userRepository.findAll(); &#125;&#125; @Configuration@EnableWebSecuritypublic class WebSecurity extends WebSecurityConfigurerAdapter &#123; private Environment env; private UserService userService; private BCryptPasswordEncoder bCryptPasswordEncoder; public WebSecurity(Environment evn, UserService userService, BCryptPasswordEncoder bCryptPasswordEncoder)&#123; this.env = env; this.userService = userService; this.bCryptPasswordEncoder = bCryptPasswordEncoder; &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService).passwordEncoder(bCryptPasswordEncoder); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable(); http.authorizeRequests().antMatchers(&quot;/users/**&quot;) .hasIpAddress(&quot;192.168.0.2&quot;) .and() .addFilter(getAuthenticationFilter()); http.headers().frameOptions().disable(); &#125; private AuthenticationFilter getAuthenticationFilter() throws Exception&#123; AuthenticationFilter authenticationFilter = new AuthenticationFilter(); authenticationFilter.setAuthenticationManager(authenticationManager()); return authenticationFilter; &#125; @Bean public BCryptPasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 15. Users Microservice AuthenticationFilter","slug":"spring/spring-cloud/spring-cloud-15","date":"2021-09-18T06:31:31.000Z","updated":"2024-02-26T15:35:48.884Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-15/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-15/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice 15. Users Microservice AuthenticationFilter@Datapublic class RequestLogin &#123; @NotNull(message = &quot;Email cannot be null&quot;) @Size(min = 2, message = &quot;Email not be less than two characters&quot;) private String email; @NotNull(message = &quot;Password cannot be null&quot;) @Size(min = 8, message = &quot;Password must be equals or grater than 8 characters&quot;) private String password;&#125; public class AuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; try &#123; RequestLogin creds = new ObjectMapper().readValue(request.getInputStream(), RequestLogin.class); Authentication token = new UsernamePasswordAuthenticationToken(creds.getEmail(), creds.getPassword(), new ArrayList&lt;&gt;()); return getAuthenticationManager().authenticate(token); &#125; catch (IOException e)&#123; throw new RuntimeException(e); &#125; &#125; @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; super.successfulAuthentication(request, response, chain, authResult); &#125;&#125;","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice 15. Users Microservice AuthenticationFilter@Datapublic class RequestLogin &#123; @NotNull(message = &quot;Email cannot be null&quot;) @Size(min = 2, message = &quot;Email not be less than two characters&quot;) private String email; @NotNull(message = &quot;Password cannot be null&quot;) @Size(min = 8, message = &quot;Password must be equals or grater than 8 characters&quot;) private String password;&#125; public class AuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; try &#123; RequestLogin creds = new ObjectMapper().readValue(request.getInputStream(), RequestLogin.class); Authentication token = new UsernamePasswordAuthenticationToken(creds.getEmail(), creds.getPassword(), new ArrayList&lt;&gt;()); return getAuthenticationManager().authenticate(token); &#125; catch (IOException e)&#123; throw new RuntimeException(e); &#125; &#125; @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; super.successfulAuthentication(request, response, chain, authResult); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 14. Users Microservice Order Service","slug":"spring/spring-cloud/spring-cloud-14","date":"2021-09-18T05:31:31.000Z","updated":"2024-02-26T15:35:44.343Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-14/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-14/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice Order Service설정server: port: 0spring: application: name: order-service h2: console: enabled: true settings: web-allow-others: true datasource: driver-class-name: org.h2.Driver username: sa password: url: jdbc:h2:mem:testdb jpa: hibernate: ddl-auto: create-drop generate-ddl: true show-sql: trueeureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; @Data@Entity@Table(name = &quot;orders&quot;)public class OrderEntity implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 120) private String productId; @Column(nullable = false) private Integer qty; @Column(nullable = false) private Integer unitPrice; @Column(nullable = false) private Integer totalPrice; @Column(nullable = false) private String userId; @Column(nullable = false, unique = true) private String orderId; @Column(nullable = false, updatable = false, insertable = false) @ColumnDefault(value = &quot;CURRENT_TIMESTAMP&quot;) private Date createdAt;&#125; @Repositorypublic interface OrderRepository extends CrudRepository&lt;OrderEntity, Long&gt; &#123; OrderEntity findByOrderId(String orderId); Iterable&lt;OrderEntity&gt; findByUserId(String userId);&#125; @Data@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseOrder &#123; private String productId; private Integer qty; private Integer unitPrice; private Integer totalPrice; private Date createdAt; private String orderId;&#125; @Datapublic class RequestOrder &#123; private String productId; private Integer qty; private Integer unitPrice;&#125;","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice Order Service설정server: port: 0spring: application: name: order-service h2: console: enabled: true settings: web-allow-others: true datasource: driver-class-name: org.h2.Driver username: sa password: url: jdbc:h2:mem:testdb jpa: hibernate: ddl-auto: create-drop generate-ddl: true show-sql: trueeureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; @Data@Entity@Table(name = &quot;orders&quot;)public class OrderEntity implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 120) private String productId; @Column(nullable = false) private Integer qty; @Column(nullable = false) private Integer unitPrice; @Column(nullable = false) private Integer totalPrice; @Column(nullable = false) private String userId; @Column(nullable = false, unique = true) private String orderId; @Column(nullable = false, updatable = false, insertable = false) @ColumnDefault(value = &quot;CURRENT_TIMESTAMP&quot;) private Date createdAt;&#125; @Repositorypublic interface OrderRepository extends CrudRepository&lt;OrderEntity, Long&gt; &#123; OrderEntity findByOrderId(String orderId); Iterable&lt;OrderEntity&gt; findByUserId(String userId);&#125; @Data@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseOrder &#123; private String productId; private Integer qty; private Integer unitPrice; private Integer totalPrice; private Date createdAt; private String orderId;&#125; @Datapublic class RequestOrder &#123; private String productId; private Integer qty; private Integer unitPrice;&#125; @Datapublic class OrderDto implements Serializable &#123; private String productId; private Integer qty; private Integer unitPrice; private Integer totalPrice; private String orderId; private String userId;&#125; public interface OrderService &#123; OrderDto createOrder(OrderDto orderDetails); OrderDto getOrderByOrderId(String orderId); Iterable&lt;OrderEntity&gt; getOrdersByUserId(String userId);&#125; @Servicepublic class OrderServiceImpl implements OrderService&#123; private OrderRepository orderRepository; public OrderServiceImpl(OrderRepository orderRepository)&#123; this.orderRepository = orderRepository; &#125; @Override public OrderDto createOrder(OrderDto orderDto) &#123; orderDto.setOrderId(UUID.randomUUID().toString()); orderDto.setTotalPrice(orderDto.getQty() * orderDto.getUnitPrice()); ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); OrderEntity orderEntity = modelMapper.map(orderDto, OrderEntity.class); orderRepository.save(orderEntity); OrderDto returnValue = modelMapper.map(orderEntity, OrderDto.class); return returnValue; &#125; @Override public OrderDto getOrderByOrderId(String orderId) &#123; OrderEntity orderEntity = orderRepository.findByOrderId(orderId); OrderDto orderDto = new ModelMapper().map(orderEntity, OrderDto.class); return orderDto; &#125; @Override public Iterable&lt;OrderEntity&gt; getOrdersByUserId(String userId) &#123; return orderRepository.findByUserId(userId); &#125;&#125; @RestController@RequestMapping(&quot;/order-service/&quot;)public class OrderController &#123; private OrderService orderService; public OrderController(OrderService orderService)&#123; this.orderService = orderService; &#125; @PostMapping(value = &quot;/&#123;userId&#125;/orders&quot;) public ResponseEntity&lt;ResponseOrder&gt; createOrder(@PathVariable(&quot;userId&quot;) String userId, @RequestBody RequestOrder orderDetails)&#123; ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); OrderDto orderDto = modelMapper.map(orderDetails, OrderDto.class); orderDto.setUserId(userId); OrderDto createDto = orderService.createOrder(orderDto); ResponseOrder returnValue = modelMapper.map(createDto, ResponseOrder.class); return ResponseEntity.status(HttpStatus.CREATED).body(returnValue); &#125; @GetMapping(value = &quot;/&#123;userId&#125;/orders&quot;) public ResponseEntity&lt;List&lt;ResponseOrder&gt;&gt; getOrder(@PathVariable(&quot;userId&quot;) String userId)&#123; Iterable&lt;OrderEntity&gt; orderList = orderService.getOrdersByUserId(userId); List&lt;ResponseOrder&gt; result = new ArrayList&lt;&gt;(); orderList.forEach(v -&gt; &#123; result.add(new ModelMapper().map(v, ResponseOrder.class)); &#125;); return ResponseEntity.status(HttpStatus.OK).body(result); &#125;&#125; Gateway에 등록- id: order-service uri: lb://ORDER-SERVICE predicates: - Path=/order-service/** filters: - CustomFilter server: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes: - id: user-service uri: lb://USER-SERVICE predicates: - Path=/user-service/** filters: - CustomFilter - id: catalog-service uri: lb://CATALOG-SERVICE predicates: - Path=/catalog-service/** filters: - CustomFilter - id: order-service uri: lb://ORDER-SERVICE predicates: - Path=/order-service/** filters: - CustomFilter","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 13. Users Microservice Catalog","slug":"spring/spring-cloud/spring-cloud-13","date":"2021-09-18T04:31:31.000Z","updated":"2024-02-26T15:35:39.584Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-13/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-13/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice 13. Users Microservice Catalog설정 정보server: port: 0spring: application: name: catalog-service h2: console: enabled: true settings: web-allow-others: true datasource: hikari: driver-class-name: org.h2.Driver url: jdbc:h2:mem:testdb username: sa password: jpa: hibernate: ddl-auto: create-drop show-sql: true generate-ddl: trueeureka: client: service-url: defaultZone: http://localhost:8761/eureka#logging:# level:# com.example.catalogservice: DEBUG @Data@Entity@Table(name = &quot;catalog&quot;)public class CatalogEntity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 120, unique = true) private String productId; @Column(nullable = false) private String productName; @Column(nullable = false) private Integer stock; @Column(nullable = false) private Integer unitPrice; @Column(nullable = false, updatable = false, insertable = false) @ColumnDefault(value = &quot;CURRENT_TIMESTAMP&quot;) private Date createdAt;&#125; @Repositorypublic interface CatalogRepository extends CrudRepository&lt;CatalogEntity, Long&gt; &#123; CatalogEntity findByProductId(String productId);&#125; public interface CatalogService &#123; Iterable&lt;CatalogEntity&gt; getAllCatalogs();&#125; @Service@Slf4jpublic class CatalogServiceImpl implements CatalogService&#123; CatalogRepository repository; Environment env; public CatalogServiceImpl(CatalogRepository repository, Environment env)&#123; this.repository = repository; this.env = env; &#125; @Override public Iterable&lt;CatalogEntity&gt; getAllCatalogs() &#123; return repository.findAll(); &#125;&#125;","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice 13. Users Microservice Catalog설정 정보server: port: 0spring: application: name: catalog-service h2: console: enabled: true settings: web-allow-others: true datasource: hikari: driver-class-name: org.h2.Driver url: jdbc:h2:mem:testdb username: sa password: jpa: hibernate: ddl-auto: create-drop show-sql: true generate-ddl: trueeureka: client: service-url: defaultZone: http://localhost:8761/eureka#logging:# level:# com.example.catalogservice: DEBUG @Data@Entity@Table(name = &quot;catalog&quot;)public class CatalogEntity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 120, unique = true) private String productId; @Column(nullable = false) private String productName; @Column(nullable = false) private Integer stock; @Column(nullable = false) private Integer unitPrice; @Column(nullable = false, updatable = false, insertable = false) @ColumnDefault(value = &quot;CURRENT_TIMESTAMP&quot;) private Date createdAt;&#125; @Repositorypublic interface CatalogRepository extends CrudRepository&lt;CatalogEntity, Long&gt; &#123; CatalogEntity findByProductId(String productId);&#125; public interface CatalogService &#123; Iterable&lt;CatalogEntity&gt; getAllCatalogs();&#125; @Service@Slf4jpublic class CatalogServiceImpl implements CatalogService&#123; CatalogRepository repository; Environment env; public CatalogServiceImpl(CatalogRepository repository, Environment env)&#123; this.repository = repository; this.env = env; &#125; @Override public Iterable&lt;CatalogEntity&gt; getAllCatalogs() &#123; return repository.findAll(); &#125;&#125; @RestController@RequestMapping(&quot;/catalog-service&quot;)public class CatalogController &#123; private Environment env; CatalogService catalogService; public CatalogController(Environment env, CatalogService catalogService)&#123; this.env = env; this.catalogService = catalogService; &#125; @GetMapping(&quot;/health_check&quot;) public String status(HttpServletRequest request)&#123; return String.format(&quot;It&#x27;s Working in Catalog Service on Port %s&quot;, request.getServerPort()); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 12. Users Microservice 사용자 조회","slug":"spring/spring-cloud/spring-cloud-12","date":"2021-09-18T03:31:31.000Z","updated":"2024-02-26T15:35:35.907Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-12/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-12/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice 12. Users Microservice 사용자 조회@Overridepublic UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orders = new ArrayList&lt;&gt;(); userDto.setOrders(orders); return userDto;&#125;@Overridepublic Iterable&lt;UserEntity&gt; getUserByAll() &#123; return userRepository.findAll();&#125; public interface UserRepository extends CrudRepository&lt;UserEntity, Long&gt; &#123; UserEntity findByUserId(String userId);&#125; 전체 User 정보 가져오기@GetMapping(&quot;/users&quot;)public ResponseEntity&lt;List&lt;ResponseUser&gt;&gt; getUsers() &#123; Iterable&lt;UserEntity&gt; userList = userService.getUserByAll(); List&lt;ResponseUser&gt; result = new ArrayList&lt;&gt;(); userList.forEach(v -&gt; &#123; result.add(new ModelMapper().map(v, ResponseUser.class)); &#125;); return ResponseEntity.status(HttpStatus.OK).body(result);&#125; 특정 User 정보 가져오기@GetMapping(&quot;/users/&#123;userId&#125;&quot;) public ResponseEntity&lt;ResponseUser&gt; getUsers(@PathVariable(&quot;userId&quot;) String userId) &#123; UserDto userDto = userService.getUserByUserId(userId); ResponseUser returnValue = new ModelMapper().map(userDto, ResponseUser.class); return ResponseEntity.status(HttpStatus.OK).body(returnValue); &#125;","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice 12. Users Microservice 사용자 조회@Overridepublic UserDto getUserByUserId(String userId) &#123; UserEntity userEntity = userRepository.findByUserId(userId); if (userEntity == null) throw new UsernameNotFoundException(&quot;User not found&quot;); UserDto userDto = new ModelMapper().map(userEntity, UserDto.class); List&lt;ResponseOrder&gt; orders = new ArrayList&lt;&gt;(); userDto.setOrders(orders); return userDto;&#125;@Overridepublic Iterable&lt;UserEntity&gt; getUserByAll() &#123; return userRepository.findAll();&#125; public interface UserRepository extends CrudRepository&lt;UserEntity, Long&gt; &#123; UserEntity findByUserId(String userId);&#125; 전체 User 정보 가져오기@GetMapping(&quot;/users&quot;)public ResponseEntity&lt;List&lt;ResponseUser&gt;&gt; getUsers() &#123; Iterable&lt;UserEntity&gt; userList = userService.getUserByAll(); List&lt;ResponseUser&gt; result = new ArrayList&lt;&gt;(); userList.forEach(v -&gt; &#123; result.add(new ModelMapper().map(v, ResponseUser.class)); &#125;); return ResponseEntity.status(HttpStatus.OK).body(result);&#125; 특정 User 정보 가져오기@GetMapping(&quot;/users/&#123;userId&#125;&quot;) public ResponseEntity&lt;ResponseUser&gt; getUsers(@PathVariable(&quot;userId&quot;) String userId) &#123; UserDto userDto = userService.getUserByUserId(userId); ResponseUser returnValue = new ModelMapper().map(userDto, ResponseUser.class); return ResponseEntity.status(HttpStatus.OK).body(returnValue); &#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 11. Users Microservice Gateway 연동","slug":"spring/spring-cloud/spring-cloud-11","date":"2021-09-18T02:31:31.000Z","updated":"2024-02-26T15:35:32.281Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-11/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-11/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice Gateway 연동@GetMapping(&quot;/health_check&quot;)public String status()&#123; return String.format(&quot;It&#x27;s Working in User Service on PORT %s&quot;, env.getProperty(&quot;local.server.port&quot;));&#125; server: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes: - id: user-service # uri: http://localhost:8081/ uri: lb://USER-SERVICE predicates: - Path=/user-service/** filters: - CustomFilter # - AddRequestHeader=first-request, first-request-header2 # - AddResponseHeader=first-response, first-response-header2 - id: first-service # uri: http://localhost:8081/ uri: lb://MY-FIRST-SERVICE predicates: - Path=/first-service/** filters: - CustomFilter # - AddRequestHeader=first-request, first-request-header2 # - AddResponseHeader=first-response, first-response-header2 Gateway를 거처 User Service에 접근하게 되면 문제가 발생 User Service의 URI와 API Gateway의 URI가 다르기 때문에 문제가 생김 @GetMapping(&quot;/user-service/health_check&quot;)public String status()&#123; return String.format(&quot;It&#x27;s Working in User Service on PORT %s&quot;, env.getProperty(&quot;local.server.port&quot;));&#125;","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice Gateway 연동@GetMapping(&quot;/health_check&quot;)public String status()&#123; return String.format(&quot;It&#x27;s Working in User Service on PORT %s&quot;, env.getProperty(&quot;local.server.port&quot;));&#125; server: port: 8080eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes: - id: user-service # uri: http://localhost:8081/ uri: lb://USER-SERVICE predicates: - Path=/user-service/** filters: - CustomFilter # - AddRequestHeader=first-request, first-request-header2 # - AddResponseHeader=first-response, first-response-header2 - id: first-service # uri: http://localhost:8081/ uri: lb://MY-FIRST-SERVICE predicates: - Path=/first-service/** filters: - CustomFilter # - AddRequestHeader=first-request, first-request-header2 # - AddResponseHeader=first-response, first-response-header2 Gateway를 거처 User Service에 접근하게 되면 문제가 발생 User Service의 URI와 API Gateway의 URI가 다르기 때문에 문제가 생김 @GetMapping(&quot;/user-service/health_check&quot;)public String status()&#123; return String.format(&quot;It&#x27;s Working in User Service on PORT %s&quot;, env.getProperty(&quot;local.server.port&quot;));&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 10. Users Microservice 사용자 추가","slug":"spring/spring-cloud/spring-cloud-10","date":"2021-09-18T01:31:31.000Z","updated":"2024-02-26T15:35:28.301Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-10/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-10/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice 사용자 추가@RestController@RequestMapping(&quot;/&quot;)public class UserController &#123; private Environment env; private UserService userService; private Greeting greeting; public UserController(Environment env, UserService userService)&#123; this.env = env; this.userService = userService; &#125; @GetMapping(&quot;/health_check&quot;) public String status()&#123; return &quot;It&#x27;s Working in User Service&quot;; &#125; @GetMapping(&quot;/welcome&quot;) public String welcome()&#123; return env.getProperty(&quot;greeting.message&quot;); &#125; @GetMapping(&quot;/welcome_value&quot;) public String welcomeValue()&#123; return greeting.getMessage(); &#125; @PostMapping(&quot;/users&quot;) public ResponseEntity createUser(@RequestBody RequestUser user)&#123; ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); UserDto userDto = modelMapper.map(user, UserDto.class); userService.createUser(userDto); ResponseUser responseUser = modelMapper.map(userDto, ResponseUser.class); return ResponseEntity.status(HttpStatus.CREATED).body(responseUser); &#125;&#125; @Datapublic class ResponseUser &#123; private String email; private String name; private String userId;&#125; @Datapublic class RequestUser &#123; @NotNull(message = &quot;Email cannot be null&quot;) @Size(min = 2, message = &quot;Email not be less than two characters&quot;) private String email; @NotNull(message = &quot;Name cannot be null&quot;) @Size(min = 2, message = &quot;Name not be less than two characters&quot;) private String pwd; @NotNull(message = &quot;Password cannot be null&quot;) @Size(min = 8, message = &quot;Password not be less than two characters&quot;) private String name;&#125; @Datapublic class UserDto &#123; private String email; private String name; private String pwd; private String userId; private Date createdAt; private String encryptedPwd;&#125; @Component@Data@AllArgsConstructor@NoArgsConstructorpublic class Greeting &#123; @Value(&quot;$&#123;greeting.message&#125;&quot;) private String message;&#125; @Data@Entity@Table(&quot;users&quot;)public class UserEntity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 50) private String email; @Column(nullable = false, length = 50) private String name; @Column(nullable = false, unique = true) private String userId; @Column(nullable = false, unique = true) private String encryptedPwd;&#125;","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice 사용자 추가@RestController@RequestMapping(&quot;/&quot;)public class UserController &#123; private Environment env; private UserService userService; private Greeting greeting; public UserController(Environment env, UserService userService)&#123; this.env = env; this.userService = userService; &#125; @GetMapping(&quot;/health_check&quot;) public String status()&#123; return &quot;It&#x27;s Working in User Service&quot;; &#125; @GetMapping(&quot;/welcome&quot;) public String welcome()&#123; return env.getProperty(&quot;greeting.message&quot;); &#125; @GetMapping(&quot;/welcome_value&quot;) public String welcomeValue()&#123; return greeting.getMessage(); &#125; @PostMapping(&quot;/users&quot;) public ResponseEntity createUser(@RequestBody RequestUser user)&#123; ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); UserDto userDto = modelMapper.map(user, UserDto.class); userService.createUser(userDto); ResponseUser responseUser = modelMapper.map(userDto, ResponseUser.class); return ResponseEntity.status(HttpStatus.CREATED).body(responseUser); &#125;&#125; @Datapublic class ResponseUser &#123; private String email; private String name; private String userId;&#125; @Datapublic class RequestUser &#123; @NotNull(message = &quot;Email cannot be null&quot;) @Size(min = 2, message = &quot;Email not be less than two characters&quot;) private String email; @NotNull(message = &quot;Name cannot be null&quot;) @Size(min = 2, message = &quot;Name not be less than two characters&quot;) private String pwd; @NotNull(message = &quot;Password cannot be null&quot;) @Size(min = 8, message = &quot;Password not be less than two characters&quot;) private String name;&#125; @Datapublic class UserDto &#123; private String email; private String name; private String pwd; private String userId; private Date createdAt; private String encryptedPwd;&#125; @Component@Data@AllArgsConstructor@NoArgsConstructorpublic class Greeting &#123; @Value(&quot;$&#123;greeting.message&#125;&quot;) private String message;&#125; @Data@Entity@Table(&quot;users&quot;)public class UserEntity &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 50) private String email; @Column(nullable = false, length = 50) private String name; @Column(nullable = false, unique = true) private String userId; @Column(nullable = false, unique = true) private String encryptedPwd;&#125; public interface UserRepository extends CrudRepository&lt;UserEntity, Long&gt; &#123;&#125; @Servicepublic class UserServiceImpl implements UserService&#123; @Autowired UserRepository userRepository; @Override public UserDto createUser(UserDto userDto) &#123; userDto.setUserId(UUID.randomUUID().toString()); ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); UserEntity userEntity = modelMapper.map(userDto, UserEntity.class); userEntity.setEncryptedPwd(&quot;encrypted_password&quot;); userRepository.save(userEntity); return null; &#125;&#125; Spring Security 연동@Configuration@EnableWebSecuritypublic class WebSecurity extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable(); http.authorizeRequests().antMatchers(&quot;/users/**&quot;).permitAll(); http.headers().frameOptions().disable(); &#125; @Bean public BCryptPasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; @Servicepublic class UserServiceImpl implements UserService&#123; UserRepository userRepository; BCryptPasswordEncoder passwordEncoder; public UserServiceImpl(UserRepository userRepository, BCryptPasswordEncoder passwordEncoder)&#123; this.userRepository = userRepository; this.passwordEncoder = passwordEncoder; &#125; @Override public UserDto createUser(UserDto userDto) &#123; userDto.setUserId(UUID.randomUUID().toString()); ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); UserEntity userEntity = modelMapper.map(userDto, UserEntity.class); userEntity.setEncryptedPwd(passwordEncoder.encode(userDto.getPwd())); userRepository.save(userEntity); UserDto returnUserDto = modelMapper.map(userEntity, UserDto.class); return returnUserDto; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9","slug":"spring/spring-cloud/spring-cloud-09","date":"2021-09-18T00:31:31.000Z","updated":"2024-02-26T15:35:24.611Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-09/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-09/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9server: port: 0spring: application: name: user-service h2: console: enabled: true settings: web-allow-others: true datasource: username: sa password: hikari: driver-class-name: org.h2.Driver url: jdbc:h2:mem:testdbeureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekagreeting: message: Welcome to the Simple E-commerce.n","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9server: port: 0spring: application: name: user-service h2: console: enabled: true settings: web-allow-others: true datasource: username: sa password: hikari: driver-class-name: org.h2.Driver url: jdbc:h2:mem:testdbeureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekagreeting: message: Welcome to the Simple E-commerce.n","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - Users Microservice","slug":"spring/spring-cloud/spring-cloud-08","date":"2021-09-17T23:31:31.000Z","updated":"2024-02-26T15:35:19.233Z","comments":true,"path":"2021/09/18/spring/spring-cloud/spring-cloud-08/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/spring-cloud-08/","excerpt":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice@RestController@RequestMapping(&quot;/&quot;)public class UserController &#123; @GetMapping(&quot;/health_check&quot;) public String status()&#123; return &quot;It&#x27;s Working in User Service&quot;; &#125;&#125; 프로젝트 설정 추가하기server: port: 0spring: application: name: user-serviceeureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka Application.yml 파일로부터 데이터 가져오기server: port: 0spring: application: name: user-serviceeureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekagreeting: message: Welcome to the Simple E-commerce. Enviroment 객체를 사용하는 방법","text":"목차 Spring Cloud - 20. Users Microservice AuthorizationHeaderFilter 추가 Spring Cloud - 19. Users Microservice JWT 생성 Spring Cloud - 18. Users Microservice 로그인 성공 처리 Spring Cloud - 17. Users Microservice Routes 정보 변경 Spring Cloud - 16. Users Microservice loadUserByUsername() 구현 Spring Cloud - 15. Users Microservice AuthenticationFilter Spring Cloud - 14. Users Microservice Order Service Spring Cloud - 13. Users Microservice Catalog Spring Cloud - 12. Users Microservice 사용자 조회 Spring Cloud - 11. Users Microservice Gateway 연동 Spring Cloud - 10. Users Microservice 사용자 추가 Spring Cloud로 개발하는 마이크로서비스 애플리케이션 9 Spring Cloud - Users Microservice Users Microservice@RestController@RequestMapping(&quot;/&quot;)public class UserController &#123; @GetMapping(&quot;/health_check&quot;) public String status()&#123; return &quot;It&#x27;s Working in User Service&quot;; &#125;&#125; 프로젝트 설정 추가하기server: port: 0spring: application: name: user-serviceeureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka Application.yml 파일로부터 데이터 가져오기server: port: 0spring: application: name: user-serviceeureka: instance: instanceId: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125; client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eurekagreeting: message: Welcome to the Simple E-commerce. Enviroment 객체를 사용하는 방법@RestController@RequestMapping(&quot;/&quot;)public class UserController &#123; private Environment env; public UserController(Environment env)&#123; this.env = env; &#125; @GetMapping(&quot;/health_check&quot;) public String status()&#123; return &quot;It&#x27;s Working in User Service&quot;; &#125; @GetMapping(&quot;/welcome&quot;) public String welcome()&#123; return env.getProperty(&quot;greeting.message&quot;); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"}],"tags":[]},{"title":"Spring Cloud - 7. Load Balancer 적용","slug":"spring/spring-cloud/gateway/spring-cloud-07","date":"2021-09-17T22:31:31.000Z","updated":"2024-02-26T15:33:55.049Z","comments":true,"path":"2021/09/18/spring/spring-cloud/gateway/spring-cloud-07/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/gateway/spring-cloud-07/","excerpt":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) Spring Cloud로 개발하는 마이크로서비스 애플리케이션 7 - Load Balancer 적용Spring Cloud Gateway와 Eureka연동 Gateway 설정eureka 설정하기 eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka Gateway 설정하기 spring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes: - id: first-service# uri: http://localhost:8081/ uri: lb://MY-FIRST-SERVICE predicates: - Path=/first-service/** filters: - CustomFilter# - AddRequestHeader=first-request, first-request-header2# - AddResponseHeader=first-response, first-response-header2 - id: second-service# uri: http://localhost:8082/ uri: lb://MY-SECOND-SERVICE predicates: - Path=/second-service/** filters: - name: CustomFilter - name: LoggingFilter args: baseMessage: Hi, there. preLogger: true postLogger: true# - AddRequestHeader=second-request, second-request-header2# - AddResponseHeader=second-response, second-response-header2 Client 설정","text":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) Spring Cloud로 개발하는 마이크로서비스 애플리케이션 7 - Load Balancer 적용Spring Cloud Gateway와 Eureka연동 Gateway 설정eureka 설정하기 eureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka Gateway 설정하기 spring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes: - id: first-service# uri: http://localhost:8081/ uri: lb://MY-FIRST-SERVICE predicates: - Path=/first-service/** filters: - CustomFilter# - AddRequestHeader=first-request, first-request-header2# - AddResponseHeader=first-response, first-response-header2 - id: second-service# uri: http://localhost:8082/ uri: lb://MY-SECOND-SERVICE predicates: - Path=/second-service/** filters: - name: CustomFilter - name: LoggingFilter args: baseMessage: Hi, there. preLogger: true postLogger: true# - AddRequestHeader=second-request, second-request-header2# - AddResponseHeader=second-response, second-response-header2 Client 설정first-service server: port: 8081spring: application: name: my-first-serviceeureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka second-service server: port: 8082spring: application: name: my-second-serviceeureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Gateway","slug":"Spring/Spring-Cloud/Gateway","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Gateway/"}],"tags":[]},{"title":"Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용","slug":"spring/spring-cloud/gateway/spring-cloud-06","date":"2021-09-17T21:31:31.000Z","updated":"2024-02-26T15:33:51.316Z","comments":true,"path":"2021/09/18/spring/spring-cloud/gateway/spring-cloud-06/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/gateway/spring-cloud-06/","excerpt":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) Spring Cloud로 개발하는 마이크로서비스 애플리케이션 6 - Spring Cloud Gateway Global Filter 적용LoggingFilter @Component@Slf4jpublic class LoggingFilter extends AbstractGatewayFilterFactory&lt;LoggingFilter.Config&gt; &#123; public LoggingFilter()&#123; super(Config.class); &#125; @Override public GatewayFilter apply(Config config) &#123; GatewayFilter filter = new OrderedGatewayFilter((exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); log.info(&quot;Logging Filter baseMessage : &#123;&#125;&quot;, request.getId()); if(config.isPreLogger())&#123; log.info(&quot;Logging Pre Filter: request id -&gt; &#123;&#125;&quot;, request.getId()); &#125; // Custom Post Filter return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; if(config.isPostLogger())&#123; log.info(&quot;Logging Post Filter: response code -&gt; &#123;&#125;&quot;, response.getStatusCode()); &#125; &#125;)); &#125;, Ordered.HIGHEST_PRECEDENCE); return filter; &#125; @Data public static class Config&#123; // Put the configuration properties private String baseMessage; private boolean preLogger; private boolean postLogger; &#125;&#125; application.yml server: port: 8080eureka: client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes: - id: first-service uri: http://localhost:8081/ predicates: - Path=/first-service/** filters: - CustomFilter# - AddRequestHeader=first-request, first-request-header2# - AddResponseHeader=first-response, first-response-header2 - id: second-service uri: http://localhost:8082/ predicates: - Path=/second-service/** filters: - name: CustomFilter - name: LoggingFilter args: baseMessage: Hi, there. preLogger: true postLogger: true# - AddRequestHeader=second-request, second-request-header2# - AddResponseHeader=second-response, second-response-header2","text":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) Spring Cloud로 개발하는 마이크로서비스 애플리케이션 6 - Spring Cloud Gateway Global Filter 적용LoggingFilter @Component@Slf4jpublic class LoggingFilter extends AbstractGatewayFilterFactory&lt;LoggingFilter.Config&gt; &#123; public LoggingFilter()&#123; super(Config.class); &#125; @Override public GatewayFilter apply(Config config) &#123; GatewayFilter filter = new OrderedGatewayFilter((exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); log.info(&quot;Logging Filter baseMessage : &#123;&#125;&quot;, request.getId()); if(config.isPreLogger())&#123; log.info(&quot;Logging Pre Filter: request id -&gt; &#123;&#125;&quot;, request.getId()); &#125; // Custom Post Filter return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; if(config.isPostLogger())&#123; log.info(&quot;Logging Post Filter: response code -&gt; &#123;&#125;&quot;, response.getStatusCode()); &#125; &#125;)); &#125;, Ordered.HIGHEST_PRECEDENCE); return filter; &#125; @Data public static class Config&#123; // Put the configuration properties private String baseMessage; private boolean preLogger; private boolean postLogger; &#125;&#125; application.yml server: port: 8080eureka: client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway Global Filter preLogger: true postLogger: true routes: - id: first-service uri: http://localhost:8081/ predicates: - Path=/first-service/** filters: - CustomFilter# - AddRequestHeader=first-request, first-request-header2# - AddResponseHeader=first-response, first-response-header2 - id: second-service uri: http://localhost:8082/ predicates: - Path=/second-service/** filters: - name: CustomFilter - name: LoggingFilter args: baseMessage: Hi, there. preLogger: true postLogger: true# - AddRequestHeader=second-request, second-request-header2# - AddResponseHeader=second-response, second-response-header2","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Gateway","slug":"Spring/Spring-Cloud/Gateway","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Gateway/"}],"tags":[]},{"title":"JPA - Persist Context (영속성 컨텍스트)","slug":"jpa/jpa-programming/persist/jpa-persist-context","date":"2021-09-17T20:31:46.000Z","updated":"2024-02-18T16:19:54.531Z","comments":true,"path":"2021/09/18/jpa/jpa-programming/persist/jpa-persist-context/","link":"","permalink":"https://ckck803.github.io/2021/09/18/jpa/jpa-programming/persist/jpa-persist-context/","excerpt":"목차 JPA - Entity의 생명주기 JPA - Persist Context (영속성 컨텍스트) Persist Context (영속성 컨텍스트) 란? JPA 가 Entity 를 관리하기 위한 공간, Entity 상태가 Database 에 반영되기 전까지 Entity 의 읽기&#x2F;쓰기&#x2F;수정&#x2F;삭제를 상태 관리한다. EntityManagerFactory 에서 EntityManager 를 생성하고 EntityManager 를 이용해 영속성 컨텍스트에 접근할 수 있다. EntityManager 를 이용해 Entity(데이터)를 저장하거나 조회하면 영속성 컨텍스트에서 해당 Entity 를 관리하게 된다. EntityManager 는 Transaction 단위로 영속성 컨텍스트를 생성하고 지운다. EntityManager 와 영속성 Context가 1:1로 대응이 된다. 영속성 Context는 내부에 1차 cache가 존재하고 (key, value) 형태로 데이터를 관리한다.장점 : buffering이나 Caching을 할 수 있다. @Id Entity Member1 member @Id : Key Entity : 객체 영속성 컨텍스트의 이점","text":"목차 JPA - Entity의 생명주기 JPA - Persist Context (영속성 컨텍스트) Persist Context (영속성 컨텍스트) 란? JPA 가 Entity 를 관리하기 위한 공간, Entity 상태가 Database 에 반영되기 전까지 Entity 의 읽기&#x2F;쓰기&#x2F;수정&#x2F;삭제를 상태 관리한다. EntityManagerFactory 에서 EntityManager 를 생성하고 EntityManager 를 이용해 영속성 컨텍스트에 접근할 수 있다. EntityManager 를 이용해 Entity(데이터)를 저장하거나 조회하면 영속성 컨텍스트에서 해당 Entity 를 관리하게 된다. EntityManager 는 Transaction 단위로 영속성 컨텍스트를 생성하고 지운다. EntityManager 와 영속성 Context가 1:1로 대응이 된다. 영속성 Context는 내부에 1차 cache가 존재하고 (key, value) 형태로 데이터를 관리한다.장점 : buffering이나 Caching을 할 수 있다. @Id Entity Member1 member @Id : Key Entity : 객체 영속성 컨텍스트의 이점 1차 캐시 Database 에서 읽어온 데이터를 임시적으로 저장하고 관리한다. 동일성 보장 같은 Key 를 통해 조회할때 반환되는 객체는 항상 같다. 트랜잭션을 지원하는 쓰기 지연 Entity 에 대한 변경 작업이 끝나면 Database 에 반영한다. 변경 감지 Entity 가 변경이 일어나면 Database 에 반영한다. 변경이 없을 경우에는 반영하지 않는다. 지연 로딩 실제 객체를 호출 전까지는 Proxy 객체를 Loading 해 놓는다. 1차 캐시에서 조회조회를 했지만 select 쿼리가 나가지 않는다. persist로 저장 시에는 1차 캐시에 데이터가 저장되기 때문이다. 조회를 할 때 DB를 조회 한 것이 아닌 우선적으로 1차 캐시를 조회해 값을 가져오기 때문에 DB에 select 쿼리가 나가지 않았던 것이다. public class JpaMain &#123; public static void main(String[] args) &#123; EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try &#123; // 비영속 상태 Member member = new Member(); member.setId(101L); member.setName(&quot;HelloJPA&quot;); // 영속 상태 em.persist(member); // Member Entity 를 조회한다. Member findMember = em.find(Member.class, 101L); System.out.println(&quot;findMember.id = &quot; + findMember.getId()); System.out.println(&quot;findMember.name = &quot; + findMember.getName()); tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; em.close(); &#125; emf.close(); &#125;&#125; Member Entity 를 조회 했지만 따로 Select 쿼리문이 나가지 않고, 새로운 데이터를 넣기 위한 Insert 문이 발생힌다. findMember.id = 101 findMember.name = HelloJPA Hibernate: /* insert hellojpa.Member */ insert into Member (name, id) values (?, ?) 1차 캐시에 data가 없는 경우 DB에서 조회 1차 Cache에 데이터를 저장(있으면)했으면 해당 객체를 가져와서 사용 1차 Cache에 없을 경우 Database 에 접근해 데이터를 가져온 후 1차 Cache 에 저장한다. 똑같은 Key(조회조건) 를 가지고 조회 했을 때 쿼리가 한번만 나가고 그 다음에는 1차 캐시(영속성 컨텍스트) 에 저장된 Entity 객체를 가져온다. public class JpaMain &#123; public static void main(String[] args) &#123; EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try &#123; Member findMember1 = em.find(Member.class, 101L); // 첫번째 조회시에는 query가 나간다. Member findMember2 = em.find(Member.class, 101L); // 두번째 조회시에는 나가지 않는다. tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; em.close(); &#125; emf.close(); &#125;&#125; 두번의 조회를 했지만 하나의 select 문만 발생하는 것을 확인할 수 있다. Hibernate: select member0_.id as id1_0_0_, member0_.name as name2_0_0_ from Member member0_ where member0_.id=? 영속 엔티티의 동일성 보장Member findMember1 = em.find(Member.class, 101L); // 첫번째 조회시에는 query가 나간다.Member findMember2 = em.find(Member.class, 101L); // 두번째 조회시에는 나가지 않는다.System.out.println(&quot;result = &quot; + (findMember1 == findMember2)); // true가 나온다. result = true 트랜잭션을 지원하는 쓰기 지연commit()을 실행했을 때 query문이 날라가는 것을 확인할 수 있다. public class JpaMain &#123; public static void main(String[] args) &#123; EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try &#123; Member member1 = new Member(150L, &quot;A&quot;); Member member2 = new Member(160L, &quot;B&quot;); em.persist(member1); em.persist(member2); System.out.println(&quot;==========================&quot;); tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; em.close(); &#125; emf.close(); &#125;&#125; Hibernate: /* insert hellojpa.Member */ insert into Member (name, id) values (?, ?)Hibernate: /* insert hellojpa.Member */ insert into Member (name, id) values (?, ?) 엔티티 수정public class JpaMain &#123; public static void main(String[] args) &#123; EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try &#123; Member member = em.find(Member.class, 150L); member.setName(&quot;ZZZZZ&quot;);// em.persist(member); persist를 사용할 필요가 없다. System.out.println(&quot;==========================&quot;); tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; em.close(); &#125; emf.close(); &#125;&#125; Hibernate: select member0_.id as id1_0_0_, member0_.name as name2_0_0_ from Member member0_ where member0_.id=?==========================Hibernate: /* update hellojpa.Member */ update Member set name=? where id=?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"JPA 프로그래밍(기본편)","slug":"Programming/JPA/JPA-프로그래밍-기본편","permalink":"https://ckck803.github.io/categories/Programming/JPA/JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B3%B8%ED%8E%B8/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용","slug":"spring/spring-cloud/gateway/spring-cloud-05","date":"2021-09-17T20:31:31.000Z","updated":"2024-02-26T15:33:47.424Z","comments":true,"path":"2021/09/18/spring/spring-cloud/gateway/spring-cloud-05/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/gateway/spring-cloud-05/","excerpt":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) Spring Cloud로 개발하는 마이크로서비스 애플리케이션 5 - Spring Cloud Gateway Global Filter 적용공통적으로 실행될 수 있는 Filter. 라우팅 정보마다 개별적으로 필터를 지정해야 하는 Custom Filter와 다르게 Global Filter의 경우 한번에 처리를 할 수 있다. GlobalFilter.java @Component@Slf4jpublic class GlobalFilter extends AbstractGatewayFilterFactory&lt;GlobalFilter.Config&gt; &#123; public GlobalFilter()&#123; super(Config.class); &#125; @Override public GatewayFilter apply(Config config) &#123; // Custom Pre Filter return (exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); log.info(&quot;Global Filter baseMessage : &#123;&#125;&quot;, request.getId()); if(config.isPreLogger())&#123; log.info(&quot;Global Filter Start: request id -&gt; &#123;&#125;&quot;, request.getId()); &#125; // Custom Post Filter return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; if(config.isPostLogger())&#123; log.info(&quot;Global Filter End: response code -&gt; &#123;&#125;&quot;, response.getStatusCode()); &#125; &#125;)); &#125;; &#125; @Data public static class Config&#123; // Put the configuration properties private String baseMessage; private boolean preLogger; private boolean postLogger; &#125;&#125; application.yml spring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway GlobalFilter preLogger: true postLogger: true","text":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) Spring Cloud로 개발하는 마이크로서비스 애플리케이션 5 - Spring Cloud Gateway Global Filter 적용공통적으로 실행될 수 있는 Filter. 라우팅 정보마다 개별적으로 필터를 지정해야 하는 Custom Filter와 다르게 Global Filter의 경우 한번에 처리를 할 수 있다. GlobalFilter.java @Component@Slf4jpublic class GlobalFilter extends AbstractGatewayFilterFactory&lt;GlobalFilter.Config&gt; &#123; public GlobalFilter()&#123; super(Config.class); &#125; @Override public GatewayFilter apply(Config config) &#123; // Custom Pre Filter return (exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); log.info(&quot;Global Filter baseMessage : &#123;&#125;&quot;, request.getId()); if(config.isPreLogger())&#123; log.info(&quot;Global Filter Start: request id -&gt; &#123;&#125;&quot;, request.getId()); &#125; // Custom Post Filter return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; if(config.isPostLogger())&#123; log.info(&quot;Global Filter End: response code -&gt; &#123;&#125;&quot;, response.getStatusCode()); &#125; &#125;)); &#125;; &#125; @Data public static class Config&#123; // Put the configuration properties private String baseMessage; private boolean preLogger; private boolean postLogger; &#125;&#125; application.yml spring: application: name: apigateway-service cloud: gateway: default-filters: - name: GlobalFilter args: baseMessage: Spring Cloud Gateway GlobalFilter preLogger: true postLogger: true","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Gateway","slug":"Spring/Spring-Cloud/Gateway","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Gateway/"}],"tags":[]},{"title":"Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용","slug":"spring/spring-cloud/gateway/spring-cloud-04","date":"2021-09-17T19:31:31.000Z","updated":"2024-02-26T15:33:43.634Z","comments":true,"path":"2021/09/18/spring/spring-cloud/gateway/spring-cloud-04/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/gateway/spring-cloud-04/","excerpt":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 사용자 정의 필터 만들기AbstractGatewayFilterFactory 를 이용해 Custom Filter를 정의할 수 있다. CustomFilter.java @Component@Slf4jpublic class CustomFilter extends AbstractGatewayFilterFactory&lt;CustomFilter.Config&gt; &#123; public CustomFilter()&#123; super(Config.class); &#125; @Override public GatewayFilter apply(Config config) &#123; // Custom Pre Filter return (exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); log.info(&quot;Custom PRE filter: request id -&gt; &#123;&#125;&quot;, request.getId()); // Custom Post Filter return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; log.info(&quot;Custom POST filter: request id -&gt; &#123;&#125;&quot;, response.getStatusCode()); &#125;)); &#125;; &#125; public static class Config&#123; // Put the configuration properties &#125;&#125; 설정에 추가하기 spring.cloud.gateway.routes.filters application.yml server: port: 8080eureka: client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: routes: - id: first-service uri: http://localhost:8081/ predicates: - Path=/first-service/** filters: - CustomFilter# - AddRequestHeader=first-request, first-request-header2# - AddResponseHeader=first-response, first-response-header2 - id: second-service uri: http://localhost:8082/ predicates: - Path=/second-service/** filters: - CustomFilter# - AddRequestHeader=second-request, second-request-header2# - AddResponseHeader=second-response, second-response-header2","text":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 사용자 정의 필터 만들기AbstractGatewayFilterFactory 를 이용해 Custom Filter를 정의할 수 있다. CustomFilter.java @Component@Slf4jpublic class CustomFilter extends AbstractGatewayFilterFactory&lt;CustomFilter.Config&gt; &#123; public CustomFilter()&#123; super(Config.class); &#125; @Override public GatewayFilter apply(Config config) &#123; // Custom Pre Filter return (exchange, chain) -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); log.info(&quot;Custom PRE filter: request id -&gt; &#123;&#125;&quot;, request.getId()); // Custom Post Filter return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; log.info(&quot;Custom POST filter: request id -&gt; &#123;&#125;&quot;, response.getStatusCode()); &#125;)); &#125;; &#125; public static class Config&#123; // Put the configuration properties &#125;&#125; 설정에 추가하기 spring.cloud.gateway.routes.filters application.yml server: port: 8080eureka: client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: routes: - id: first-service uri: http://localhost:8081/ predicates: - Path=/first-service/** filters: - CustomFilter# - AddRequestHeader=first-request, first-request-header2# - AddResponseHeader=first-response, first-response-header2 - id: second-service uri: http://localhost:8082/ predicates: - Path=/second-service/** filters: - CustomFilter# - AddRequestHeader=second-request, second-request-header2# - AddResponseHeader=second-response, second-response-header2","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Gateway","slug":"Spring/Spring-Cloud/Gateway","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Gateway/"}],"tags":[]},{"title":"Spring Cloud - 3. Spring Cloud Gateway Filter 적용","slug":"spring/spring-cloud/gateway/spring-cloud-03","date":"2021-09-17T18:31:31.000Z","updated":"2024-02-26T15:33:39.327Z","comments":true,"path":"2021/09/18/spring/spring-cloud/gateway/spring-cloud-03/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/gateway/spring-cloud-03/","excerpt":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 코드를 통한 라우팅 설정RouteLocatorBuilder 를 이용해 Filter를 추가할 수 있다. FilterConfig.java @Configurationpublic class FilterConfig &#123; @Bean public RouteLocator gatewayRoutes(RouteLocatorBuilder builder) &#123; return builder.routes() .route(r -&gt; r.path(&quot;/first-service/**&quot;) .filters(f -&gt; f.addRequestHeader(&quot;first-request&quot;, &quot;first-request-header&quot;) .addResponseHeader(&quot;first-response&quot;, &quot;first-response-header&quot;)) .uri(&quot;http://localhost:8081&quot;)) .route(r -&gt; r.path(&quot;/second-service/**&quot;) .filters(f -&gt; f.addRequestHeader(&quot;second-request&quot;, &quot;second-request-header&quot;) .addResponseHeader(&quot;second-response&quot;, &quot;second-response-header&quot;)) .uri(&quot;http://localhost:8082&quot;)) .build(); &#125;&#125; application.yml을 통한 라우팅 설정 spring.cloud.gateway.routes.filters application.yml spring: application: name: apigateway-service cloud: gateway: routes: - id: first-service uri: http://localhost:8081/ predicates: - Path=/first-service/** filters: - AddRequestHeader=first-request, first-request-header2 - AddResponseHeader=first-response, first-response-header2 - id: second-service uri: http://localhost:8082/ predicates: - Path=/second-service/** filters: - AddRequestHeader=second-request, second-request-header2 - AddResponseHeader=second-response, second-response-header2","text":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 코드를 통한 라우팅 설정RouteLocatorBuilder 를 이용해 Filter를 추가할 수 있다. FilterConfig.java @Configurationpublic class FilterConfig &#123; @Bean public RouteLocator gatewayRoutes(RouteLocatorBuilder builder) &#123; return builder.routes() .route(r -&gt; r.path(&quot;/first-service/**&quot;) .filters(f -&gt; f.addRequestHeader(&quot;first-request&quot;, &quot;first-request-header&quot;) .addResponseHeader(&quot;first-response&quot;, &quot;first-response-header&quot;)) .uri(&quot;http://localhost:8081&quot;)) .route(r -&gt; r.path(&quot;/second-service/**&quot;) .filters(f -&gt; f.addRequestHeader(&quot;second-request&quot;, &quot;second-request-header&quot;) .addResponseHeader(&quot;second-response&quot;, &quot;second-response-header&quot;)) .uri(&quot;http://localhost:8082&quot;)) .build(); &#125;&#125; application.yml을 통한 라우팅 설정 spring.cloud.gateway.routes.filters application.yml spring: application: name: apigateway-service cloud: gateway: routes: - id: first-service uri: http://localhost:8081/ predicates: - Path=/first-service/** filters: - AddRequestHeader=first-request, first-request-header2 - AddResponseHeader=first-response, first-response-header2 - id: second-service uri: http://localhost:8082/ predicates: - Path=/second-service/** filters: - AddRequestHeader=second-request, second-request-header2 - AddResponseHeader=second-response, second-response-header2","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Gateway","slug":"Spring/Spring-Cloud/Gateway","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Gateway/"}],"tags":[]},{"title":"Spring Cloud - 2. Spring Cloud Gateway 사용하기","slug":"spring/spring-cloud/gateway/spring-cloud-02","date":"2021-09-17T17:31:31.000Z","updated":"2024-02-26T15:33:27.553Z","comments":true,"path":"2021/09/18/spring/spring-cloud/gateway/spring-cloud-02/","link":"","permalink":"https://ckck803.github.io/2021/09/18/spring/spring-cloud/gateway/spring-cloud-02/","excerpt":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 참고 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/ Spring Cloud Gateway당연히 가능합니다! Spring Cloud Gateway는 스프링 생태계에서 제공하는 도구 중 하나로, 마이크로서비스 아키텍처를 구축하기 위해 사용됩니다. Spring Cloud Gateway는 API 게이트웨이로 작동하여 클라이언트와 백엔드 서비스 사이의 통신을 관리하고 보안, 로드 밸런싱, 라우팅, 필터링 등의 기능을 제공합니다. Spring Cloud Gateway의 핵심 개념은 라우트(Routes)와 필터(Filters)입니다. 라우트는 클라이언트 요청을 수신하고, 해당 요청을 백엔드 서비스로 전달하는 방법을 정의하는데 사용됩니다. 각 라우트는 요청을 받을 수 있는 경로, 요청을 보낼 수 있는 대상 URI, 필요한 필터 등을 포함하고 있습니다. 이를 통해 요청의 동적인 라우팅과 로드 밸런싱을 구현할 수 있습니다. 또한, 필터는 요청과 응답에 대한 전처리와 후처리 작업을 수행하기 위해 사용됩니다. 예를 들어, 인증, 로깅, 헤더 조작 등의 작업을 필터를 통해 처리할 수 있습니다. 필터는 전역 필터(Global Filters)와 라우트별 필터(Route Filters)로 구분될 수 있으며, 필터 체인을 통해 여러 필터를 조합하여 사용할 수 있습니다. Spring Cloud Gateway는 Netty 서버를 기반으로 동작하며, 비동기적이고 넌블로킹 방식으로 요청을 처리합니다. 이를 통해 높은 성능과 확장성을 제공합니다. 또한, Spring Cloud Gateway는 다양한 기능과 확장 포인트를 제공하여 개발자가 필요에 맞게 사용할 수 있습니다. 요약하자면, Spring Cloud Gateway는 스프링 기반의 API 게이트웨이로서 마이크로서비스 아키텍처에서 클라이언트와 서비스 사이의 통신을 관리하고 보안, 로드 밸런싱, 라우팅, 필터링 등의 기능을 제공합니다.","text":"Spring Cloud - 7. Load Balancer 적용 Spring Cloud - 6. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 5. Spring Cloud Gateway Global Filter 적용 Spring Cloud - 4. Spring Cloud Gateway Custom Filter 적용 Spring Cloud - 3. Spring Cloud Gateway Filter 적용 Spring Cloud - 2. Spring Cloud Gateway 사용하기 Spring Cloud - Eureka 에 Service 등록하기 Spring Cloud - Service Discovery Server (Eureka) 참고 https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/ Spring Cloud Gateway당연히 가능합니다! Spring Cloud Gateway는 스프링 생태계에서 제공하는 도구 중 하나로, 마이크로서비스 아키텍처를 구축하기 위해 사용됩니다. Spring Cloud Gateway는 API 게이트웨이로 작동하여 클라이언트와 백엔드 서비스 사이의 통신을 관리하고 보안, 로드 밸런싱, 라우팅, 필터링 등의 기능을 제공합니다. Spring Cloud Gateway의 핵심 개념은 라우트(Routes)와 필터(Filters)입니다. 라우트는 클라이언트 요청을 수신하고, 해당 요청을 백엔드 서비스로 전달하는 방법을 정의하는데 사용됩니다. 각 라우트는 요청을 받을 수 있는 경로, 요청을 보낼 수 있는 대상 URI, 필요한 필터 등을 포함하고 있습니다. 이를 통해 요청의 동적인 라우팅과 로드 밸런싱을 구현할 수 있습니다. 또한, 필터는 요청과 응답에 대한 전처리와 후처리 작업을 수행하기 위해 사용됩니다. 예를 들어, 인증, 로깅, 헤더 조작 등의 작업을 필터를 통해 처리할 수 있습니다. 필터는 전역 필터(Global Filters)와 라우트별 필터(Route Filters)로 구분될 수 있으며, 필터 체인을 통해 여러 필터를 조합하여 사용할 수 있습니다. Spring Cloud Gateway는 Netty 서버를 기반으로 동작하며, 비동기적이고 넌블로킹 방식으로 요청을 처리합니다. 이를 통해 높은 성능과 확장성을 제공합니다. 또한, Spring Cloud Gateway는 다양한 기능과 확장 포인트를 제공하여 개발자가 필요에 맞게 사용할 수 있습니다. 요약하자면, Spring Cloud Gateway는 스프링 기반의 API 게이트웨이로서 마이크로서비스 아키텍처에서 클라이언트와 서비스 사이의 통신을 관리하고 보안, 로드 밸런싱, 라우팅, 필터링 등의 기능을 제공합니다. Spring Cloud Gateway 의존성 추가implementation &#x27;org.springframework.cloud:spring-cloud-starter-gateway&#x27;implementation &#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27; Gateway 설정하기 spring.cloud.gateway.routes.id spring.cloud.gateway.routes.uri spring.cloud.gateway.routes.predicates application.yml server: port: 8080eureka: client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: apigateway-service cloud: gateway: routes: - id: first-service uri: http://localhost:8081/ predicates: - Path=/first-service/** - id: second-service uri: http://localhost:8082/ predicates: - Path=/second-service/** First Serviceserver: port: 8081spring: application: name: my-first-serviceeureka: client: fetch-registry: false register-with-eureka: false @RestController@RequestMapping(&quot;first-service&quot;)public class FirstServiceController &#123; @GetMapping(&quot;/welcome&quot;) public String welcome()&#123; return &quot;Welcome to the First Service&quot;; &#125;&#125; Second Serviceserver: port: 8082spring: application: name: my-first-serviceeureka: client: fetch-registry: false register-with-eureka: false @RestController@RequestMapping(&quot;second-service&quot;)public class SecondServiceController &#123; @GetMapping(&quot;/welcome&quot;) public String welcome()&#123; return &quot;Welcome to the Second service&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Gateway","slug":"Spring/Spring-Cloud/Gateway","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Gateway/"}],"tags":[]},{"title":"React Toast UI Editor 4 - 이미지 올리기","slug":"react/ToastUI/toastui-4","date":"2021-09-15T00:31:46.000Z","updated":"2024-11-23T16:46:03.959Z","comments":true,"path":"2021/09/15/react/ToastUI/toastui-4/","link":"","permalink":"https://ckck803.github.io/2021/09/15/react/ToastUI/toastui-4/","excerpt":"React Toast UI Editor 4 - 이미지 올리기Editor에서 이미지 업로드를 지원하다고 해서 이미지를 붙여 넣었더니 다음과 같이 이미지가 base64로 인코딩 돼 올라가는 것을 보고 살짝 당황했다. 어떻게 해야지 하면서 문득 생각이 들었던게 Markdown Editor를 사용하는 대표 블로그 사이트인 velog가 생각이 났다. 그래서 당장 velog로 가서 이미지를 올려보니! 다음과 같이 이미지가 저장된 URL을 가져오는 것을 확인 할 수 있었다. 아마 내부적으로 이미지가 들어오면 먼저 서버에 이미지를 저장하고 이미지가 저장된 경로를 받는 로직 같았다. 즉! 이미지를 업로드 하려면 이미지를 저장할 수 있는 서버를 준비해 연동할 필요가 있다는 것이다. Toast UI Editor에 Image 업로드 하기 위한 방법을 찾다 보니 처음에 연결된 Hook을 제거하고 새로운 Hook을 정의해 서버에 이미지를 올릴 수 있는 것을 알게 됐다. https://github.com/nhn/tui.editor/issues/1588 TOAST UI 에 Image Server 에 올리는 기능 구현import React, &#123; useRef, useEffect &#125; from &quot;react&quot;;import axios from &quot;axios&quot;;// Toast UI Editor 모듈 추가import &#123; Editor &#125; from &quot;@toast-ui/react-editor&quot;;import &quot;@toast-ui/editor/dist/toastui-editor.css&quot;;// SyntaxHighlight 모듈 추가import codeSyntaxHighlight from &quot;@toast-ui/editor-plugin-code-syntax-highlight/dist/toastui-editor-plugin-code-syntax-highlight-all.js&quot;;// prism 모듈 추가import &quot;prismjs/themes/prism.css&quot;;const Write = () =&gt; &#123; const editorRef = useRef(); const handleClick = () =&gt; &#123; console.log(editorRef.current.getInstance().getMarkdown()); &#125;; useEffect(() =&gt; &#123; if (editorRef.current) &#123; // 기존에 Image 를 Import 하는 Hook 을 제거한다. editorRef.current.getInstance().removeHook(&quot;addImageBlobHook&quot;); // 새롭게 Image 를 Import 하는 Hook 을 생성한다. editorRef.current .getInstance() .addHook(&quot;addImageBlobHook&quot;, (blob, callback) =&gt; &#123; (async () =&gt; &#123; let formData = new FormData(); formData.append(&quot;file&quot;, blob); console.log(&quot;이미지가 업로드 됐습니다.&quot;); const &#123; data: filename &#125; = await axios.post( &quot;/file/upload&quot;, formData, &#123; header: &#123; &quot;content-type&quot;: &quot;multipart/formdata&quot; &#125;, &#125; ); // .then((response) =&gt; &#123; // console.log(response); // &#125;); const imageUrl = &quot;http://localhost:8080/file/upload/&quot; + filename; // Image 를 가져올 수 있는 URL 을 callback 메서드에 넣어주면 자동으로 이미지를 가져온다. callback(imageUrl, &quot;iamge&quot;); &#125;)(); return false; &#125;); &#125; return () =&gt; &#123;&#125;; &#125;, [editorRef]); return ( &lt;div&gt; &lt;Editor initialValue=&quot;hello react editor world!&quot; previewStyle=&quot;vertical&quot; height=&quot;800px&quot; initialEditType=&quot;markdown&quot; useCommandShortcut=&#123;true&#125; ref=&#123;editorRef&#125; plugins=&#123;[codeSyntaxHighlight]&#125; /&gt; &lt;button onClick=&#123;handleClick&#125;&gt;Markdown 반환하기&lt;/button&gt; &lt;/div&gt; );&#125;;export default Write;","text":"React Toast UI Editor 4 - 이미지 올리기Editor에서 이미지 업로드를 지원하다고 해서 이미지를 붙여 넣었더니 다음과 같이 이미지가 base64로 인코딩 돼 올라가는 것을 보고 살짝 당황했다. 어떻게 해야지 하면서 문득 생각이 들었던게 Markdown Editor를 사용하는 대표 블로그 사이트인 velog가 생각이 났다. 그래서 당장 velog로 가서 이미지를 올려보니! 다음과 같이 이미지가 저장된 URL을 가져오는 것을 확인 할 수 있었다. 아마 내부적으로 이미지가 들어오면 먼저 서버에 이미지를 저장하고 이미지가 저장된 경로를 받는 로직 같았다. 즉! 이미지를 업로드 하려면 이미지를 저장할 수 있는 서버를 준비해 연동할 필요가 있다는 것이다. Toast UI Editor에 Image 업로드 하기 위한 방법을 찾다 보니 처음에 연결된 Hook을 제거하고 새로운 Hook을 정의해 서버에 이미지를 올릴 수 있는 것을 알게 됐다. https://github.com/nhn/tui.editor/issues/1588 TOAST UI 에 Image Server 에 올리는 기능 구현import React, &#123; useRef, useEffect &#125; from &quot;react&quot;;import axios from &quot;axios&quot;;// Toast UI Editor 모듈 추가import &#123; Editor &#125; from &quot;@toast-ui/react-editor&quot;;import &quot;@toast-ui/editor/dist/toastui-editor.css&quot;;// SyntaxHighlight 모듈 추가import codeSyntaxHighlight from &quot;@toast-ui/editor-plugin-code-syntax-highlight/dist/toastui-editor-plugin-code-syntax-highlight-all.js&quot;;// prism 모듈 추가import &quot;prismjs/themes/prism.css&quot;;const Write = () =&gt; &#123; const editorRef = useRef(); const handleClick = () =&gt; &#123; console.log(editorRef.current.getInstance().getMarkdown()); &#125;; useEffect(() =&gt; &#123; if (editorRef.current) &#123; // 기존에 Image 를 Import 하는 Hook 을 제거한다. editorRef.current.getInstance().removeHook(&quot;addImageBlobHook&quot;); // 새롭게 Image 를 Import 하는 Hook 을 생성한다. editorRef.current .getInstance() .addHook(&quot;addImageBlobHook&quot;, (blob, callback) =&gt; &#123; (async () =&gt; &#123; let formData = new FormData(); formData.append(&quot;file&quot;, blob); console.log(&quot;이미지가 업로드 됐습니다.&quot;); const &#123; data: filename &#125; = await axios.post( &quot;/file/upload&quot;, formData, &#123; header: &#123; &quot;content-type&quot;: &quot;multipart/formdata&quot; &#125;, &#125; ); // .then((response) =&gt; &#123; // console.log(response); // &#125;); const imageUrl = &quot;http://localhost:8080/file/upload/&quot; + filename; // Image 를 가져올 수 있는 URL 을 callback 메서드에 넣어주면 자동으로 이미지를 가져온다. callback(imageUrl, &quot;iamge&quot;); &#125;)(); return false; &#125;); &#125; return () =&gt; &#123;&#125;; &#125;, [editorRef]); return ( &lt;div&gt; &lt;Editor initialValue=&quot;hello react editor world!&quot; previewStyle=&quot;vertical&quot; height=&quot;800px&quot; initialEditType=&quot;markdown&quot; useCommandShortcut=&#123;true&#125; ref=&#123;editorRef&#125; plugins=&#123;[codeSyntaxHighlight]&#125; /&gt; &lt;button onClick=&#123;handleClick&#125;&gt;Markdown 반환하기&lt;/button&gt; &lt;/div&gt; );&#125;;export default Write; 이미지 업로드 서버 구현이미지 저장 API 구현 동일한 Image 명으로 인해 기존 이미지를 덮어쓰는 문제를 방지하기 위해 UUID 를 이용해 Image 를 저장한다. String filePath = &quot;/Users/dongwoo-yang/spring-file/&quot;;@PostMapping(&quot;/file/upload&quot;)public ResponseEntity upload(@RequestParam(&quot;file&quot;) MultipartFile multipartFile, HttpServletRequest request) throws IOException, URISyntaxException &#123; if(multipartFile.isEmpty())&#123; log.info(&quot;File is empty&quot;); &#125; String fullFilename = multipartFile.getOriginalFilename(); int lastIndex = fullFilename.lastIndexOf(&quot;.&quot;); String filename = fullFilename.substring(0, lastIndex); String ext = fullFilename.substring(lastIndex + 1); // 새로운 파일 이름 생성 String newName = UUID.randomUUID() + &quot;.&quot; + ext; String uploadPath = filePath + newName; // Path 객체를 이용해 저장 multipartFile.transferTo(Paths.get(uploadPath)); URI uri = new URI(request.getRequestURI()); return ResponseEntity.created(uri).body(newName);&#125; 저장된 이미지 불러오기 위한 API 구현 전달 받은 File 명을 이용해 서버에 저장된 이미지를 가져온 후 UrlResource 객체로 반환하면 브라우저에서 이미지를 확인할 수 있다. @ResponseBody@GetMapping(&quot;/file/upload/&#123;filename&#125;&quot;)public Resource downloadImage(@PathVariable String filename) throws MalformedURLException &#123; log.info(&quot;file: &#123;&#125;&quot;, filePath + filename); return new UrlResource(&quot;file:&quot; + filePath + filename);&#125; 이미지를 성공적으로 서버에 올리고 서버에 저장된 이미지를 가져오는 것을 확인할 수 있다.","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"ToastUI","slug":"Frontend/ToastUI","permalink":"https://ckck803.github.io/categories/Frontend/ToastUI/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"React Toast UI Editor 3 - 입력 내용 가져오기","slug":"react/ToastUI/toastui-3","date":"2021-09-14T23:31:46.000Z","updated":"2024-11-23T16:46:03.816Z","comments":true,"path":"2021/09/15/react/ToastUI/toastui-3/","link":"","permalink":"https://ckck803.github.io/2021/09/15/react/ToastUI/toastui-3/","excerpt":"React Toast UI Editor 3 - 입력 내용 가져오기Editor에 입력된 내용을 저장하고 관리하기 위해서는 입력된 값을 받아와야 한다. Toast UI Editor에서는 useRef를 이용해 const editorRef = useRef(); 버튼 Event Handler 만들기버튼을 만들어줘 버튼을 눌렀을 때 Editor에 입력된 내용을 반환해 주는 Evnet를 작성한다. 입력된 값을 받아올 때는 Ref 객체인 editorRef 를 이용해 Toast UI Editor 객체를 가져와 입력된 값을 받아올 수 있도록 한다. const handleClick = () =&gt; &#123; console.log(editorRef.current.getInstance().getMarkdown());&#125;; Button 클릭에 대한 이벤트 핸들러와 Editor 컴포넌트에 Ref 객체를 넣어준다. &lt;div&gt; &lt;Editor initialValue=&quot;hello react editor world!&quot; previewStyle=&quot;vertical&quot; height=&quot;600px&quot; initialEditType=&quot;markdown&quot; useCommandShortcut=&#123;true&#125; ref=&#123;editorRef&#125; plugins=&#123;[codeSyntaxHighlight]&#125; /&gt; &lt;button onClick=&#123;handleClick&#125;&gt;Markdown 반환하기&lt;/button&gt;&lt;/div&gt; 전체 소스","text":"React Toast UI Editor 3 - 입력 내용 가져오기Editor에 입력된 내용을 저장하고 관리하기 위해서는 입력된 값을 받아와야 한다. Toast UI Editor에서는 useRef를 이용해 const editorRef = useRef(); 버튼 Event Handler 만들기버튼을 만들어줘 버튼을 눌렀을 때 Editor에 입력된 내용을 반환해 주는 Evnet를 작성한다. 입력된 값을 받아올 때는 Ref 객체인 editorRef 를 이용해 Toast UI Editor 객체를 가져와 입력된 값을 받아올 수 있도록 한다. const handleClick = () =&gt; &#123; console.log(editorRef.current.getInstance().getMarkdown());&#125;; Button 클릭에 대한 이벤트 핸들러와 Editor 컴포넌트에 Ref 객체를 넣어준다. &lt;div&gt; &lt;Editor initialValue=&quot;hello react editor world!&quot; previewStyle=&quot;vertical&quot; height=&quot;600px&quot; initialEditType=&quot;markdown&quot; useCommandShortcut=&#123;true&#125; ref=&#123;editorRef&#125; plugins=&#123;[codeSyntaxHighlight]&#125; /&gt; &lt;button onClick=&#123;handleClick&#125;&gt;Markdown 반환하기&lt;/button&gt;&lt;/div&gt; 전체 소스import React, &#123; useRef &#125; from &quot;react&quot;;// Toast UI Editor 모듈 추가import &#123; Editor &#125; from &quot;@toast-ui/react-editor&quot;;import &quot;@toast-ui/editor/dist/toastui-editor.css&quot;;// SyntaxHighlight 모듈 추가import codeSyntaxHighlight from &quot;@toast-ui/editor-plugin-code-syntax-highlight/dist/toastui-editor-plugin-code-syntax-highlight-all.js&quot;;// prism 모듈 추가import &quot;prismjs/themes/prism.css&quot;;const Write = () =&gt; &#123; const editorRef = useRef(); const handleClick = () =&gt; &#123; console.log(editorRef.current.getInstance().getMarkdown()); &#125;; return ( &lt;div&gt; &lt;Editor initialValue=&quot;hello react editor world!&quot; previewStyle=&quot;vertical&quot; height=&quot;600px&quot; initialEditType=&quot;markdown&quot; useCommandShortcut=&#123;true&#125; ref=&#123;editorRef&#125; plugins=&#123;[codeSyntaxHighlight]&#125; /&gt; &lt;button onClick=&#123;handleClick&#125;&gt;Markdown 반환하기&lt;/button&gt; &lt;/div&gt; );&#125;;export default Write; Editor에 입력된 값들이 Markdown 반환하기 버튼을 누를 때마다 Console에 찍히는 것을 확인할 수 있다. https://github.com/nhn/tui.editor/tree/master/apps/react-editor","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"ToastUI","slug":"Frontend/ToastUI","permalink":"https://ckck803.github.io/categories/Frontend/ToastUI/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"React Toast UI Editor 2 - Syntax Highlight 적용하기","slug":"react/ToastUI/toastui-2","date":"2021-09-14T22:31:46.000Z","updated":"2024-11-23T16:46:03.700Z","comments":true,"path":"2021/09/15/react/ToastUI/toastui-2/","link":"","permalink":"https://ckck803.github.io/2021/09/15/react/ToastUI/toastui-2/","excerpt":"React로 Toast UI Editor 2 - Syntax Highlight 적용하기https://github.com/nhn/tui.editor/tree/master/plugins/code-syntax-highlight 글을 쓰다보면 Post에 코드를 같이 올릴 경우가 많은데, 초기 Setting은 Code Highlight가 적용돼 있지 않는 것을 확인할 수 있었다. 아무래도 Code Highlight가 없어서 코드를 작성하게 되면 가독성도 좀 떨어지고 Post 작성할 맛도 안나서 Editor에 Code Highlight를 적용하려고 한다. 패키지 추가yarn add @toast-ui/editor-plugin-code-syntax-highlightyarn add prism import React from &quot;react&quot;;// Toast UI Editor 모듈 추가import &#123; Editor &#125; from &quot;@toast-ui/react-editor&quot;;import &quot;@toast-ui/editor/dist/toastui-editor.css&quot;;// SyntaxHighlight 모듈 추가import codeSyntaxHighlight from &quot;@toast-ui/editor-plugin-code-syntax-highlight/dist/toastui-editor-plugin-code-syntax-highlight-all.js&quot;;// prism 모듈 추가import &quot;prismjs/themes/prism.css&quot;;const Write = () =&gt; &#123; return ( &lt;Editor initialValue=&quot;hello react editor world!&quot; previewStyle=&quot;vertical&quot; height=&quot;600px&quot; initialEditType=&quot;markdown&quot; useCommandShortcut=&#123;true&#125; plugins=&#123;[codeSyntaxHighlight]&#125; /&gt; );&#125;;export default Write; Code Highlight가 적용된 것을 확인할 수 있다. 덕분에 가독성도 훨씬 좋아져 점점 맘에 들기 시작했다.","text":"React로 Toast UI Editor 2 - Syntax Highlight 적용하기https://github.com/nhn/tui.editor/tree/master/plugins/code-syntax-highlight 글을 쓰다보면 Post에 코드를 같이 올릴 경우가 많은데, 초기 Setting은 Code Highlight가 적용돼 있지 않는 것을 확인할 수 있었다. 아무래도 Code Highlight가 없어서 코드를 작성하게 되면 가독성도 좀 떨어지고 Post 작성할 맛도 안나서 Editor에 Code Highlight를 적용하려고 한다. 패키지 추가yarn add @toast-ui/editor-plugin-code-syntax-highlightyarn add prism import React from &quot;react&quot;;// Toast UI Editor 모듈 추가import &#123; Editor &#125; from &quot;@toast-ui/react-editor&quot;;import &quot;@toast-ui/editor/dist/toastui-editor.css&quot;;// SyntaxHighlight 모듈 추가import codeSyntaxHighlight from &quot;@toast-ui/editor-plugin-code-syntax-highlight/dist/toastui-editor-plugin-code-syntax-highlight-all.js&quot;;// prism 모듈 추가import &quot;prismjs/themes/prism.css&quot;;const Write = () =&gt; &#123; return ( &lt;Editor initialValue=&quot;hello react editor world!&quot; previewStyle=&quot;vertical&quot; height=&quot;600px&quot; initialEditType=&quot;markdown&quot; useCommandShortcut=&#123;true&#125; plugins=&#123;[codeSyntaxHighlight]&#125; /&gt; );&#125;;export default Write; Code Highlight가 적용된 것을 확인할 수 있다. 덕분에 가독성도 훨씬 좋아져 점점 맘에 들기 시작했다.","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"ToastUI","slug":"Frontend/ToastUI","permalink":"https://ckck803.github.io/categories/Frontend/ToastUI/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"React로 Toast UI Editor 사용해보기","slug":"react/ToastUI/toastui-1","date":"2021-09-14T21:31:46.000Z","updated":"2024-11-23T16:46:03.901Z","comments":true,"path":"2021/09/15/react/ToastUI/toastui-1/","link":"","permalink":"https://ckck803.github.io/2021/09/15/react/ToastUI/toastui-1/","excerpt":"React로 Toast UI Editor 사용해보기개인 프로젝트도 하고 싶고 나만의 블로그를 만들고 싶은 마음에 UI도 찾아보고 Editor도 찾고 있었었다. 개인적으로 Editor를 찾고 있던 기준은 첫번째는 Markdown 언어가 사용 가능해야 하고 두번째는 이미지 업로드가 가능한 Editor를 찾고 있던 와중에 NHN에서 제공하는 Toast UI Editor를 찾게 됐다. 기능들이 너무너무 맘에 들어 사용해보기로 했다. Toast UI Editor에서는 내가 가장 원했던 Markdown 문법이 사용 가능 했고, 이미지 업로드도 가능 했다.!!! 그리고 코드블럭에 마음에 드는 Syntax Highlighter를 적용할 수 있는 장점과 다양한 기능들이 있어 너무나도 맘에 들었다. 플러그인 설치하기yarn add @toast-ui/react-editor Write.jsx import React from &quot;react&quot;;import &#123; Editor &#125; from &quot;@toast-ui/react-editor&quot;;import &quot;@toast-ui/editor/dist/toastui-editor.css&quot;;const Write = () =&gt; &#123; return ( &lt;Editor initialValue=&quot;hello react editor world!&quot; previewStyle=&quot;vertical&quot; height=&quot;600px&quot; initialEditType=&quot;markdown&quot; useCommandShortcut=&#123;true&#125; /&gt; );&#125;;export default Write; 마지막으로 App.js에 새로만든 Write.jsx 컴포넌트를 추가하면 화면에서 Toast UI가 나타나는 것을 확인할 수 있다.","text":"React로 Toast UI Editor 사용해보기개인 프로젝트도 하고 싶고 나만의 블로그를 만들고 싶은 마음에 UI도 찾아보고 Editor도 찾고 있었었다. 개인적으로 Editor를 찾고 있던 기준은 첫번째는 Markdown 언어가 사용 가능해야 하고 두번째는 이미지 업로드가 가능한 Editor를 찾고 있던 와중에 NHN에서 제공하는 Toast UI Editor를 찾게 됐다. 기능들이 너무너무 맘에 들어 사용해보기로 했다. Toast UI Editor에서는 내가 가장 원했던 Markdown 문법이 사용 가능 했고, 이미지 업로드도 가능 했다.!!! 그리고 코드블럭에 마음에 드는 Syntax Highlighter를 적용할 수 있는 장점과 다양한 기능들이 있어 너무나도 맘에 들었다. 플러그인 설치하기yarn add @toast-ui/react-editor Write.jsx import React from &quot;react&quot;;import &#123; Editor &#125; from &quot;@toast-ui/react-editor&quot;;import &quot;@toast-ui/editor/dist/toastui-editor.css&quot;;const Write = () =&gt; &#123; return ( &lt;Editor initialValue=&quot;hello react editor world!&quot; previewStyle=&quot;vertical&quot; height=&quot;600px&quot; initialEditType=&quot;markdown&quot; useCommandShortcut=&#123;true&#125; /&gt; );&#125;;export default Write; 마지막으로 App.js에 새로만든 Write.jsx 컴포넌트를 추가하면 화면에서 Toast UI가 나타나는 것을 확인할 수 있다. App.js import Write from &#x27;./Write&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;Write /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;export default App; 하단에 고정시키기상단에 있으면 네비게이션바나 POST 제목을 추가하기 불편해 상단에 고정돼 있는 Editor를 하단으로 내려서 사용할 것이다. style 옵션을 통해 Toast UI Editor를 하단에 고정시킬 수 있다 import Write from &#x27;./Write&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;div style=&#123;&#123; position: &quot;fixed&quot;, bottom: &quot;0&quot;, width: &quot;100%&quot; &#125;&#125;&gt; &lt;Write /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;export default App;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"ToastUI","slug":"Frontend/ToastUI","permalink":"https://ckck803.github.io/categories/Frontend/ToastUI/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"}]},{"title":"JPA 프로그래밍(기본편) 2 - JPA 설정하기","slug":"jpa/jpa-programming/jpa-2","date":"2021-09-10T20:31:46.000Z","updated":"2024-02-18T16:19:54.528Z","comments":true,"path":"2021/09/11/jpa/jpa-programming/jpa-2/","link":"","permalink":"https://ckck803.github.io/2021/09/11/jpa/jpa-programming/jpa-2/","excerpt":"JPA 프로그래밍(기본편) 2 - JPA 설정하기Entity 생성하기Entity 어노테이션을 통해 JPA가 관리하는 객체임을 명시해준다. @Entitypublic class Member &#123; @Id private long id; private String name; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; EntityManagerFactory 생성하기 JPA를 사용하기 위해 persistence.xml에 JPA 설정 정보를 넣어 줬다. 해당 정보를 사용하기 위해서 EntityManagerFactory를 생성해주도록 한다. EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager 생성하기EntityManagerFactory를 이용해 EntityManager를 생성해준다.","text":"JPA 프로그래밍(기본편) 2 - JPA 설정하기Entity 생성하기Entity 어노테이션을 통해 JPA가 관리하는 객체임을 명시해준다. @Entitypublic class Member &#123; @Id private long id; private String name; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; EntityManagerFactory 생성하기 JPA를 사용하기 위해 persistence.xml에 JPA 설정 정보를 넣어 줬다. 해당 정보를 사용하기 위해서 EntityManagerFactory를 생성해주도록 한다. EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager 생성하기EntityManagerFactory를 이용해 EntityManager를 생성해준다. // EntityManager를 생성한다.EntityManager entityManager = entityManagerFactory.createEntityManager(); 트랜잭션 생성하기JPA에서 데이터를 변경하는 모든 작업은 트랜잭션 안에서 작업을 진행해야 한다. // 트랜잭션을 생성한다.EntityTransaction transaction = entityManager.getTransaction(); 데이터 저장하기 (Create)새로운 Member 객체를 생성하고 EntityManager의 persist 메소드를 통해 영속성 컨텍스트에 저장해준다. Member member = new Member();member.setId(1L);member.setName(&quot;HelloA&quot;);// 영속성 컨텍스트에 저장한다.entityManager.persist(member); 데이터 조회하기 (Read)저장된 데이터를 조회하기 위해서는 EntityManager의 find 메소드를 이용해 DB에서 저장된 데이터를 불러온다. Member findMember = entityManager.find(Member.class, 1L); 데이터 수정하기 (Update)저장된 데이터를 수정하기 위해서는 EntityManager의 find 메소드를 이용해 DB에서 저장된 데이터를 불러오고 정보를 수정해준다. 정보 수정이 끝난 후 persist 메소드를 사용하지 않아도 JPA의 변경 감지를 통해 update가 이뤄진다. Member findMember = entityManager.find(Member.class, 1L);findMember.setName(&quot;HelloJPA&quot;); 데이터 삭제하기\u001e (Delete)저장된 데이터를 삭제하기 위해서는 EntityManager의 find 메소드를 이용해 DB에서 저장된 데이터를 불러오고 remove 메소드를 사용해 데이터를 삭제해 준다. Member findMember = entityManager.find(Member.class, 1L);entityManager.remove(findMember); JPQL을 이용해 특정 쿼리 작성하기JPA에서 제공해주는 기본적인 쿼리문외에 다른 여러가지 쿼리를 작성하고 싶은 경우에는 EntityManager에서 제공하는 CreateQuery 메소드를 통해 쿼리를 작성할 수 있다. 이를 JPQL이라 하고 JPQL은 객체를 대상으로 쿼리를 만들어준다. List&lt;Member&gt; result = entityManager.createQuery(&quot;select m from Member as m&quot;, Member.class) .setFirstResult(5) .setMaxResults(10) .getResultList(); public class JpaMain &#123; public static void main(String[] ars) &#123; // persistence.xml을 이용해 // EntityManagerFactory를 생성한다. EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;hello&quot;); // EntityManager를 생성한다. EntityManager entityManager = entityManagerFactory.createEntityManager(); // 트랜잭션을 생성한다. EntityTransaction transaction = entityManager.getTransaction(); // JPA에서 데이터를 변경하는 모든 작업은 트랜잭션 내에서 이루어져야 한다. transaction.begin(); try &#123; Member member = new Member(); member.setId(1L); member.setName(&quot;HelloA&quot;); List&lt;Member&gt; result = entityManager.createQuery(&quot;select m from Member as m&quot;, Member.class) .setFirstResult(5) .setMaxResults(10) .getResultList(); // 영속성 컨텍스트에 저장한다. entityManager.persist(member); // DB에 변경사항을 반영한다. transaction.commit(); &#125; catch (Exception e) &#123; transaction.rollback(); &#125; finally &#123; // EntityManager를 종료시킨다. entityManager.close(); &#125; // EntityManagerFactory를 종료시킨다. entityManagerFactory.close(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"JPA 프로그래밍(기본편) 1 - JPA 설정하기","slug":"jpa/jpa-programming/jpa-1","date":"2021-09-10T19:31:46.000Z","updated":"2024-02-18T16:19:54.528Z","comments":true,"path":"2021/09/11/jpa/jpa-programming/jpa-1/","link":"","permalink":"https://ckck803.github.io/2021/09/11/jpa/jpa-programming/jpa-1/","excerpt":"JPA 프로그래밍(기본편) 1 - JPA 설정하기의존성 추가하기JPA를 사용하기 위해서 JPA를 구현한 hibernate 라이브러리를 사용한다. DB로는 메모리 DB인 H2 DataBase를 사용하도록 한다. &lt;!-- JPA 하이버네이트 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;5.3.10.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- H2 데이터베이스 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.200&lt;/version&gt;&lt;/dependency&gt; JPA Setting 하기resource&#x2F;META-INF&#x2F;persistence.xml JPA 표준 문법 설정 javax.persistence.jdbc.driver : 사용하고자 하는 DB 드라이버를 설정한다. javax.persistence.jdbc.user : DB에 접근하기 위한 Username javax.persistence.jdbc.password : DB에 접근하기 위한 Password javax.persistence.jdbc.url : 접근하고자 하는 DataBase 경로 hibernate 전용 문법 설정","text":"JPA 프로그래밍(기본편) 1 - JPA 설정하기의존성 추가하기JPA를 사용하기 위해서 JPA를 구현한 hibernate 라이브러리를 사용한다. DB로는 메모리 DB인 H2 DataBase를 사용하도록 한다. &lt;!-- JPA 하이버네이트 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;5.3.10.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- H2 데이터베이스 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.200&lt;/version&gt;&lt;/dependency&gt; JPA Setting 하기resource&#x2F;META-INF&#x2F;persistence.xml JPA 표준 문법 설정 javax.persistence.jdbc.driver : 사용하고자 하는 DB 드라이버를 설정한다. javax.persistence.jdbc.user : DB에 접근하기 위한 Username javax.persistence.jdbc.password : DB에 접근하기 위한 Password javax.persistence.jdbc.url : 접근하고자 하는 DataBase 경로 hibernate 전용 문법 설정 hibernate.dialect : DB에서 사용하는 SQL 문법을 적용한다.(DB마다 약간씩 차이가 존재) hibernate.show_sql : hibernate에서 만들어주는 쿼리문을 볼 수 있도록 설정한다. hibernate.format_sql : hibernate에서 보여주는 쿼리문을 보기 좋게 포멧팅 해준다. hibernate.use_sql_comments : 어떤 객체를 사용해 작업을 진행하는지 확인할 수 있다.(디버깅시 용이) hibernate.hbm2ddl.auto : 프로젝트가 실행될 때 자동으로 DDL을 생성할지에 대한 설정을 해준다. persistence.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;persistence version=&quot;2.2&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot;&gt; &lt;persistence-unit name=&quot;hello&quot;&gt; &lt;properties&gt; &lt;!-- 필수 속성 --&gt; &lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;org.h2.Driver&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;sa&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:h2:tcp://localhost/~/test&quot;/&gt; &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&gt; &lt;!-- 옵션 --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.use_sql_comments&quot; value=&quot;true&quot;/&gt; &lt;!--&lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot; /&gt;--&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"리엑트 로그인 페이지 만들기","slug":"react/login/login","date":"2021-09-10T11:10:40.000Z","updated":"2024-11-23T16:46:04.576Z","comments":true,"path":"2021/09/10/react/login/login/","link":"","permalink":"https://ckck803.github.io/2021/09/10/react/login/login/","excerpt":"리엑트 로그인 페이지 만들기import React, &#123; useState, useCallback &#125; from &quot;react&quot;;import styled from &quot;styled-components&quot;;import axios from &quot;axios&quot;;const LoginFragment = styled.div` display:flex; justify-content:center; align-items:center; width:400px; height:400px; position: relative; /* 추후 박스 하단에 추가 버튼을 위치시키기 위한 설정 */ background: white; border-radius: 16px; box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.04); margin: 0 auto;`;const LoginInputs = () =&gt; &#123; const [id, setId] = useState(&quot;&quot;); const [password, setPassword] = useState(&quot;&quot;); const onChangeId = useCallback((e) =&gt; &#123; setId(e.target.value); &#125;, []); const onChangePassword = useCallback((e) =&gt; &#123; setPassword(e.target.value); &#125;, []); const onSubmit = useCallback((e) =&gt; &#123; e.preventDefault(); let data = &#123; username: id, password: password, &#125; console.log(data); axios.post(&quot;/api/users/login&quot;, data) .then((response =&gt; &#123; console.log(response.data) &#125;)); &#125;, [id, password]) return ( &lt;LoginFragment&gt; &lt;form style= &#123;&#123; display: &quot;flex&quot;, flexDirection: &quot;column&quot;, &#125;&#125; onSubmit=&#123;onSubmit&#125; &gt; &lt;label htmlFor=&quot;user-id&quot;&gt;아이디&lt;/label&gt; &lt;input name=&quot;user-id&quot; value=&#123;id&#125; onChange=&#123;onChangeId&#125; /&gt; &lt;label htmlFor=&quot;user-password&quot;&gt;비밀번호&lt;/label&gt; &lt;input name=&quot;user-password&quot; type=&quot;password&quot; value=&#123;password&#125; onChange=&#123;onChangePassword&#125; /&gt; &lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;로그인&lt;/button&gt; &lt;/form&gt; &lt;/LoginFragment &gt; )&#125;export default LoginInputs; import React from &quot;react&quot;import &#123; styled, createGlobalStyle &#125; from &quot;styled-components&quot;;import LoginInputs from &quot;./components/LoginInputs&quot;;const GlobalStyle = createGlobalStyle` body &#123; background: #e9ecef; &#125;`;function App() &#123; return ( &lt;div&gt; &lt;GlobalStyle /&gt; &lt;LoginInputs /&gt; &lt;/div&gt; )&#125;export default App; CORS 해결하기const &#123; createProxyMiddleware &#125; = require(&quot;http-proxy-middleware&quot;);module.exports = (app) =&gt; &#123; app.use( &quot;/api&quot;, createProxyMiddleware(&#123; target: &quot;http://localhost:8080&quot;, changeOrigin: true, &#125;) );&#125;;","text":"리엑트 로그인 페이지 만들기import React, &#123; useState, useCallback &#125; from &quot;react&quot;;import styled from &quot;styled-components&quot;;import axios from &quot;axios&quot;;const LoginFragment = styled.div` display:flex; justify-content:center; align-items:center; width:400px; height:400px; position: relative; /* 추후 박스 하단에 추가 버튼을 위치시키기 위한 설정 */ background: white; border-radius: 16px; box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.04); margin: 0 auto;`;const LoginInputs = () =&gt; &#123; const [id, setId] = useState(&quot;&quot;); const [password, setPassword] = useState(&quot;&quot;); const onChangeId = useCallback((e) =&gt; &#123; setId(e.target.value); &#125;, []); const onChangePassword = useCallback((e) =&gt; &#123; setPassword(e.target.value); &#125;, []); const onSubmit = useCallback((e) =&gt; &#123; e.preventDefault(); let data = &#123; username: id, password: password, &#125; console.log(data); axios.post(&quot;/api/users/login&quot;, data) .then((response =&gt; &#123; console.log(response.data) &#125;)); &#125;, [id, password]) return ( &lt;LoginFragment&gt; &lt;form style= &#123;&#123; display: &quot;flex&quot;, flexDirection: &quot;column&quot;, &#125;&#125; onSubmit=&#123;onSubmit&#125; &gt; &lt;label htmlFor=&quot;user-id&quot;&gt;아이디&lt;/label&gt; &lt;input name=&quot;user-id&quot; value=&#123;id&#125; onChange=&#123;onChangeId&#125; /&gt; &lt;label htmlFor=&quot;user-password&quot;&gt;비밀번호&lt;/label&gt; &lt;input name=&quot;user-password&quot; type=&quot;password&quot; value=&#123;password&#125; onChange=&#123;onChangePassword&#125; /&gt; &lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;로그인&lt;/button&gt; &lt;/form&gt; &lt;/LoginFragment &gt; )&#125;export default LoginInputs; import React from &quot;react&quot;import &#123; styled, createGlobalStyle &#125; from &quot;styled-components&quot;;import LoginInputs from &quot;./components/LoginInputs&quot;;const GlobalStyle = createGlobalStyle` body &#123; background: #e9ecef; &#125;`;function App() &#123; return ( &lt;div&gt; &lt;GlobalStyle /&gt; &lt;LoginInputs /&gt; &lt;/div&gt; )&#125;export default App; CORS 해결하기const &#123; createProxyMiddleware &#125; = require(&quot;http-proxy-middleware&quot;);module.exports = (app) =&gt; &#123; app.use( &quot;/api&quot;, createProxyMiddleware(&#123; target: &quot;http://localhost:8080&quot;, changeOrigin: true, &#125;) );&#125;;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"로그인","slug":"Frontend/로그인","permalink":"https://ckck803.github.io/categories/Frontend/%EB%A1%9C%EA%B7%B8%EC%9D%B8/"}],"tags":[]},{"title":"리엑트 Todo List 만들기 3 - Context API를 이용해 상태 관리하기","slug":"react/todolist/todolist-3","date":"2021-09-09T11:10:40.000Z","updated":"2024-11-23T16:52:20.124Z","comments":true,"path":"2021/09/09/react/todolist/todolist-3/","link":"","permalink":"https://ckck803.github.io/2021/09/09/react/todolist/todolist-3/","excerpt":"리엑트 Todo List 만들기 3 - Context API를 이용해 상태 관리하기 리엑트 Todo List 만들기 2 - 리스트 항목 만들기 리엑트 Todo List 만들기 1 - 기본 템플릿 만들기 리엑트 Todo List 만들기 3 - Context API를 이용해 상태 관리하기Context API 사용 설정하기Reducer 생성function todoReducer(state, action) &#123; switch (action.type) &#123; case &quot;CREATE&quot;: return state.concat(action.todo); case &quot;TOGGLE&quot;: return state.map((todo) =&gt; todo.id === action.id ? &#123; ...todo, done: !todo.done &#125; : todo ); case &quot;REMOVE&quot;: return state.filter((todo) =&gt; todo.id !== action.id); default: throw new Error(`Unhandled action type: $&#123;action.type&#125;`); &#125;&#125; Conext API 적용하기const TodoStateContext = createContext();const TodoDispatchContext = createContext();const TodoNextIdContext = createContext();export function TodoProvider(&#123; children &#125;) &#123; const [state, dispatch] = useReducer(todoReducer, initialTodos); const nextId = useRef(5); return ( &lt;TodoStateContext.Provider value=&#123;state&#125;&gt; &lt;TodoDispatchContext.Provider value=&#123;dispatch&#125;&gt; &lt;TodoNextIdContext.Provider value=&#123;nextId&#125;&gt; &#123;children&#125; &lt;/TodoNextIdContext.Provider&gt; &lt;/TodoDispatchContext.Provider&gt; &lt;/TodoStateContext.Provider&gt; );&#125; Context 사용을 위한 Custom Hook 생성export function useTodoState() &#123; return useContext(TodoStateContext);&#125;export function useTodoDispatch() &#123; return useContext(TodoDispatchContext);&#125;export function useTodoNextId() &#123; return useContext(TodoNextIdContext);&#125;","text":"리엑트 Todo List 만들기 3 - Context API를 이용해 상태 관리하기 리엑트 Todo List 만들기 2 - 리스트 항목 만들기 리엑트 Todo List 만들기 1 - 기본 템플릿 만들기 리엑트 Todo List 만들기 3 - Context API를 이용해 상태 관리하기Context API 사용 설정하기Reducer 생성function todoReducer(state, action) &#123; switch (action.type) &#123; case &quot;CREATE&quot;: return state.concat(action.todo); case &quot;TOGGLE&quot;: return state.map((todo) =&gt; todo.id === action.id ? &#123; ...todo, done: !todo.done &#125; : todo ); case &quot;REMOVE&quot;: return state.filter((todo) =&gt; todo.id !== action.id); default: throw new Error(`Unhandled action type: $&#123;action.type&#125;`); &#125;&#125; Conext API 적용하기const TodoStateContext = createContext();const TodoDispatchContext = createContext();const TodoNextIdContext = createContext();export function TodoProvider(&#123; children &#125;) &#123; const [state, dispatch] = useReducer(todoReducer, initialTodos); const nextId = useRef(5); return ( &lt;TodoStateContext.Provider value=&#123;state&#125;&gt; &lt;TodoDispatchContext.Provider value=&#123;dispatch&#125;&gt; &lt;TodoNextIdContext.Provider value=&#123;nextId&#125;&gt; &#123;children&#125; &lt;/TodoNextIdContext.Provider&gt; &lt;/TodoDispatchContext.Provider&gt; &lt;/TodoStateContext.Provider&gt; );&#125; Context 사용을 위한 Custom Hook 생성export function useTodoState() &#123; return useContext(TodoStateContext);&#125;export function useTodoDispatch() &#123; return useContext(TodoDispatchContext);&#125;export function useTodoNextId() &#123; return useContext(TodoNextIdContext);&#125; TodoContext.js import React, &#123; useReducer, createContext, useContext, useRef &#125; from &quot;react&quot;;const initialTodos = [ &#123; id: 1, text: &quot;프로젝트 생성하기&quot;, done: true, &#125;, &#123; id: 2, text: &quot;컴포넌트 스타일링하기&quot;, done: true, &#125;, &#123; id: 3, text: &quot;Context 만들기&quot;, done: false, &#125;, &#123; id: 4, text: &quot;기능 구현하기&quot;, done: false, &#125;,];function todoReducer(state, action) &#123; switch (action.type) &#123; case &quot;CREATE&quot;: return state.concat(action.todo); case &quot;TOGGLE&quot;: return state.map((todo) =&gt; todo.id === action.id ? &#123; ...todo, done: !todo.done &#125; : todo ); case &quot;REMOVE&quot;: return state.filter((todo) =&gt; todo.id !== action.id); default: throw new Error(`Unhandled action type: $&#123;action.type&#125;`); &#125;&#125;const TodoStateContext = createContext();const TodoDispatchContext = createContext();const TodoNextIdContext = createContext();export function TodoProvider(&#123; children &#125;) &#123; const [state, dispatch] = useReducer(todoReducer, initialTodos); const nextId = useRef(5); return ( &lt;TodoStateContext.Provider value=&#123;state&#125;&gt; &lt;TodoDispatchContext.Provider value=&#123;dispatch&#125;&gt; &lt;TodoNextIdContext.Provider value=&#123;nextId&#125;&gt; &#123;children&#125; &lt;/TodoNextIdContext.Provider&gt; &lt;/TodoDispatchContext.Provider&gt; &lt;/TodoStateContext.Provider&gt; );&#125;export function useTodoState() &#123; return useContext(TodoStateContext);&#125;export function useTodoDispatch() &#123; return useContext(TodoDispatchContext);&#125;export function useTodoNextId() &#123; return useContext(TodoNextIdContext);&#125; Context API 적용하기App.js import React from &quot;react&quot;;import &#123; createGlobalStyle &#125; from &quot;styled-components&quot;;import TodoTemplate from &quot;./components/TodoTemplate&quot;;import TodoHead from &quot;./components/TodoHead&quot;;import TodoList from &quot;./components/TodoList&quot;;import TodoCreate from &quot;./components/TodoCreate&quot;;import &#123; TodoProvider &#125; from &quot;./TodoContext&quot;;const GlobalStyle = createGlobalStyle` body &#123; background: #e9ecef; &#125;`;function App() &#123; return ( &lt;TodoProvider&gt; &lt;GlobalStyle /&gt; &lt;TodoTemplate&gt; &lt;TodoHead /&gt; &lt;TodoList /&gt; &lt;TodoCreate /&gt; &lt;/TodoTemplate&gt; &lt;/TodoProvider&gt; );&#125;export default App;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"To do List","slug":"Frontend/To-do-List","permalink":"https://ckck803.github.io/categories/Frontend/To-do-List/"}],"tags":[]},{"title":"리엑트 Todo List 만들기 2 - 리스트 항목 만들기","slug":"react/todolist/todolist-2","date":"2021-09-08T11:10:40.000Z","updated":"2024-11-23T16:52:16.322Z","comments":true,"path":"2021/09/08/react/todolist/todolist-2/","link":"","permalink":"https://ckck803.github.io/2021/09/08/react/todolist/todolist-2/","excerpt":"리엑트 Todo List 만들기 3 - Context API를 이용해 상태 관리하기 리엑트 Todo List 만들기 2 - 리스트 항목 만들기 리엑트 Todo List 만들기 1 - 기본 템플릿 만들기 리엑트 Todo List 만들기 2- 리스트 항목 만들기 TodoCreate.js import React, &#123; useState &#125; from &#x27;react&#x27;;import styled, &#123; css &#125; from &#x27;styled-components&#x27;;import &#123; MdAdd &#125; from &#x27;react-icons/md&#x27;;const CircleButton = styled.button` background: #38d9a9; &amp;:hover &#123; background: #63e6be; &#125; &amp;:active &#123; background: #20c997; &#125; z-index: 5; cursor: pointer; width: 80px; height: 80px; display: block; align-items: center; justify-content: center; font-size: 60px; position: absolute; left: 50%; bottom: 0px; transform: translate(-50%, 50%); color: white; border-radius: 50%; border: none; outline: none; display: flex; align-items: center; justify-content: center; transition: 0.125s all ease-in; $&#123;props =&gt; props.open &amp;&amp; css` background: #ff6b6b; &amp;:hover &#123; background: #ff8787; &#125; &amp;:active &#123; background: #fa5252; &#125; transform: translate(-50%, 50%) rotate(45deg); `&#125;`;const InsertFormPositioner = styled.div` width: 100%; bottom: 0; left: 0; position: absolute;`;const InsertForm = styled.form` background: #f8f9fa; padding-left: 32px; padding-top: 32px; padding-right: 32px; padding-bottom: 72px; border-bottom-left-radius: 16px; border-bottom-right-radius: 16px; border-top: 1px solid #e9ecef;`;const Input = styled.input` padding: 12px; border-radius: 4px; border: 1px solid #dee2e6; width: 100%; outline: none; font-size: 18px; box-sizing: border-box;`;function TodoCreate() &#123; const [open, setOpen] = useState(false); const onToggle = () =&gt; setOpen(!open); const isOpen = (open) =&gt;&#123; if(open)&#123; return( &lt;InsertFormPositioner&gt; &lt;InsertForm&gt; &lt;Input autoFocus placeholder=&quot;할 일을 입력 후, Enter 를 누르세요&quot; /&gt; &lt;/InsertForm&gt; &lt;/InsertFormPositioner&gt;) &#125;else&#123; return null; &#125; &#125; return ( &lt;div&gt; &#123;isOpen(open)&#125; &lt;CircleButton onClick=&#123;onToggle&#125; open=&#123;open&#125;&gt; &lt;MdAdd /&gt; &lt;/CircleButton&gt; &lt;/div&gt; );&#125;export default TodoCreate; TodoItem.js import React from &quot;react&quot;;import styled, &#123; css &#125; from &quot;styled-components&quot;;import &#123; MdDone, MdDelete &#125; from &quot;react-icons/md&quot;;import &#123; useTodoDispatch &#125; from &quot;../TodoContext&quot;;const Remove = styled.div` display: flex; align-items: center; justify-content: center; color: #dee2e6; font-size: 24px; cursor: pointer; opacity: 0; &amp;:hover &#123; color: #ff6b6b; &#125;`;const TodoItemBlock = styled.div` display: flex; align-items: center; padding-top: 12px; padding-bottom: 12px; &amp;:hover &#123; $&#123;Remove&#125; &#123; opacity: 1; &#125; &#125;`;const CheckCircle = styled.div` width: 32px; height: 32px; border-radius: 16px; border: 1px solid #ced4da; font-size: 24px; display: flex; align-items: center; justify-content: center; margin-right: 20px; cursor: pointer; $&#123;(props) =&gt; props.done &amp;&amp; css` border: 1px solid #38d9a9; color: #38d9a9; `&#125;`;const Text = styled.div` flex: 1; font-size: 21px; color: #495057; $&#123;(props) =&gt; props.done &amp;&amp; css` color: #ced4da; `&#125;`;function TodoItem(&#123; id, done, text &#125;) &#123; const dispatch = useTodoDispatch(); const onToggle = () =&gt; dispatch(&#123; type: &quot;TOGGLE&quot;, id &#125;); const onRemove = () =&gt; dispatch(&#123; type: &quot;REMOVE&quot;, id &#125;); return ( &lt;TodoItemBlock&gt; &lt;CheckCircle done=&#123;done&#125; onClick=&#123;onToggle&#125;&gt; &#123;done &amp;&amp; &lt;MdDone /&gt;&#125; &lt;/CheckCircle&gt; &lt;Text done=&#123;done&#125;&gt;&#123;text&#125;&lt;/Text&gt; &lt;Remove onClick=&#123;onRemove&#125;&gt; &lt;MdDelete /&gt; &lt;/Remove&gt; &lt;/TodoItemBlock&gt; );&#125;export default TodoItem;","text":"리엑트 Todo List 만들기 3 - Context API를 이용해 상태 관리하기 리엑트 Todo List 만들기 2 - 리스트 항목 만들기 리엑트 Todo List 만들기 1 - 기본 템플릿 만들기 리엑트 Todo List 만들기 2- 리스트 항목 만들기 TodoCreate.js import React, &#123; useState &#125; from &#x27;react&#x27;;import styled, &#123; css &#125; from &#x27;styled-components&#x27;;import &#123; MdAdd &#125; from &#x27;react-icons/md&#x27;;const CircleButton = styled.button` background: #38d9a9; &amp;:hover &#123; background: #63e6be; &#125; &amp;:active &#123; background: #20c997; &#125; z-index: 5; cursor: pointer; width: 80px; height: 80px; display: block; align-items: center; justify-content: center; font-size: 60px; position: absolute; left: 50%; bottom: 0px; transform: translate(-50%, 50%); color: white; border-radius: 50%; border: none; outline: none; display: flex; align-items: center; justify-content: center; transition: 0.125s all ease-in; $&#123;props =&gt; props.open &amp;&amp; css` background: #ff6b6b; &amp;:hover &#123; background: #ff8787; &#125; &amp;:active &#123; background: #fa5252; &#125; transform: translate(-50%, 50%) rotate(45deg); `&#125;`;const InsertFormPositioner = styled.div` width: 100%; bottom: 0; left: 0; position: absolute;`;const InsertForm = styled.form` background: #f8f9fa; padding-left: 32px; padding-top: 32px; padding-right: 32px; padding-bottom: 72px; border-bottom-left-radius: 16px; border-bottom-right-radius: 16px; border-top: 1px solid #e9ecef;`;const Input = styled.input` padding: 12px; border-radius: 4px; border: 1px solid #dee2e6; width: 100%; outline: none; font-size: 18px; box-sizing: border-box;`;function TodoCreate() &#123; const [open, setOpen] = useState(false); const onToggle = () =&gt; setOpen(!open); const isOpen = (open) =&gt;&#123; if(open)&#123; return( &lt;InsertFormPositioner&gt; &lt;InsertForm&gt; &lt;Input autoFocus placeholder=&quot;할 일을 입력 후, Enter 를 누르세요&quot; /&gt; &lt;/InsertForm&gt; &lt;/InsertFormPositioner&gt;) &#125;else&#123; return null; &#125; &#125; return ( &lt;div&gt; &#123;isOpen(open)&#125; &lt;CircleButton onClick=&#123;onToggle&#125; open=&#123;open&#125;&gt; &lt;MdAdd /&gt; &lt;/CircleButton&gt; &lt;/div&gt; );&#125;export default TodoCreate; TodoItem.js import React from &quot;react&quot;;import styled, &#123; css &#125; from &quot;styled-components&quot;;import &#123; MdDone, MdDelete &#125; from &quot;react-icons/md&quot;;import &#123; useTodoDispatch &#125; from &quot;../TodoContext&quot;;const Remove = styled.div` display: flex; align-items: center; justify-content: center; color: #dee2e6; font-size: 24px; cursor: pointer; opacity: 0; &amp;:hover &#123; color: #ff6b6b; &#125;`;const TodoItemBlock = styled.div` display: flex; align-items: center; padding-top: 12px; padding-bottom: 12px; &amp;:hover &#123; $&#123;Remove&#125; &#123; opacity: 1; &#125; &#125;`;const CheckCircle = styled.div` width: 32px; height: 32px; border-radius: 16px; border: 1px solid #ced4da; font-size: 24px; display: flex; align-items: center; justify-content: center; margin-right: 20px; cursor: pointer; $&#123;(props) =&gt; props.done &amp;&amp; css` border: 1px solid #38d9a9; color: #38d9a9; `&#125;`;const Text = styled.div` flex: 1; font-size: 21px; color: #495057; $&#123;(props) =&gt; props.done &amp;&amp; css` color: #ced4da; `&#125;`;function TodoItem(&#123; id, done, text &#125;) &#123; const dispatch = useTodoDispatch(); const onToggle = () =&gt; dispatch(&#123; type: &quot;TOGGLE&quot;, id &#125;); const onRemove = () =&gt; dispatch(&#123; type: &quot;REMOVE&quot;, id &#125;); return ( &lt;TodoItemBlock&gt; &lt;CheckCircle done=&#123;done&#125; onClick=&#123;onToggle&#125;&gt; &#123;done &amp;&amp; &lt;MdDone /&gt;&#125; &lt;/CheckCircle&gt; &lt;Text done=&#123;done&#125;&gt;&#123;text&#125;&lt;/Text&gt; &lt;Remove onClick=&#123;onRemove&#125;&gt; &lt;MdDelete /&gt; &lt;/Remove&gt; &lt;/TodoItemBlock&gt; );&#125;export default TodoItem;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"To do List","slug":"Frontend/To-do-List","permalink":"https://ckck803.github.io/categories/Frontend/To-do-List/"}],"tags":[]},{"title":"리엑트 Todo List 만들기 1 - 기본 템플릿 만들기","slug":"react/todolist/todolist-1","date":"2021-09-07T11:10:40.000Z","updated":"2024-11-23T16:52:11.410Z","comments":true,"path":"2021/09/07/react/todolist/todolist-1/","link":"","permalink":"https://ckck803.github.io/2021/09/07/react/todolist/todolist-1/","excerpt":"리엑트 Todo List 만들기 3 - Context API를 이용해 상태 관리하기 리엑트 Todo List 만들기 2 - 리스트 항목 만들기 리엑트 Todo List 만들기 1 - 기본 템플릿 만들기 리엑트 Todo List 만들기 1 - 기본 템플릿 만들기 TodoTemplate.js import React from &quot;react&quot;;import styled from &quot;styled-components&quot;;const TodoTemplateBlock = styled.div` width: 512px; height: 768px; position: relative; /* 추후 박스 하단에 추가 버튼을 위치시키기 위한 설정 */ background: white; border-radius: 16px; box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.04); margin: 0 auto; /* 페이지 중앙에 나타나도록 설정 */ margin-top: 96px; margin-bottom: 32px; display: flex; flex-direction: column;`;const TodoTemplate = (&#123; children &#125;) =&gt; &#123; return &lt;TodoTemplateBlock&gt;&#123;children&#125;&lt;/TodoTemplateBlock&gt;;&#125;export default TodoTemplate; TodoHead.js import React from &#x27;react&#x27;;import styled from &#x27;styled-components&#x27;;import &#123; useTodoState &#125; from &#x27;../TodoContext&#x27;;const TodoHeadBlock = styled.div` padding-top: 48px; padding-left: 32px; padding-right: 32px; padding-bottom: 24px; border-bottom: 1px solid #e9ecef; h1 &#123; margin: 0; font-size: 36px; color: #343a40; &#125; .day &#123; margin-top: 4px; color: #868e96; font-size: 21px; &#125; .tasks-left &#123; color: #20c997; font-size: 18px; margin-top: 40px; font-weight: bold; &#125;`;function TodoHead() &#123; const todos = useTodoState(); const undoneTasks = todos.filter(todo =&gt; !todo.done); const today = new Date(); const dateString = today.toLocaleDateString(&#x27;ko-KR&#x27;, &#123; year: &#x27;numeric&#x27;, month: &#x27;long&#x27;, day: &#x27;numeric&#x27; &#125;); const dayName = today.toLocaleDateString(&#x27;ko-KR&#x27;, &#123; weekday: &#x27;long&#x27; &#125;); return ( &lt;TodoHeadBlock&gt; &lt;h1&gt;&#123;dateString&#125;&lt;/h1&gt; &lt;div className=&quot;day&quot;&gt;&#123;dayName&#125;&lt;/div&gt; &lt;div className=&quot;tasks-left&quot;&gt;할 일 &#123;undoneTasks.length&#125;개 남음&lt;/div&gt; &lt;/TodoHeadBlock&gt; );&#125;export default TodoHead;","text":"리엑트 Todo List 만들기 3 - Context API를 이용해 상태 관리하기 리엑트 Todo List 만들기 2 - 리스트 항목 만들기 리엑트 Todo List 만들기 1 - 기본 템플릿 만들기 리엑트 Todo List 만들기 1 - 기본 템플릿 만들기 TodoTemplate.js import React from &quot;react&quot;;import styled from &quot;styled-components&quot;;const TodoTemplateBlock = styled.div` width: 512px; height: 768px; position: relative; /* 추후 박스 하단에 추가 버튼을 위치시키기 위한 설정 */ background: white; border-radius: 16px; box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.04); margin: 0 auto; /* 페이지 중앙에 나타나도록 설정 */ margin-top: 96px; margin-bottom: 32px; display: flex; flex-direction: column;`;const TodoTemplate = (&#123; children &#125;) =&gt; &#123; return &lt;TodoTemplateBlock&gt;&#123;children&#125;&lt;/TodoTemplateBlock&gt;;&#125;export default TodoTemplate; TodoHead.js import React from &#x27;react&#x27;;import styled from &#x27;styled-components&#x27;;import &#123; useTodoState &#125; from &#x27;../TodoContext&#x27;;const TodoHeadBlock = styled.div` padding-top: 48px; padding-left: 32px; padding-right: 32px; padding-bottom: 24px; border-bottom: 1px solid #e9ecef; h1 &#123; margin: 0; font-size: 36px; color: #343a40; &#125; .day &#123; margin-top: 4px; color: #868e96; font-size: 21px; &#125; .tasks-left &#123; color: #20c997; font-size: 18px; margin-top: 40px; font-weight: bold; &#125;`;function TodoHead() &#123; const todos = useTodoState(); const undoneTasks = todos.filter(todo =&gt; !todo.done); const today = new Date(); const dateString = today.toLocaleDateString(&#x27;ko-KR&#x27;, &#123; year: &#x27;numeric&#x27;, month: &#x27;long&#x27;, day: &#x27;numeric&#x27; &#125;); const dayName = today.toLocaleDateString(&#x27;ko-KR&#x27;, &#123; weekday: &#x27;long&#x27; &#125;); return ( &lt;TodoHeadBlock&gt; &lt;h1&gt;&#123;dateString&#125;&lt;/h1&gt; &lt;div className=&quot;day&quot;&gt;&#123;dayName&#125;&lt;/div&gt; &lt;div className=&quot;tasks-left&quot;&gt;할 일 &#123;undoneTasks.length&#125;개 남음&lt;/div&gt; &lt;/TodoHeadBlock&gt; );&#125;export default TodoHead; TodoList.js import React from &quot;react&quot;;import styled from &quot;styled-components&quot;;import TodoItem from &quot;./TodoItem&quot;;import &#123; useTodoState &#125; from &quot;../TodoContext&quot;;const TodoListBlock = styled.div` flex: 1; padding: 20px 32px; padding-bottom: 48px; overflow-y: auto;`;function TodoList() &#123; const todos = useTodoState(); return ( &lt;TodoListBlock&gt; &#123;todos.map((todo) =&gt; ( &lt;TodoItem key=&#123;todo.id&#125; id=&#123;todo.id&#125; text=&#123;todo.text&#125; done=&#123;todo.done&#125; /&gt; ))&#125; &lt;/TodoListBlock&gt; );&#125;export default TodoList; App.js import React from &quot;react&quot;;import &#123; createGlobalStyle &#125; from &quot;styled-components&quot;;import TodoTemplate from &quot;./components/TodoTemplate&quot;;import TodoHead from &quot;./components/TodoHead&quot;;import TodoList from &quot;./components/TodoList&quot;;import TodoCreate from &quot;./components/TodoCreate&quot;;import &#123; TodoProvider &#125; from &quot;./TodoContext&quot;;const GlobalStyle = createGlobalStyle` body &#123; background: #e9ecef; &#125;`;function App() &#123; return ( &lt;TodoProvider&gt; &lt;GlobalStyle /&gt; &lt;TodoTemplate&gt; &lt;TodoHead /&gt; &lt;TodoList /&gt; &lt;TodoCreate /&gt; &lt;/TodoTemplate&gt; &lt;/TodoProvider&gt; );&#125;export default App;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"To do List","slug":"Frontend/To-do-List","permalink":"https://ckck803.github.io/categories/Frontend/To-do-List/"}],"tags":[]},{"title":"리엑트 블로그 만들기 15 - Post Card List 만들기 2","slug":"react/react-blog/react-blog-15-postcardlist2","date":"2021-09-07T03:10:40.000Z","updated":"2024-11-23T16:51:43.346Z","comments":true,"path":"2021/09/07/react/react-blog/react-blog-15-postcardlist2/","link":"","permalink":"https://ckck803.github.io/2021/09/07/react/react-blog/react-blog-15-postcardlist2/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 15 - Post Card List 만들기 2import &#123; POSTS_LOADING_FAILURE, POSTS_LOADING_REQUEST, POSTS_LOADING_SUCCESS &#125; from &quot;../types&quot;;const initialState = &#123; isAuthenticated: null, posts: [], postDetails: &quot;&quot;, postCount: &quot;&quot;, loading: false, error: &quot;&quot;, creatorId: &quot;&quot;, categoryFindResult: &quot;&quot;, title: &quot;&quot;, searchBy: &quot;&quot;, searchResult: &quot;&quot;,&#125;;export default function postReducer(state = initialState, action) &#123; switch (action.type) &#123; case POSTS_LOADING_REQUEST: return &#123; ...state, posts: [], loading: true, &#125; case POSTS_LOADING_SUCCESS: return &#123; ...state, posts: [...state.posts, ...action.payload], loading: false, &#125;; case POSTS_LOADING_FAILURE: return &#123; ...state, loading: false, &#125;; default: return state; &#125;;&#125; // POST WRITEexport const POSTS_WRITE_REQUEST = &quot;POST_WRITE_REQUEST&quot;;export const POSTS_WRITE_FAILURE = &quot;POST_WRITE_FAILURE&quot;;export const POSTS_WRITE_SUCCESS = &quot;POST_WRITE_SUCCESS&quot;;// POST LOADINGexport const POSTS_LOADING_REQUEST = &quot;POST_LOADING_REQUEST&quot;;export const POSTS_LOADING_FAILURE = &quot;POST_LOADING_FAILURE&quot;;export const POSTS_LOADING_SUCCESS = &quot;POST_LOADING_SUCCESS&quot;; import &#123; combineReducers &#125; from &quot;redux&quot;;import &#123; connectRouter &#125; from &quot;connected-react-router&quot;;import authReducer from &quot;./authReducer.js&quot;;import postReducer from &quot;./postReducer.js&quot;;import commentReducer from &quot;./commentReducer.js&quot;;const createRootReducer = (history) =&gt; combineReducers(&#123; router: connectRouter(history), auth: authReducer, post: postReducer, comment: commentReducer, &#125;);export default createRootReducer; import axios from &quot;axios&quot;;import &#123; put, call, takeEvery, all, fork &#125; from &quot;redux-saga/effects&quot;;import &#123; push &#125; from &quot;connected-react-router&quot;;import &#123; POSTS_LOADING_FAILURE, POSTS_LOADING_SUCCESS, POSTS_LOADING_REQUEST, POST_UPLOADING_SUCCESS, POST_UPLOADING_FAILURE, POST_UPLOADING_REQUEST, POST_DETAIL_LOADING_SUCCESS, POST_DETAIL_LOADING_FAILURE, POST_DETAIL_LOADING_REQUEST, POST_DELETE_SUCCESS, POST_DELETE_FAILURE, POST_DELETE_REQUEST, POST_EDIT_LOADING_SUCCESS, POST_EDIT_LOADING_FAILURE, POST_EDIT_UPLOADING_SUCCESS, POST_EDIT_UPLOADING_FAILURE, POST_EDIT_UPLOADING_REQUEST, POST_EDIT_LOADING_REQUEST, CATEGORY_FIND_FAILURE, CATEGORY_FIND_SUCCESS, CATEGORY_FIND_REQUEST, SEARCH_SUCCESS, SEARCH_FAILURE, SEARCH_REQUEST,&#125; from &quot;../types&quot;;// All Posts loadconst loadPostAPI = (payload) =&gt; &#123; return axios.get(`/api/post/skip/$&#123;payload&#125;`);&#125;;function* loadPosts(action) &#123; try &#123; const result = yield call(loadPostAPI, action.payload); console.log(result, &quot;loadPosts&quot;); yield put(&#123; type: POSTS_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POSTS_LOADING_FAILURE, payload: e, &#125;); &#125;&#125;function* watchLoadPosts() &#123; yield takeEvery(POSTS_LOADING_REQUEST, loadPosts);&#125;// Post Uploadconst uploadPostAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.post(&quot;/api/post&quot;, payload, config);&#125;;function* uploadPosts(action) &#123; try &#123; console.log(action, &quot;uploadPost function&quot;); const result = yield call(uploadPostAPI, action.payload); console.log(result, &quot;uploadPostAPI, action.payload&quot;); yield put(&#123; type: POST_UPLOADING_SUCCESS, payload: result.data, &#125;); yield put(push(`/post/$&#123;result.data._id&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: POST_UPLOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchuploadPosts() &#123; yield takeEvery(POST_UPLOADING_REQUEST, uploadPosts);&#125;// Post Detailconst loadPostDetailAPI = (payload) =&gt; &#123; console.log(payload); return axios.get(`/api/post/$&#123;payload&#125;`);&#125;;function* loadPostDetail(action) &#123; try &#123; console.log(action); const result = yield call(loadPostDetailAPI, action.payload); console.log(result, &quot;post_detail_saga_data&quot;); yield put(&#123; type: POST_DETAIL_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POST_DETAIL_LOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchloadPostDetail() &#123; yield takeEvery(POST_DETAIL_LOADING_REQUEST, loadPostDetail);&#125;// Post Deleteconst DeletePostAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.delete(`/api/post/$&#123;payload.id&#125;`, config);&#125;;function* DeletePost(action) &#123; try &#123; const result = yield call(DeletePostAPI, action.payload); yield put(&#123; type: POST_DELETE_SUCCESS, payload: result.data, &#125;); yield put(push(&quot;/&quot;)); &#125; catch (e) &#123; yield put(&#123; type: POST_DELETE_FAILURE, payload: e, &#125;); &#125;&#125;function* watchDeletePost() &#123; yield takeEvery(POST_DELETE_REQUEST, DeletePost);&#125;// Post Edit Loadconst PostEditLoadAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.get(`/api/post/$&#123;payload.id&#125;/edit`, config);&#125;;function* PostEditLoad(action) &#123; try &#123; const result = yield call(PostEditLoadAPI, action.payload); yield put(&#123; type: POST_EDIT_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POST_EDIT_LOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchPostEditLoad() &#123; yield takeEvery(POST_EDIT_LOADING_REQUEST, PostEditLoad);&#125;// Post Edit UpLoadconst PostEditUploadAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.post(`/api/post/$&#123;payload.id&#125;/edit`, payload, config);&#125;;function* PostEditUpload(action) &#123; try &#123; const result = yield call(PostEditUploadAPI, action.payload); yield put(&#123; type: POST_EDIT_UPLOADING_SUCCESS, payload: result.data, &#125;); yield put(push(`/post/$&#123;result.data._id&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: POST_EDIT_UPLOADING_FAILURE, payload: e, &#125;); &#125;&#125;function* watchPostEditUpload() &#123; yield takeEvery(POST_EDIT_UPLOADING_REQUEST, PostEditUpload);&#125;// Category Findconst CategoryFindAPI = (payload) =&gt; &#123; return axios.get(`/api/post/category/$&#123;encodeURIComponent(payload)&#125;`);&#125;;function* CategoryFind(action) &#123; try &#123; const result = yield call(CategoryFindAPI, action.payload); yield put(&#123; type: CATEGORY_FIND_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: CATEGORY_FIND_FAILURE, payload: e, &#125;); &#125;&#125;function* watchCategoryFind() &#123; yield takeEvery(CATEGORY_FIND_REQUEST, CategoryFind);&#125;// Search Findconst SearchResultAPI = (payload) =&gt; &#123; return axios.get(`/api/search/$&#123;encodeURIComponent(payload)&#125;`);&#125;;function* SearchResult(action) &#123; try &#123; const result = yield call(SearchResultAPI, action.payload); yield put(&#123; type: SEARCH_SUCCESS, payload: result.data, &#125;); yield put(push(`/search/$&#123;encodeURIComponent(action.payload)&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: SEARCH_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchSearchResult() &#123; yield takeEvery(SEARCH_REQUEST, SearchResult);&#125;export default function* postSaga() &#123; yield all([ fork(watchLoadPosts), fork(watchuploadPosts), fork(watchloadPostDetail), fork(watchDeletePost), fork(watchPostEditLoad), fork(watchPostEditUpload), fork(watchCategoryFind), fork(watchSearchResult), ]);&#125; import React, &#123; Fragment &#125; from &quot;react&quot;;import &#123; Row, Spinner &#125; from &quot;reactstrap&quot;;export const GrowingSpinner = ( &lt;Fragment&gt; &lt;Row className=&quot;d-flex justify-content-center m-5&quot;&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;primary&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;secondary&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;success&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;danger&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;warning&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;info&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;light&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;dark&quot; /&gt; &lt;/Row&gt; &lt;/Fragment&gt;); import React, &#123; Fragment &#125; from &quot;react&quot;;import &#123; Card, CardImg, CardBody, CardTitle, Button, Badge, Row,&#125; from &quot;reactstrap&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; FontAwesomeIcon &#125; from &quot;@fortawesome/react-fontawesome&quot;;import &#123; faMouse &#125; from &quot;@fortawesome/free-solid-svg-icons&quot;;const PostCardOne = (&#123; posts &#125;) =&gt; &#123; return ( &lt;Fragment&gt; &#123;Array.isArray(posts) ? posts.map((&#123; _id, title, fileUrl, comments, views &#125;) =&gt; &#123; return ( &lt;div key=&#123;_id&#125; className=&quot;col-md-4&quot;&gt; &lt;Link to=&#123;`/post/$&#123;_id&#125;`&#125; className=&quot;text-dark text-decoration-none&quot; &gt; &lt;Card className=&quot;mb-3&quot;&gt; &lt;CardImg top alt=&quot;카드이미지&quot; src=&#123;fileUrl&#125; /&gt; &lt;CardBody&gt; &lt;CardTitle className=&quot;text-truncate d-flex justify-content-between&quot;&gt; &lt;span className=&quot;text-truncate&quot;&gt;&#123;title&#125; &lt;/span&gt; &lt;span&gt; &lt;FontAwesomeIcon icon=&#123;faMouse&#125; /&gt; &amp;nbsp;&amp;nbsp; &lt;span&gt;&#123;views&#125;&lt;/span&gt; &lt;/span&gt; &lt;/CardTitle&gt; &lt;Row&gt; &lt;Button color=&quot;primary&quot; className=&quot;p-2 btn-block&quot;&gt; More &lt;Badge color=&quot;light&quot;&gt;&#123;comments.length&#125;&lt;/Badge&gt; &lt;/Button&gt; &lt;/Row&gt; &lt;/CardBody&gt; &lt;/Card&gt; &lt;/Link&gt; &lt;/div&gt; ); &#125;) : &quot;&quot;&#125; &lt;/Fragment&gt; );&#125;;export default PostCardOne;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 15 - Post Card List 만들기 2import &#123; POSTS_LOADING_FAILURE, POSTS_LOADING_REQUEST, POSTS_LOADING_SUCCESS &#125; from &quot;../types&quot;;const initialState = &#123; isAuthenticated: null, posts: [], postDetails: &quot;&quot;, postCount: &quot;&quot;, loading: false, error: &quot;&quot;, creatorId: &quot;&quot;, categoryFindResult: &quot;&quot;, title: &quot;&quot;, searchBy: &quot;&quot;, searchResult: &quot;&quot;,&#125;;export default function postReducer(state = initialState, action) &#123; switch (action.type) &#123; case POSTS_LOADING_REQUEST: return &#123; ...state, posts: [], loading: true, &#125; case POSTS_LOADING_SUCCESS: return &#123; ...state, posts: [...state.posts, ...action.payload], loading: false, &#125;; case POSTS_LOADING_FAILURE: return &#123; ...state, loading: false, &#125;; default: return state; &#125;;&#125; // POST WRITEexport const POSTS_WRITE_REQUEST = &quot;POST_WRITE_REQUEST&quot;;export const POSTS_WRITE_FAILURE = &quot;POST_WRITE_FAILURE&quot;;export const POSTS_WRITE_SUCCESS = &quot;POST_WRITE_SUCCESS&quot;;// POST LOADINGexport const POSTS_LOADING_REQUEST = &quot;POST_LOADING_REQUEST&quot;;export const POSTS_LOADING_FAILURE = &quot;POST_LOADING_FAILURE&quot;;export const POSTS_LOADING_SUCCESS = &quot;POST_LOADING_SUCCESS&quot;; import &#123; combineReducers &#125; from &quot;redux&quot;;import &#123; connectRouter &#125; from &quot;connected-react-router&quot;;import authReducer from &quot;./authReducer.js&quot;;import postReducer from &quot;./postReducer.js&quot;;import commentReducer from &quot;./commentReducer.js&quot;;const createRootReducer = (history) =&gt; combineReducers(&#123; router: connectRouter(history), auth: authReducer, post: postReducer, comment: commentReducer, &#125;);export default createRootReducer; import axios from &quot;axios&quot;;import &#123; put, call, takeEvery, all, fork &#125; from &quot;redux-saga/effects&quot;;import &#123; push &#125; from &quot;connected-react-router&quot;;import &#123; POSTS_LOADING_FAILURE, POSTS_LOADING_SUCCESS, POSTS_LOADING_REQUEST, POST_UPLOADING_SUCCESS, POST_UPLOADING_FAILURE, POST_UPLOADING_REQUEST, POST_DETAIL_LOADING_SUCCESS, POST_DETAIL_LOADING_FAILURE, POST_DETAIL_LOADING_REQUEST, POST_DELETE_SUCCESS, POST_DELETE_FAILURE, POST_DELETE_REQUEST, POST_EDIT_LOADING_SUCCESS, POST_EDIT_LOADING_FAILURE, POST_EDIT_UPLOADING_SUCCESS, POST_EDIT_UPLOADING_FAILURE, POST_EDIT_UPLOADING_REQUEST, POST_EDIT_LOADING_REQUEST, CATEGORY_FIND_FAILURE, CATEGORY_FIND_SUCCESS, CATEGORY_FIND_REQUEST, SEARCH_SUCCESS, SEARCH_FAILURE, SEARCH_REQUEST,&#125; from &quot;../types&quot;;// All Posts loadconst loadPostAPI = (payload) =&gt; &#123; return axios.get(`/api/post/skip/$&#123;payload&#125;`);&#125;;function* loadPosts(action) &#123; try &#123; const result = yield call(loadPostAPI, action.payload); console.log(result, &quot;loadPosts&quot;); yield put(&#123; type: POSTS_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POSTS_LOADING_FAILURE, payload: e, &#125;); &#125;&#125;function* watchLoadPosts() &#123; yield takeEvery(POSTS_LOADING_REQUEST, loadPosts);&#125;// Post Uploadconst uploadPostAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.post(&quot;/api/post&quot;, payload, config);&#125;;function* uploadPosts(action) &#123; try &#123; console.log(action, &quot;uploadPost function&quot;); const result = yield call(uploadPostAPI, action.payload); console.log(result, &quot;uploadPostAPI, action.payload&quot;); yield put(&#123; type: POST_UPLOADING_SUCCESS, payload: result.data, &#125;); yield put(push(`/post/$&#123;result.data._id&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: POST_UPLOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchuploadPosts() &#123; yield takeEvery(POST_UPLOADING_REQUEST, uploadPosts);&#125;// Post Detailconst loadPostDetailAPI = (payload) =&gt; &#123; console.log(payload); return axios.get(`/api/post/$&#123;payload&#125;`);&#125;;function* loadPostDetail(action) &#123; try &#123; console.log(action); const result = yield call(loadPostDetailAPI, action.payload); console.log(result, &quot;post_detail_saga_data&quot;); yield put(&#123; type: POST_DETAIL_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POST_DETAIL_LOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchloadPostDetail() &#123; yield takeEvery(POST_DETAIL_LOADING_REQUEST, loadPostDetail);&#125;// Post Deleteconst DeletePostAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.delete(`/api/post/$&#123;payload.id&#125;`, config);&#125;;function* DeletePost(action) &#123; try &#123; const result = yield call(DeletePostAPI, action.payload); yield put(&#123; type: POST_DELETE_SUCCESS, payload: result.data, &#125;); yield put(push(&quot;/&quot;)); &#125; catch (e) &#123; yield put(&#123; type: POST_DELETE_FAILURE, payload: e, &#125;); &#125;&#125;function* watchDeletePost() &#123; yield takeEvery(POST_DELETE_REQUEST, DeletePost);&#125;// Post Edit Loadconst PostEditLoadAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.get(`/api/post/$&#123;payload.id&#125;/edit`, config);&#125;;function* PostEditLoad(action) &#123; try &#123; const result = yield call(PostEditLoadAPI, action.payload); yield put(&#123; type: POST_EDIT_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POST_EDIT_LOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchPostEditLoad() &#123; yield takeEvery(POST_EDIT_LOADING_REQUEST, PostEditLoad);&#125;// Post Edit UpLoadconst PostEditUploadAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.post(`/api/post/$&#123;payload.id&#125;/edit`, payload, config);&#125;;function* PostEditUpload(action) &#123; try &#123; const result = yield call(PostEditUploadAPI, action.payload); yield put(&#123; type: POST_EDIT_UPLOADING_SUCCESS, payload: result.data, &#125;); yield put(push(`/post/$&#123;result.data._id&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: POST_EDIT_UPLOADING_FAILURE, payload: e, &#125;); &#125;&#125;function* watchPostEditUpload() &#123; yield takeEvery(POST_EDIT_UPLOADING_REQUEST, PostEditUpload);&#125;// Category Findconst CategoryFindAPI = (payload) =&gt; &#123; return axios.get(`/api/post/category/$&#123;encodeURIComponent(payload)&#125;`);&#125;;function* CategoryFind(action) &#123; try &#123; const result = yield call(CategoryFindAPI, action.payload); yield put(&#123; type: CATEGORY_FIND_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: CATEGORY_FIND_FAILURE, payload: e, &#125;); &#125;&#125;function* watchCategoryFind() &#123; yield takeEvery(CATEGORY_FIND_REQUEST, CategoryFind);&#125;// Search Findconst SearchResultAPI = (payload) =&gt; &#123; return axios.get(`/api/search/$&#123;encodeURIComponent(payload)&#125;`);&#125;;function* SearchResult(action) &#123; try &#123; const result = yield call(SearchResultAPI, action.payload); yield put(&#123; type: SEARCH_SUCCESS, payload: result.data, &#125;); yield put(push(`/search/$&#123;encodeURIComponent(action.payload)&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: SEARCH_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchSearchResult() &#123; yield takeEvery(SEARCH_REQUEST, SearchResult);&#125;export default function* postSaga() &#123; yield all([ fork(watchLoadPosts), fork(watchuploadPosts), fork(watchloadPostDetail), fork(watchDeletePost), fork(watchPostEditLoad), fork(watchPostEditUpload), fork(watchCategoryFind), fork(watchSearchResult), ]);&#125; import React, &#123; Fragment &#125; from &quot;react&quot;;import &#123; Row, Spinner &#125; from &quot;reactstrap&quot;;export const GrowingSpinner = ( &lt;Fragment&gt; &lt;Row className=&quot;d-flex justify-content-center m-5&quot;&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;primary&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;secondary&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;success&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;danger&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;warning&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;info&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;light&quot; /&gt; &lt;Spinner style=&#123;&#123; width: &quot;2rem&quot;, height: &quot;2rem&quot; &#125;&#125; type=&quot;grow&quot; color=&quot;dark&quot; /&gt; &lt;/Row&gt; &lt;/Fragment&gt;); import React, &#123; Fragment &#125; from &quot;react&quot;;import &#123; Card, CardImg, CardBody, CardTitle, Button, Badge, Row,&#125; from &quot;reactstrap&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; FontAwesomeIcon &#125; from &quot;@fortawesome/react-fontawesome&quot;;import &#123; faMouse &#125; from &quot;@fortawesome/free-solid-svg-icons&quot;;const PostCardOne = (&#123; posts &#125;) =&gt; &#123; return ( &lt;Fragment&gt; &#123;Array.isArray(posts) ? posts.map((&#123; _id, title, fileUrl, comments, views &#125;) =&gt; &#123; return ( &lt;div key=&#123;_id&#125; className=&quot;col-md-4&quot;&gt; &lt;Link to=&#123;`/post/$&#123;_id&#125;`&#125; className=&quot;text-dark text-decoration-none&quot; &gt; &lt;Card className=&quot;mb-3&quot;&gt; &lt;CardImg top alt=&quot;카드이미지&quot; src=&#123;fileUrl&#125; /&gt; &lt;CardBody&gt; &lt;CardTitle className=&quot;text-truncate d-flex justify-content-between&quot;&gt; &lt;span className=&quot;text-truncate&quot;&gt;&#123;title&#125; &lt;/span&gt; &lt;span&gt; &lt;FontAwesomeIcon icon=&#123;faMouse&#125; /&gt; &amp;nbsp;&amp;nbsp; &lt;span&gt;&#123;views&#125;&lt;/span&gt; &lt;/span&gt; &lt;/CardTitle&gt; &lt;Row&gt; &lt;Button color=&quot;primary&quot; className=&quot;p-2 btn-block&quot;&gt; More &lt;Badge color=&quot;light&quot;&gt;&#123;comments.length&#125;&lt;/Badge&gt; &lt;/Button&gt; &lt;/Row&gt; &lt;/CardBody&gt; &lt;/Card&gt; &lt;/Link&gt; &lt;/div&gt; ); &#125;) : &quot;&quot;&#125; &lt;/Fragment&gt; );&#125;;export default PostCardOne;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 14 - Post Card List 만들기","slug":"react/react-blog/react-blog-14-postcardlist","date":"2021-09-06T10:10:40.000Z","updated":"2024-11-23T16:51:42.503Z","comments":true,"path":"2021/09/06/react/react-blog/react-blog-14-postcardlist/","link":"","permalink":"https://ckck803.github.io/2021/09/06/react/react-blog/react-blog-14-postcardlist/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 14 - Post Card List 만들기import &#123; POSTS_LOADING_FAILURE, POSTS_LOADING_REQUEST, POSTS_LOADING_SUCCESS &#125; from &quot;../types&quot;;const initialState = &#123; isAuthenticated: null, posts: [], postDetails: &quot;&quot;, postCount: &quot;&quot;, loading: false, error: &quot;&quot;, creatorId: &quot;&quot;, categoryFindResult: &quot;&quot;, title: &quot;&quot;, searchBy: &quot;&quot;, searchResult: &quot;&quot;,&#125;;export default function postReducer(state = initialState, action) &#123; switch (action.type) &#123; case POSTS_LOADING_REQUEST: return &#123; ...state, posts: [], loading: true, &#125; case POSTS_LOADING_SUCCESS: return &#123; ...state, posts: [...state.posts, ...action.payload], loading: false, &#125;; case POSTS_LOADING_FAILURE: return &#123; ...state, loading: false, &#125;; default: return state; &#125;;&#125; // POST WRITEexport const POSTS_WRITE_REQUEST = &quot;POST_WRITE_REQUEST&quot;;export const POSTS_WRITE_FAILURE = &quot;POST_WRITE_FAILURE&quot;;export const POSTS_WRITE_SUCCESS = &quot;POST_WRITE_SUCCESS&quot;;// POST LOADINGexport const POSTS_LOADING_REQUEST = &quot;POST_LOADING_REQUEST&quot;;export const POSTS_LOADING_FAILURE = &quot;POST_LOADING_FAILURE&quot;;export const POSTS_LOADING_SUCCESS = &quot;POST_LOADING_SUCCESS&quot;; import &#123; combineReducers &#125; from &quot;redux&quot;;import &#123; connectRouter &#125; from &quot;connected-react-router&quot;;import authReducer from &quot;./authReducer.js&quot;;import postReducer from &quot;./postReducer.js&quot;;import commentReducer from &quot;./commentReducer.js&quot;;const createRootReducer = (history) =&gt; combineReducers(&#123; router: connectRouter(history), auth: authReducer, post: postReducer, comment: commentReducer, &#125;);export default createRootReducer; import axios from &quot;axios&quot;;import &#123; put, call, takeEvery, all, fork &#125; from &quot;redux-saga/effects&quot;;import &#123; push &#125; from &quot;connected-react-router&quot;;import &#123; POSTS_LOADING_FAILURE, POSTS_LOADING_SUCCESS, POSTS_LOADING_REQUEST, POST_UPLOADING_SUCCESS, POST_UPLOADING_FAILURE, POST_UPLOADING_REQUEST, POST_DETAIL_LOADING_SUCCESS, POST_DETAIL_LOADING_FAILURE, POST_DETAIL_LOADING_REQUEST, POST_DELETE_SUCCESS, POST_DELETE_FAILURE, POST_DELETE_REQUEST, POST_EDIT_LOADING_SUCCESS, POST_EDIT_LOADING_FAILURE, POST_EDIT_UPLOADING_SUCCESS, POST_EDIT_UPLOADING_FAILURE, POST_EDIT_UPLOADING_REQUEST, POST_EDIT_LOADING_REQUEST, CATEGORY_FIND_FAILURE, CATEGORY_FIND_SUCCESS, CATEGORY_FIND_REQUEST, SEARCH_SUCCESS, SEARCH_FAILURE, SEARCH_REQUEST,&#125; from &quot;../types&quot;;// All Posts loadconst loadPostAPI = (payload) =&gt; &#123; return axios.get(`/api/post/skip/$&#123;payload&#125;`);&#125;;function* loadPosts(action) &#123; try &#123; const result = yield call(loadPostAPI, action.payload); console.log(result, &quot;loadPosts&quot;); yield put(&#123; type: POSTS_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POSTS_LOADING_FAILURE, payload: e, &#125;); &#125;&#125;function* watchLoadPosts() &#123; yield takeEvery(POSTS_LOADING_REQUEST, loadPosts);&#125;// Post Uploadconst uploadPostAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.post(&quot;/api/post&quot;, payload, config);&#125;;function* uploadPosts(action) &#123; try &#123; console.log(action, &quot;uploadPost function&quot;); const result = yield call(uploadPostAPI, action.payload); console.log(result, &quot;uploadPostAPI, action.payload&quot;); yield put(&#123; type: POST_UPLOADING_SUCCESS, payload: result.data, &#125;); yield put(push(`/post/$&#123;result.data._id&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: POST_UPLOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchuploadPosts() &#123; yield takeEvery(POST_UPLOADING_REQUEST, uploadPosts);&#125;// Post Detailconst loadPostDetailAPI = (payload) =&gt; &#123; console.log(payload); return axios.get(`/api/post/$&#123;payload&#125;`);&#125;;function* loadPostDetail(action) &#123; try &#123; console.log(action); const result = yield call(loadPostDetailAPI, action.payload); console.log(result, &quot;post_detail_saga_data&quot;); yield put(&#123; type: POST_DETAIL_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POST_DETAIL_LOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchloadPostDetail() &#123; yield takeEvery(POST_DETAIL_LOADING_REQUEST, loadPostDetail);&#125;// Post Deleteconst DeletePostAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.delete(`/api/post/$&#123;payload.id&#125;`, config);&#125;;function* DeletePost(action) &#123; try &#123; const result = yield call(DeletePostAPI, action.payload); yield put(&#123; type: POST_DELETE_SUCCESS, payload: result.data, &#125;); yield put(push(&quot;/&quot;)); &#125; catch (e) &#123; yield put(&#123; type: POST_DELETE_FAILURE, payload: e, &#125;); &#125;&#125;function* watchDeletePost() &#123; yield takeEvery(POST_DELETE_REQUEST, DeletePost);&#125;// Post Edit Loadconst PostEditLoadAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.get(`/api/post/$&#123;payload.id&#125;/edit`, config);&#125;;function* PostEditLoad(action) &#123; try &#123; const result = yield call(PostEditLoadAPI, action.payload); yield put(&#123; type: POST_EDIT_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POST_EDIT_LOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchPostEditLoad() &#123; yield takeEvery(POST_EDIT_LOADING_REQUEST, PostEditLoad);&#125;// Post Edit UpLoadconst PostEditUploadAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.post(`/api/post/$&#123;payload.id&#125;/edit`, payload, config);&#125;;function* PostEditUpload(action) &#123; try &#123; const result = yield call(PostEditUploadAPI, action.payload); yield put(&#123; type: POST_EDIT_UPLOADING_SUCCESS, payload: result.data, &#125;); yield put(push(`/post/$&#123;result.data._id&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: POST_EDIT_UPLOADING_FAILURE, payload: e, &#125;); &#125;&#125;function* watchPostEditUpload() &#123; yield takeEvery(POST_EDIT_UPLOADING_REQUEST, PostEditUpload);&#125;// Category Findconst CategoryFindAPI = (payload) =&gt; &#123; return axios.get(`/api/post/category/$&#123;encodeURIComponent(payload)&#125;`);&#125;;function* CategoryFind(action) &#123; try &#123; const result = yield call(CategoryFindAPI, action.payload); yield put(&#123; type: CATEGORY_FIND_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: CATEGORY_FIND_FAILURE, payload: e, &#125;); &#125;&#125;function* watchCategoryFind() &#123; yield takeEvery(CATEGORY_FIND_REQUEST, CategoryFind);&#125;// Search Findconst SearchResultAPI = (payload) =&gt; &#123; return axios.get(`/api/search/$&#123;encodeURIComponent(payload)&#125;`);&#125;;function* SearchResult(action) &#123; try &#123; const result = yield call(SearchResultAPI, action.payload); yield put(&#123; type: SEARCH_SUCCESS, payload: result.data, &#125;); yield put(push(`/search/$&#123;encodeURIComponent(action.payload)&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: SEARCH_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchSearchResult() &#123; yield takeEvery(SEARCH_REQUEST, SearchResult);&#125;export default function* postSaga() &#123; yield all([ fork(watchLoadPosts), fork(watchuploadPosts), fork(watchloadPostDetail), fork(watchDeletePost), fork(watchPostEditLoad), fork(watchPostEditUpload), fork(watchCategoryFind), fork(watchSearchResult), ]);&#125;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 14 - Post Card List 만들기import &#123; POSTS_LOADING_FAILURE, POSTS_LOADING_REQUEST, POSTS_LOADING_SUCCESS &#125; from &quot;../types&quot;;const initialState = &#123; isAuthenticated: null, posts: [], postDetails: &quot;&quot;, postCount: &quot;&quot;, loading: false, error: &quot;&quot;, creatorId: &quot;&quot;, categoryFindResult: &quot;&quot;, title: &quot;&quot;, searchBy: &quot;&quot;, searchResult: &quot;&quot;,&#125;;export default function postReducer(state = initialState, action) &#123; switch (action.type) &#123; case POSTS_LOADING_REQUEST: return &#123; ...state, posts: [], loading: true, &#125; case POSTS_LOADING_SUCCESS: return &#123; ...state, posts: [...state.posts, ...action.payload], loading: false, &#125;; case POSTS_LOADING_FAILURE: return &#123; ...state, loading: false, &#125;; default: return state; &#125;;&#125; // POST WRITEexport const POSTS_WRITE_REQUEST = &quot;POST_WRITE_REQUEST&quot;;export const POSTS_WRITE_FAILURE = &quot;POST_WRITE_FAILURE&quot;;export const POSTS_WRITE_SUCCESS = &quot;POST_WRITE_SUCCESS&quot;;// POST LOADINGexport const POSTS_LOADING_REQUEST = &quot;POST_LOADING_REQUEST&quot;;export const POSTS_LOADING_FAILURE = &quot;POST_LOADING_FAILURE&quot;;export const POSTS_LOADING_SUCCESS = &quot;POST_LOADING_SUCCESS&quot;; import &#123; combineReducers &#125; from &quot;redux&quot;;import &#123; connectRouter &#125; from &quot;connected-react-router&quot;;import authReducer from &quot;./authReducer.js&quot;;import postReducer from &quot;./postReducer.js&quot;;import commentReducer from &quot;./commentReducer.js&quot;;const createRootReducer = (history) =&gt; combineReducers(&#123; router: connectRouter(history), auth: authReducer, post: postReducer, comment: commentReducer, &#125;);export default createRootReducer; import axios from &quot;axios&quot;;import &#123; put, call, takeEvery, all, fork &#125; from &quot;redux-saga/effects&quot;;import &#123; push &#125; from &quot;connected-react-router&quot;;import &#123; POSTS_LOADING_FAILURE, POSTS_LOADING_SUCCESS, POSTS_LOADING_REQUEST, POST_UPLOADING_SUCCESS, POST_UPLOADING_FAILURE, POST_UPLOADING_REQUEST, POST_DETAIL_LOADING_SUCCESS, POST_DETAIL_LOADING_FAILURE, POST_DETAIL_LOADING_REQUEST, POST_DELETE_SUCCESS, POST_DELETE_FAILURE, POST_DELETE_REQUEST, POST_EDIT_LOADING_SUCCESS, POST_EDIT_LOADING_FAILURE, POST_EDIT_UPLOADING_SUCCESS, POST_EDIT_UPLOADING_FAILURE, POST_EDIT_UPLOADING_REQUEST, POST_EDIT_LOADING_REQUEST, CATEGORY_FIND_FAILURE, CATEGORY_FIND_SUCCESS, CATEGORY_FIND_REQUEST, SEARCH_SUCCESS, SEARCH_FAILURE, SEARCH_REQUEST,&#125; from &quot;../types&quot;;// All Posts loadconst loadPostAPI = (payload) =&gt; &#123; return axios.get(`/api/post/skip/$&#123;payload&#125;`);&#125;;function* loadPosts(action) &#123; try &#123; const result = yield call(loadPostAPI, action.payload); console.log(result, &quot;loadPosts&quot;); yield put(&#123; type: POSTS_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POSTS_LOADING_FAILURE, payload: e, &#125;); &#125;&#125;function* watchLoadPosts() &#123; yield takeEvery(POSTS_LOADING_REQUEST, loadPosts);&#125;// Post Uploadconst uploadPostAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.post(&quot;/api/post&quot;, payload, config);&#125;;function* uploadPosts(action) &#123; try &#123; console.log(action, &quot;uploadPost function&quot;); const result = yield call(uploadPostAPI, action.payload); console.log(result, &quot;uploadPostAPI, action.payload&quot;); yield put(&#123; type: POST_UPLOADING_SUCCESS, payload: result.data, &#125;); yield put(push(`/post/$&#123;result.data._id&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: POST_UPLOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchuploadPosts() &#123; yield takeEvery(POST_UPLOADING_REQUEST, uploadPosts);&#125;// Post Detailconst loadPostDetailAPI = (payload) =&gt; &#123; console.log(payload); return axios.get(`/api/post/$&#123;payload&#125;`);&#125;;function* loadPostDetail(action) &#123; try &#123; console.log(action); const result = yield call(loadPostDetailAPI, action.payload); console.log(result, &quot;post_detail_saga_data&quot;); yield put(&#123; type: POST_DETAIL_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POST_DETAIL_LOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchloadPostDetail() &#123; yield takeEvery(POST_DETAIL_LOADING_REQUEST, loadPostDetail);&#125;// Post Deleteconst DeletePostAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.delete(`/api/post/$&#123;payload.id&#125;`, config);&#125;;function* DeletePost(action) &#123; try &#123; const result = yield call(DeletePostAPI, action.payload); yield put(&#123; type: POST_DELETE_SUCCESS, payload: result.data, &#125;); yield put(push(&quot;/&quot;)); &#125; catch (e) &#123; yield put(&#123; type: POST_DELETE_FAILURE, payload: e, &#125;); &#125;&#125;function* watchDeletePost() &#123; yield takeEvery(POST_DELETE_REQUEST, DeletePost);&#125;// Post Edit Loadconst PostEditLoadAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.get(`/api/post/$&#123;payload.id&#125;/edit`, config);&#125;;function* PostEditLoad(action) &#123; try &#123; const result = yield call(PostEditLoadAPI, action.payload); yield put(&#123; type: POST_EDIT_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: POST_EDIT_LOADING_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchPostEditLoad() &#123; yield takeEvery(POST_EDIT_LOADING_REQUEST, PostEditLoad);&#125;// Post Edit UpLoadconst PostEditUploadAPI = (payload) =&gt; &#123; const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; const token = payload.token; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.post(`/api/post/$&#123;payload.id&#125;/edit`, payload, config);&#125;;function* PostEditUpload(action) &#123; try &#123; const result = yield call(PostEditUploadAPI, action.payload); yield put(&#123; type: POST_EDIT_UPLOADING_SUCCESS, payload: result.data, &#125;); yield put(push(`/post/$&#123;result.data._id&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: POST_EDIT_UPLOADING_FAILURE, payload: e, &#125;); &#125;&#125;function* watchPostEditUpload() &#123; yield takeEvery(POST_EDIT_UPLOADING_REQUEST, PostEditUpload);&#125;// Category Findconst CategoryFindAPI = (payload) =&gt; &#123; return axios.get(`/api/post/category/$&#123;encodeURIComponent(payload)&#125;`);&#125;;function* CategoryFind(action) &#123; try &#123; const result = yield call(CategoryFindAPI, action.payload); yield put(&#123; type: CATEGORY_FIND_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: CATEGORY_FIND_FAILURE, payload: e, &#125;); &#125;&#125;function* watchCategoryFind() &#123; yield takeEvery(CATEGORY_FIND_REQUEST, CategoryFind);&#125;// Search Findconst SearchResultAPI = (payload) =&gt; &#123; return axios.get(`/api/search/$&#123;encodeURIComponent(payload)&#125;`);&#125;;function* SearchResult(action) &#123; try &#123; const result = yield call(SearchResultAPI, action.payload); yield put(&#123; type: SEARCH_SUCCESS, payload: result.data, &#125;); yield put(push(`/search/$&#123;encodeURIComponent(action.payload)&#125;`)); &#125; catch (e) &#123; yield put(&#123; type: SEARCH_FAILURE, payload: e, &#125;); yield put(push(&quot;/&quot;)); &#125;&#125;function* watchSearchResult() &#123; yield takeEvery(SEARCH_REQUEST, SearchResult);&#125;export default function* postSaga() &#123; yield all([ fork(watchLoadPosts), fork(watchuploadPosts), fork(watchloadPostDetail), fork(watchDeletePost), fork(watchPostEditLoad), fork(watchPostEditUpload), fork(watchCategoryFind), fork(watchSearchResult), ]);&#125;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 13 - 라우트","slug":"react/react-blog/react-blog-13-category","date":"2021-09-06T09:10:40.000Z","updated":"2024-11-23T16:51:42.909Z","comments":true,"path":"2021/09/06/react/react-blog/react-blog-13-category/","link":"","permalink":"https://ckck803.github.io/2021/09/06/react/react-blog/react-blog-13-category/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 13 - 라우트import React from &#x27;react&#x27;;const CategoryResult = () =&gt; &#123; return &lt;h1&gt;CategoryResult&lt;/h1&gt;&#125;export default CategoryResult; import &#123; Fragment, useEffect &#125; from &quot;react&quot;;import &#123; Helmet &#125; from &quot;react-helmet&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Row, Spinner &#125; from &#x27;reactstrap&#x27;;import PostCardOne from &quot;../../components/post/PostCardOne&quot;;import &#123; POSTS_LOADING_REQUEST &#125; from &quot;../../redux/types&quot;;const PostCardList = () =&gt; &#123; const &#123; posts &#125; = useSelector((state) =&gt; state.post) const dispatch = useDispatch() useEffect(() =&gt; &#123; dispatch(&#123; type: POSTS_LOADING_REQUEST &#125;) &#125;, [dispatch]) return ( &lt;Fragment&gt; &lt;Helmet title=&quot;Home&quot; /&gt; &lt;Row&gt; &#123;posts ? &lt;PostCardOne posts=&#123;posts&#125; /&gt; : &lt;Spinner /&gt;&#125; &lt;/Row&gt; &lt;/Fragment&gt; )&#125;export default PostCardList; import React from &#x27;react&#x27;;const PostDetail = () =&gt; &#123; return ( &lt;div&gt; PostDetail &lt;/div&gt; )&#125;export default PostDetail; import React from &#x27;react&#x27;;const PostEdit = () =&gt; &#123; return ( &lt;div&gt; PostEdit &lt;/div&gt; )&#125;export default PostEdit; import React, &#123; useState &#125; from &#x27;react&#x27;import &#123; useDispatch, useSelector &#125; from &#x27;react-redux&#x27;import &#123; Col, Form, FormGroup, Label, Progress, Button, Input &#125; from &#x27;reactstrap&#x27;import &#123; CKEditor &#125; from &quot;@ckeditor/ckeditor5-react&quot;import ClassicEditor from &#x27;@ckeditor/ckeditor5-editor-classic/src/classiceditor&#x27;import &#123; editorConfiguration &#125; from &#x27;../../components/editor/EditorConfig&#x27;import Myinit from &#x27;../../components/editor/UploadAdapter&#x27;const PostWrite = () =&gt; &#123; const &#123; isAuthenticated &#125; = useSelector((state) =&gt; state.auth) const [form, setValues] = useState(&#123; title: &quot;&quot;, contents: &quot;&quot;, fileUrl: &quot;&quot; &#125;) const diapatch = useDispatch const onChange = (e) =&gt; &#123; setValues(&#123; ...form, [e.target.name]: e.target.value &#125;) &#125; const onSubmit = async (e) =&gt; &#123; await e.preventDefault() const &#123; title, contents, fileUrl, category &#125; = form &#125; const getDataFromCKEditor = (event, editor) =&gt; &#123; console.log(&quot;editor&quot;) &#125; return ( &lt;div&gt; &#123;isAuthenticated ? ( &lt;Form onSubmit=&#123;onSubmit&#125;&gt; &lt;FormGroup className=&quot;mb-3&quot;&gt; &lt;Label for=&quot;title&quot;&gt;Title&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;title&quot; id=&quot;title&quot; className=&quot;form-control&quot; onChange=&#123;onChange&#125; /&gt; &lt;/FormGroup&gt; &lt;FormGroup className=&quot;mb-3&quot;&gt; &lt;Label for=&quot;category&quot;&gt;Category&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;category&quot; id=&quot;category&quot; className=&quot;form-control&quot; onChange=&#123;onChange&#125; /&gt; &lt;/FormGroup&gt; &lt;FormGroup className=&quot;mb-3&quot;&gt; &lt;Label for=&quot;content&quot;&gt;Content&lt;/Label&gt; &lt;CKEditor editor=&#123;ClassicEditor&#125; config=&#123;editorConfiguration&#125; onInit=&#123;Myinit&#125; onBlur=&#123;getDataFromCKEditor&#125; /&gt; &lt;Button color=&quot;success&quot; block className=&quot;mt-3 col-md-2 offset-md-10 mb-3&quot; &gt; 제출하기 &lt;/Button&gt; &lt;/FormGroup&gt; &lt;/Form&gt; ) : ( &lt;Col width=&#123;50&#125; className=&quot;p-5 m-5&quot;&gt; &lt;Progress animated color=&quot;info&quot; value=&#123;100&#125; /&gt; &lt;/Col&gt; )&#125; &lt;/div&gt; )&#125;export default PostWrite import React from &#x27;react&#x27;const Profile = () =&gt; &#123; &lt;div&gt; Profile &lt;/div&gt;&#125;export default Profile import React from &#x27;react&#x27;const Search = () =&gt; &#123; return ( &lt;div&gt; Search &lt;/div&gt; )&#125;export default Search","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 13 - 라우트import React from &#x27;react&#x27;;const CategoryResult = () =&gt; &#123; return &lt;h1&gt;CategoryResult&lt;/h1&gt;&#125;export default CategoryResult; import &#123; Fragment, useEffect &#125; from &quot;react&quot;;import &#123; Helmet &#125; from &quot;react-helmet&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Row, Spinner &#125; from &#x27;reactstrap&#x27;;import PostCardOne from &quot;../../components/post/PostCardOne&quot;;import &#123; POSTS_LOADING_REQUEST &#125; from &quot;../../redux/types&quot;;const PostCardList = () =&gt; &#123; const &#123; posts &#125; = useSelector((state) =&gt; state.post) const dispatch = useDispatch() useEffect(() =&gt; &#123; dispatch(&#123; type: POSTS_LOADING_REQUEST &#125;) &#125;, [dispatch]) return ( &lt;Fragment&gt; &lt;Helmet title=&quot;Home&quot; /&gt; &lt;Row&gt; &#123;posts ? &lt;PostCardOne posts=&#123;posts&#125; /&gt; : &lt;Spinner /&gt;&#125; &lt;/Row&gt; &lt;/Fragment&gt; )&#125;export default PostCardList; import React from &#x27;react&#x27;;const PostDetail = () =&gt; &#123; return ( &lt;div&gt; PostDetail &lt;/div&gt; )&#125;export default PostDetail; import React from &#x27;react&#x27;;const PostEdit = () =&gt; &#123; return ( &lt;div&gt; PostEdit &lt;/div&gt; )&#125;export default PostEdit; import React, &#123; useState &#125; from &#x27;react&#x27;import &#123; useDispatch, useSelector &#125; from &#x27;react-redux&#x27;import &#123; Col, Form, FormGroup, Label, Progress, Button, Input &#125; from &#x27;reactstrap&#x27;import &#123; CKEditor &#125; from &quot;@ckeditor/ckeditor5-react&quot;import ClassicEditor from &#x27;@ckeditor/ckeditor5-editor-classic/src/classiceditor&#x27;import &#123; editorConfiguration &#125; from &#x27;../../components/editor/EditorConfig&#x27;import Myinit from &#x27;../../components/editor/UploadAdapter&#x27;const PostWrite = () =&gt; &#123; const &#123; isAuthenticated &#125; = useSelector((state) =&gt; state.auth) const [form, setValues] = useState(&#123; title: &quot;&quot;, contents: &quot;&quot;, fileUrl: &quot;&quot; &#125;) const diapatch = useDispatch const onChange = (e) =&gt; &#123; setValues(&#123; ...form, [e.target.name]: e.target.value &#125;) &#125; const onSubmit = async (e) =&gt; &#123; await e.preventDefault() const &#123; title, contents, fileUrl, category &#125; = form &#125; const getDataFromCKEditor = (event, editor) =&gt; &#123; console.log(&quot;editor&quot;) &#125; return ( &lt;div&gt; &#123;isAuthenticated ? ( &lt;Form onSubmit=&#123;onSubmit&#125;&gt; &lt;FormGroup className=&quot;mb-3&quot;&gt; &lt;Label for=&quot;title&quot;&gt;Title&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;title&quot; id=&quot;title&quot; className=&quot;form-control&quot; onChange=&#123;onChange&#125; /&gt; &lt;/FormGroup&gt; &lt;FormGroup className=&quot;mb-3&quot;&gt; &lt;Label for=&quot;category&quot;&gt;Category&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;category&quot; id=&quot;category&quot; className=&quot;form-control&quot; onChange=&#123;onChange&#125; /&gt; &lt;/FormGroup&gt; &lt;FormGroup className=&quot;mb-3&quot;&gt; &lt;Label for=&quot;content&quot;&gt;Content&lt;/Label&gt; &lt;CKEditor editor=&#123;ClassicEditor&#125; config=&#123;editorConfiguration&#125; onInit=&#123;Myinit&#125; onBlur=&#123;getDataFromCKEditor&#125; /&gt; &lt;Button color=&quot;success&quot; block className=&quot;mt-3 col-md-2 offset-md-10 mb-3&quot; &gt; 제출하기 &lt;/Button&gt; &lt;/FormGroup&gt; &lt;/Form&gt; ) : ( &lt;Col width=&#123;50&#125; className=&quot;p-5 m-5&quot;&gt; &lt;Progress animated color=&quot;info&quot; value=&#123;100&#125; /&gt; &lt;/Col&gt; )&#125; &lt;/div&gt; )&#125;export default PostWrite import React from &#x27;react&#x27;const Profile = () =&gt; &#123; &lt;div&gt; Profile &lt;/div&gt;&#125;export default Profile import React from &#x27;react&#x27;const Search = () =&gt; &#123; return ( &lt;div&gt; Search &lt;/div&gt; )&#125;export default Search import React, &#123; Fragment &#125; from &#x27;react&#x27;;import &#123; Redirect, Route, Switch &#125; from &#x27;react-router-dom&#x27;;import &#123; Container &#125; from &#x27;reactstrap&#x27;;import AppNavbar from &quot;../components/AppNavbar&quot;;import Footer from &#x27;../components/Footer&#x27;;import Header from &#x27;../components/Header&#x27;;import CategoryResult from &#x27;./normalRoute/CategoryResult&#x27;;import PostCardList from &#x27;./normalRoute/PostCardList&#x27;;import PostDetail from &#x27;./normalRoute/PostDetail&#x27;;import PostWrite from &#x27;./normalRoute/PostWrite&#x27;;import Search from &#x27;./normalRoute/Search&#x27;;const Router = () =&gt; ( &lt;Fragment&gt; &lt;AppNavbar /&gt; &lt;Header /&gt; &lt;Container id=&quot;main-body&quot;&gt; &lt;Switch&gt; &lt;Route path=&#x27;/&#x27; exact component=&#123;PostCardList&#125; /&gt; &lt;Route path=&#x27;/post&#x27; exact component=&#123;PostWrite&#125; /&gt; &lt;Route path=&#x27;/post/:id&#x27; exact component=&#123;PostDetail&#125; /&gt; &lt;Route path=&#x27;/post/category/:categoryName&#x27; exact component=&#123;CategoryResult&#125; /&gt; &lt;Route path=&#x27;/search/:searchTerm&#x27; exact component=&#123;Search&#125; /&gt; &lt;Redirect from=&quot;*&quot; to=&quot;/&quot; /&gt; &lt;/Switch&gt; &#123;/* &lt;h1&gt;Hello Body&lt;/h1&gt; */&#125; &lt;/Container&gt; &lt;Footer /&gt; &lt;/Fragment&gt;)export default Router","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 12 - Loading 만들기","slug":"react/react-blog/react-blog-12-loading","date":"2021-09-06T08:10:40.000Z","updated":"2024-11-23T16:51:42.423Z","comments":true,"path":"2021/09/06/react/react-blog/react-blog-12-loading/","link":"","permalink":"https://ckck803.github.io/2021/09/06/react/react-blog/react-blog-12-loading/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 12 - Loading 만들기// USER LOADINGexport const USER_LOADING_REQUEST = &quot;USER_LOADING_REQUEST&quot;export const USER_LOADING_SUCCESS = &quot;USER_LOADING_SUCCESS&quot;export const USER_LOADING_FAILURE = &quot;USER_LOADING_FAILURE&quot; const authReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case REGISTER_REQUEST: case LOGIN_REQUEST: case LOGOUT_REQUEST: return &#123; ...state, errorMsg: &quot;&quot;, isLoading: true &#125; case REGISTER_SUCCESS: case LOGIN_SUCCESS: localStorage.setItem(&quot;token&quot;, action.payload.token) return &#123; ...state, ...action.payload, isAuthenticated: true, isLoading: false, userId: action.payload.user.userId, userRole: action.payload.user.role, errorMsg: &quot;&quot; &#125; case REGISTER_FAILURE: case LOGOUT_FAILURE: case LOGIN_FAILURE: localStorage.removeItem(&quot;token&quot;) return &#123; ...state, ...action.payload, token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: action.payload.user.role &#125; case LOGOUT_SUCCESS: localStorage.removeItem(&quot;token&quot;) return &#123; token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: &quot;&quot; &#125;; case CLEAR_ERROR_REQUEST: return &#123; ...state, errorMsg: null, &#125; case CLEAR_ERROR_SUCCESS: return &#123; ...state, errorMsg: null, &#125; case CLEAR_ERROR_FAILURE: return &#123; ...state, errorMsg: null &#125; case USER_LOADING_REQUEST: return &#123; ...state, isLoading: true &#125; case USER_LOADING_SUCCESS: return &#123; ...state, isAuthenticated: true, isLoading: false, user: action.payload, userId: action.payload._id, userName: action.payload.userName, userRole: action.payload.role &#125; case USER_LOADING_FAILURE: return &#123; ...state, user: null, isAuthenticated: false, isLoading: false, userRole: &quot;&quot;, &#125; default: return state; &#125;&#125; // User Loadingconst userLoadingAPI = (token) =&gt; &#123; console.log(token); const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;applicatio n/json&quot;, &#125;, &#125;; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.get(&quot;api/auth/user&quot;, config);&#125;function* userLoading(action) &#123; try &#123; console.log(action, &quot;userLoading&quot;) const result = yield call(userLoadingAPI, action.payload) console.log(result) yield put(&#123; type: USER_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: USER_LOADING_FAILURE, payload: e.response &#125;) &#125;&#125; // Clear Errorfunction* clearError() &#123; try &#123; yield put(&#123; type: CLEAR_ERROR_SUCCESS, &#125;); &#125; catch (e) &#123; yield put(&#123; type: CLEAR_ERROR_FAILURE, &#125;); &#125;&#125;function* watchClearError() &#123; yield takeEvery(CLEAR_ERROR_REQUEST, clearError);&#125; export default function* authSaga() &#123; yield all([ fork(watchLoginUser), fork(watchLogoutUser), fork(watchUserLoading), fork(watchRegisterUser), fork(watchClearError), ]);&#125; import &#123; USER_LOADING_REQUEST &#125; from &#x27;../../redux/types&#x27;;import store from &#x27;../../store&#x27;;const laodUser = () =&gt; &#123; try &#123; store.dispatch(&#123; type: USER_LOADING_REQUEST, payload: localStorage.getItem(&quot;token&quot;), &#125;); &#125; catch (e) &#123; console.log(e); &#125;&#125;export default laodUser; import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;import loadUser from &#x27;./components/auth/loadUser&#x27;;import &#x27;./index.css&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;// 로그인을 항상 유지loadUser();ReactDOM.render( &lt;App /&gt;, document.getElementById(&#x27;root&#x27;));// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals();","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 12 - Loading 만들기// USER LOADINGexport const USER_LOADING_REQUEST = &quot;USER_LOADING_REQUEST&quot;export const USER_LOADING_SUCCESS = &quot;USER_LOADING_SUCCESS&quot;export const USER_LOADING_FAILURE = &quot;USER_LOADING_FAILURE&quot; const authReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case REGISTER_REQUEST: case LOGIN_REQUEST: case LOGOUT_REQUEST: return &#123; ...state, errorMsg: &quot;&quot;, isLoading: true &#125; case REGISTER_SUCCESS: case LOGIN_SUCCESS: localStorage.setItem(&quot;token&quot;, action.payload.token) return &#123; ...state, ...action.payload, isAuthenticated: true, isLoading: false, userId: action.payload.user.userId, userRole: action.payload.user.role, errorMsg: &quot;&quot; &#125; case REGISTER_FAILURE: case LOGOUT_FAILURE: case LOGIN_FAILURE: localStorage.removeItem(&quot;token&quot;) return &#123; ...state, ...action.payload, token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: action.payload.user.role &#125; case LOGOUT_SUCCESS: localStorage.removeItem(&quot;token&quot;) return &#123; token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: &quot;&quot; &#125;; case CLEAR_ERROR_REQUEST: return &#123; ...state, errorMsg: null, &#125; case CLEAR_ERROR_SUCCESS: return &#123; ...state, errorMsg: null, &#125; case CLEAR_ERROR_FAILURE: return &#123; ...state, errorMsg: null &#125; case USER_LOADING_REQUEST: return &#123; ...state, isLoading: true &#125; case USER_LOADING_SUCCESS: return &#123; ...state, isAuthenticated: true, isLoading: false, user: action.payload, userId: action.payload._id, userName: action.payload.userName, userRole: action.payload.role &#125; case USER_LOADING_FAILURE: return &#123; ...state, user: null, isAuthenticated: false, isLoading: false, userRole: &quot;&quot;, &#125; default: return state; &#125;&#125; // User Loadingconst userLoadingAPI = (token) =&gt; &#123; console.log(token); const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;applicatio n/json&quot;, &#125;, &#125;; if (token) &#123; config.headers[&quot;x-auth-token&quot;] = token; &#125; return axios.get(&quot;api/auth/user&quot;, config);&#125;function* userLoading(action) &#123; try &#123; console.log(action, &quot;userLoading&quot;) const result = yield call(userLoadingAPI, action.payload) console.log(result) yield put(&#123; type: USER_LOADING_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: USER_LOADING_FAILURE, payload: e.response &#125;) &#125;&#125; // Clear Errorfunction* clearError() &#123; try &#123; yield put(&#123; type: CLEAR_ERROR_SUCCESS, &#125;); &#125; catch (e) &#123; yield put(&#123; type: CLEAR_ERROR_FAILURE, &#125;); &#125;&#125;function* watchClearError() &#123; yield takeEvery(CLEAR_ERROR_REQUEST, clearError);&#125; export default function* authSaga() &#123; yield all([ fork(watchLoginUser), fork(watchLogoutUser), fork(watchUserLoading), fork(watchRegisterUser), fork(watchClearError), ]);&#125; import &#123; USER_LOADING_REQUEST &#125; from &#x27;../../redux/types&#x27;;import store from &#x27;../../store&#x27;;const laodUser = () =&gt; &#123; try &#123; store.dispatch(&#123; type: USER_LOADING_REQUEST, payload: localStorage.getItem(&quot;token&quot;), &#125;); &#125; catch (e) &#123; console.log(e); &#125;&#125;export default laodUser; import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;import loadUser from &#x27;./components/auth/loadUser&#x27;;import &#x27;./index.css&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;// 로그인을 항상 유지loadUser();ReactDOM.render( &lt;App /&gt;, document.getElementById(&#x27;root&#x27;));// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals();","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 11 - 회원가입 리덕스 작업","slug":"react/react-blog/react-blog-11-register","date":"2021-09-06T06:10:40.000Z","updated":"2024-11-23T16:51:43.259Z","comments":true,"path":"2021/09/06/react/react-blog/react-blog-11-register/","link":"","permalink":"https://ckck803.github.io/2021/09/06/react/react-blog/react-blog-11-register/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업const authReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case REGISTER_REQUEST: case LOGIN_REQUEST: case LOGOUT_REQUEST: return &#123; ...state, errorMsg: &quot;&quot;, isLoading: true &#125; case REGISTER_SUCCESS: case LOGIN_SUCCESS: localStorage.setItem(&quot;token&quot;, action.payload.token) return &#123; ...state, ...action.payload, isAuthenticated: true, isLoading: false, userId: action.payload.user.userId, userRole: action.payload.user.role, errorMsg: &quot;&quot; &#125; case REGISTER_FAILURE: case LOGOUT_FAILURE: case LOGIN_FAILURE: localStorage.removeItem(&quot;token&quot;) return &#123; ...state, ...action.payload, token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: action.payload.user.role &#125; case LOGOUT_SUCCESS: localStorage.removeItem(&quot;token&quot;) return &#123; token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: &quot;&quot; &#125;; case CLEAR_ERROR_REQUEST: return &#123; ...state, errorMsg: null, &#125; case CLEAR_ERROR_SUCCESS: return &#123; ...state, errorMsg: null, &#125; case CLEAR_ERROR_FAILURE: return &#123; ...state, errorMsg: null &#125; case USER_LOADING_REQUEST: return &#123; ...state, isLoading: true &#125; case USER_LOADING_SUCCESS: return &#123; ...state, isAuthenticated: true, isLoading: false, user: action.payload, userId: action.payload._id, userName: action.payload.userName, userRole: action.payload.role &#125; case USER_LOADING_FAILURE: return &#123; ...state, user: null, isAuthenticated: false, isLoading: false, userRole: &quot;&quot;, &#125; default: return state; &#125;&#125; // Registerconst registerUserAPI = (req) =&gt; &#123; console.log(req, &quot;req&quot;); return axios.post(&quot;api/user&quot;, req);&#125;;function* registerUser(action) &#123; try &#123; const result = yield call(registerUserAPI, action.payload); console.log(result, &quot;RegisterUser Data&quot;); yield put(&#123; type: REGISTER_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: REGISTER_FAILURE, payload: e.response, &#125;); &#125;&#125;function* watchRegisterUser() &#123; yield takeEvery(REGISTER_REQUEST, registerUser);&#125; export default function* authSaga() &#123; yield all([ fork(watchLoginUser), fork(watchLogoutUser), fork(watchUserLoading), fork(watchRegisterUser), fork(watchClearError), ]);&#125;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업const authReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case REGISTER_REQUEST: case LOGIN_REQUEST: case LOGOUT_REQUEST: return &#123; ...state, errorMsg: &quot;&quot;, isLoading: true &#125; case REGISTER_SUCCESS: case LOGIN_SUCCESS: localStorage.setItem(&quot;token&quot;, action.payload.token) return &#123; ...state, ...action.payload, isAuthenticated: true, isLoading: false, userId: action.payload.user.userId, userRole: action.payload.user.role, errorMsg: &quot;&quot; &#125; case REGISTER_FAILURE: case LOGOUT_FAILURE: case LOGIN_FAILURE: localStorage.removeItem(&quot;token&quot;) return &#123; ...state, ...action.payload, token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: action.payload.user.role &#125; case LOGOUT_SUCCESS: localStorage.removeItem(&quot;token&quot;) return &#123; token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: &quot;&quot; &#125;; case CLEAR_ERROR_REQUEST: return &#123; ...state, errorMsg: null, &#125; case CLEAR_ERROR_SUCCESS: return &#123; ...state, errorMsg: null, &#125; case CLEAR_ERROR_FAILURE: return &#123; ...state, errorMsg: null &#125; case USER_LOADING_REQUEST: return &#123; ...state, isLoading: true &#125; case USER_LOADING_SUCCESS: return &#123; ...state, isAuthenticated: true, isLoading: false, user: action.payload, userId: action.payload._id, userName: action.payload.userName, userRole: action.payload.role &#125; case USER_LOADING_FAILURE: return &#123; ...state, user: null, isAuthenticated: false, isLoading: false, userRole: &quot;&quot;, &#125; default: return state; &#125;&#125; // Registerconst registerUserAPI = (req) =&gt; &#123; console.log(req, &quot;req&quot;); return axios.post(&quot;api/user&quot;, req);&#125;;function* registerUser(action) &#123; try &#123; const result = yield call(registerUserAPI, action.payload); console.log(result, &quot;RegisterUser Data&quot;); yield put(&#123; type: REGISTER_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: REGISTER_FAILURE, payload: e.response, &#125;); &#125;&#125;function* watchRegisterUser() &#123; yield takeEvery(REGISTER_REQUEST, registerUser);&#125; export default function* authSaga() &#123; yield all([ fork(watchLoginUser), fork(watchLogoutUser), fork(watchUserLoading), fork(watchRegisterUser), fork(watchClearError), ]);&#125;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 10 - 회원가입 2","slug":"react/react-blog/react-blog-10-register","date":"2021-09-06T05:10:40.000Z","updated":"2024-11-23T16:51:42.574Z","comments":true,"path":"2021/09/06/react/react-blog/react-blog-10-register/","link":"","permalink":"https://ckck803.github.io/2021/09/06/react/react-blog/react-blog-10-register/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 10 - 회원가입 2import React, &#123; Fragment, useCallback, useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; Button, Collapse, Container, Form, Nav, Navbar, NavbarToggler, NavItem,&#125; from &quot;reactstrap&quot;;import &#123; LOGOUT_REQUEST &#125; from &quot;../redux/types&quot;;import LoginModal from &quot;./auth/LoginModal&quot;;import RegisterModal from &quot;./auth/RegisterModal&quot;;const AppNavbar = () =&gt; &#123; const [isOpen, setIsOpen] = useState(false); const &#123; isAuthenticated, user, userRole &#125; = useSelector( (state) =&gt; state.auth ); console.log(userRole, &quot;UserRole&quot;); const dispatch = useDispatch(); const onLogout = useCallback(() =&gt; &#123; dispatch(&#123; type: LOGOUT_REQUEST, &#125;); &#125;, [dispatch]); useEffect(() =&gt; &#123; setIsOpen(false); &#125;, [user]); const handleToggle = () =&gt; &#123; setIsOpen(!isOpen); &#125;; const addPostClick = () =&gt; &#123;&#125;; const authLink = ( &lt;Fragment&gt; &lt;NavItem&gt; &#123;userRole === &quot;MainJuin&quot; ? ( &lt;Form className=&quot;col mt-2&quot;&gt; &lt;Link to=&quot;posts&quot; className=&quot;btn btn-success block text-white px-3&quot; onClick=&#123;addPostClick&#125; &gt; AddPost &lt;/Link&gt; &lt;/Form&gt; ) : ( &quot;&quot; )&#125; &lt;/NavItem&gt; &lt;NavItem className=&quot;d-flex justify-content-center&quot;&gt; &lt;Form className=&quot;col mt-2&quot;&gt; &#123;user &amp;&amp; user.name ? ( &lt;Link&gt; &lt;Button outline color=&quot;light&quot; className=&quot;px-3&quot; block&gt; &lt;strong&gt;&#123;user ? `Welcom $&#123;user.name&#125;` : &quot;&quot;&#125;&lt;/strong&gt; &lt;/Button&gt; &lt;/Link&gt; ) : ( &lt;Button outline color=&quot;light&quot; className=&quot;px-3&quot; block&gt; &lt;strong&gt;No User&lt;/strong&gt; &lt;/Button&gt; )&#125; &lt;/Form&gt; &lt;/NavItem&gt; &lt;NavItem&gt; &lt;Form className=&quot;col&quot;&gt; &lt;Link onClick=&#123;onLogout&#125; to=&quot;#&quot;&gt; &lt;Button outline color=&quot;light&quot; className=&quot;mt-2&quot; block&gt; Logout &lt;/Button&gt; &lt;/Link&gt; &lt;/Form&gt; &lt;/NavItem&gt; &lt;/Fragment&gt; ); const guestLink = ( &lt;Fragment&gt; &lt;NavItem&gt; &lt;RegisterModal /&gt; &lt;/NavItem&gt; &lt;NavItem&gt; &lt;LoginModal /&gt; &lt;/NavItem&gt; &lt;/Fragment&gt; ); return ( &lt;div&gt; &lt;Navbar color=&quot;dark&quot; dark expand=&quot;lg&quot; className=&quot;sticky-top&quot;&gt; &lt;Container&gt; &lt;Link to=&quot;/&quot; className=&quot;text-white text-decoration-none&quot;&gt; Victor의 블로그 &lt;/Link&gt; &lt;NavbarToggler onClick=&#123;handleToggle&#125; /&gt; &lt;Collapse isOpen=&#123;isOpen&#125; navbar&gt; &lt;Nav className=&quot;ml-auto d-flex justify-content-around&quot; navbar&gt; &#123;isAuthenticated ? authLink : guestLink&#125; &lt;/Nav&gt; &lt;/Collapse&gt; &lt;/Container&gt; &lt;/Navbar&gt; &lt;/div&gt; );&#125;;export default AppNavbar;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 10 - 회원가입 2import React, &#123; Fragment, useCallback, useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; Button, Collapse, Container, Form, Nav, Navbar, NavbarToggler, NavItem,&#125; from &quot;reactstrap&quot;;import &#123; LOGOUT_REQUEST &#125; from &quot;../redux/types&quot;;import LoginModal from &quot;./auth/LoginModal&quot;;import RegisterModal from &quot;./auth/RegisterModal&quot;;const AppNavbar = () =&gt; &#123; const [isOpen, setIsOpen] = useState(false); const &#123; isAuthenticated, user, userRole &#125; = useSelector( (state) =&gt; state.auth ); console.log(userRole, &quot;UserRole&quot;); const dispatch = useDispatch(); const onLogout = useCallback(() =&gt; &#123; dispatch(&#123; type: LOGOUT_REQUEST, &#125;); &#125;, [dispatch]); useEffect(() =&gt; &#123; setIsOpen(false); &#125;, [user]); const handleToggle = () =&gt; &#123; setIsOpen(!isOpen); &#125;; const addPostClick = () =&gt; &#123;&#125;; const authLink = ( &lt;Fragment&gt; &lt;NavItem&gt; &#123;userRole === &quot;MainJuin&quot; ? ( &lt;Form className=&quot;col mt-2&quot;&gt; &lt;Link to=&quot;posts&quot; className=&quot;btn btn-success block text-white px-3&quot; onClick=&#123;addPostClick&#125; &gt; AddPost &lt;/Link&gt; &lt;/Form&gt; ) : ( &quot;&quot; )&#125; &lt;/NavItem&gt; &lt;NavItem className=&quot;d-flex justify-content-center&quot;&gt; &lt;Form className=&quot;col mt-2&quot;&gt; &#123;user &amp;&amp; user.name ? ( &lt;Link&gt; &lt;Button outline color=&quot;light&quot; className=&quot;px-3&quot; block&gt; &lt;strong&gt;&#123;user ? `Welcom $&#123;user.name&#125;` : &quot;&quot;&#125;&lt;/strong&gt; &lt;/Button&gt; &lt;/Link&gt; ) : ( &lt;Button outline color=&quot;light&quot; className=&quot;px-3&quot; block&gt; &lt;strong&gt;No User&lt;/strong&gt; &lt;/Button&gt; )&#125; &lt;/Form&gt; &lt;/NavItem&gt; &lt;NavItem&gt; &lt;Form className=&quot;col&quot;&gt; &lt;Link onClick=&#123;onLogout&#125; to=&quot;#&quot;&gt; &lt;Button outline color=&quot;light&quot; className=&quot;mt-2&quot; block&gt; Logout &lt;/Button&gt; &lt;/Link&gt; &lt;/Form&gt; &lt;/NavItem&gt; &lt;/Fragment&gt; ); const guestLink = ( &lt;Fragment&gt; &lt;NavItem&gt; &lt;RegisterModal /&gt; &lt;/NavItem&gt; &lt;NavItem&gt; &lt;LoginModal /&gt; &lt;/NavItem&gt; &lt;/Fragment&gt; ); return ( &lt;div&gt; &lt;Navbar color=&quot;dark&quot; dark expand=&quot;lg&quot; className=&quot;sticky-top&quot;&gt; &lt;Container&gt; &lt;Link to=&quot;/&quot; className=&quot;text-white text-decoration-none&quot;&gt; Victor의 블로그 &lt;/Link&gt; &lt;NavbarToggler onClick=&#123;handleToggle&#125; /&gt; &lt;Collapse isOpen=&#123;isOpen&#125; navbar&gt; &lt;Nav className=&quot;ml-auto d-flex justify-content-around&quot; navbar&gt; &#123;isAuthenticated ? authLink : guestLink&#125; &lt;/Nav&gt; &lt;/Collapse&gt; &lt;/Container&gt; &lt;/Navbar&gt; &lt;/div&gt; );&#125;;export default AppNavbar;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 9 - 회원가입","slug":"react/react-blog/react-blog-09-register","date":"2021-09-06T03:10:40.000Z","updated":"2024-11-23T16:51:43.151Z","comments":true,"path":"2021/09/06/react/react-blog/react-blog-09-register/","link":"","permalink":"https://ckck803.github.io/2021/09/06/react/react-blog/react-blog-09-register/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 9 - 회원가입// REGISTERexport const REGISTER_REQUEST = &quot;REGISTER_REQUEST&quot;;export const REGISTER_SUCCESS = &quot;REGISTER_SUCCESS&quot;;export const REGISTER_FAILURE = &quot;REGISTER_FAILURE&quot;; import React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Alert, Button, Form, FormGroup, Input, Label, Modal, ModalBody, ModalHeader, NavLink,&#125; from &quot;reactstrap&quot;;import &#123; CLEAR_ERROR_REQUEST, REGISTER_REQUEST &#125; from &quot;../../redux/types&quot;;const RegisterModal = () =&gt; &#123; const [modal, setModal] = useState(false); const [form, setValue] = useState(&#123; name: &quot;&quot;, email: &quot;&quot;, password: &quot;&quot;, &#125;); const [localMsg, setLocalMsg] = useState(&quot;&quot;); const &#123; errorMsg &#125; = useSelector((state) =&gt; state.auth); const dispatch = useDispatch(); const handleToggle = () =&gt; &#123; dispatch(&#123; type: CLEAR_ERROR_REQUEST, &#125;); setModal(!modal); &#125;; useEffect(() =&gt; &#123; try &#123; setLocalMsg(errorMsg); &#125; catch (e) &#123; console.error(e); &#125; &#125;, [errorMsg]); const onChange = (e) =&gt; &#123; setValue(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;; const onSubmit = (e) =&gt; &#123; e.preventDefault(); const &#123; name, email, password &#125; = form; const newUser = &#123; name, email, password &#125;; console.log(newUser, &quot;newUser&quot;); dispatch(&#123; type: REGISTER_REQUEST, payload: newUser, &#125;); &#125;; return ( &lt;div&gt; &lt;NavLink onClick=&#123;handleToggle&#125; href=&quot;#&quot;&gt; Register &lt;/NavLink&gt; &lt;Modal isOpen=&#123;modal&#125; toggle=&#123;handleToggle&#125;&gt; &lt;ModalHeader toggle=&#123;handleToggle&#125;&gt;Register&lt;/ModalHeader&gt; &lt;ModalBody&gt; &#123;localMsg ? &lt;Alert color=&quot;danger&quot;&gt;&lt;/Alert&gt; : null&#125; &lt;Form onSubmit=&#123;onSubmit&#125;&gt; &lt;FormGroup&gt; &lt;Label for=&quot;name&quot;&gt;Name&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;Name&quot; onChange=&#123;onChange&#125; /&gt; &lt;Label for=&quot;email&quot;&gt;Email&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;email&quot; onChange=&#123;onChange&#125; /&gt; &lt;Label for=&quot;password&quot;&gt;Password&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;Button color=&quot;dark&quot; className=&quot;mt-2&quot; block&gt; Register &lt;/Button&gt; &lt;/FormGroup&gt; &lt;/Form&gt; &lt;/ModalBody&gt; &lt;/Modal&gt; &lt;/div&gt; );&#125;;export default RegisterModal; import React, &#123; Fragment, useCallback, useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; Button, Collapse, Container, Form, Nav, Navbar, NavbarToggler, NavItem,&#125; from &quot;reactstrap&quot;;import &#123; LOGOUT_REQUEST &#125; from &quot;../redux/types&quot;;import LoginModal from &quot;./auth/LoginModal&quot;;import RegisterModal from &quot;./auth/RegisterModal&quot;;const AppNavbar = () =&gt; &#123; const [isOpen, setIsOpen] = useState(false); const &#123; isAuthenticated, user, userRole &#125; = useSelector( (state) =&gt; state.auth ); console.log(userRole, &quot;UserRole&quot;); const dispatch = useDispatch(); const onLogout = useCallback(() =&gt; &#123; dispatch(&#123; type: LOGOUT_REQUEST, &#125;); &#125;, [dispatch]); useEffect(() =&gt; &#123; setIsOpen(false); &#125;, [user]); const handleToggle = () =&gt; &#123; setIsOpen(!isOpen); &#125;; const addPostClick = () =&gt; &#123;&#125;; const authLink = ( &lt;Fragment&gt; &lt;NavItem&gt; &#123;userRole === &quot;MainJuin&quot; ? ( &lt;Form className=&quot;col mt-2&quot;&gt; &lt;Link to=&quot;posts&quot; className=&quot;btn btn-success block text-white px-3&quot; onClick=&#123;addPostClick&#125; &gt; AddPost &lt;/Link&gt; &lt;/Form&gt; ) : ( &quot;&quot; )&#125; &lt;/NavItem&gt; &lt;NavItem className=&quot;d-flex justify-content-center&quot;&gt; &lt;Form className=&quot;col mt-2&quot;&gt; &#123;user &amp;&amp; user.name ? ( &lt;Link&gt; &lt;Button outline color=&quot;light&quot; className=&quot;px-3&quot; block&gt; &lt;strong&gt;&#123;user ? `Welcom $&#123;user.name&#125;` : &quot;&quot;&#125;&lt;/strong&gt; &lt;/Button&gt; &lt;/Link&gt; ) : ( &lt;Button outline color=&quot;light&quot; className=&quot;px-3&quot; block&gt; &lt;strong&gt;No User&lt;/strong&gt; &lt;/Button&gt; )&#125; &lt;/Form&gt; &lt;/NavItem&gt; &lt;NavItem&gt; &lt;Form className=&quot;col&quot;&gt; &lt;Link onClick=&#123;onLogout&#125; to=&quot;#&quot;&gt; &lt;Button outline color=&quot;light&quot; className=&quot;mt-2&quot; block&gt; Logout &lt;/Button&gt; &lt;/Link&gt; &lt;/Form&gt; &lt;/NavItem&gt; &lt;/Fragment&gt; ); const guestLink = ( &lt;Fragment&gt; &lt;NavItem&gt; &lt;RegisterModal /&gt; &lt;/NavItem&gt; &lt;NavItem&gt; &lt;LoginModal /&gt; &lt;/NavItem&gt; &lt;/Fragment&gt; ); return ( &lt;div&gt; &lt;Navbar color=&quot;dark&quot; dark expand=&quot;lg&quot; className=&quot;sticky-top&quot;&gt; &lt;Container&gt; &lt;Link to=&quot;/&quot; className=&quot;text-white text-decoration-none&quot;&gt; Victor의 블로그 &lt;/Link&gt; &lt;NavbarToggler onClick=&#123;handleToggle&#125; /&gt; &lt;Collapse isOpen=&#123;isOpen&#125; navbar&gt; &lt;Nav className=&quot;ml-auto d-flex justify-content-around&quot; navbar&gt; &#123;isAuthenticated ? authLink : guestLink&#125; &lt;/Nav&gt; &lt;/Collapse&gt; &lt;/Container&gt; &lt;/Navbar&gt; &lt;/div&gt; );&#125;;export default AppNavbar;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 9 - 회원가입// REGISTERexport const REGISTER_REQUEST = &quot;REGISTER_REQUEST&quot;;export const REGISTER_SUCCESS = &quot;REGISTER_SUCCESS&quot;;export const REGISTER_FAILURE = &quot;REGISTER_FAILURE&quot;; import React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Alert, Button, Form, FormGroup, Input, Label, Modal, ModalBody, ModalHeader, NavLink,&#125; from &quot;reactstrap&quot;;import &#123; CLEAR_ERROR_REQUEST, REGISTER_REQUEST &#125; from &quot;../../redux/types&quot;;const RegisterModal = () =&gt; &#123; const [modal, setModal] = useState(false); const [form, setValue] = useState(&#123; name: &quot;&quot;, email: &quot;&quot;, password: &quot;&quot;, &#125;); const [localMsg, setLocalMsg] = useState(&quot;&quot;); const &#123; errorMsg &#125; = useSelector((state) =&gt; state.auth); const dispatch = useDispatch(); const handleToggle = () =&gt; &#123; dispatch(&#123; type: CLEAR_ERROR_REQUEST, &#125;); setModal(!modal); &#125;; useEffect(() =&gt; &#123; try &#123; setLocalMsg(errorMsg); &#125; catch (e) &#123; console.error(e); &#125; &#125;, [errorMsg]); const onChange = (e) =&gt; &#123; setValue(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;; const onSubmit = (e) =&gt; &#123; e.preventDefault(); const &#123; name, email, password &#125; = form; const newUser = &#123; name, email, password &#125;; console.log(newUser, &quot;newUser&quot;); dispatch(&#123; type: REGISTER_REQUEST, payload: newUser, &#125;); &#125;; return ( &lt;div&gt; &lt;NavLink onClick=&#123;handleToggle&#125; href=&quot;#&quot;&gt; Register &lt;/NavLink&gt; &lt;Modal isOpen=&#123;modal&#125; toggle=&#123;handleToggle&#125;&gt; &lt;ModalHeader toggle=&#123;handleToggle&#125;&gt;Register&lt;/ModalHeader&gt; &lt;ModalBody&gt; &#123;localMsg ? &lt;Alert color=&quot;danger&quot;&gt;&lt;/Alert&gt; : null&#125; &lt;Form onSubmit=&#123;onSubmit&#125;&gt; &lt;FormGroup&gt; &lt;Label for=&quot;name&quot;&gt;Name&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;Name&quot; onChange=&#123;onChange&#125; /&gt; &lt;Label for=&quot;email&quot;&gt;Email&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;email&quot; onChange=&#123;onChange&#125; /&gt; &lt;Label for=&quot;password&quot;&gt;Password&lt;/Label&gt; &lt;Input type=&quot;text&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;Password&quot; onChange=&#123;onChange&#125; /&gt; &lt;Button color=&quot;dark&quot; className=&quot;mt-2&quot; block&gt; Register &lt;/Button&gt; &lt;/FormGroup&gt; &lt;/Form&gt; &lt;/ModalBody&gt; &lt;/Modal&gt; &lt;/div&gt; );&#125;;export default RegisterModal; import React, &#123; Fragment, useCallback, useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; Button, Collapse, Container, Form, Nav, Navbar, NavbarToggler, NavItem,&#125; from &quot;reactstrap&quot;;import &#123; LOGOUT_REQUEST &#125; from &quot;../redux/types&quot;;import LoginModal from &quot;./auth/LoginModal&quot;;import RegisterModal from &quot;./auth/RegisterModal&quot;;const AppNavbar = () =&gt; &#123; const [isOpen, setIsOpen] = useState(false); const &#123; isAuthenticated, user, userRole &#125; = useSelector( (state) =&gt; state.auth ); console.log(userRole, &quot;UserRole&quot;); const dispatch = useDispatch(); const onLogout = useCallback(() =&gt; &#123; dispatch(&#123; type: LOGOUT_REQUEST, &#125;); &#125;, [dispatch]); useEffect(() =&gt; &#123; setIsOpen(false); &#125;, [user]); const handleToggle = () =&gt; &#123; setIsOpen(!isOpen); &#125;; const addPostClick = () =&gt; &#123;&#125;; const authLink = ( &lt;Fragment&gt; &lt;NavItem&gt; &#123;userRole === &quot;MainJuin&quot; ? ( &lt;Form className=&quot;col mt-2&quot;&gt; &lt;Link to=&quot;posts&quot; className=&quot;btn btn-success block text-white px-3&quot; onClick=&#123;addPostClick&#125; &gt; AddPost &lt;/Link&gt; &lt;/Form&gt; ) : ( &quot;&quot; )&#125; &lt;/NavItem&gt; &lt;NavItem className=&quot;d-flex justify-content-center&quot;&gt; &lt;Form className=&quot;col mt-2&quot;&gt; &#123;user &amp;&amp; user.name ? ( &lt;Link&gt; &lt;Button outline color=&quot;light&quot; className=&quot;px-3&quot; block&gt; &lt;strong&gt;&#123;user ? `Welcom $&#123;user.name&#125;` : &quot;&quot;&#125;&lt;/strong&gt; &lt;/Button&gt; &lt;/Link&gt; ) : ( &lt;Button outline color=&quot;light&quot; className=&quot;px-3&quot; block&gt; &lt;strong&gt;No User&lt;/strong&gt; &lt;/Button&gt; )&#125; &lt;/Form&gt; &lt;/NavItem&gt; &lt;NavItem&gt; &lt;Form className=&quot;col&quot;&gt; &lt;Link onClick=&#123;onLogout&#125; to=&quot;#&quot;&gt; &lt;Button outline color=&quot;light&quot; className=&quot;mt-2&quot; block&gt; Logout &lt;/Button&gt; &lt;/Link&gt; &lt;/Form&gt; &lt;/NavItem&gt; &lt;/Fragment&gt; ); const guestLink = ( &lt;Fragment&gt; &lt;NavItem&gt; &lt;RegisterModal /&gt; &lt;/NavItem&gt; &lt;NavItem&gt; &lt;LoginModal /&gt; &lt;/NavItem&gt; &lt;/Fragment&gt; ); return ( &lt;div&gt; &lt;Navbar color=&quot;dark&quot; dark expand=&quot;lg&quot; className=&quot;sticky-top&quot;&gt; &lt;Container&gt; &lt;Link to=&quot;/&quot; className=&quot;text-white text-decoration-none&quot;&gt; Victor의 블로그 &lt;/Link&gt; &lt;NavbarToggler onClick=&#123;handleToggle&#125; /&gt; &lt;Collapse isOpen=&#123;isOpen&#125; navbar&gt; &lt;Nav className=&quot;ml-auto d-flex justify-content-around&quot; navbar&gt; &#123;isAuthenticated ? authLink : guestLink&#125; &lt;/Nav&gt; &lt;/Collapse&gt; &lt;/Container&gt; &lt;/Navbar&gt; &lt;/div&gt; );&#125;;export default AppNavbar;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 8 - 로그인 & 로그아웃","slug":"react/react-blog/react-blog-08-logout","date":"2021-09-06T02:10:40.000Z","updated":"2024-11-23T16:51:43.068Z","comments":true,"path":"2021/09/06/react/react-blog/react-blog-08-logout/","link":"","permalink":"https://ckck803.github.io/2021/09/06/react/react-blog/react-blog-08-logout/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃//LOGINexport const LOGIN_REQUEST = &quot;LOGIN_REQUEST&quot;;export const LOGIN_SUCCESS = &quot;LOGIN_SUCCESS&quot;;export const LOGIN_FAILURE = &quot;LOGIN_FAILURE&quot;;//LOGINexport const LOGOUT_REQUEST = &quot;LOGOUT_REQUEST&quot;;export const LOGOUT_SUCCESS = &quot;LOGOUT_SUCCESS&quot;;export const LOGOUT_FAILURE = &quot;LOGOUT_FAILURE&quot;;// CLEAR ERRORexport const CLEAR_ERROR_REQUEST = &quot;CLEAR_REQUEST&quot;;export const CLEAR_ERROR_SUCCESS = &quot;CLEAR_SUCCESS&quot;;export const CLEAR_ERROR_FAILURE = &quot;CLEAR_FAILURE&quot;; import &#123; LOGIN_REQUEST, LOGIN_SUCCESS, LOGIN_FAILURE, CLEAR_ERROR_REQUEST, CLEAR_ERROR_SUCCESS, CLEAR_ERROR_FAILURE, LOGOUT_REQUEST, LOGOUT_SUCCESS, LOGOUT_FAILURE,&#125; from &quot;../types&quot;;const initialState = &#123; token: localStorage.getItem(&quot;token&quot;), isAuthenticated: null, isLoading: false, user: &quot;&quot;, userId: &quot;&quot;, userName: &quot;&quot;, userRole: &quot;&quot;, errorMsg: &quot;&quot;, successMsg: &quot;&quot;,&#125;;const authReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case LOGOUT_REQUEST: case LOGIN_REQUEST: return &#123; ...state, errorMsg: &quot;&quot;, &#125;; case LOGIN_SUCCESS: localStorage.setItem(&quot;token&quot;, action.payload.token); return &#123; ...state, ...action.payload, isAuthenticated: true, isLoading: false, userId: action.payload.user.id, userRole: action.payload.user.role, errorMsg: &quot;&quot;, &#125;; case LOGOUT_FAILURE: case LOGIN_FAILURE: localStorage.removeItem(&quot;token&quot;); return &#123; ...state, ...action.payload, token: null, user: null, userId: null, userRole: null, errorMsg: action.payload.data.msg, &#125;; case LOGOUT_SUCCESS: localStorage.removeItem(&quot;token&quot;); return &#123; ...state, ...action.payload, token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: &quot;&quot;, &#125;; case CLEAR_ERROR_REQUEST: return &#123; ...state, errorMsg: null, &#125;; case CLEAR_ERROR_SUCCESS: return &#123; ...state, errorMsg: null, &#125;; case CLEAR_ERROR_FAILURE: return &#123; ...state, errorMsg: null, &#125;; default: return state; &#125;&#125;;export default authReducer; import &#123; all, put &#125; from &quot;@redux-saga/core/effects&quot;;import axios from &quot;axios&quot;;import &#123; call, fork, takeEvery &#125; from &quot;redux-saga/effects&quot;;import &#123; LOGIN_FAILURE, LOGIN_REQUEST, LOGIN_SUCCESS, LOGOUT_REQUEST,&#125; from &quot;../types&quot;;const loginUserAPI = (loginData) =&gt; &#123; console.log(loginData, &quot;loginData&quot;); const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; return axios.post(&quot;api/auth&quot;, loginData, config);&#125;;function* loginUser(action) &#123; try &#123; const result = yield call(loginUserAPI, action.payload); console.log(result); yield put(&#123; type: LOGIN_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: LOGIN_FAILURE, payload: e.response, &#125;); &#125;&#125;function* logout(action) &#123; try &#123; const result = yield call(loginUserAPI, action.payload); console.log(result); yield put(&#123; type: LOGIN_SUCCESS, &#125;); &#125; catch (e) &#123; yield put(&#123; type: LOGIN_FAILURE, &#125;); console.log(e); &#125;&#125;function* watchLoginUser() &#123; yield takeEvery(LOGIN_REQUEST, loginUser);&#125;function* watchLogout() &#123; yield takeEvery(LOGOUT_REQUEST, logout);&#125;export default function* authSaga() &#123; yield all([fork(watchLoginUser), fork(watchLogout)]);&#125; import React, &#123; useCallback, useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; Collapse, Container, Nav, Navbar, NavbarToggler &#125; from &quot;reactstrap&quot;;import &#123; LOGOUT_REQUEST &#125; from &quot;../redux/types&quot;;import LoginModal from &quot;./auth/LoginModal&quot;;const AppNavbar = () =&gt; &#123; const [isOpen, setIsOpen] = useState(false); const &#123; isAuthenticated, user, userRole &#125; = useSelector( (state) =&gt; state.auth ); console.log(userRole, &quot;UserRole&quot;); const dispatch = useDispatch(); const onLogout = useCallback(() =&gt; &#123; dispatch(&#123; type: LOGOUT_REQUEST, &#125;); &#125;, [dispatch]); useEffect(() =&gt; &#123; setIsOpen(false); &#125;, [user]); const handleToggle = () =&gt; &#123; setIsOpen(!isOpen); &#125;; return ( &lt;div&gt; &lt;Navbar color=&quot;dark&quot; dark expand=&quot;lg&quot; className=&quot;sticky-top&quot;&gt; &lt;Container&gt; &lt;Link to=&quot;/&quot; className=&quot;text-white text-decoration-none&quot;&gt; Victor의 블로그 &lt;/Link&gt; &lt;NavbarToggler onClick=&#123;handleToggle&#125; /&gt; &lt;Collapse isOpen=&#123;isOpen&#125; navbar&gt; &lt;Nav className=&quot;ml-auto d-flex justify-content-around&quot; navbar&gt; &#123;isAuthenticated ? ( &lt;h1 className=&quot;text-white&quot;&gt;authLink&lt;/h1&gt; ) : ( &lt;LoginModal /&gt; )&#125; &lt;/Nav&gt; &lt;/Collapse&gt; &lt;/Container&gt; &lt;/Navbar&gt; &lt;/div&gt; );&#125;;export default AppNavbar;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃//LOGINexport const LOGIN_REQUEST = &quot;LOGIN_REQUEST&quot;;export const LOGIN_SUCCESS = &quot;LOGIN_SUCCESS&quot;;export const LOGIN_FAILURE = &quot;LOGIN_FAILURE&quot;;//LOGINexport const LOGOUT_REQUEST = &quot;LOGOUT_REQUEST&quot;;export const LOGOUT_SUCCESS = &quot;LOGOUT_SUCCESS&quot;;export const LOGOUT_FAILURE = &quot;LOGOUT_FAILURE&quot;;// CLEAR ERRORexport const CLEAR_ERROR_REQUEST = &quot;CLEAR_REQUEST&quot;;export const CLEAR_ERROR_SUCCESS = &quot;CLEAR_SUCCESS&quot;;export const CLEAR_ERROR_FAILURE = &quot;CLEAR_FAILURE&quot;; import &#123; LOGIN_REQUEST, LOGIN_SUCCESS, LOGIN_FAILURE, CLEAR_ERROR_REQUEST, CLEAR_ERROR_SUCCESS, CLEAR_ERROR_FAILURE, LOGOUT_REQUEST, LOGOUT_SUCCESS, LOGOUT_FAILURE,&#125; from &quot;../types&quot;;const initialState = &#123; token: localStorage.getItem(&quot;token&quot;), isAuthenticated: null, isLoading: false, user: &quot;&quot;, userId: &quot;&quot;, userName: &quot;&quot;, userRole: &quot;&quot;, errorMsg: &quot;&quot;, successMsg: &quot;&quot;,&#125;;const authReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case LOGOUT_REQUEST: case LOGIN_REQUEST: return &#123; ...state, errorMsg: &quot;&quot;, &#125;; case LOGIN_SUCCESS: localStorage.setItem(&quot;token&quot;, action.payload.token); return &#123; ...state, ...action.payload, isAuthenticated: true, isLoading: false, userId: action.payload.user.id, userRole: action.payload.user.role, errorMsg: &quot;&quot;, &#125;; case LOGOUT_FAILURE: case LOGIN_FAILURE: localStorage.removeItem(&quot;token&quot;); return &#123; ...state, ...action.payload, token: null, user: null, userId: null, userRole: null, errorMsg: action.payload.data.msg, &#125;; case LOGOUT_SUCCESS: localStorage.removeItem(&quot;token&quot;); return &#123; ...state, ...action.payload, token: null, user: null, userId: null, isAuthenticated: false, isLoading: false, userRole: null, errorMsg: &quot;&quot;, &#125;; case CLEAR_ERROR_REQUEST: return &#123; ...state, errorMsg: null, &#125;; case CLEAR_ERROR_SUCCESS: return &#123; ...state, errorMsg: null, &#125;; case CLEAR_ERROR_FAILURE: return &#123; ...state, errorMsg: null, &#125;; default: return state; &#125;&#125;;export default authReducer; import &#123; all, put &#125; from &quot;@redux-saga/core/effects&quot;;import axios from &quot;axios&quot;;import &#123; call, fork, takeEvery &#125; from &quot;redux-saga/effects&quot;;import &#123; LOGIN_FAILURE, LOGIN_REQUEST, LOGIN_SUCCESS, LOGOUT_REQUEST,&#125; from &quot;../types&quot;;const loginUserAPI = (loginData) =&gt; &#123; console.log(loginData, &quot;loginData&quot;); const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; return axios.post(&quot;api/auth&quot;, loginData, config);&#125;;function* loginUser(action) &#123; try &#123; const result = yield call(loginUserAPI, action.payload); console.log(result); yield put(&#123; type: LOGIN_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: LOGIN_FAILURE, payload: e.response, &#125;); &#125;&#125;function* logout(action) &#123; try &#123; const result = yield call(loginUserAPI, action.payload); console.log(result); yield put(&#123; type: LOGIN_SUCCESS, &#125;); &#125; catch (e) &#123; yield put(&#123; type: LOGIN_FAILURE, &#125;); console.log(e); &#125;&#125;function* watchLoginUser() &#123; yield takeEvery(LOGIN_REQUEST, loginUser);&#125;function* watchLogout() &#123; yield takeEvery(LOGOUT_REQUEST, logout);&#125;export default function* authSaga() &#123; yield all([fork(watchLoginUser), fork(watchLogout)]);&#125; import React, &#123; useCallback, useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; Collapse, Container, Nav, Navbar, NavbarToggler &#125; from &quot;reactstrap&quot;;import &#123; LOGOUT_REQUEST &#125; from &quot;../redux/types&quot;;import LoginModal from &quot;./auth/LoginModal&quot;;const AppNavbar = () =&gt; &#123; const [isOpen, setIsOpen] = useState(false); const &#123; isAuthenticated, user, userRole &#125; = useSelector( (state) =&gt; state.auth ); console.log(userRole, &quot;UserRole&quot;); const dispatch = useDispatch(); const onLogout = useCallback(() =&gt; &#123; dispatch(&#123; type: LOGOUT_REQUEST, &#125;); &#125;, [dispatch]); useEffect(() =&gt; &#123; setIsOpen(false); &#125;, [user]); const handleToggle = () =&gt; &#123; setIsOpen(!isOpen); &#125;; return ( &lt;div&gt; &lt;Navbar color=&quot;dark&quot; dark expand=&quot;lg&quot; className=&quot;sticky-top&quot;&gt; &lt;Container&gt; &lt;Link to=&quot;/&quot; className=&quot;text-white text-decoration-none&quot;&gt; Victor의 블로그 &lt;/Link&gt; &lt;NavbarToggler onClick=&#123;handleToggle&#125; /&gt; &lt;Collapse isOpen=&#123;isOpen&#125; navbar&gt; &lt;Nav className=&quot;ml-auto d-flex justify-content-around&quot; navbar&gt; &#123;isAuthenticated ? ( &lt;h1 className=&quot;text-white&quot;&gt;authLink&lt;/h1&gt; ) : ( &lt;LoginModal /&gt; )&#125; &lt;/Nav&gt; &lt;/Collapse&gt; &lt;/Container&gt; &lt;/Navbar&gt; &lt;/div&gt; );&#125;;export default AppNavbar;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 7 - Login Modal 만들기 2","slug":"react/react-blog/react-blog-07-login","date":"2021-09-06T01:10:40.000Z","updated":"2024-11-23T16:51:42.837Z","comments":true,"path":"2021/09/06/react/react-blog/react-blog-07-login/","link":"","permalink":"https://ckck803.github.io/2021/09/06/react/react-blog/react-blog-07-login/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 7 - Login Modal 만들기 2import React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; NavLink &#125; from &quot;react-router-dom&quot;;import &#123; Alert, Button, Form, FormGroup, Input, Label, Modal, ModalBody, ModalHeader,&#125; from &quot;reactstrap&quot;;import &#123; CLEAR_ERROR_REQUEST, LOGIN_REQUEST &#125; from &quot;../../redux/types&quot;;const LoginModal = () =&gt; &#123; const [modal, setModal] = useState(false); const [localMsg, setLocalMsg] = useState(&quot;&quot;); const [form, setValues] = useState(&#123; email: &quot;&quot;, password: &quot;&quot;, &#125;); const dispatch = useDispatch(); const &#123; errorMsg &#125; = useSelector((state) =&gt; state.auth); useEffect(() =&gt; &#123; try &#123; setLocalMsg(errorMsg); &#125; catch (e) &#123; console.log(e); &#125; &#125;, [errorMsg]); const handleToggle = () =&gt; &#123; dispatch(&#123; type: CLEAR_ERROR_REQUEST, &#125;); setModal(!modal); &#125;; const onChange = (e) =&gt; &#123; setValues(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;; const onSubmit = (e) =&gt; &#123; e.preventDefault(); const &#123; email, password &#125; = form; const user = &#123; email, password &#125;; console.log(user); dispatch(&#123; type: LOGIN_REQUEST, data: user, &#125;); &#125;; return ( &lt;div&gt; &lt;NavLink onClick=&#123;handleToggle&#125; href=&quot;#&quot;&gt; Login &lt;/NavLink&gt; &lt;Modal isOpen=&#123;modal&#125; toggle=&#123;handleToggle&#125;&gt; &lt;ModalHeader toggle=&#123;handleToggle&#125;&gt;Login&lt;/ModalHeader&gt; &lt;ModalBody&gt; &#123;localMsg ? &lt;Alert color=&quot;danger&quot;&gt;&#123;localMsg&#125;&lt;/Alert&gt; : null&#125; &lt;Form&gt; &lt;FormGroup&gt; &lt;Label for=&quot;email&quot;&gt;Email&lt;/Label&gt; &lt;Input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;Label for=&quot;passowrd&quot;&gt;Passowrd&lt;/Label&gt; &lt;Input type=&quot;passowrd&quot; name=&quot;passowrd&quot; id=&quot;passowrd&quot; placeholder=&quot;Passowrd&quot; onChange=&#123;onChange&#125; /&gt; &lt;Button color=&quot;dark&quot; style=&#123;&#123; marginTop: &quot;2rem&quot; &#125;&#125; block /&gt; &lt;/FormGroup&gt; &lt;/Form&gt; &lt;/ModalBody&gt; &lt;/Modal&gt; &lt;/div&gt; );&#125;;export default LoginModal;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 7 - Login Modal 만들기 2import React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;import &#123; NavLink &#125; from &quot;react-router-dom&quot;;import &#123; Alert, Button, Form, FormGroup, Input, Label, Modal, ModalBody, ModalHeader,&#125; from &quot;reactstrap&quot;;import &#123; CLEAR_ERROR_REQUEST, LOGIN_REQUEST &#125; from &quot;../../redux/types&quot;;const LoginModal = () =&gt; &#123; const [modal, setModal] = useState(false); const [localMsg, setLocalMsg] = useState(&quot;&quot;); const [form, setValues] = useState(&#123; email: &quot;&quot;, password: &quot;&quot;, &#125;); const dispatch = useDispatch(); const &#123; errorMsg &#125; = useSelector((state) =&gt; state.auth); useEffect(() =&gt; &#123; try &#123; setLocalMsg(errorMsg); &#125; catch (e) &#123; console.log(e); &#125; &#125;, [errorMsg]); const handleToggle = () =&gt; &#123; dispatch(&#123; type: CLEAR_ERROR_REQUEST, &#125;); setModal(!modal); &#125;; const onChange = (e) =&gt; &#123; setValues(&#123; ...form, [e.target.name]: e.target.value, &#125;); &#125;; const onSubmit = (e) =&gt; &#123; e.preventDefault(); const &#123; email, password &#125; = form; const user = &#123; email, password &#125;; console.log(user); dispatch(&#123; type: LOGIN_REQUEST, data: user, &#125;); &#125;; return ( &lt;div&gt; &lt;NavLink onClick=&#123;handleToggle&#125; href=&quot;#&quot;&gt; Login &lt;/NavLink&gt; &lt;Modal isOpen=&#123;modal&#125; toggle=&#123;handleToggle&#125;&gt; &lt;ModalHeader toggle=&#123;handleToggle&#125;&gt;Login&lt;/ModalHeader&gt; &lt;ModalBody&gt; &#123;localMsg ? &lt;Alert color=&quot;danger&quot;&gt;&#123;localMsg&#125;&lt;/Alert&gt; : null&#125; &lt;Form&gt; &lt;FormGroup&gt; &lt;Label for=&quot;email&quot;&gt;Email&lt;/Label&gt; &lt;Input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Email&quot; onChange=&#123;onChange&#125; /&gt; &lt;Label for=&quot;passowrd&quot;&gt;Passowrd&lt;/Label&gt; &lt;Input type=&quot;passowrd&quot; name=&quot;passowrd&quot; id=&quot;passowrd&quot; placeholder=&quot;Passowrd&quot; onChange=&#123;onChange&#125; /&gt; &lt;Button color=&quot;dark&quot; style=&#123;&#123; marginTop: &quot;2rem&quot; &#125;&#125; block /&gt; &lt;/FormGroup&gt; &lt;/Form&gt; &lt;/ModalBody&gt; &lt;/Modal&gt; &lt;/div&gt; );&#125;;export default LoginModal;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 6 - Login Modal 만들기 1","slug":"react/react-blog/react-blog-06-login","date":"2021-09-05T14:10:40.000Z","updated":"2024-11-23T16:51:42.687Z","comments":true,"path":"2021/09/05/react/react-blog/react-blog-06-login/","link":"","permalink":"https://ckck803.github.io/2021/09/05/react/react-blog/react-blog-06-login/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 6 - Login Modal 만들기 1import &#123; all, put &#125; from &quot;@redux-saga/core/effects&quot;;import axios from &quot;axios&quot;;import &#123; takeEvery &#125; from &quot;redux-saga&quot;;import &#123; call, fork &#125; from &quot;redux-saga/effects&quot;;import &#123; LOGIN_FAILURE, LOGIN_REQUEST, LOGIN_SUCCESS &#125; from &quot;../types&quot;;const loginUserAPI = (loginData) =&gt; &#123; console.log(loginData, &quot;loginData&quot;); const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; return axios.post(&quot;api/auth&quot;, loginData, config);&#125;;function* loginUser(action) &#123; try &#123; const result = yield call(loginUserAPI, action.payload); console.log(result); yield put(&#123; ytpe: LOGIN_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: LOGIN_FAILURE, payload: e.response, &#125;); &#125;&#125;function* watchLoginUser() &#123; yield takeEvery(LOGIN_REQUEST, loginUser);&#125;export default function* authSaga()&#123; yield all([ fork(watchLoginUser) ])&#125;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 6 - Login Modal 만들기 1import &#123; all, put &#125; from &quot;@redux-saga/core/effects&quot;;import axios from &quot;axios&quot;;import &#123; takeEvery &#125; from &quot;redux-saga&quot;;import &#123; call, fork &#125; from &quot;redux-saga/effects&quot;;import &#123; LOGIN_FAILURE, LOGIN_REQUEST, LOGIN_SUCCESS &#125; from &quot;../types&quot;;const loginUserAPI = (loginData) =&gt; &#123; console.log(loginData, &quot;loginData&quot;); const config = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &#125;, &#125;; return axios.post(&quot;api/auth&quot;, loginData, config);&#125;;function* loginUser(action) &#123; try &#123; const result = yield call(loginUserAPI, action.payload); console.log(result); yield put(&#123; ytpe: LOGIN_SUCCESS, payload: result.data, &#125;); &#125; catch (e) &#123; yield put(&#123; type: LOGIN_FAILURE, payload: e.response, &#125;); &#125;&#125;function* watchLoginUser() &#123; yield takeEvery(LOGIN_REQUEST, loginUser);&#125;export default function* authSaga()&#123; yield all([ fork(watchLoginUser) ])&#125;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 5 - 리덕스 세팅하기","slug":"react/react-blog/react-blog-05-reudx-setting","date":"2021-09-05T13:10:40.000Z","updated":"2024-11-23T16:51:42.992Z","comments":true,"path":"2021/09/05/react/react-blog/react-blog-05-reudx-setting/","link":"","permalink":"https://ckck803.github.io/2021/09/05/react/react-blog/react-blog-05-reudx-setting/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 5 - 리덕스 세팅하기//LOGINexport const LOGIN_REQUEST = &quot;LOGIN_REQUEST&quot;;export const LOGIN_SUCCESS = &quot;LOGIN_SUCCESS&quot;;export const LOGIN_FAILURE = &quot;LOGIN_FAILURE&quot;;// CLEAR ERRORexport const CLEAR_ERROR_REQUEST = &quot;CLEAR_REQUEST&quot;;export const CLEAR_ERROR_SUCCESS = &quot;CLEAR_SUCCESS&quot;;export const CLEAR_ERROR_FAILURE = &quot;CLEAR_FAILURE&quot;; import &#123; LOGIN_REQUEST, LOGIN_SUCCESS, LOGIN_FAILURE, CLEAR_ERROR_REQUEST, CLEAR_ERROR_SUCCESS, CLEAR_ERROR_FAILURE,&#125; from &quot;../types&quot;;const initialState = &#123; token: localStorage.getItem(&quot;token&quot;), isAuthenticated: null, isLoading: false, user: &quot;&quot;, userId: &quot;&quot;, userName: &quot;&quot;, userRole: &quot;&quot;, errorMsg: &quot;&quot;, successMsg: &quot;&quot;,&#125;;const authReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case LOGIN_REQUEST: return &#123; ...state, errorMsg: &quot;&quot;, &#125;; case LOGIN_SUCCESS: localStorage.setItem(&quot;token&quot;, action.payload.token); return &#123; ...state, ...action.payload, isAuthenticated: true, isLoading: false, userId: action.payload.user.id, userRole: action.payload.user.role, errorMsg: &quot;&quot;, &#125;; case LOGIN_FAILURE: localStorage.removeItem(&quot;token&quot;); return &#123; ...state, ...action.payload, token: null, user: null, userId: null, userRole: null, errorMsg: action.payload.data.msg, &#125;; case CLEAR_ERROR_REQUEST: return &#123; ...state, errorMsg: null, &#125;; case CLEAR_ERROR_SUCCESS: return &#123; ...state, errorMsg: null, &#125;; case CLEAR_ERROR_FAILURE: return &#123; ...state, errorMsg: null, &#125;; default: return state; &#125;&#125;;export default authReducer;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 5 - 리덕스 세팅하기//LOGINexport const LOGIN_REQUEST = &quot;LOGIN_REQUEST&quot;;export const LOGIN_SUCCESS = &quot;LOGIN_SUCCESS&quot;;export const LOGIN_FAILURE = &quot;LOGIN_FAILURE&quot;;// CLEAR ERRORexport const CLEAR_ERROR_REQUEST = &quot;CLEAR_REQUEST&quot;;export const CLEAR_ERROR_SUCCESS = &quot;CLEAR_SUCCESS&quot;;export const CLEAR_ERROR_FAILURE = &quot;CLEAR_FAILURE&quot;; import &#123; LOGIN_REQUEST, LOGIN_SUCCESS, LOGIN_FAILURE, CLEAR_ERROR_REQUEST, CLEAR_ERROR_SUCCESS, CLEAR_ERROR_FAILURE,&#125; from &quot;../types&quot;;const initialState = &#123; token: localStorage.getItem(&quot;token&quot;), isAuthenticated: null, isLoading: false, user: &quot;&quot;, userId: &quot;&quot;, userName: &quot;&quot;, userRole: &quot;&quot;, errorMsg: &quot;&quot;, successMsg: &quot;&quot;,&#125;;const authReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case LOGIN_REQUEST: return &#123; ...state, errorMsg: &quot;&quot;, &#125;; case LOGIN_SUCCESS: localStorage.setItem(&quot;token&quot;, action.payload.token); return &#123; ...state, ...action.payload, isAuthenticated: true, isLoading: false, userId: action.payload.user.id, userRole: action.payload.user.role, errorMsg: &quot;&quot;, &#125;; case LOGIN_FAILURE: localStorage.removeItem(&quot;token&quot;); return &#123; ...state, ...action.payload, token: null, user: null, userId: null, userRole: null, errorMsg: action.payload.data.msg, &#125;; case CLEAR_ERROR_REQUEST: return &#123; ...state, errorMsg: null, &#125;; case CLEAR_ERROR_SUCCESS: return &#123; ...state, errorMsg: null, &#125;; case CLEAR_ERROR_FAILURE: return &#123; ...state, errorMsg: null, &#125;; default: return state; &#125;&#125;;export default authReducer;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 4 - Navbar 작성하기","slug":"react/react-blog/react-blog-04-navbar","date":"2021-09-05T12:10:40.000Z","updated":"2024-11-23T16:51:42.763Z","comments":true,"path":"2021/09/05/react/react-blog/react-blog-04-navbar/","link":"","permalink":"https://ckck803.github.io/2021/09/05/react/react-blog/react-blog-04-navbar/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 4 - Navbar 작성하기import React from &quot;react&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; Collapse, Container, Nav, Navbar, NavbarToggler &#125; from &quot;reactstrap&quot;;const AppNavbar = () =&gt; &#123; return ( &lt;div&gt; &lt;Navbar color=&quot;dark&quot; dark expand=&quot;lg&quot; className=&quot;sticky-top&quot;&gt; &lt;Container&gt; &lt;Link to=&quot;/&quot; className=&quot;text-white text-decoration-none&quot;&gt; Victor의 블로그 &lt;/Link&gt; &lt;NavbarToggler /&gt; &lt;Collapse isOpen=&#123;true&#125; navbar&gt; &lt;Nav className=&quot;ml-auto d-flex justify-content-around&quot; navbar&gt; &#123;true ? ( &lt;h1 className=&quot;text-white&quot;&gt;authLink&lt;/h1&gt; ) : ( &lt;h1 className=&quot;text-white&quot;&gt;gestLink&lt;/h1&gt; )&#125; &lt;/Nav&gt; &lt;/Collapse&gt; &lt;/Container&gt; &lt;/Navbar&gt; &lt;/div&gt; );&#125;;export default AppNavbar; import React, &#123; Fragment &#125; from &quot;react&quot;;import Header from &quot;../components/Header&quot;;import Footer from &quot;../components/Footer&quot;;import AppNavbar from &quot;../components/AppNavbar&quot;;const MyRouter = () =&gt; ( &lt;Fragment&gt; &lt;AppNavbar /&gt; &lt;Header&gt; &lt;h1&gt;Hello Body&lt;/h1&gt; &lt;/Header&gt; &lt;Footer&gt;&lt;/Footer&gt; &lt;/Fragment&gt;);export default MyRouter;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 4 - Navbar 작성하기import React from &quot;react&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; Collapse, Container, Nav, Navbar, NavbarToggler &#125; from &quot;reactstrap&quot;;const AppNavbar = () =&gt; &#123; return ( &lt;div&gt; &lt;Navbar color=&quot;dark&quot; dark expand=&quot;lg&quot; className=&quot;sticky-top&quot;&gt; &lt;Container&gt; &lt;Link to=&quot;/&quot; className=&quot;text-white text-decoration-none&quot;&gt; Victor의 블로그 &lt;/Link&gt; &lt;NavbarToggler /&gt; &lt;Collapse isOpen=&#123;true&#125; navbar&gt; &lt;Nav className=&quot;ml-auto d-flex justify-content-around&quot; navbar&gt; &#123;true ? ( &lt;h1 className=&quot;text-white&quot;&gt;authLink&lt;/h1&gt; ) : ( &lt;h1 className=&quot;text-white&quot;&gt;gestLink&lt;/h1&gt; )&#125; &lt;/Nav&gt; &lt;/Collapse&gt; &lt;/Container&gt; &lt;/Navbar&gt; &lt;/div&gt; );&#125;;export default AppNavbar; import React, &#123; Fragment &#125; from &quot;react&quot;;import Header from &quot;../components/Header&quot;;import Footer from &quot;../components/Footer&quot;;import AppNavbar from &quot;../components/AppNavbar&quot;;const MyRouter = () =&gt; ( &lt;Fragment&gt; &lt;AppNavbar /&gt; &lt;Header&gt; &lt;h1&gt;Hello Body&lt;/h1&gt; &lt;/Header&gt; &lt;Footer&gt;&lt;/Footer&gt; &lt;/Fragment&gt;);export default MyRouter;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 3 - Header 작성하기","slug":"react/react-blog/react-blog-03-header","date":"2021-09-05T11:10:40.000Z","updated":"2024-11-23T16:51:40.748Z","comments":true,"path":"2021/09/05/react/react-blog/react-blog-03-header/","link":"","permalink":"https://ckck803.github.io/2021/09/05/react/react-blog/react-blog-03-header/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 3 - Header 작성하기import React from &quot;react&quot;;import &#123; Row, Col &#125; from &quot;reactstrap&quot;;const Header = () =&gt; &#123; return ( &lt;div id=&quot;page-header&quot;&gt; &lt;Row&gt; &lt;Col md=&quot;6&quot; sm=&quot;auto&quot; className=&quot;text-center m-auto&quot;&gt; &lt;h1&gt;Read Our Blog&lt;/h1&gt; &lt;p&gt;Victor의 사이드 블로그 입니다.&lt;/p&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; );&#125;;export default Header; #main-footer&#123; background: #343a40; color:#fff;&#125;#page-header&#123; height:200px; background: url(./img/free-image.jpeg); background-position: 54% 94%; background-attachment: fixed; color: #fff; border-bottom: 1px #eee solid; padding-top: 60px;&#125;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 3 - Header 작성하기import React from &quot;react&quot;;import &#123; Row, Col &#125; from &quot;reactstrap&quot;;const Header = () =&gt; &#123; return ( &lt;div id=&quot;page-header&quot;&gt; &lt;Row&gt; &lt;Col md=&quot;6&quot; sm=&quot;auto&quot; className=&quot;text-center m-auto&quot;&gt; &lt;h1&gt;Read Our Blog&lt;/h1&gt; &lt;p&gt;Victor의 사이드 블로그 입니다.&lt;/p&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; );&#125;;export default Header; #main-footer&#123; background: #343a40; color:#fff;&#125;#page-header&#123; height:200px; background: url(./img/free-image.jpeg); background-position: 54% 94%; background-attachment: fixed; color: #fff; border-bottom: 1px #eee solid; padding-top: 60px;&#125;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 2 - Footer 작성하기","slug":"react/react-blog/react-blog-02-footer","date":"2021-09-04T11:10:40.000Z","updated":"2024-11-23T16:50:29.083Z","comments":true,"path":"2021/09/04/react/react-blog/react-blog-02-footer/","link":"","permalink":"https://ckck803.github.io/2021/09/04/react/react-blog/react-blog-02-footer/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 2 - Footer 작성하기import React from &quot;react&quot;;import &#123; Row, Col &#125; from &quot;reactstrap&quot;;const Footer = () =&gt; &#123; const thisYear = () =&gt; &#123; const year = new Date().getFullYear(); return year; &#125;; return ( &lt;div id=&quot;main-footer&quot; className=&quot;text-center m-center p-2&quot;&gt; &lt;Row&gt; &lt;Col&gt; &lt;p&gt; Copyright Copy &lt;span&gt;&#123;thisYear()&#125;&lt;/span&gt; &lt;/p&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; );&#125;;export default Footer; 패키지 설치 npm install node-sass sass-loaderyarn add node-sass sass-loader #main-footer&#123; background: #343a40; color:#fff;&#125; import React from &quot;react&quot;import &#123; Provider &#125; from &#x27;react-redux&#x27;import &#123; ConnectedRouter &#125; from &#x27;connected-react-router&#x27;import store, &#123; history &#125; from &quot;./store&quot;import MyRouter from &#x27;./routes/Router&#x27;import &quot;bootstrap/dist/css/bootstrap.min.css&quot;;import &quot;./assets/custom.scss&quot;const App = () =&gt; &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;ConnectedRouter history=&#123;history&#125;&gt; &lt;MyRouter /&gt; &lt;/ConnectedRouter&gt; &lt;/Provider&gt; );&#125;export default App;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 2 - Footer 작성하기import React from &quot;react&quot;;import &#123; Row, Col &#125; from &quot;reactstrap&quot;;const Footer = () =&gt; &#123; const thisYear = () =&gt; &#123; const year = new Date().getFullYear(); return year; &#125;; return ( &lt;div id=&quot;main-footer&quot; className=&quot;text-center m-center p-2&quot;&gt; &lt;Row&gt; &lt;Col&gt; &lt;p&gt; Copyright Copy &lt;span&gt;&#123;thisYear()&#125;&lt;/span&gt; &lt;/p&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; );&#125;;export default Footer; 패키지 설치 npm install node-sass sass-loaderyarn add node-sass sass-loader #main-footer&#123; background: #343a40; color:#fff;&#125; import React from &quot;react&quot;import &#123; Provider &#125; from &#x27;react-redux&#x27;import &#123; ConnectedRouter &#125; from &#x27;connected-react-router&#x27;import store, &#123; history &#125; from &quot;./store&quot;import MyRouter from &#x27;./routes/Router&#x27;import &quot;bootstrap/dist/css/bootstrap.min.css&quot;;import &quot;./assets/custom.scss&quot;const App = () =&gt; &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;ConnectedRouter history=&#123;history&#125;&gt; &lt;MyRouter /&gt; &lt;/ConnectedRouter&gt; &lt;/Provider&gt; );&#125;export default App;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"리엑트 블로그 만들기 1 - 초기 setting 하기","slug":"react/react-blog/react-blog-01-setting","date":"2021-09-03T11:10:40.000Z","updated":"2024-11-23T16:49:57.152Z","comments":true,"path":"2021/09/03/react/react-blog/react-blog-01-setting/","link":"","permalink":"https://ckck803.github.io/2021/09/03/react/react-blog/react-blog-01-setting/","excerpt":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 1 - 초기 setting 하기yarn add axios redux react-redux redux-saga react-router-dom connected-react-router dotenv bootstrap reactstrap Root Reducer 생성&#x2F;src&#x2F;redux&#x2F;reducers&#x2F;index.js import &#123; connectRouter &#125; from &#x27;connected-react-router&#x27;;import &#123; combineReducers &#125; from &quot;redux&quot;;// Root Reducer를 생성한다.const createRootReducer = (history) =&gt; combineReducers(&#123; router: connectRouter(history),&#125;);export default createRootReducer; Root Saga 생성&#x2F;src&#x2F;redux&#x2F;sagas&#x2F;index.js import &#123; all &#125; from &#x27;redux-saga/effects&#x27;;// Root Saga를 생성한다.export default function* rootSaga() &#123; yield all([]);&#125;","text":"리엑트 블로그 만들기 15 - Post Card List 만들기 2 리엑트 블로그 만들기 14 - Post Card List 만들기 리엑트 블로그 만들기 13 - 라우트 리엑트 블로그 만들기 12 - Loading 만들기 리엑트 블로그 만들기 11 - 회원가입 리덕스 작업 리엑트 블로그 만들기 10 - 회원가입 2 리엑트 블로그 만들기 9 - 회원가입 리엑트 블로그 만들기 8 - 로그인 &amp; 로그아웃 리엑트 블로그 만들기 7 - Login Modal 만들기 2 리엑트 블로그 만들기 6 - Login Modal 만들기 1 리엑트 블로그 만들기 5 - 리덕스 세팅하기 리엑트 블로그 만들기 4 - Navbar 작성하기 리엑트 블로그 만들기 3 - Header 작성하기 리엑트 블로그 만들기 2 - Footer 작성하기 리엑트 블로그 만들기 1 - 초기 setting 하기 리엑트 블로그 만들기 1 - 초기 setting 하기yarn add axios redux react-redux redux-saga react-router-dom connected-react-router dotenv bootstrap reactstrap Root Reducer 생성&#x2F;src&#x2F;redux&#x2F;reducers&#x2F;index.js import &#123; connectRouter &#125; from &#x27;connected-react-router&#x27;;import &#123; combineReducers &#125; from &quot;redux&quot;;// Root Reducer를 생성한다.const createRootReducer = (history) =&gt; combineReducers(&#123; router: connectRouter(history),&#125;);export default createRootReducer; Root Saga 생성&#x2F;src&#x2F;redux&#x2F;sagas&#x2F;index.js import &#123; all &#125; from &#x27;redux-saga/effects&#x27;;// Root Saga를 생성한다.export default function* rootSaga() &#123; yield all([]);&#125; Store 만들어주기src&#x2F;store.js import &#123; createStore, compose, applyMiddleware &#125; from &#x27;redux&#x27;;import createSagaMiddleware from &#x27;@redux-saga&#x27;;import &#123; createBrowserHistory &#125; from &#x27;history&#x27;;import &#123; routerMiddleware &#125; from &#x27;connected-react-router&#x27;;import createRootReducer from &#x27;./redux/reducers&#x27;;import rootSaga from &#x27;./redux/sagas&#x27;;export const history = createBrowserHistory();const sagaMiddleware = createSagaMiddleware();const initialState = &#123;&#125;;const middleware = [sagaMiddleware, routerMiddleware(history)];const devtools = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__const composeEnhancer = process.env.NODE_ENV === &#x27;production&#x27; ? compose : devtools || compose;const store = createStore( createRootReducer(history), initialState, composeEnhancer(applyMiddleware(...middleware)))sagaMiddleware.run(rootSaga);export default store; Router 생성하기src&#x2F;routes&#x2F;Router.js import React, &#123; Fragment &#125; from &#x27;react&#x27;import Header from &#x27;../components/Header&#x27;import Footer from &#x27;../components/Footer&#x27;const MyRouter = () =&gt; &#123; &lt;Fragment&gt; &lt;Header&gt; &lt;h1&gt;Hello Body&lt;/h1&gt; &lt;/Header&gt; &lt;/Fragment&gt;&#125;export default MyRouter; Redux와 Router 적용해주기src&#x2F;app.js import React from &#x27;react&#x27;import &#123; Provider &#125; from &#x27;react-redux&#x27;import &#123; ConnectedRouter &#125; from &#x27;connected-react-router&#x27;import store, &#123; history &#125; from &#x27;./store&#x27;import MyRouter from &#x27;./routes/Router&#x27;import &quot;bootstrap/dist/css/bootstrap.min.css&quot;;import &#x27;./assets/custom.scss&#x27;function App() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;ConnectedRouter history=&#123;history&#125;&gt; &lt;MyRouter /&gt; &lt;/ConnectedRouter&gt; &lt;/Provider&gt; );&#125;export default App;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"}],"tags":[]},{"title":"프로그래머스 - 카드 짝 맞추기 (Cpp)","slug":"algorithm/programmers/경우의수/72415-카드짝맞추기-Cpp","date":"2021-08-26T11:10:40.000Z","updated":"2024-02-18T16:19:54.514Z","comments":true,"path":"2021/08/26/algorithm/programmers/경우의수/72415-카드짝맞추기-Cpp/","link":"","permalink":"https://ckck803.github.io/2021/08/26/algorithm/programmers/%EA%B2%BD%EC%9A%B0%EC%9D%98%EC%88%98/72415-%EC%B9%B4%EB%93%9C%EC%A7%9D%EB%A7%9E%EC%B6%94%EA%B8%B0-Cpp/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/72415 문제 풀이좌표를 이동할 때 고려해야 하는 상황이 2가지가 있다 첫 번째 상, 하, 좌, 우 한칸씩 이동하는 경우와 한번에 카드가 있는 곳이나 벽쪽으로 바로 이동하는 경우다.카드를 찾는 경우의 수를 만드는데 있어 고려해야 하는 사항이 2가지가 있다. 첫번째는 서로 다른 카드를 찾아가는 경우의 수와 같은 숫자를 찾는 순서를 정하는 경우의 수다.예를 들어 1 -&gt; 2 -&gt; 3 의 순서로 카드를 찾아간다고 하면 (1 -&gt; 1 짝 찾는 순서) -&gt; (2 -&gt; 2 짝 찾는 순서) -&gt; (3 -&gt; 3 짝 찾는 순서) 를 고려해야 한다는 의미다. 경우의 수가 만들어지면 각 순서에 맞게 BFS를 이용해 최단거리를 구해주면 된다. 다만, 카드는 짝을 만다면 사라지므로 최단 거리를 찾을 때 board 에서 카드가 사라졌는지에 대한 여부도 고려하면서 이동해줘야 한다. 고려 사항 enter를 누르는 것도 count 1을 갖는다. 카드 뒤집는 모든 경우의 수를 계산해야 한다. 1, 2, 3 서로 다른 카드를 찾아가는 경우의 수를 찾는다. 각각의 순서를 고려 하므로 순열의 경우의 수를 갖는다. 1 -&gt; 1, 2 -&gt; 2, 3 -&gt; 3 각각 짝을 만드는 방향이 단방향으로 정해진 것이 아니기 때문에 반대 방향에 대해서도 고려애 줘야 한다. 즉, 최대 경우의 수는 6! * 2 ^ 6 이된다. 이동할 때 카드가 사라졌는지 확인해야 한다. board 에서 각 카드의 위치 찾기int findCards(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; int count = 0; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int value = board[i][j]; if (value &gt; 0) &#123; cards[value].push_back(&#123;i, j&#125;); count++; &#125; &#125; &#125; return (count / 2);&#125; 카드를 뒤집는 모든 경우의 수 찾기","text":"https://programmers.co.kr/learn/courses/30/lessons/72415 문제 풀이좌표를 이동할 때 고려해야 하는 상황이 2가지가 있다 첫 번째 상, 하, 좌, 우 한칸씩 이동하는 경우와 한번에 카드가 있는 곳이나 벽쪽으로 바로 이동하는 경우다.카드를 찾는 경우의 수를 만드는데 있어 고려해야 하는 사항이 2가지가 있다. 첫번째는 서로 다른 카드를 찾아가는 경우의 수와 같은 숫자를 찾는 순서를 정하는 경우의 수다.예를 들어 1 -&gt; 2 -&gt; 3 의 순서로 카드를 찾아간다고 하면 (1 -&gt; 1 짝 찾는 순서) -&gt; (2 -&gt; 2 짝 찾는 순서) -&gt; (3 -&gt; 3 짝 찾는 순서) 를 고려해야 한다는 의미다. 경우의 수가 만들어지면 각 순서에 맞게 BFS를 이용해 최단거리를 구해주면 된다. 다만, 카드는 짝을 만다면 사라지므로 최단 거리를 찾을 때 board 에서 카드가 사라졌는지에 대한 여부도 고려하면서 이동해줘야 한다. 고려 사항 enter를 누르는 것도 count 1을 갖는다. 카드 뒤집는 모든 경우의 수를 계산해야 한다. 1, 2, 3 서로 다른 카드를 찾아가는 경우의 수를 찾는다. 각각의 순서를 고려 하므로 순열의 경우의 수를 갖는다. 1 -&gt; 1, 2 -&gt; 2, 3 -&gt; 3 각각 짝을 만드는 방향이 단방향으로 정해진 것이 아니기 때문에 반대 방향에 대해서도 고려애 줘야 한다. 즉, 최대 경우의 수는 6! * 2 ^ 6 이된다. 이동할 때 카드가 사라졌는지 확인해야 한다. board 에서 각 카드의 위치 찾기int findCards(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; int count = 0; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int value = board[i][j]; if (value &gt; 0) &#123; cards[value].push_back(&#123;i, j&#125;); count++; &#125; &#125; &#125; return (count / 2);&#125; 카드를 뒤집는 모든 경우의 수 찾기void findAllOrderCase(int depth) &#123; if (depth == cardCount * 2) &#123; allOrderCase.push_back(oneOrderCase); return; &#125; for (int i = 1; i &lt; 7; i++) &#123; if (cards[i].size() &gt; 0 &amp;&amp; checkOrder[i] == false) &#123; pair&lt;int, int&gt; point1 = cards[i][0]; pair&lt;int, int&gt; point2 = cards[i][1]; checkOrder[i] = true; oneOrderCase[depth] = point1; oneOrderCase[depth + 1] = point2; findAllOrderCase(depth + 2); oneOrderCase[depth] = point2; oneOrderCase[depth + 1] = point1; findAllOrderCase(depth + 2); checkOrder[i] = false; &#125; &#125;&#125; 한 점에서 다른 점까지의 최단거리 구하기int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; board, pair&lt;int, int&gt; startPoint, pair&lt;int, int&gt; endPoint) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;startPoint.first, startPoint.second&#125;); int count = 0; while (!q.empty()) &#123; int q_size = q.size(); while (q_size--) &#123; int cntY = q.front().first; int cntX = q.front().second; q.pop(); if (cntY == endPoint.first &amp;&amp; cntX == endPoint.second) &#123; if (board[startPoint.first][startPoint.second] == board[endPoint.first][endPoint.second]) &#123; isDisappear[startPoint.first][startPoint.second] = true; isDisappear[endPoint.first][endPoint.second] = true; &#125; return count + 1; &#125; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &gt; ny || ny &gt;= 4 || 0 &gt; nx || nx &gt;= 4) &#123; continue; &#125; q.push(&#123;ny, nx&#125;); while (0 &lt;= (ny + dy[i]) &amp;&amp; (ny + dy[i]) &lt; 4 &amp;&amp; 0 &lt;= (nx + dx[i]) &amp;&amp; (nx + dx[i]) &lt; 4 &amp;&amp; (board[ny][nx] == 0 || isDisappear[ny][nx] == true)) &#123; ny += dy[i]; nx += dx[i]; &#125; q.push(&#123;ny, nx&#125;); &#125; &#125; count++; &#125; return count;&#125; 전체 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 987654321;vector&lt;pair&lt;int, int&gt;&gt; cards[7];int cardCount = 0;bool checkCard[7];int dy[4] = &#123;1, -1, 0, 0&#125;;int dx[4] = &#123;0, 0, 1, -1&#125;;bool checkOrder[7];vector&lt;pair&lt;int, int&gt;&gt; oneOrderCase;vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; allOrderCase;vector&lt;vector&lt;bool&gt;&gt; isDisappear;int findCards(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; int count = 0; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; int value = board[i][j]; if (value &gt; 0) &#123; cards[value].push_back(&#123;i, j&#125;); count++; &#125; &#125; &#125; return (count / 2);&#125;void findAllOrderCase(int depth) &#123; if (depth == cardCount * 2) &#123; allOrderCase.push_back(oneOrderCase); return; &#125; for (int i = 1; i &lt; 7; i++) &#123; if (cards[i].size() &gt; 0 &amp;&amp; checkOrder[i] == false) &#123; pair&lt;int, int&gt; point1 = cards[i][0]; pair&lt;int, int&gt; point2 = cards[i][1]; checkOrder[i] = true; oneOrderCase[depth] = point1; oneOrderCase[depth + 1] = point2; findAllOrderCase(depth + 2); oneOrderCase[depth] = point2; oneOrderCase[depth + 1] = point1; findAllOrderCase(depth + 2); checkOrder[i] = false; &#125; &#125;&#125;int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; board, pair&lt;int, int&gt; startPoint, pair&lt;int, int&gt; endPoint) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;startPoint.first, startPoint.second&#125;); int count = 0; while (!q.empty()) &#123; int q_size = q.size(); while (q_size--) &#123; int cntY = q.front().first; int cntX = q.front().second; q.pop(); if (cntY == endPoint.first &amp;&amp; cntX == endPoint.second) &#123; if (board[startPoint.first][startPoint.second] == board[endPoint.first][endPoint.second]) &#123; isDisappear[startPoint.first][startPoint.second] = true; isDisappear[endPoint.first][endPoint.second] = true; &#125; return count + 1; &#125; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &gt; ny || ny &gt;= 4 || 0 &gt; nx || nx &gt;= 4) &#123; continue; &#125; q.push(&#123;ny, nx&#125;); while (0 &lt;= (ny + dy[i]) &amp;&amp; (ny + dy[i]) &lt; 4 &amp;&amp; 0 &lt;= (nx + dx[i]) &amp;&amp; (nx + dx[i]) &lt; 4 &amp;&amp; (board[ny][nx] == 0 || isDisappear[ny][nx] == true)) &#123; ny += dy[i]; nx += dx[i]; &#125; q.push(&#123;ny, nx&#125;); &#125; &#125; count++; &#125; return count;&#125;int solution(vector&lt;vector&lt;int&gt;&gt; board, int r, int c) &#123; int answer = 0; cardCount = findCards(board); oneOrderCase = vector&lt;pair&lt;int, int&gt;&gt;(cardCount * 2); findAllOrderCase(0); int minDist = INF; for (vector&lt;pair&lt;int, int&gt;&gt; points : allOrderCase) &#123; isDisappear = vector&lt;vector&lt;bool&gt;&gt;(4, vector&lt;bool&gt;(4, false)); pair&lt;int, int&gt; startPoint = &#123;r, c&#125;; int cntDist = 0; for (int i = 0; i &lt; points.size(); i++) &#123; pair&lt;int, int&gt; endPoint = points[i]; int value = bfs(board, startPoint, endPoint); cntDist += value; startPoint = endPoint; &#125; minDist = min(minDist, cntDist); &#125; answer = minDist; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"경우의 수","slug":"Programming/프로그래머스/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"}],"tags":[]},{"title":"Spring Data JPA - Auditing","slug":"spring/spring-data-jpa/10-spring-data-jpa-auditing","date":"2021-08-26T10:39:59.000Z","updated":"2024-02-26T15:37:30.325Z","comments":true,"path":"2021/08/26/spring/spring-data-jpa/10-spring-data-jpa-auditing/","link":"","permalink":"https://ckck803.github.io/2021/08/26/spring/spring-data-jpa/10-spring-data-jpa-auditing/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 참고https://docs.spring.io/spring-data/jpa/docs/1.7.0.DATAJPA-580-SNAPSHOT/reference/html/auditing.html Spring Data JPA - Auditing(감사) 데이터가 언제 누구에 의해서 생성, 수정 됐는지 추적할 필요가 있는데Spring Data JPA 에서는 쉽게 Audit 를 할 수 있는 기능들을 제공한다. Spring Data JPA Auditing 사용하기EnableJpaAuditing 어노테이션을 이용해 프로젝트에 Auditing 기능을 사용할 수 있도록 설정한다. @SpringBootApplication@EnableJpaAuditingpublic class DataJpaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DataJpaApplication.class, args); &#125; // 데이터가 생성 및 수정될 때 생성한 사람과 수정한 사람 정보를 넣기 위한 Bean 을 만들어준다. @Bean public AuditorAware&lt;String&gt; auditorProvider()&#123; return () -&gt; Optional.of(UUID.randomUUID().toString()); &#125;&#125;","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 참고https://docs.spring.io/spring-data/jpa/docs/1.7.0.DATAJPA-580-SNAPSHOT/reference/html/auditing.html Spring Data JPA - Auditing(감사) 데이터가 언제 누구에 의해서 생성, 수정 됐는지 추적할 필요가 있는데Spring Data JPA 에서는 쉽게 Audit 를 할 수 있는 기능들을 제공한다. Spring Data JPA Auditing 사용하기EnableJpaAuditing 어노테이션을 이용해 프로젝트에 Auditing 기능을 사용할 수 있도록 설정한다. @SpringBootApplication@EnableJpaAuditingpublic class DataJpaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DataJpaApplication.class, args); &#125; // 데이터가 생성 및 수정될 때 생성한 사람과 수정한 사람 정보를 넣기 위한 Bean 을 만들어준다. @Bean public AuditorAware&lt;String&gt; auditorProvider()&#123; return () -&gt; Optional.of(UUID.randomUUID().toString()); &#125;&#125; @EntityListeners(AuditingEntityListener.class) 해당 클래스에 Auditing 기능을 포함 시킨다. CreatedDate : Entity 가 생성될 때 시간을 자동으로 저장한다. LastModifiedDate : Entity가 수정될 때 시간을 자동으로 저장한다. CreatedBy : Entity 를 생성한 주체를 저장한다. LastModifiedBy : Entity 를 수정한 주체를 저장한다. EntityListeners : JPA Entity에 이벤트가 발생할 때 Callback 을 처리하고 실행하는 방법 @EntityListeners(AuditingEntityListener.class)@MappedSuperclass@Getterpublic class BaseEntity &#123; @CreatedDate @Column(updatable = false) private LocalDateTime createdDate; @LastModifiedDate private LocalDateTime lastModifiedDate; @CreatedBy @Column(updatable = false) private String createdBy; @LastModifiedBy private String lastModifiedBy;&#125; Auditing 기능 적용하기@Entity@Setter@Getter@NoArgsConstructor(access = AccessLevel.PROTECTED)@ToString(of = &#123;&quot;id&quot;, &quot;username&quot;, &quot;age&quot;&#125;)@NamedEntityGraph(name = &quot;Member.all&quot;, attributeNodes = @NamedAttributeNode(&quot;team&quot;))public class Member extends BaseEntity&#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;member_id&quot;) private Long id; private String username; private int age; // 여러명의 Member가 한 팀에 가입 @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;team_id&quot;) private Team team; public Member(String username)&#123; this.username = username; &#125; public Member(String username, int age, Team team) &#123; this.username = username; this.age = age; if (team != null) &#123; changeTeam(team); &#125; &#125; public Member(String username, int age) &#123; this.username = username; this.age = age; &#125; public void changeTeam(Team team)&#123; this.team = team; team.getMembers().add(this); &#125;&#125; @Entity@Setter@Getter@NoArgsConstructor(access= AccessLevel.PROTECTED)@ToString(of = &#123;&quot;id&quot;, &quot;name&quot;&#125;)public class Team extends BaseEntity&#123; @Id @GeneratedValue @Column(name = &quot;team_id&quot;) private Long id; private String name; // 한 팀에 여러명의 회원이 가입하는 개념 @OneToMany(mappedBy = &quot;team&quot;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;(); public Team(String name) &#123; this.name = name; &#125;&#125; Spring Data JPA Auditing 사용하기 데이터 추가 및 삭제시 사용자 정보를 Auditing 하기 위해서는 AuditorAware Bean 이 필요하다. @CreatedBy 와 @LastModifiedBy 으로 컬럼에 명시하면 데이터 생성, 변경시 사용자 정보를 자동으로 넣어준다. @SpringBootApplication@EnableJpaAuditingpublic class DataJpaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DataJpaApplication.class, args); &#125; // 데이터가 생성 및 수정될 때 생성한 사람과 수정한 사람 정보를 넣기 위한 Bean 을 만들어준다. @Bean public AuditorAware&lt;String&gt; auditorProvider()&#123; return () -&gt; Optional.of(UUID.randomUUID().toString()); &#125;&#125; AuditorAware 인터페이스를 이용한 구현체 생성public class AuditorAwareImpl implements AuditorAware&lt;String&gt; &#123; @Override public Optional&lt;String&gt; getCurrentAuditor() &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if(authentication == null)&#123; return Optional.of(null); &#125; String username = authentication.getName(); return Optional.of(username); &#125;&#125; Config Class 에 AuditorAware Bean 을 등록한다. @Configuration@EnableJpaAuditing@RequiredArgsConstructor@Slf4jpublic class JpaConfig &#123; @Bean public AuditorAware&lt;String&gt; auditorProvider()&#123; return new AuditorAwareImpl(); &#125;&#125; 람다식으로 생성@Configuration@EnableJpaAuditing@RequiredArgsConstructor@Slf4jpublic class JpaConfig &#123; @Bean public AuditorAware&lt;String&gt; auditorProvider()&#123; return () -&gt; &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if(authentication == null)&#123; return Optional.ofNullable(null); &#125; String username = authentication.getName(); return Optional.of(username); &#125;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"Spring Data JPA - Paging Request Paramater","slug":"spring/spring-data-jpa/09-spring-data-jpa-paging-web","date":"2021-08-26T09:39:59.000Z","updated":"2024-02-26T15:37:25.832Z","comments":true,"path":"2021/08/26/spring/spring-data-jpa/09-spring-data-jpa-paging-web/","link":"","permalink":"https://ckck803.github.io/2021/08/26/spring/spring-data-jpa/09-spring-data-jpa-paging-web/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 참고https://docs.spring.io/spring-data/jpa/docs/1.7.0.DATAJPA-580-SNAPSHOT/reference/html/auditing.html Paging Request Paramater Page 와 Size 를 사용해 Paging 과 관련한 Request Parameter 요청을 보낼 수 있다. Page Paging 된 데이터의 Page 번호 Size Paging 할 데이터 크기 Default Size &#x3D; 20 이다. @GetMapping(&quot;/members&quot;)public Page&lt;Member&gt; list(Pageable pageable) &#123; Page&lt;Member&gt; page = memberRepository.findAll(pageable); return page;&#125; Paramater 를 이용해 요청 보내기","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 참고https://docs.spring.io/spring-data/jpa/docs/1.7.0.DATAJPA-580-SNAPSHOT/reference/html/auditing.html Paging Request Paramater Page 와 Size 를 사용해 Paging 과 관련한 Request Parameter 요청을 보낼 수 있다. Page Paging 된 데이터의 Page 번호 Size Paging 할 데이터 크기 Default Size &#x3D; 20 이다. @GetMapping(&quot;/members&quot;)public Page&lt;Member&gt; list(Pageable pageable) &#123; Page&lt;Member&gt; page = memberRepository.findAll(pageable); return page;&#125; Paramater 를 이용해 요청 보내기# 0번 페이지에 해당하는 데이터들을 모두 가져온다.http://localhost:8080/members?page=0# 1번 페이지에 해당하는 데이터들을 모두 가져온다.http://localhost:8080/members?page=1# 전체 데이터를 size에 맞춰서 Paging하고 0번 페이지에 해당하는 데이터를 가져온다.http://localhost:8080/members?page=0&amp;size=3 Default Paging 설정 변경하기Global(전역적) 으로 Paging 설정propertiy를 이용해 Paging Size와 최대 Page의 개수를 설정할 수 있다. spring.data.web.pageable.default-page-size : Paging Size 의 크기를 설정한다. spring.data.web.pageable.max-age-size : Paging 의 최대 개수를 설정한다. spring: data: web: pageable: default-page-size: 10 max-page-size: 2000 지역적으로 Paging 설정PageableDefault 어노테이션을 이용해 기본적인 Page, Size, Sort 를 설정할 수 있다. @GetMapping(&quot;/members&quot;)public Page&lt;Member&gt; list(@PageableDefault(size = 5, sort = &quot;username&quot;) Pageable pageable) &#123; Pageable requestPaging = pageable; Page&lt;Member&gt; page = memberRepository.findAll(pageable); return page;&#125; Paging 내용을 DTO로 변환Method Reference로 변형하기@Datapublic class MemberDto &#123; private Long id; private String username; private String teamName; public MemberDto(Long id, String username, String teamName)&#123; this.id = id; this.username = username; this.teamName = teamName; &#125; // Entity를 이용해 Dto 객체를 생성 public MemberDto(Member member) &#123; this.id = member.getId(); this.username = member.getUsername(); &#125;&#125; @GetMapping(&quot;/members&quot;)public Page&lt;MemberDto&gt; list(@PageableDefault(size = 5, sort = &quot;username&quot;) Pageable pageable) &#123; Page&lt;Member&gt; page = memberRepository.findAll(pageable); // Paging 결과를 DTO class로 변환해 반환한다. Page&lt;MemberDto&gt; map = page .map(member -&gt; new MemberDto(member.getId(), member.getUsername(), null)); return map;&#125; @GetMapping(&quot;/members&quot;)public Page&lt;MemberDto&gt; list(@PageableDefault(size = 5, sort = &quot;username&quot;) Pageable pageable) &#123; // Paging 결과를 DTO class로 변환해 반환한다. Page&lt;MemberDto&gt; map = memberRepository.findAll(pageable) .map(MemberDto::new); return map;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"Spring Data JPA - 페이징과 정렬","slug":"spring/spring-data-jpa/08-spring-data-jpa-paging","date":"2021-08-26T07:39:59.000Z","updated":"2024-02-26T15:37:21.684Z","comments":true,"path":"2021/08/26/spring/spring-data-jpa/08-spring-data-jpa-paging/","link":"","permalink":"https://ckck803.github.io/2021/08/26/spring/spring-data-jpa/08-spring-data-jpa-paging/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 Spring Data JPA - 페이징과 정렬 조회 쿼리에 Pageable 객체를 넣어 줌으로써 JPA 에서 제공하는 Paging 기능을 사용할 수 있다. 스프링에서는 Page 을 손쉽게 사용할 수 있도록 Pageable 인터페이스를 제공합니다. 페이징시 offset (시작지점) 부터 시작해 limit 만큼씩 잘라 Page Number 를 붙입니다. // Page 객체를 반환Page&lt;Member&gt; findPageByAge(int age, Pageable pageable);// Slice 객체를 반환Slice&lt;Member&gt; findSliceByAge(int age, Pageable pageable);// List 객체를 반환List&lt;Member&gt; findListByAge(int age, Pageable pageable); Paging 반환 값Paging 반환되는 객체로 Page, Slice, List 세가지 종류의 객체가 있습니다. 종류 설명 Page Count 쿼리 를 포함하는 페이징 Slice 내부적으로 Limit + 1 조회 List 별도의 작업 없이 결과만 반환","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 Spring Data JPA - 페이징과 정렬 조회 쿼리에 Pageable 객체를 넣어 줌으로써 JPA 에서 제공하는 Paging 기능을 사용할 수 있다. 스프링에서는 Page 을 손쉽게 사용할 수 있도록 Pageable 인터페이스를 제공합니다. 페이징시 offset (시작지점) 부터 시작해 limit 만큼씩 잘라 Page Number 를 붙입니다. // Page 객체를 반환Page&lt;Member&gt; findPageByAge(int age, Pageable pageable);// Slice 객체를 반환Slice&lt;Member&gt; findSliceByAge(int age, Pageable pageable);// List 객체를 반환List&lt;Member&gt; findListByAge(int age, Pageable pageable); Paging 반환 값Paging 반환되는 객체로 Page, Slice, List 세가지 종류의 객체가 있습니다. 종류 설명 Page Count 쿼리 를 포함하는 페이징 Slice 내부적으로 Limit + 1 조회 List 별도의 작업 없이 결과만 반환 Pageable 인터페이스 getPageNumber 현재 페이지 번호를 가져옵니다. getPageSize 페이지당 데이터 개수를 가져옵니다. getOffset 페이징을 시작하는 시작 번호를 가져옵니다. offset &#x3D; page * size; public interface Pageable &#123; static Pageable unpaged() &#123; return Unpaged.INSTANCE; &#125; static Pageable ofSize(int pageSize) &#123; return PageRequest.of(0, pageSize); &#125; default boolean isPaged() &#123; return true; &#125; default boolean isUnpaged() &#123; return !isPaged(); &#125; int getPageNumber(); int getPageSize(); long getOffset(); Sort getSort(); default Sort getSortOr(Sort sort) &#123; Assert.notNull(sort, &quot;Fallback Sort must not be null&quot;); return getSort().isSorted() ? getSort() : sort; &#125; Pageable next(); Pageable previousOrFirst(); Pageable first(); Pageable withPage(int pageNumber); boolean hasPrevious(); default Optional&lt;Pageable&gt; toOptional() &#123; return isUnpaged() ? Optional.empty() : Optional.of(this); &#125;&#125; PageRequest - Pageable 인터페이스 구현체PageRequest 는 Pageable 구현체로 찾을 Page Index 정보, Paging 할 Size 를 이용해 생성할 수 있습니다. 만약 정렬햇 Paging 을 할 경우 Sort 객체를 추가로 넣어줄 수 있습니다. PageRequest pageRequest = PageRequest .of(0, 3);// Page Index가 0부터 시작한다.// username 으로 정렬 후 Paging 합니다.PageRequest pageRequest = PageRequest .of(0, 3, Sort.by(Sort.Direction.DESC, &quot;username&quot;));// Page Index가 0부터 시작한다. 테스트 코드 작성Page 객체로 반환// whenPage&lt;Member&gt; page = memberRepository.findPageByAge(10, pageRequest);// thenList&lt;Member&gt; content = page.getContent();long totalElement = page.getTotalElements();for (Member member : content) &#123; System.out.println(&quot;member : &quot; + member);&#125;System.out.println(&quot;totalElements : &quot; + totalElement);assertThat(content.size()).isEqualTo(3); // paging 된 element 개수를 가져온다.assertThat(page.getTotalElements()).isEqualTo(5); // 전체 element 개수를 가져온다.assertThat(page.getNumber()).isEqualTo(0); // paging 시작 index를 가져온다.assertThat(page.getTotalPages()).isEqualTo(2); // page 개수를 가져온다.assertThat(page.isFirst()).isTrue(); // 첫번째 page인지 확인assertThat(page.hasNext()).isTrue(); // 다음 page가 있는지 확인 Slice 객체로 반환Slice&lt;Member&gt; slice = memberRepository.findSliceByAge(10, pageRequest);assertThat(content.size()).isEqualTo(3); // paging 된 element 개수를 가져온다.assertThat(slice.getNumber()).isEqualTo(0); // paging 시작 index를 가져온다.assertThat(slice.isFirst()).isTrue(); // 첫번째 page인지 확인assertThat(slice.hasNext()).isTrue(); // 다음 page가 있는지 확인 List 객체로 반환List&lt;Member&gt; list = memberRepository.findListByAge(10, pageRequest); 전체 코드@Testpublic void paging()&#123; // given memberRepository.save(new Member(&quot;member1&quot;, 10)); memberRepository.save(new Member(&quot;member2&quot;, 10)); memberRepository.save(new Member(&quot;member3&quot;, 10)); memberRepository.save(new Member(&quot;member4&quot;, 10)); memberRepository.save(new Member(&quot;member5&quot;, 10)); int age = 10; PageRequest pageRequest = PageRequest .of(0, 3, Sort.by(Sort.Direction.DESC, &quot;username&quot;));// Page Index가 0부터 시작한다. // when Page&lt;Member&gt; page = memberRepository.findPageByAge(10, pageRequest); // then List&lt;Member&gt; content = page.getContent(); long totalElement = page.getTotalElements(); for (Member member : content) &#123; System.out.println(&quot;member : &quot; + member); &#125; System.out.println(&quot;totalElements : &quot; + totalElement); assertThat(content.size()).isEqualTo(3); // paging 된 element 개수를 가져온다. assertThat(page.getTotalElements()).isEqualTo(5); // 전체 element 개수를 가져온다. assertThat(page.getNumber()).isEqualTo(0); // paging 시작 index를 가져온다. assertThat(page.getTotalPages()).isEqualTo(2); // page 개수를 가져온다. assertThat(page.isFirst()).isTrue(); // 첫번째 page인지 확인 assertThat(page.hasNext()).isTrue(); // 다음 page가 있는지 확인 Slice&lt;Member&gt; slice = memberRepository.findSliceByAge(10, pageRequest); assertThat(content.size()).isEqualTo(3); // paging 된 element 개수를 가져온다. assertThat(slice.getNumber()).isEqualTo(0); // paging 시작 index를 가져온다. assertThat(slice.isFirst()).isTrue(); // 첫번째 page인지 확인 assertThat(slice.hasNext()).isTrue(); // 다음 page가 있는지 확인 List&lt;Member&gt; list = memberRepository.findListByAge(10, pageRequest); Page&lt;Member&gt; pageDivideCount = memberRepository.findPageDivideCountByAge(10, pageRequest); List&lt;Member&gt; contentDivideCount = page.getContent(); long totalElementDivideCount = page.getTotalElements(); System.out.println(&quot;totalElementDivideCount : &quot; + totalElementDivideCount); assertThat(content.size()).isEqualTo(3); // paging 된 element 개수를 가져온다. assertThat(pageDivideCount.getTotalElements()).isEqualTo(5); // 전체 element 개수를 가져온다. assertThat(pageDivideCount.getNumber()).isEqualTo(0); // paging 시작 index를 가져온다. assertThat(pageDivideCount.getTotalPages()).isEqualTo(2); // page 개수를 가져온다. assertThat(pageDivideCount.isFirst()).isTrue(); // 첫번째 page인지 확인 assertThat(pageDivideCount.hasNext()).isTrue(); // 다음 page가 있는지 확인&#125; Count 쿼리 분리하기 Page 객체를 반환하게 될 경우 Count 쿼리도 같이 실행이 된다. 이때 실행하고 싶은 Count 쿼리를 별도로 작성해 실행 시킬 수 있다. @Query 사용시 countQuery 속성을 이용해 Count 쿼리를 분리할 수 있습니다. Count 쿼리를 염두해 둬야 하는 이유는 객체끼리의 연관관계가 있을 경우 잘 못하면 N+1 의 문제가 발생할 수 있다. // Count 쿼리 분리@Query(value = &quot;select m from Member m left join m.team t&quot;, countQuery = &quot;select count(m.username) from Member m&quot;)Page&lt;Member&gt; findPageDivideCountByAge(int age, Pageable pageable);","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"Spring Data JPA - JPQL 페이징과 정렬","slug":"spring/spring-data-jpa/07-spring-data-jpa-jpql-paging","date":"2021-08-26T05:39:59.000Z","updated":"2024-02-26T15:37:17.780Z","comments":true,"path":"2021/08/26/spring/spring-data-jpa/07-spring-data-jpa-jpql-paging/","link":"","permalink":"https://ckck803.github.io/2021/08/26/spring/spring-data-jpa/07-spring-data-jpa-jpql-paging/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Spring Data JPA - JPQL 페이징과 정렬 Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 JPQL 페이징과 정렬public List&lt;Member&gt; findByPage(int age, int offset, int limit) &#123; return em.createQuery(&quot;select m from Member m where m.age = :age order by m.username desc&quot;) .setParameter(&quot;age&quot;, age) .setFirstResult(offset) // Paging 시작 Index .setMaxResults(limit) .getResultList();&#125;public long totalCount(int age)&#123; return em.createQuery(&quot;select count(m) from Member m where m.age = :age&quot;, Long.class) .setParameter(&quot;age&quot;, age) .getSingleResult();&#125; @Testpublic void paging()&#123; // given memberJpaRepository.save(new Member(&quot;member1&quot;, 10)); memberJpaRepository.save(new Member(&quot;member2&quot;, 10)); memberJpaRepository.save(new Member(&quot;member3&quot;, 10)); memberJpaRepository.save(new Member(&quot;member4&quot;, 10)); memberJpaRepository.save(new Member(&quot;member5&quot;, 10)); int age = 10; int offset = 0; int limit = 3; // when List&lt;Member&gt; members = memberJpaRepository.findByPage(age, offset, limit); long totalCount = memberJpaRepository.totalCount(age); // then assertThat(members.size()).isEqualTo(3); assertThat(totalCount).isEqualTo(5);&#125;","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Spring Data JPA - JPQL 페이징과 정렬 Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 JPQL 페이징과 정렬public List&lt;Member&gt; findByPage(int age, int offset, int limit) &#123; return em.createQuery(&quot;select m from Member m where m.age = :age order by m.username desc&quot;) .setParameter(&quot;age&quot;, age) .setFirstResult(offset) // Paging 시작 Index .setMaxResults(limit) .getResultList();&#125;public long totalCount(int age)&#123; return em.createQuery(&quot;select count(m) from Member m where m.age = :age&quot;, Long.class) .setParameter(&quot;age&quot;, age) .getSingleResult();&#125; @Testpublic void paging()&#123; // given memberJpaRepository.save(new Member(&quot;member1&quot;, 10)); memberJpaRepository.save(new Member(&quot;member2&quot;, 10)); memberJpaRepository.save(new Member(&quot;member3&quot;, 10)); memberJpaRepository.save(new Member(&quot;member4&quot;, 10)); memberJpaRepository.save(new Member(&quot;member5&quot;, 10)); int age = 10; int offset = 0; int limit = 3; // when List&lt;Member&gt; members = memberJpaRepository.findByPage(age, offset, limit); long totalCount = memberJpaRepository.totalCount(age); // then assertThat(members.size()).isEqualTo(3); assertThat(totalCount).isEqualTo(5);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"프로그래머스 - 합승 택시 요금 (Cpp)","slug":"algorithm/programmers/다익스트라/72413-합승택시요금","date":"2021-08-25T11:10:40.000Z","updated":"2024-02-18T16:19:54.515Z","comments":true,"path":"2021/08/25/algorithm/programmers/다익스트라/72413-합승택시요금/","link":"","permalink":"https://ckck803.github.io/2021/08/25/algorithm/programmers/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/72413-%ED%95%A9%EC%8A%B9%ED%83%9D%EC%8B%9C%EC%9A%94%EA%B8%88/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/72413 문제 풀이모든 간선의 weight가 음수가 아닌 값, 시작점 s에서 도착할 수 있는 거리의 최소 비용을 구하는 문제라 다익스트라를 이용해 문제를 해결할 수 있다. 시작점 s에서 시작해 x점까지 같이 이동하는 최소 비용 + x점에서 시작해 a점까지 이동하는 최소 비용 + x점에서 시작해 b점까지 이동하는 최소 비용 중에서 가장 값이 작은 값을 찾는 문제다.원리는 간단하지만 다익스트라에 대해 잘 알고 있어야 풀 수 있는 문제다. void dijkstra(int node) &#123; for (int i = 1; i &lt; 220; i++) &#123; dist[node][i] = INF; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; pq; pq.push(make_pair(0, node)); dist[node][node] = 0; while (!pq.empty()) &#123; int nodeDist = -pq.top().first; int cntNode = pq.top().second; pq.pop(); if (dist[node][cntNode] != nodeDist) &#123; continue; &#125; for (pair&lt;int, int&gt; vertex : graph[cntNode]) &#123; int nextWeight = nodeDist + vertex.second; int nextNode = vertex.first; if (nextWeight &lt; dist[node][nextNode]) &#123; dist[node][nextNode] = nextWeight; pq.push(make_pair(-nextWeight, nextNode)); &#125; &#125; &#125;&#125; 전체 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 987654321;long long dist[220][220];vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;void dijkstra(int node) &#123; for (int i = 1; i &lt; 220; i++) &#123; dist[node][i] = INF; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; pq; pq.push(make_pair(0, node)); dist[node][node] = 0; while (!pq.empty()) &#123; int nodeDist = -pq.top().first; int cntNode = pq.top().second; pq.pop(); if (dist[node][cntNode] != nodeDist) &#123; continue; &#125; for (pair&lt;int, int&gt; vertex : graph[cntNode]) &#123; int nextWeight = nodeDist + vertex.second; int nextNode = vertex.first; if (nextWeight &lt; dist[node][nextNode]) &#123; dist[node][nextNode] = nextWeight; pq.push(make_pair(-nextWeight, nextNode)); &#125; &#125; &#125;&#125;int solution(int n, int s, int a, int b, vector&lt;vector&lt;int&gt;&gt; fares) &#123; int answer = 0; graph = vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(n + 1); for (vector&lt;int&gt; fare : fares) &#123; int start = fare[0]; int end = fare[1]; int weight = fare[2]; graph[start].push_back(make_pair(end, weight)); graph[end].push_back(make_pair(start, weight)); &#125; // dijkstra_start(s); for (int i = 1; i &lt;= n; i++) &#123; dijkstra(i); &#125; long long minValue = INF; for (int i = 1; i &lt;= n; i++) &#123; if (minValue &gt; dist[s][i] + dist[i][a] + dist[i][b]) &#123; minValue = dist[s][i] + dist[i][a] + dist[i][b]; &#125; &#125; answer = minValue; return answer;&#125;","text":"https://programmers.co.kr/learn/courses/30/lessons/72413 문제 풀이모든 간선의 weight가 음수가 아닌 값, 시작점 s에서 도착할 수 있는 거리의 최소 비용을 구하는 문제라 다익스트라를 이용해 문제를 해결할 수 있다. 시작점 s에서 시작해 x점까지 같이 이동하는 최소 비용 + x점에서 시작해 a점까지 이동하는 최소 비용 + x점에서 시작해 b점까지 이동하는 최소 비용 중에서 가장 값이 작은 값을 찾는 문제다.원리는 간단하지만 다익스트라에 대해 잘 알고 있어야 풀 수 있는 문제다. void dijkstra(int node) &#123; for (int i = 1; i &lt; 220; i++) &#123; dist[node][i] = INF; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; pq; pq.push(make_pair(0, node)); dist[node][node] = 0; while (!pq.empty()) &#123; int nodeDist = -pq.top().first; int cntNode = pq.top().second; pq.pop(); if (dist[node][cntNode] != nodeDist) &#123; continue; &#125; for (pair&lt;int, int&gt; vertex : graph[cntNode]) &#123; int nextWeight = nodeDist + vertex.second; int nextNode = vertex.first; if (nextWeight &lt; dist[node][nextNode]) &#123; dist[node][nextNode] = nextWeight; pq.push(make_pair(-nextWeight, nextNode)); &#125; &#125; &#125;&#125; 전체 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 987654321;long long dist[220][220];vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;void dijkstra(int node) &#123; for (int i = 1; i &lt; 220; i++) &#123; dist[node][i] = INF; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; pq; pq.push(make_pair(0, node)); dist[node][node] = 0; while (!pq.empty()) &#123; int nodeDist = -pq.top().first; int cntNode = pq.top().second; pq.pop(); if (dist[node][cntNode] != nodeDist) &#123; continue; &#125; for (pair&lt;int, int&gt; vertex : graph[cntNode]) &#123; int nextWeight = nodeDist + vertex.second; int nextNode = vertex.first; if (nextWeight &lt; dist[node][nextNode]) &#123; dist[node][nextNode] = nextWeight; pq.push(make_pair(-nextWeight, nextNode)); &#125; &#125; &#125;&#125;int solution(int n, int s, int a, int b, vector&lt;vector&lt;int&gt;&gt; fares) &#123; int answer = 0; graph = vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(n + 1); for (vector&lt;int&gt; fare : fares) &#123; int start = fare[0]; int end = fare[1]; int weight = fare[2]; graph[start].push_back(make_pair(end, weight)); graph[end].push_back(make_pair(start, weight)); &#125; // dijkstra_start(s); for (int i = 1; i &lt;= n; i++) &#123; dijkstra(i); &#125; long long minValue = INF; for (int i = 1; i &lt;= n; i++) &#123; if (minValue &gt; dist[s][i] + dist[i][a] + dist[i][b]) &#123; minValue = dist[s][i] + dist[i][a] + dist[i][b]; &#125; &#125; answer = minValue; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"경우의 수","slug":"Programming/프로그래머스/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://ckck803.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}]},{"title":"Spring Data JPA - 반환 타입","slug":"spring/spring-data-jpa/06-spring-data-jpa-dto","date":"2021-08-25T05:39:59.000Z","updated":"2024-02-26T15:37:14.088Z","comments":true,"path":"2021/08/25/spring/spring-data-jpa/06-spring-data-jpa-dto/","link":"","permalink":"https://ckck803.github.io/2021/08/25/spring/spring-data-jpa/06-spring-data-jpa-dto/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 반환 타입List&lt;Member&gt; findListByUsername(String username); // 반환 타입 : 컬랙션Member findMemberByUsername(String username); // 반환 타입 : 단건Optional&lt;Member&gt; findOptionalByUsername(String useranme); // 반환 티입 : 단건 Optional public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; &#123; List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age); @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;) List&lt;Member&gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age); // 값으로 조회하기 @Query(&quot;select m.username from Member m&quot;) List&lt;String&gt; findUsernameList(); // DTO로 조회하기 @Query(&quot;select new com.example.datajpa.dto.MemberDto( m.id, m.username, t.name)from Member m join m.team t&quot;) List&lt;MemberDto&gt; findMemberByDto(); @Query(&quot;select m from Member m where m.username in :names&quot;) List&lt;Member&gt; findByNames(@Param(&quot;names&quot;) Collection&lt;String&gt; names); List&lt;Member&gt; findListByUsername(String username); // 반환 타입 : 컬랙션 Member findMemberByUsername(String username); // 반환 타입 : 단건 Optional&lt;Member&gt; findOptionalByUsername(String useranme); // 반환 티입 : 단건 Optional&#125; @Testpublic void returnType()&#123; Member member1 = new Member(&quot;AAA&quot;, 10); Member member2 = new Member(&quot;BBB&quot;, 20); memberRepository.save(member1); memberRepository.save(member2); List&lt;Member&gt; members = memberRepository.findListByUsername(&quot;AAA&quot;); Member member = memberRepository.findMemberByUsername(&quot;AAA&quot;); Optional&lt;Member&gt; optional = memberRepository.findOptionalByUsername(&quot;AAA&quot;); assertThat(members).isInstanceOf(List.class); assertThat(member).isInstanceOf(Member.class); assertThat(optional).isInstanceOf(Optional.class);&#125;","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 반환 타입List&lt;Member&gt; findListByUsername(String username); // 반환 타입 : 컬랙션Member findMemberByUsername(String username); // 반환 타입 : 단건Optional&lt;Member&gt; findOptionalByUsername(String useranme); // 반환 티입 : 단건 Optional public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; &#123; List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age); @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;) List&lt;Member&gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age); // 값으로 조회하기 @Query(&quot;select m.username from Member m&quot;) List&lt;String&gt; findUsernameList(); // DTO로 조회하기 @Query(&quot;select new com.example.datajpa.dto.MemberDto( m.id, m.username, t.name)from Member m join m.team t&quot;) List&lt;MemberDto&gt; findMemberByDto(); @Query(&quot;select m from Member m where m.username in :names&quot;) List&lt;Member&gt; findByNames(@Param(&quot;names&quot;) Collection&lt;String&gt; names); List&lt;Member&gt; findListByUsername(String username); // 반환 타입 : 컬랙션 Member findMemberByUsername(String username); // 반환 타입 : 단건 Optional&lt;Member&gt; findOptionalByUsername(String useranme); // 반환 티입 : 단건 Optional&#125; @Testpublic void returnType()&#123; Member member1 = new Member(&quot;AAA&quot;, 10); Member member2 = new Member(&quot;BBB&quot;, 20); memberRepository.save(member1); memberRepository.save(member2); List&lt;Member&gt; members = memberRepository.findListByUsername(&quot;AAA&quot;); Member member = memberRepository.findMemberByUsername(&quot;AAA&quot;); Optional&lt;Member&gt; optional = memberRepository.findOptionalByUsername(&quot;AAA&quot;); assertThat(members).isInstanceOf(List.class); assertThat(member).isInstanceOf(Member.class); assertThat(optional).isInstanceOf(Optional.class);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"프로그래머스 - 순위 검색 (JAVA)","slug":"algorithm/programmers/경우의수/72412-순위검색-Java","date":"2021-08-24T11:10:40.000Z","updated":"2024-02-18T16:19:54.514Z","comments":true,"path":"2021/08/24/algorithm/programmers/경우의수/72412-순위검색-Java/","link":"","permalink":"https://ckck803.github.io/2021/08/24/algorithm/programmers/%EA%B2%BD%EC%9A%B0%EC%9D%98%EC%88%98/72412-%EC%88%9C%EC%9C%84%EA%B2%80%EC%83%89-Java/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/72412 문제 풀이이 문제는 그냥 문자열대 문자열로 부딪히게 되면 시간 초과가 날 수 밖에 없는 문제다. 선형적으로 풀면 info 배열의 최대 크기는 5만, query 배열의 최대 크기는 10만 이므로 최대 50억 연산을 하게 되므로 효율성 측면에서 문제가 생긴다.결국 이 문제는 어떤 방법을 이용해 검색할 것인가가 가장 큰 관건이 된다. 선형적인 탐색을 하는 방법이 아닌 O(logn)의 시간 복잡도를 갖는 자료구조 혹은 탐색 기법을 이용하는 방법으로 문제를 접근해야 한다. 동시에 만들 수 있는 문장의 경우의 수를 고려해줘야 한다. 복합적인 문제라 쉽지 않다. 처음에 각 문자열내 문자들을 파싱해서 map에다가 저장을 해야 하나?…. 그러면 탐색을 어떻게 해야하지?… 하면서 문제 접근을 못하다가 다른 분 풀이를 살짝 참고 했는데 문자열 자체를 map의 key값으로 넣는 것을 보고 힌트를 얻어 문제를 접근할 수 있었다. info 내 문자열을 정재해 띄어쓰기는 문장을 만들어준다. key로 정재된 문장을 value로는 같은 key를 갖는 문장에 대한 값들을 보관하기 위해 List형태로 넣어준다. info 내 문장들이 map으로 다 들어갔으면 Binary Search를 사용하기 위해 오름 차순으로 정렬 해준다. query 내 문자열을 정재해 준다. info에서 구분자는 띄어쓰기 였지만 query에서 구분자는 and와 띄어쓰기다. ‘-‘를 만나게 되면 만들 수 있는 문장의 모든 경우의 수를 만들어준다. 정재된 문자를 갖고 info에 값이 있는지 확인한다. 값이 있으면 List에서 query에서 요구하는 값 이상이 되는 사람 수를 찾는다.(Lower Bound) 쿼리가 여러개인 경우는 각각의 경우들을 모두 찾아서 더해준다. 찾은 결과를 answer에 넣어 반환한다. info 내 문자열을 정재하기public void infoToMap(String[] info) &#123; for (int i = 0; i &lt; info.length; i++) &#123; String[] words = info[i].split(&quot; &quot;); StringBuilder sb = new StringBuilder(); int score = Integer.parseInt(words[words.length - 1]); for (int j = 0; j &lt; words.length - 1; j++) &#123; sb.append(words[j]); &#125; String key = sb.toString(); infos.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(score); &#125;&#125; map 내 List값들을 오름차순으로 정렬하기infos.forEach((key, value) -&gt; &#123; value.sort(null);&#125;);","text":"https://programmers.co.kr/learn/courses/30/lessons/72412 문제 풀이이 문제는 그냥 문자열대 문자열로 부딪히게 되면 시간 초과가 날 수 밖에 없는 문제다. 선형적으로 풀면 info 배열의 최대 크기는 5만, query 배열의 최대 크기는 10만 이므로 최대 50억 연산을 하게 되므로 효율성 측면에서 문제가 생긴다.결국 이 문제는 어떤 방법을 이용해 검색할 것인가가 가장 큰 관건이 된다. 선형적인 탐색을 하는 방법이 아닌 O(logn)의 시간 복잡도를 갖는 자료구조 혹은 탐색 기법을 이용하는 방법으로 문제를 접근해야 한다. 동시에 만들 수 있는 문장의 경우의 수를 고려해줘야 한다. 복합적인 문제라 쉽지 않다. 처음에 각 문자열내 문자들을 파싱해서 map에다가 저장을 해야 하나?…. 그러면 탐색을 어떻게 해야하지?… 하면서 문제 접근을 못하다가 다른 분 풀이를 살짝 참고 했는데 문자열 자체를 map의 key값으로 넣는 것을 보고 힌트를 얻어 문제를 접근할 수 있었다. info 내 문자열을 정재해 띄어쓰기는 문장을 만들어준다. key로 정재된 문장을 value로는 같은 key를 갖는 문장에 대한 값들을 보관하기 위해 List형태로 넣어준다. info 내 문장들이 map으로 다 들어갔으면 Binary Search를 사용하기 위해 오름 차순으로 정렬 해준다. query 내 문자열을 정재해 준다. info에서 구분자는 띄어쓰기 였지만 query에서 구분자는 and와 띄어쓰기다. ‘-‘를 만나게 되면 만들 수 있는 문장의 모든 경우의 수를 만들어준다. 정재된 문자를 갖고 info에 값이 있는지 확인한다. 값이 있으면 List에서 query에서 요구하는 값 이상이 되는 사람 수를 찾는다.(Lower Bound) 쿼리가 여러개인 경우는 각각의 경우들을 모두 찾아서 더해준다. 찾은 결과를 answer에 넣어 반환한다. info 내 문자열을 정재하기public void infoToMap(String[] info) &#123; for (int i = 0; i &lt; info.length; i++) &#123; String[] words = info[i].split(&quot; &quot;); StringBuilder sb = new StringBuilder(); int score = Integer.parseInt(words[words.length - 1]); for (int j = 0; j &lt; words.length - 1; j++) &#123; sb.append(words[j]); &#125; String key = sb.toString(); infos.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(score); &#125;&#125; map 내 List값들을 오름차순으로 정렬하기infos.forEach((key, value) -&gt; &#123; value.sort(null);&#125;); query 내 문자열 정재하고 모든 경우의 수 만들기‘-‘는 모든 조건을 허용한다는 의미이므로 조건에 해당하는 모든 경우의 수를 만들어 주도록 한다. String[] words = query[i].split(&quot; and | &quot;);// 언어 cpp, java, python, -// 직군 backend, frontend, -// 경력 junior, senior, -// 소울 푸드 chicken, pizza, -// 점수ArrayList&lt;String&gt; qu = new ArrayList&lt;&gt;();qu.add(&quot;&quot;);for (int j = 0; j &lt; words.length - 1; j++) &#123; int arrSize = qu.size(); for (int aIndex = 0; aIndex &lt; arrSize; aIndex++) &#123; String subStr = qu.get(aIndex); if (words[j].equals(&quot;-&quot;)) &#123; if (j == 0) &#123; qu.set(aIndex, subStr + &quot;cpp&quot;); qu.add(subStr + &quot;java&quot;); qu.add(subStr + &quot;python&quot;); &#125; else if (j == 1) &#123; qu.set(aIndex, subStr + &quot;backend&quot;); qu.add(subStr + &quot;frontend&quot;); &#125; else if (j == 2) &#123; qu.set(aIndex, subStr + &quot;junior&quot;); qu.add(subStr + &quot;senior&quot;); &#125; else if (j == 3) &#123; qu.set(aIndex, subStr + &quot;chicken&quot;); qu.add(subStr + &quot;pizza&quot;); &#125; &#125; else &#123; qu.set(aIndex, subStr + words[j]); &#125; &#125;&#125; 정재된 query 문자열을 이용해 qeury에서 요구하는 값 이상의 사람 수를 찾는다.public int binarySearch(List&lt;Integer&gt; list, int value) &#123; int begin = 0; int end = list.size(); int mid = (begin + end) / 2; while (begin &lt; end) &#123; mid = (begin + end) / 2; if (value &gt; list.get(mid)) &#123; begin = mid + 1; &#125; else &#123; end = mid; &#125; &#125; return list.size() - begin;&#125; int num = 0;for (int j = 0; j &lt; qu.size(); j++) &#123; String key = qu.get(j).trim(); int value = Integer.parseInt(words[words.length - 1]); List&lt;Integer&gt; list = infos.getOrDefault(key, new ArrayList&lt;&gt;()); num += binarySearch(list, value);&#125;answer[i] = num; 전체 소스import java.util.*;import java.io.*;class Solution &#123; Map&lt;String, List&lt;Integer&gt;&gt; infos = new HashMap&lt;&gt;(); // Map&lt;String, Integer&gt; querys = new HashMap&lt;&gt;(); // int[] filter1() public int binarySearch(List&lt;Integer&gt; list, int value) &#123; int begin = 0; int end = list.size(); int mid = (begin + end) / 2; while (begin &lt; end) &#123; mid = (begin + end) / 2; if (value &gt; list.get(mid)) &#123; begin = mid + 1; &#125; else &#123; end = mid; &#125; &#125; return list.size() - begin; &#125; public void infoToMap(String[] info) &#123; for (int i = 0; i &lt; info.length; i++) &#123; String[] words = info[i].split(&quot; &quot;); StringBuilder sb = new StringBuilder(); int score = Integer.parseInt(words[words.length - 1]); for (int j = 0; j &lt; words.length - 1; j++) &#123; sb.append(words[j]); &#125; String key = sb.toString(); infos.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(score); &#125; &#125; public int[] solution(String[] info, String[] query) &#123; int[] answer = new int[query.length]; infoToMap(info); infos.forEach((key, value) -&gt; &#123; value.sort(null); &#125;); for (int i = 0; i &lt; query.length; i++) &#123; String[] words = query[i].split(&quot; and | &quot;); // 언어 cpp, java, python, - // 직군 backend, frontend, - // 경력 junior, senior, - // 소울 푸드 chicken, pizza, - // 점수 ArrayList&lt;String&gt; qu = new ArrayList&lt;&gt;(); qu.add(&quot;&quot;); for (int j = 0; j &lt; words.length - 1; j++) &#123; int arrSize = qu.size(); for (int aIndex = 0; aIndex &lt; arrSize; aIndex++) &#123; String subStr = qu.get(aIndex); if (words[j].equals(&quot;-&quot;)) &#123; if (j == 0) &#123; qu.set(aIndex, subStr + &quot;cpp&quot;); qu.add(subStr + &quot;java&quot;); qu.add(subStr + &quot;python&quot;); &#125; else if (j == 1) &#123; qu.set(aIndex, subStr + &quot;backend&quot;); qu.add(subStr + &quot;frontend&quot;); &#125; else if (j == 2) &#123; qu.set(aIndex, subStr + &quot;junior&quot;); qu.add(subStr + &quot;senior&quot;); &#125; else if (j == 3) &#123; qu.set(aIndex, subStr + &quot;chicken&quot;); qu.add(subStr + &quot;pizza&quot;); &#125; &#125; else &#123; qu.set(aIndex, subStr + words[j]); &#125; &#125; &#125; int num = 0; for (int j = 0; j &lt; qu.size(); j++) &#123; String key = qu.get(j).trim(); int value = Integer.parseInt(words[words.length - 1]); List&lt;Integer&gt; list = infos.getOrDefault(key, new ArrayList&lt;&gt;()); num += binarySearch(list, value); &#125; answer[i] = num; &#125; return answer; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"경우의 수","slug":"Programming/프로그래머스/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://ckck803.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}]},{"title":"Spring Data JPA - Query 파라미터 바인딩","slug":"spring/spring-data-jpa/05-spring-data-jpa-query-param","date":"2021-08-24T05:39:59.000Z","updated":"2024-02-26T15:37:10.391Z","comments":true,"path":"2021/08/24/spring/spring-data-jpa/05-spring-data-jpa-query-param/","link":"","permalink":"https://ckck803.github.io/2021/08/24/spring/spring-data-jpa/05-spring-data-jpa-query-param/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 JPQL에 파라미터 바인딩Param 어노테이션을 이용해 쿼리문내 파라미터들을 바인딩 해준다. @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;)List&lt;Member&gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age); 컬렉션 파리미터 바인딩Collection 타입으로 in 절 지원 @Query(&quot;select m from Member m where m.username in :names&quot;)List&lt;Member&gt; findByNames(@Param(&quot;names&quot;) List&lt;String&gt; names); @Testpublic void findByNames()&#123; Member member1 = new Member(&quot;AAA&quot;, 10); Member member2 = new Member(&quot;BBB&quot;, 20); memberRepository.save(member1); memberRepository.save(member2); List&lt;Member&gt; result = memberRepository.findByNames(Arrays.asList(&quot;AAA&quot;, &quot;BBB&quot;)); for (Member member : result) &#123; System.out.println(&quot;Member : &quot; + member); &#125;&#125;","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 JPQL에 파라미터 바인딩Param 어노테이션을 이용해 쿼리문내 파라미터들을 바인딩 해준다. @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;)List&lt;Member&gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age); 컬렉션 파리미터 바인딩Collection 타입으로 in 절 지원 @Query(&quot;select m from Member m where m.username in :names&quot;)List&lt;Member&gt; findByNames(@Param(&quot;names&quot;) List&lt;String&gt; names); @Testpublic void findByNames()&#123; Member member1 = new Member(&quot;AAA&quot;, 10); Member member2 = new Member(&quot;BBB&quot;, 20); memberRepository.save(member1); memberRepository.save(member2); List&lt;Member&gt; result = memberRepository.findByNames(Arrays.asList(&quot;AAA&quot;, &quot;BBB&quot;)); for (Member member : result) &#123; System.out.println(&quot;Member : &quot; + member); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기","slug":"spring/spring-data-jpa/04-spring-data-jpa-query","date":"2021-08-23T05:39:59.000Z","updated":"2024-02-26T15:37:06.108Z","comments":true,"path":"2021/08/23/spring/spring-data-jpa/04-spring-data-jpa-query/","link":"","permalink":"https://ckck803.github.io/2021/08/23/spring/spring-data-jpa/04-spring-data-jpa-query/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 @Query 를 이용한 조회 결과를 특정 값으로 반환하기 DB로 부터 조회한 결과에서 객체의 특정 값만 가져오고 싶은 경우 객체에서 feild값을 조회 하듯이 객체.field 형식으로 명시해주면 해당 값을 가져올 수 있다. 반환 형식으로는 해당 field의 데이터 형식에 맞춰주면 된다. @Query(&quot;select m.username from Member m&quot;)List&lt;String&gt; findUsernameList(); public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; &#123; List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age); @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;) List&lt;Member&gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age); @Query(&quot;select m.username from Member m&quot;) List&lt;String&gt; findUsernameList();&#125; @Testpublic void findUsernameList() &#123; Member m1 = new Member(&quot;AAA&quot;, 10); Member m2 = new Member(&quot;BBB&quot;, 20); memberRepository.save(m1); memberRepository.save(m2); List&lt;String&gt; memberNames = memberRepository.findUsernameList(); for (String name : memberNames) &#123; System.out.println(&quot;Username : &quot; + name); &#125;&#125; DTO를 사용해 @Query 작성하기일반적으로 DB에서 데이터를 조회할 때 Entity 모든 값보다는 필요한 값 몇가지만을 가져오는 경우가 많다. 이렇게 필요한 데이터 만을 가져올 수 있도록 DTO class를 정의하고 DTO를 이용해 Entity에서 필요한 데이터만을 조회하는 방법이 더 효율적으로 데이터를 가져오는 방식이다. DTO를 이용해 해당 Entity에서 필요한 데이터만을 조회할 수 있도록 구현해보자!","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 @Query 를 이용한 조회 결과를 특정 값으로 반환하기 DB로 부터 조회한 결과에서 객체의 특정 값만 가져오고 싶은 경우 객체에서 feild값을 조회 하듯이 객체.field 형식으로 명시해주면 해당 값을 가져올 수 있다. 반환 형식으로는 해당 field의 데이터 형식에 맞춰주면 된다. @Query(&quot;select m.username from Member m&quot;)List&lt;String&gt; findUsernameList(); public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; &#123; List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age); @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;) List&lt;Member&gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age); @Query(&quot;select m.username from Member m&quot;) List&lt;String&gt; findUsernameList();&#125; @Testpublic void findUsernameList() &#123; Member m1 = new Member(&quot;AAA&quot;, 10); Member m2 = new Member(&quot;BBB&quot;, 20); memberRepository.save(m1); memberRepository.save(m2); List&lt;String&gt; memberNames = memberRepository.findUsernameList(); for (String name : memberNames) &#123; System.out.println(&quot;Username : &quot; + name); &#125;&#125; DTO를 사용해 @Query 작성하기일반적으로 DB에서 데이터를 조회할 때 Entity 모든 값보다는 필요한 값 몇가지만을 가져오는 경우가 많다. 이렇게 필요한 데이터 만을 가져올 수 있도록 DTO class를 정의하고 DTO를 이용해 Entity에서 필요한 데이터만을 조회하는 방법이 더 효율적으로 데이터를 가져오는 방식이다. DTO를 이용해 해당 Entity에서 필요한 데이터만을 조회할 수 있도록 구현해보자! @Datapublic class MemberDto &#123; private Long id; private String username; private String teamName; public MemberDto(Long id, String username, String teamName)&#123; this.id = id; this.username = username; this.teamName = teamName; &#125;&#125; @Query에서 DTO를 사용하기 위해서는 Select절에 패키지를 포함한 Class 경로를 명시해줘야 한다. // DTO 로 결과 값 반환 받기@Query(&quot;select new com.example.datajpa.dto.MemberDto( m.id, m.username, t.name)from Member m join m.team t&quot;)List&lt;MemberDto&gt; findMemberByDto(); 반환 값 확인하기@Testpublic void findMemberDto()&#123; Team team = new Team(&quot;teamA&quot;); teamRepository.save(team); Member member = new Member(&quot;AAA&quot;, 10); member.setTeam(team); memberRepository.save(member); // Dto로 결과 값을 반환 받는다. List&lt;MemberDto&gt; memberDto = memberRepository.findMemberByDto(); for(MemberDto dto : memberDto)&#123; System.out.println(&quot;dto : &quot; + dto); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기","slug":"spring/spring-data-jpa/03-spring-data-jpa-jpql","date":"2021-08-23T03:39:59.000Z","updated":"2024-02-26T15:37:01.647Z","comments":true,"path":"2021/08/23/spring/spring-data-jpa/03-spring-data-jpa-jpql/","link":"","permalink":"https://ckck803.github.io/2021/08/23/spring/spring-data-jpa/03-spring-data-jpa-jpql/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 JPQL (Java Persistence Query Lange) 사용하기 Table 대상이 아닌 Etity(객체) 를 대상으로 작성하는 객체 지향 쿼리 특정 데이터 베이스 SQL에 의존하지 않는 장점이 있다. EntityManager 객체 createQuery 메소드를 사용해 쿼리문을 만들어 줄 수 있다. select 문으로 데이터 조회 후 List, Stream, 단건 데이터 3가지 방식으로 결과를 가져올 수 있다. 메소드 설명 getResultList select 문 실행후 여러 Row 결과 데이터를 List로 반환한다. getResultStream select 문 실행후 여러 Row 결과 데이터를 Stream 으로 반환한다. getSingleResult select 문 실행후 한 Row 결과 데이터를 반환한다. // Readpublic List&lt;Member&gt; findAll() &#123; // JPQL List&lt;Member&gt; result = em.createQuery(&quot;select m from Member m&quot;, Member.class) .getResultList(); return result;&#125; public long count() &#123; return em.createQuery(&quot;select count(m) from Member m&quot;, Long.class) .getSingleResult();&#125; public List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age) &#123; return em.createQuery(&quot;select m from Member m &quot; + &quot;where m.username = :username &quot; + &quot;and m.age &gt; :age&quot;) .setParameter(&quot;username&quot;, username) .setParameter(&quot;age&quot;, age) .getResultList();&#125;","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 JPQL (Java Persistence Query Lange) 사용하기 Table 대상이 아닌 Etity(객체) 를 대상으로 작성하는 객체 지향 쿼리 특정 데이터 베이스 SQL에 의존하지 않는 장점이 있다. EntityManager 객체 createQuery 메소드를 사용해 쿼리문을 만들어 줄 수 있다. select 문으로 데이터 조회 후 List, Stream, 단건 데이터 3가지 방식으로 결과를 가져올 수 있다. 메소드 설명 getResultList select 문 실행후 여러 Row 결과 데이터를 List로 반환한다. getResultStream select 문 실행후 여러 Row 결과 데이터를 Stream 으로 반환한다. getSingleResult select 문 실행후 한 Row 결과 데이터를 반환한다. // Readpublic List&lt;Member&gt; findAll() &#123; // JPQL List&lt;Member&gt; result = em.createQuery(&quot;select m from Member m&quot;, Member.class) .getResultList(); return result;&#125; public long count() &#123; return em.createQuery(&quot;select count(m) from Member m&quot;, Long.class) .getSingleResult();&#125; public List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age) &#123; return em.createQuery(&quot;select m from Member m &quot; + &quot;where m.username = :username &quot; + &quot;and m.age &gt; :age&quot;) .setParameter(&quot;username&quot;, username) .setParameter(&quot;age&quot;, age) .getResultList();&#125; @Testpublic void findByUsernameAndAgeGreaterThen()&#123; Member member1 = new Member(&quot;AAA&quot;, 10); Member member2 = new Member(&quot;AAA&quot;, 20); memberJpaRepository.save(member1); memberJpaRepository.save(member2); List&lt;Member&gt; result = memberJpaRepository.findByUsernameAndAgeGreaterThan(&quot;AAA&quot;, 15); assertThat(result.get(0).getUsername()).isEqualTo(&quot;AAA&quot;); assertThat(result.get(0).getAge()).isEqualTo(20); assertThat(result.size()).isEqualTo(1);&#125; @Query, 리포지토리 메소드에 쿼리 정의하기 Query 어노테이션을 이용하면 인터페이스 메소드에 JPQL 을 바로 정의할 수 있다.쿼리문에 오타가 있어도 Application 로딩 시점에 파싱을 진행해 오류를 잡아준다. @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;)List&lt;Member&gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age); @Testpublic void testQuery()&#123; Member m1 = new Member(&quot;AAA&quot;, 10); Member m2 = new Member(&quot;AAA&quot;, 20); memberRepository.save(m1); memberRepository.save(m2); List&lt;Member&gt; members = memberRepository.findUser(&quot;AAA&quot;, 10); assertThat(members.get(0).getUsername()).isEqualTo(&quot;AAA&quot;); assertThat(members.get(0).getAge()).isEqualTo(10);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"Spring Data JPA - 메소드 이름으로 쿼리 생성하기","slug":"spring/spring-data-jpa/02-spring-data-jpa-methodname","date":"2021-08-22T14:29:59.000Z","updated":"2024-02-26T15:36:58.107Z","comments":true,"path":"2021/08/22/spring/spring-data-jpa/02-spring-data-jpa-methodname/","link":"","permalink":"https://ckck803.github.io/2021/08/22/spring/spring-data-jpa/02-spring-data-jpa-methodname/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 메소드 이름으로 쿼리 생성하기https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation @Testpublic void findByUsernameAndAgeGreaterThen()&#123; Member member1 = new Member(&quot;AAA&quot;, 10); Member member2 = new Member(&quot;AAA&quot;, 20); memberJpaRepository.save(member1); memberJpaRepository.save(member2); List&lt;Member&gt; result = memberJpaRepository.findByUsernameAndAgeGreaterThan(&quot;AAA&quot;, 15); assertThat(result.get(0).getUsername()).isEqualTo(&quot;AAA&quot;); assertThat(result.get(0).getAge()).isEqualTo(20); assertThat(result.size()).isEqualTo(1);&#125; List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age);","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 메소드 이름으로 쿼리 생성하기https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation @Testpublic void findByUsernameAndAgeGreaterThen()&#123; Member member1 = new Member(&quot;AAA&quot;, 10); Member member2 = new Member(&quot;AAA&quot;, 20); memberJpaRepository.save(member1); memberJpaRepository.save(member2); List&lt;Member&gt; result = memberJpaRepository.findByUsernameAndAgeGreaterThan(&quot;AAA&quot;, 15); assertThat(result.get(0).getUsername()).isEqualTo(&quot;AAA&quot;); assertThat(result.get(0).getAge()).isEqualTo(20); assertThat(result.size()).isEqualTo(1);&#125; List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age);","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"Spring Data JPA - 시작하기","slug":"spring/spring-data-jpa/01-spring-data-jpa","date":"2021-08-22T13:39:59.000Z","updated":"2024-02-26T15:36:54.069Z","comments":true,"path":"2021/08/22/spring/spring-data-jpa/01-spring-data-jpa/","link":"","permalink":"https://ckck803.github.io/2021/08/22/spring/spring-data-jpa/01-spring-data-jpa/","excerpt":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 Spring Data JPA 시작하기JPA를 사용해 Repository 구성하기스프링에서 EntityManager 는 다른 Bean들과는 다르게 PersistenceContext 어노테이션을 이용해 객체를 주입 받는다.EntityManager 를 이용해 간단하게 CRUD를 구현할 수 있다. persist : Create remove : Delete find : Read @Repositorypublic class MemberRepository&#123; @PersistenceContext private EntityManager em; // Create public Member save(Member member)&#123; em.persist(member); // DB 에 데이터 저장 return member; &#125; // Delete public void delete(Member member) &#123; em.remove(member); // DB 에 저장된 데이터 삭제 &#125; // Read public Member find(Long id)&#123; Member member = em.find(Member.class, id); // DB 에 저장된 데이터 조회 return member; &#125;&#125; 스프링에서 제공하는 JpaRepository를 사용스프링에서 제공하는 JpaRepository 를 사용하게 되면 기본적인 CRUD 기능을 만들어주기 때문에 보다 간편하게 데이터를 조회할 수 있다.","text":"목차 Spring Data JPA - 벌크성 수정 쿼리 Spring Data JPA - Convertor Spring Data JPA - Auditing Spring Data JPA - Paging Request Paramater Spring Data JPA - 페이징과 정렬 Post not found: spring/spring-data-jpa/07-spring-data-jpa Spring Data JPA - 반환 타입 Spring Data JPA - Query 파라미터 바인딩 Spring Data JPA - Query 를 이용한 조회 결과를 특정 값으로 반환하기 Spring Data JPA - JPQL (Java Persistence Query Lange) 사용하기 Spring Data JPA - 메소드 이름으로 쿼리 생성하기 Spring Data JPA - 시작하기 Spring Data JPA 시작하기JPA를 사용해 Repository 구성하기스프링에서 EntityManager 는 다른 Bean들과는 다르게 PersistenceContext 어노테이션을 이용해 객체를 주입 받는다.EntityManager 를 이용해 간단하게 CRUD를 구현할 수 있다. persist : Create remove : Delete find : Read @Repositorypublic class MemberRepository&#123; @PersistenceContext private EntityManager em; // Create public Member save(Member member)&#123; em.persist(member); // DB 에 데이터 저장 return member; &#125; // Delete public void delete(Member member) &#123; em.remove(member); // DB 에 저장된 데이터 삭제 &#125; // Read public Member find(Long id)&#123; Member member = em.find(Member.class, id); // DB 에 저장된 데이터 조회 return member; &#125;&#125; 스프링에서 제공하는 JpaRepository를 사용스프링에서 제공하는 JpaRepository 를 사용하게 되면 기본적인 CRUD 기능을 만들어주기 때문에 보다 간편하게 데이터를 조회할 수 있다. public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; &#123;&#125; @SpringBootTest@Transactional@Rollback(value = false)public class MemberRepositoryTest &#123; @Autowired private MemberRepository memberRepository; @Test public void testMember()&#123; Member member = new Member(&quot;memberA&quot;); Member savedMember = memberRepository.save(member); Member findMember = memberRepository.findById(savedMember.getId()).get(); assertThat(findMember.getId()).isEqualTo(member.getId()); assertThat(findMember.getUsername()).isEqualTo(member.getUsername()); assertThat(findMember).isEqualTo(member); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"}],"tags":[]},{"title":"프로그래머스 - 메뉴 리뉴얼 (JAVA)","slug":"algorithm/programmers/경우의수/72411-메뉴리뉴얼-Java","date":"2021-08-22T11:10:40.000Z","updated":"2024-02-18T16:19:54.514Z","comments":true,"path":"2021/08/22/algorithm/programmers/경우의수/72411-메뉴리뉴얼-Java/","link":"","permalink":"https://ckck803.github.io/2021/08/22/algorithm/programmers/%EA%B2%BD%EC%9A%B0%EC%9D%98%EC%88%98/72411-%EB%A9%94%EB%89%B4%EB%A6%AC%EB%89%B4%EC%96%BC-Java/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/72411 문제 풀이처음에 문자열 비교로 접근해 엄청 해멨다. 이 문제는 문자열 비교로 접근을 하는게 아니라 한 사람이 시킨 메뉴 코스를 이용해 만들 수 있는 경우의 수를 만들어 비교하는 문제다. 코스를 사전 순서로 저장할 수 있도록 주문을 정렬해준다. 한 손님이 주문한 단품 메뉴들로 만들 수 있는 모든 코스 조합을 만들어준다. 코스내 메뉴 개수에 따라 가장 많이 선택된 횟수를 저장해 놓는다. 코스를 선택할때 코스내 메뉴가 메뉴 개수에서 가장 많이 선택된 횟수와 같다면 넣어준다. 모든 코스를 만들어주는 함수public void findAllCourse(String order, String subOrder, int depth) &#123; if (depth == order.length()) &#123; if (subOrder.length() &gt; 1) &#123; if (map.containsKey(subOrder)) &#123; int value = map.get(subOrder); map.put(subOrder, value + 1); &#125; else &#123; map.put(subOrder, 1); &#125; &#125; return; &#125; findAllCourse(order, subOrder + order.charAt(depth), depth + 1); findAllCourse(order, subOrder, depth + 1);&#125; 전체 소스import java.io.*;import java.util.*;class Solution &#123; Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(); public void findAllCourse(String order, String subOrder, int depth) &#123; if (depth == order.length()) &#123; if (subOrder.length() &gt; 1) &#123; if (map.containsKey(subOrder)) &#123; int value = map.get(subOrder); map.put(subOrder, value + 1); &#125; else &#123; map.put(subOrder, 1); &#125; &#125; return; &#125; findAllCourse(order, subOrder + order.charAt(depth), depth + 1); findAllCourse(order, subOrder, depth + 1); &#125; public String[] solution(String[] orders, int[] course) &#123; for (String order : orders) &#123; // 문자열내 문자들을 사전 순서대로 정렬 char[] charArr = order.toCharArray(); Arrays.sort(charArr); String sortedOrder = new String(charArr); // 주문한 메뉴들로 만들 수 있는 모든 코스 조합을 만들어준다. findAllCourse(sortedOrder, &quot;&quot;, 0); &#125; int[] maxValues = new int[101]; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); map.forEach((key, value) -&gt; maxValues[key.length()] = Math.max(maxValues[key.length()], value)); map.forEach((key, value) -&gt; &#123; if (value &gt;= maxValues[key.length()] &amp;&amp; value &gt; 1) &#123; for (int i = 0; i &lt; course.length; i++) &#123; if (course[i] == key.length()) &#123; result.add(key); &#125; &#125; &#125; &#125;); String[] answer = new String[result.size()]; int index = 0; for (String s : result) &#123; answer[index++] = s; &#125; return answer; &#125;&#125;","text":"https://programmers.co.kr/learn/courses/30/lessons/72411 문제 풀이처음에 문자열 비교로 접근해 엄청 해멨다. 이 문제는 문자열 비교로 접근을 하는게 아니라 한 사람이 시킨 메뉴 코스를 이용해 만들 수 있는 경우의 수를 만들어 비교하는 문제다. 코스를 사전 순서로 저장할 수 있도록 주문을 정렬해준다. 한 손님이 주문한 단품 메뉴들로 만들 수 있는 모든 코스 조합을 만들어준다. 코스내 메뉴 개수에 따라 가장 많이 선택된 횟수를 저장해 놓는다. 코스를 선택할때 코스내 메뉴가 메뉴 개수에서 가장 많이 선택된 횟수와 같다면 넣어준다. 모든 코스를 만들어주는 함수public void findAllCourse(String order, String subOrder, int depth) &#123; if (depth == order.length()) &#123; if (subOrder.length() &gt; 1) &#123; if (map.containsKey(subOrder)) &#123; int value = map.get(subOrder); map.put(subOrder, value + 1); &#125; else &#123; map.put(subOrder, 1); &#125; &#125; return; &#125; findAllCourse(order, subOrder + order.charAt(depth), depth + 1); findAllCourse(order, subOrder, depth + 1);&#125; 전체 소스import java.io.*;import java.util.*;class Solution &#123; Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(); public void findAllCourse(String order, String subOrder, int depth) &#123; if (depth == order.length()) &#123; if (subOrder.length() &gt; 1) &#123; if (map.containsKey(subOrder)) &#123; int value = map.get(subOrder); map.put(subOrder, value + 1); &#125; else &#123; map.put(subOrder, 1); &#125; &#125; return; &#125; findAllCourse(order, subOrder + order.charAt(depth), depth + 1); findAllCourse(order, subOrder, depth + 1); &#125; public String[] solution(String[] orders, int[] course) &#123; for (String order : orders) &#123; // 문자열내 문자들을 사전 순서대로 정렬 char[] charArr = order.toCharArray(); Arrays.sort(charArr); String sortedOrder = new String(charArr); // 주문한 메뉴들로 만들 수 있는 모든 코스 조합을 만들어준다. findAllCourse(sortedOrder, &quot;&quot;, 0); &#125; int[] maxValues = new int[101]; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); map.forEach((key, value) -&gt; maxValues[key.length()] = Math.max(maxValues[key.length()], value)); map.forEach((key, value) -&gt; &#123; if (value &gt;= maxValues[key.length()] &amp;&amp; value &gt; 1) &#123; for (int i = 0; i &lt; course.length; i++) &#123; if (course[i] == key.length()) &#123; result.add(key); &#125; &#125; &#125; &#125;); String[] answer = new String[result.size()]; int index = 0; for (String s : result) &#123; answer[index++] = s; &#125; return answer; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"경우의 수","slug":"Programming/프로그래머스/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://ckck803.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}]},{"title":"프로그래머스 - 메뉴 리뉴얼 (Cpp)","slug":"algorithm/programmers/경우의수/72411-메뉴리뉴얼-Cpp","date":"2021-08-20T11:10:40.000Z","updated":"2024-02-18T16:19:54.514Z","comments":true,"path":"2021/08/20/algorithm/programmers/경우의수/72411-메뉴리뉴얼-Cpp/","link":"","permalink":"https://ckck803.github.io/2021/08/20/algorithm/programmers/%EA%B2%BD%EC%9A%B0%EC%9D%98%EC%88%98/72411-%EB%A9%94%EB%89%B4%EB%A6%AC%EB%89%B4%EC%96%BC-Cpp/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/72411 문제 풀이처음에 문자열 비교로 접근해 엄청 해멨다. 이 문제는 문자열 비교로 접근을 하는게 아니라 한 사람이 시킨 메뉴 코스를 이용해 만들 수 있는 경우의 수를 만들어 비교하는 문제다. 코스를 사전 순서로 저장할 수 있도록 주문을 정렬해준다. 한 손님이 주문한 단품 메뉴들로 만들 수 있는 모든 코스 조합을 만들어준다. 코스내 메뉴 개수에 따라 가장 많이 선택된 횟수를 저장해 놓는다. 코스를 선택할때 코스내 메뉴가 메뉴 개수에서 가장 많이 선택된 횟수와 같다면 넣어준다. 모든 코스 조합을 만들어주는 함수void makeAllCourse(string subOrder, string order, int depth) &#123; if (depth &gt; order.size()) &#123; return; &#125; if (depth == order.size() &amp;&amp; subOrder.size() &gt; 1) &#123; if (m.find(subOrder) == m.end()) &#123; m[subOrder] = 1; &#125; else &#123; m[subOrder] += 1; &#125; &#125; // 현재 메뉴를 선택하고 다음 메뉴로 넘어간다. makeAllCourse(subOrder + order[depth], order, depth + 1); // 현재 메뉴를 선택하지 않고 다음 메뉴로 넘어간다. makeAllCourse(subOrder, order, depth + 1);&#125; 전체 소스#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string, int&gt; m;int maxValues[100];void makeAllCourse(string subOrder, string order, int depth) &#123; if (depth &gt; order.size()) &#123; return; &#125; if (depth == order.size() &amp;&amp; subOrder.size() &gt; 1) &#123; if (m.find(subOrder) == m.end()) &#123; m[subOrder] = 1; &#125; else &#123; m[subOrder] += 1; &#125; &#125; makeAllCourse(subOrder + order[depth], order, depth + 1); makeAllCourse(subOrder, order, depth + 1);&#125;vector&lt;string&gt; solution(vector&lt;string&gt; orders, vector&lt;int&gt; course) &#123; vector&lt;string&gt; answer; for (int i = 0; i &lt; orders.size(); i++) &#123; sort(orders[i].begin(), orders[i].end()); makeAllCourse(&quot;&quot;, orders[i], 0); &#125; for (auto iter = m.begin(); iter != m.end(); iter++) &#123; int courseCount = iter-&gt;first.length(); maxValues[courseCount] = max(maxValues[courseCount], iter-&gt;second); &#125; for (auto iter = m.begin(); iter != m.end(); iter++) &#123; int courseCount = iter-&gt;first.length(); if (iter-&gt;second == maxValues[courseCount] &amp;&amp; iter-&gt;second &gt;= 2) &#123; for (int i = 0; i &lt; course.size(); i++) &#123; if (courseCount == course[i]) &#123; answer.push_back(iter-&gt;first); &#125; &#125; &#125; &#125; return answer;&#125;","text":"https://programmers.co.kr/learn/courses/30/lessons/72411 문제 풀이처음에 문자열 비교로 접근해 엄청 해멨다. 이 문제는 문자열 비교로 접근을 하는게 아니라 한 사람이 시킨 메뉴 코스를 이용해 만들 수 있는 경우의 수를 만들어 비교하는 문제다. 코스를 사전 순서로 저장할 수 있도록 주문을 정렬해준다. 한 손님이 주문한 단품 메뉴들로 만들 수 있는 모든 코스 조합을 만들어준다. 코스내 메뉴 개수에 따라 가장 많이 선택된 횟수를 저장해 놓는다. 코스를 선택할때 코스내 메뉴가 메뉴 개수에서 가장 많이 선택된 횟수와 같다면 넣어준다. 모든 코스 조합을 만들어주는 함수void makeAllCourse(string subOrder, string order, int depth) &#123; if (depth &gt; order.size()) &#123; return; &#125; if (depth == order.size() &amp;&amp; subOrder.size() &gt; 1) &#123; if (m.find(subOrder) == m.end()) &#123; m[subOrder] = 1; &#125; else &#123; m[subOrder] += 1; &#125; &#125; // 현재 메뉴를 선택하고 다음 메뉴로 넘어간다. makeAllCourse(subOrder + order[depth], order, depth + 1); // 현재 메뉴를 선택하지 않고 다음 메뉴로 넘어간다. makeAllCourse(subOrder, order, depth + 1);&#125; 전체 소스#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string, int&gt; m;int maxValues[100];void makeAllCourse(string subOrder, string order, int depth) &#123; if (depth &gt; order.size()) &#123; return; &#125; if (depth == order.size() &amp;&amp; subOrder.size() &gt; 1) &#123; if (m.find(subOrder) == m.end()) &#123; m[subOrder] = 1; &#125; else &#123; m[subOrder] += 1; &#125; &#125; makeAllCourse(subOrder + order[depth], order, depth + 1); makeAllCourse(subOrder, order, depth + 1);&#125;vector&lt;string&gt; solution(vector&lt;string&gt; orders, vector&lt;int&gt; course) &#123; vector&lt;string&gt; answer; for (int i = 0; i &lt; orders.size(); i++) &#123; sort(orders[i].begin(), orders[i].end()); makeAllCourse(&quot;&quot;, orders[i], 0); &#125; for (auto iter = m.begin(); iter != m.end(); iter++) &#123; int courseCount = iter-&gt;first.length(); maxValues[courseCount] = max(maxValues[courseCount], iter-&gt;second); &#125; for (auto iter = m.begin(); iter != m.end(); iter++) &#123; int courseCount = iter-&gt;first.length(); if (iter-&gt;second == maxValues[courseCount] &amp;&amp; iter-&gt;second &gt;= 2) &#123; for (int i = 0; i &lt; course.size(); i++) &#123; if (courseCount == course[i]) &#123; answer.push_back(iter-&gt;first); &#125; &#125; &#125; &#125; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"경우의 수","slug":"Programming/프로그래머스/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://ckck803.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}]},{"title":"백준 2178 - 미로탐색","slug":"algorithm/baekjoon/BFS/2178-미로탐색","date":"2021-08-17T06:19:42.000Z","updated":"2024-02-18T16:19:54.509Z","comments":true,"path":"2021/08/17/algorithm/baekjoon/BFS/2178-미로탐색/","link":"","permalink":"https://ckck803.github.io/2021/08/17/algorithm/baekjoon/BFS/2178-%EB%AF%B8%EB%A1%9C%ED%83%90%EC%83%89/","excerpt":"링크https://www.acmicpc.net/problem/2178 문제 풀이기본적인 BFS 문제다. 조건에 맞춰 값을 읽어온 후 탐색을 진행하면 원하는 값을 얻을 수 있다. 전체 소스import java.io.BufferedReader;import java.io.IOError;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;public class Main &#123; public static int height, width; public static int[] dx = &#123; 0, 0, 1, -1 &#125;; public static int[] dy = &#123; 1, -1, 0, 0 &#125;; public static int[][] map; public static int bfs() &#123; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); boolean check[][] = new boolean[height + 1][width + 1]; q.offer(new int[] &#123; 0, 0 &#125;); check[0][0] = true; int count = 0; while (!q.isEmpty()) &#123; int qSize = q.size(); count++; while (qSize-- &gt; 0) &#123; int[] point = q.remove(); int cntY = point[0]; int cntX = point[1]; if (cntY == height - 1 &amp;&amp; cntX == width - 1) &#123; return count; &#125; for (int i = 0; i &lt; 4; i++) &#123; int nY = cntY + dy[i]; int nX = cntX + dx[i]; if (0 &lt;= nY &amp;&amp; nY &lt; height &amp;&amp; 0 &lt;= nX &amp;&amp; nX &lt; width) &#123; if (check[nY][nX] == false &amp;&amp; map[nY][nX] == 1) &#123; check[nY][nX] = true; q.offer(new int[] &#123; nY, nX &#125;); &#125; &#125; &#125; &#125; &#125; return count; &#125; public static void main(String args[]) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] inputValues = br.readLine().split(&quot; &quot;); height = Integer.parseInt(inputValues[0]); width = Integer.parseInt(inputValues[1]); map = new int[height + 1][width + 1]; for (int h = 0; h &lt; height; h++) &#123; String inputValue = br.readLine(); for (int w = 0; w &lt; width; w++) &#123; // System.out.println(inputValue.charAt(w)); map[h][w] = inputValue.charAt(w) - &#x27;0&#x27;; &#125; &#125; int count = bfs(); System.out.println(count); br.close(); &#125;&#125;","text":"링크https://www.acmicpc.net/problem/2178 문제 풀이기본적인 BFS 문제다. 조건에 맞춰 값을 읽어온 후 탐색을 진행하면 원하는 값을 얻을 수 있다. 전체 소스import java.io.BufferedReader;import java.io.IOError;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;public class Main &#123; public static int height, width; public static int[] dx = &#123; 0, 0, 1, -1 &#125;; public static int[] dy = &#123; 1, -1, 0, 0 &#125;; public static int[][] map; public static int bfs() &#123; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); boolean check[][] = new boolean[height + 1][width + 1]; q.offer(new int[] &#123; 0, 0 &#125;); check[0][0] = true; int count = 0; while (!q.isEmpty()) &#123; int qSize = q.size(); count++; while (qSize-- &gt; 0) &#123; int[] point = q.remove(); int cntY = point[0]; int cntX = point[1]; if (cntY == height - 1 &amp;&amp; cntX == width - 1) &#123; return count; &#125; for (int i = 0; i &lt; 4; i++) &#123; int nY = cntY + dy[i]; int nX = cntX + dx[i]; if (0 &lt;= nY &amp;&amp; nY &lt; height &amp;&amp; 0 &lt;= nX &amp;&amp; nX &lt; width) &#123; if (check[nY][nX] == false &amp;&amp; map[nY][nX] == 1) &#123; check[nY][nX] = true; q.offer(new int[] &#123; nY, nX &#125;); &#125; &#125; &#125; &#125; &#125; return count; &#125; public static void main(String args[]) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] inputValues = br.readLine().split(&quot; &quot;); height = Integer.parseInt(inputValues[0]); width = Integer.parseInt(inputValues[1]); map = new int[height + 1][width + 1]; for (int h = 0; h &lt; height; h++) &#123; String inputValue = br.readLine(); for (int w = 0; w &lt; width; w++) &#123; // System.out.println(inputValue.charAt(w)); map[h][w] = inputValue.charAt(w) - &#x27;0&#x27;; &#125; &#125; int count = bfs(); System.out.println(count); br.close(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"}]},{"title":"Spring Security 권한 계층 사용하기 - @RoleHierarcy","slug":"spring/spring-security/security/role-hierarchy","date":"2021-08-16T07:34:10.000Z","updated":"2024-02-26T16:28:09.586Z","comments":true,"path":"2021/08/16/spring/spring-security/security/role-hierarchy/","link":"","permalink":"https://ckck803.github.io/2021/08/16/spring/spring-security/security/role-hierarchy/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 @RoleHierarcy우리는 일반적으로 ADMIN, MANAGER, USER 권한이 있다고 하면 Admin 권한으로 모든 자원에 접근이 가능하다고 생각하지만 Spring Security는 상하위 개념으로 인식하지 못하고 권한들을 독립적으로 인식해 MANAGER 권한, USER 권한 리소스에 접근할 수 없다. 만약 접근하려고 하면 접근 권한과 관련된 403(Forbidden) Error 가 발생한다. 권한간 상하 관계를 적용하기 위해 Spring Security에서는 RoleHierarchy 인터페이스를 제공하고 구현체로는 RoleHierarchyImpl 를 제공한다.권한을 적용하기 위해 RoleHierarchyVoter 객체에 RoleHierarchy 객체를 넣어줌으로써 권한 계층 구조를 사용할 수 있다. RoleHierarchy : 권한간 계층 관계 정보를 저장 RoleHierarchyVoter 인가 처리시 RoleHierarchy 내 저장된 권한간 계층 정보를 사용할 수 있도록 한다. 권한을 저장하기 위한 Entity@Entity@Table(name = &quot;ROLE_HIERARCHY&quot;)@AllArgsConstructor@NoArgsConstructor@Data@Builder@ToString(exclude = &#123;&quot;parentName&quot;, &quot;roleHierarchy&quot;&#125;)public class RoleHierarchy implements Serializable &#123; @Id @GeneratedValue private Long id; @Column(name = &quot;child_name&quot;) private String childName; @ManyToOne(cascade = &#123;CascadeType.ALL&#125;, fetch = FetchType.LAZY) @JoinColumn(name = &quot;parent_name&quot;, referencedColumnName = &quot;child_name&quot;) private RoleHierarchy parentName; @OneToMany(mappedBy = &quot;parentName&quot;, cascade = &#123;CascadeType.ALL &#125;) private Set&lt;RoleHierarchy&gt; roleHierarchy = new HashSet&lt;&gt;();&#125;","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 @RoleHierarcy우리는 일반적으로 ADMIN, MANAGER, USER 권한이 있다고 하면 Admin 권한으로 모든 자원에 접근이 가능하다고 생각하지만 Spring Security는 상하위 개념으로 인식하지 못하고 권한들을 독립적으로 인식해 MANAGER 권한, USER 권한 리소스에 접근할 수 없다. 만약 접근하려고 하면 접근 권한과 관련된 403(Forbidden) Error 가 발생한다. 권한간 상하 관계를 적용하기 위해 Spring Security에서는 RoleHierarchy 인터페이스를 제공하고 구현체로는 RoleHierarchyImpl 를 제공한다.권한을 적용하기 위해 RoleHierarchyVoter 객체에 RoleHierarchy 객체를 넣어줌으로써 권한 계층 구조를 사용할 수 있다. RoleHierarchy : 권한간 계층 관계 정보를 저장 RoleHierarchyVoter 인가 처리시 RoleHierarchy 내 저장된 권한간 계층 정보를 사용할 수 있도록 한다. 권한을 저장하기 위한 Entity@Entity@Table(name = &quot;ROLE_HIERARCHY&quot;)@AllArgsConstructor@NoArgsConstructor@Data@Builder@ToString(exclude = &#123;&quot;parentName&quot;, &quot;roleHierarchy&quot;&#125;)public class RoleHierarchy implements Serializable &#123; @Id @GeneratedValue private Long id; @Column(name = &quot;child_name&quot;) private String childName; @ManyToOne(cascade = &#123;CascadeType.ALL&#125;, fetch = FetchType.LAZY) @JoinColumn(name = &quot;parent_name&quot;, referencedColumnName = &quot;child_name&quot;) private RoleHierarchy parentName; @OneToMany(mappedBy = &quot;parentName&quot;, cascade = &#123;CascadeType.ALL &#125;) private Set&lt;RoleHierarchy&gt; roleHierarchy = new HashSet&lt;&gt;();&#125; 권한 정보를 가져오기 위한 Repository@Repositorypublic interface RoleHierarchyRepository extends JpaRepository&lt;RoleHierarchy, Long&gt; &#123; RoleHierarchy findByChildName(String roleName);&#125; 권한을 가져와 권한간 계층을 적용findAllHierarchy 메소드를 이용해 저장된 권한을 가져와 상하 관계를 만들어 준다.상위 권한 &gt; 하위 권한 형태로 만들어 반환해준다. @Servicepublic class RoleHierarchyService &#123; @Autowired private RoleHierarchyRepository roleHierarchyRepository; @Transactional public String findAllHierarchy()&#123; List&lt;RoleHierarchy&gt; roleHierarchies = roleHierarchyRepository.findAll(); StringBuilder concatedRoles = new StringBuilder(); roleHierarchies.stream().forEach( roleHierarchy -&gt; &#123; if(roleHierarchy.getParentName() != null)&#123; concatedRoles.append(roleHierarchy.getParentName().getChildName()); concatedRoles.append(&quot; &gt; &quot;); concatedRoles.append(roleHierarchy.getChildName()); concatedRoles.append(&quot;\\n&quot;); &#125; &#125;); return concatedRoles.toString(); &#125;&#125; 설정을 확인하기 위한 Controller@RestControllerpublic class SampleController &#123; @GetMapping(&quot;/&quot;) public String home()&#123; return &quot;Home&quot;; &#125; @GetMapping(&quot;/user&quot;) public String user()&#123; return &quot;user&quot;; &#125; @GetMapping(&quot;/manager&quot;) public String manager(Principal principal)&#123; return &quot;manager&quot;; &#125; @GetMapping(&quot;/admin&quot;) public String admin(Principal principal)&#123; return &quot;admin&quot;; &#125;&#125; Security 설정 /user : USER 권한이 있는 유저가 접근할 수 있다. /manager : MANAGER 권한이 있는 유저가 접근할 수 있다. /admin : ADMIN 권한이 있는 유저가 접근할 수 있다. 간단한 User 등록을 위해 In-Memory User를 사용할 것이다. User는 총 3명으로 각각 ADMIN, MANAGER, USER 권한을 가지고 있다. @EnableWebSecurity@Slf4jpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private RoleHierarchyService roleHierarchyService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(&quot;admin&quot;).password(&quot;&#123;noop&#125;1234&quot;).roles(&quot;ADMIN&quot;).and() .withUser(&quot;manager&quot;).password(&quot;&#123;noop&#125;1234&quot;).roles(&quot;MANAGER&quot;).and() .withUser(&quot;user&quot;).password(&quot;&#123;noop&#125;1234&quot;).roles(&quot;USER&quot;); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http. authorizeRequests() .antMatchers(&quot;/signup&quot;).permitAll() .antMatchers(&quot;/h2-console/**&quot;).permitAll() .antMatchers(&quot;/login&quot;).permitAll() .antMatchers(&quot;/logout&quot;).permitAll() .antMatchers(&quot;/user&quot;).hasRole(&quot;USER&quot;) .antMatchers(&quot;/manager&quot;).hasRole(&quot;MANAGER&quot;) .antMatchers(&quot;/admin&quot;).hasRole(&quot;ADMIN&quot;) .anyRequest().authenticated(); http .formLogin().permitAll(); &#125; @Bean public RoleHierarchyImpl roleHierarchy()&#123; String allHierarchy = roleHierarchyService.findAllHierarchy(); RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); roleHierarchy.setHierarchy(allHierarchy); return roleHierarchy; &#125; @Bean public AccessDecisionVoter&lt;? extends Object&gt; roleVoter()&#123; RoleHierarchyVoter roleHierarchyVoter = new RoleHierarchyVoter(roleHierarchy()); return roleHierarchyVoter; &#125;&#125; 스프링 Security에서 권한간 상하관계를 인식할 수 있어 ADMIN 권한으로 MANAGER 권한의 자원에 접근할 수 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"}],"tags":[]},{"title":"프로그래머스 - 신규 아이디 추천 (Python)","slug":"algorithm/programmers/string/72410-신규아이디추천-python","date":"2021-08-09T11:10:40.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2021/08/09/algorithm/programmers/string/72410-신규아이디추천-python/","link":"","permalink":"https://ckck803.github.io/2021/08/09/algorithm/programmers/string/72410-%EC%8B%A0%EA%B7%9C%EC%95%84%EC%9D%B4%EB%94%94%EC%B6%94%EC%B2%9C-python/","excerpt":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/72410 프로그래머스 - 신규 아이디 추천 (Java) 프로그래머스 - 신규 아이디 추천 (Python) def solution(new_id): answer = &#x27;&#x27; lowerLine = new_id.lower() for i in lowerLine: if i.isalpha() or i.isdigit() or i in [&#x27;-&#x27;, &#x27;_&#x27;, &#x27;.&#x27;]: answer += i while &#x27;..&#x27; in answer: answer = answer.replace(&#x27;..&#x27;, &#x27;.&#x27;) if len(answer) &gt; 1: if answer[0] == &#x27;.&#x27;: answer = answer[1:] elif len(answer) == 1 and answer[0] == &#x27;.&#x27;: answer = &#x27;&#x27; if len(answer) &gt; 1: if answer[-1] == &#x27;.&#x27;: answer = answer[:-1] elif len(answer) == 1 and answer[-1] == &#x27;.&#x27;: answer = &#x27;&#x27; if len(answer) == 0: answer += &#x27;a&#x27; if len(answer) &gt; 15: answer = answer[:15] if answer[-1] == &#x27;.&#x27;: answer = answer[:-1] while len(answer) &lt;= 2: answer += answer[-1] return answer","text":"문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/72410 프로그래머스 - 신규 아이디 추천 (Java) 프로그래머스 - 신규 아이디 추천 (Python) def solution(new_id): answer = &#x27;&#x27; lowerLine = new_id.lower() for i in lowerLine: if i.isalpha() or i.isdigit() or i in [&#x27;-&#x27;, &#x27;_&#x27;, &#x27;.&#x27;]: answer += i while &#x27;..&#x27; in answer: answer = answer.replace(&#x27;..&#x27;, &#x27;.&#x27;) if len(answer) &gt; 1: if answer[0] == &#x27;.&#x27;: answer = answer[1:] elif len(answer) == 1 and answer[0] == &#x27;.&#x27;: answer = &#x27;&#x27; if len(answer) &gt; 1: if answer[-1] == &#x27;.&#x27;: answer = answer[:-1] elif len(answer) == 1 and answer[-1] == &#x27;.&#x27;: answer = &#x27;&#x27; if len(answer) == 0: answer += &#x27;a&#x27; if len(answer) &gt; 15: answer = answer[:15] if answer[-1] == &#x27;.&#x27;: answer = answer[:-1] while len(answer) &lt;= 2: answer += answer[-1] return answer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"정규 표현식","slug":"Programming/프로그래머스/문자열/정규-표현식","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://ckck803.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}]},{"title":"프로그래머스 - 표 편집 (Cpp)","slug":"algorithm/programmers/자료구조/SET/81303-표편집-Cpp","date":"2021-08-03T11:10:40.000Z","updated":"2024-02-18T16:19:54.515Z","comments":true,"path":"2021/08/03/algorithm/programmers/자료구조/SET/81303-표편집-Cpp/","link":"","permalink":"https://ckck803.github.io/2021/08/03/algorithm/programmers/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/SET/81303-%ED%91%9C%ED%8E%B8%EC%A7%91-Cpp/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/81303 문제 해설자료구조 Set에 대한 확실한 이해가 있어야 해결할 수 있는 문제,Set의 다양한 함수를 사용할 수 있는 좋은 문제다. 전체 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;bool check[1000010];set&lt;int&gt; arr;stack&lt;int&gt; deletedData;int executeCmd(int point, string cmd) &#123; char commond = cmd[0]; auto iter = arr.find(point); string str; int value; if (commond == &#x27;U&#x27; || commond == &#x27;D&#x27;) &#123; for (int i = 2; i &lt; cmd.size(); i++) &#123; str += cmd[i]; &#125; value = stoi(str); &#125; if (commond == &#x27;U&#x27;) &#123; for (int i = 0; i &lt; value; i++) &#123; iter--; &#125; &#125; if (commond == &#x27;D&#x27;) &#123; for (int i = 0; i &lt; value; i++) &#123; iter++; &#125; &#125; if (commond == &#x27;C&#x27;) &#123; deletedData.push(*iter); iter = arr.erase(iter); if (iter == arr.end()) &#123; iter--; &#125; &#125; if (commond == &#x27;Z&#x27;) &#123; if (!deletedData.empty()) &#123; int value = deletedData.top(); deletedData.pop(); arr.insert(value); &#125; &#125; return *iter;&#125;void insertNumber(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; arr.insert(i); &#125;&#125;void scanSet() &#123; for (auto iter = arr.begin(); iter != arr.end(); iter++) &#123; int index = *iter; check[index] = true; &#125;&#125;string solution(int n, int k, vector&lt;string&gt; cmd) &#123; string answer = &quot;&quot;; insertNumber(n); int point = k; for (int i = 0; i &lt; cmd.size(); i++) &#123; point = executeCmd(point, cmd[i]); &#125; scanSet(); for (int i = 0; i &lt; n; i++) &#123; if (check[i]) &#123; answer += &#x27;O&#x27;; &#125; else &#123; answer += &#x27;X&#x27;; &#125; &#125; return answer;&#125;","text":"https://programmers.co.kr/learn/courses/30/lessons/81303 문제 해설자료구조 Set에 대한 확실한 이해가 있어야 해결할 수 있는 문제,Set의 다양한 함수를 사용할 수 있는 좋은 문제다. 전체 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;bool check[1000010];set&lt;int&gt; arr;stack&lt;int&gt; deletedData;int executeCmd(int point, string cmd) &#123; char commond = cmd[0]; auto iter = arr.find(point); string str; int value; if (commond == &#x27;U&#x27; || commond == &#x27;D&#x27;) &#123; for (int i = 2; i &lt; cmd.size(); i++) &#123; str += cmd[i]; &#125; value = stoi(str); &#125; if (commond == &#x27;U&#x27;) &#123; for (int i = 0; i &lt; value; i++) &#123; iter--; &#125; &#125; if (commond == &#x27;D&#x27;) &#123; for (int i = 0; i &lt; value; i++) &#123; iter++; &#125; &#125; if (commond == &#x27;C&#x27;) &#123; deletedData.push(*iter); iter = arr.erase(iter); if (iter == arr.end()) &#123; iter--; &#125; &#125; if (commond == &#x27;Z&#x27;) &#123; if (!deletedData.empty()) &#123; int value = deletedData.top(); deletedData.pop(); arr.insert(value); &#125; &#125; return *iter;&#125;void insertNumber(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; arr.insert(i); &#125;&#125;void scanSet() &#123; for (auto iter = arr.begin(); iter != arr.end(); iter++) &#123; int index = *iter; check[index] = true; &#125;&#125;string solution(int n, int k, vector&lt;string&gt; cmd) &#123; string answer = &quot;&quot;; insertNumber(n); int point = k; for (int i = 0; i &lt; cmd.size(); i++) &#123; point = executeCmd(point, cmd[i]); &#125; scanSet(); for (int i = 0; i &lt; n; i++) &#123; if (check[i]) &#123; answer += &#x27;O&#x27;; &#125; else &#123; answer += &#x27;X&#x27;; &#125; &#125; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"자료구조","slug":"Programming/프로그래머스/자료구조","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"SET","slug":"Programming/프로그래머스/자료구조/SET","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/SET/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://ckck803.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"Cpp","slug":"Cpp","permalink":"https://ckck803.github.io/tags/Cpp/"}]},{"title":"카프카 사용하기","slug":"kafka/spring-cloud-kafka","date":"2021-04-19T16:58:03.000Z","updated":"2024-03-18T15:47:29.810Z","comments":true,"path":"2021/04/20/kafka/spring-cloud-kafka/","link":"","permalink":"https://ckck803.github.io/2021/04/20/kafka/spring-cloud-kafka/","excerpt":"카프카 명령어주키퍼 실행 ./bin/zookeeper-server-start.sh config/zookeeper.properties 카프카 실행 ./bin/kafka-server-start.sh config/server.properties 카프카 토픽관리토픽을 새로 생성하고 싶으면 kafka-topics 명령어에 --create 옵셩을 통해 새로운 토픽을 생성할 수 있습니다. ./bin/kafka-topics.sh \\ --create \\ --topic quickstart-events \\ --bootstrap-server localhost:9092 카프카에 저장된 모든 토픽 정보를 보고 싶을 경우 --list 옵셩을 통해 확인할 수 있습니다.","text":"카프카 명령어주키퍼 실행 ./bin/zookeeper-server-start.sh config/zookeeper.properties 카프카 실행 ./bin/kafka-server-start.sh config/server.properties 카프카 토픽관리토픽을 새로 생성하고 싶으면 kafka-topics 명령어에 --create 옵셩을 통해 새로운 토픽을 생성할 수 있습니다. ./bin/kafka-topics.sh \\ --create \\ --topic quickstart-events \\ --bootstrap-server localhost:9092 카프카에 저장된 모든 토픽 정보를 보고 싶을 경우 --list 옵셩을 통해 확인할 수 있습니다. ./bin/kafka-topics.sh \\ --bootstrap-server localhost:9092 \\ --list 토픽에 대한 상세 정보를 보고 싶을 경우 --describe 옵션을 통해 정보를 확인할 수 있습니다. ./bin/kafka-topics.sh \\ --describe \\ --topic quickstart-events \\ --bootstrap-server localhost:9092 카프카 메시지 생성카프카 토픽에 새로운 메시지를 보내고 싶을 경우 kafka-console-producer 명령어를 사용하면 됩니다. --broker-list 메시지를 보내기 위한 카프카 브로커 주소 --topic 메시지가 저장될 토픽 ./bin/kafka-console-producer.sh \\ --broker-list localhost:9092 \\ --topic quickstart-events 카프카 메시지 소비카프카 토픽에 메시지를 사용하고 싶을 경우 kafka-console-consumer 명령어를 사용하면 됩니다. --bootstrap-server 메시지를 구독하기 위한 카프카 주소 --topic 구독할 토픽 정보 ./bin/kafka-console-consumer.sh \\ --bootstrap-server localhost:9092 \\ --topic quickstart-events \\ --from-beginning","categories":[{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"Kafka","slug":"Develop/Kafka","permalink":"https://ckck803.github.io/categories/Develop/Kafka/"}],"tags":[]},{"title":"백준 3015 - 단어 정렬","slug":"algorithm/baekjoon/자료구조/SET/1181-단어정렬","date":"2021-04-17T01:53:25.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2021/04/17/algorithm/baekjoon/자료구조/SET/1181-단어정렬/","link":"","permalink":"https://ckck803.github.io/2021/04/17/algorithm/baekjoon/%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9/SET/1181-%EB%8B%A8%EC%96%B4%EC%A0%95%EB%A0%AC/","excerpt":"https://www.acmicpc.net/problem/1181 백준 3015 단어 정렬문제 풀이자료구조 Set을 사용하기 좋은 문제이다. 다만 Set에서 사용하는 정렬방식을 조건에 맞게 변형해줄 필요가 있다. 소스코드#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;pair&lt;int, string&gt;&gt; s;int n;int main(void) &#123; cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false); cin &gt;&gt; n; while (n--) &#123; string word; cin &gt;&gt; word; s.insert(&#123;word.length(), word&#125;); &#125; for (auto iter = s.begin(); iter != s.end(); iter++) &#123; cout &lt;&lt; iter-&gt;second &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 자바 소스 코드Comparator 인터페이스를 이용해 set의 정렬기준을 사용자가 정의한 정렬기준으로 변경할 수 있다. Comparator 인터페이스를 사용하게 되면 compare 메소드를 오버라이딩해 원하는 정렬 기준을 적용할 수 있다. import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Comparator;import java.util.Set;import java.util.TreeSet;public class Main &#123; public static void main(String args[]) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int count = Integer.parseInt(br.readLine()); Set&lt;String&gt; words = new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; if (o1.length() &lt; o2.length()) &#123; return -1; &#125; else if (o1.length() &gt; o2.length()) &#123; return 1; &#125; else &#123; return o1.compareTo(o2); &#125; &#125; &#125;); for (int countIdx = 0; countIdx &lt; count; countIdx++) &#123; String word = br.readLine(); words.add(word); &#125; words.stream().forEach(x -&gt; System.out.println(x)); &#125;&#125;","text":"https://www.acmicpc.net/problem/1181 백준 3015 단어 정렬문제 풀이자료구조 Set을 사용하기 좋은 문제이다. 다만 Set에서 사용하는 정렬방식을 조건에 맞게 변형해줄 필요가 있다. 소스코드#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;pair&lt;int, string&gt;&gt; s;int n;int main(void) &#123; cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false); cin &gt;&gt; n; while (n--) &#123; string word; cin &gt;&gt; word; s.insert(&#123;word.length(), word&#125;); &#125; for (auto iter = s.begin(); iter != s.end(); iter++) &#123; cout &lt;&lt; iter-&gt;second &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 자바 소스 코드Comparator 인터페이스를 이용해 set의 정렬기준을 사용자가 정의한 정렬기준으로 변경할 수 있다. Comparator 인터페이스를 사용하게 되면 compare 메소드를 오버라이딩해 원하는 정렬 기준을 적용할 수 있다. import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Comparator;import java.util.Set;import java.util.TreeSet;public class Main &#123; public static void main(String args[]) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int count = Integer.parseInt(br.readLine()); Set&lt;String&gt; words = new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; if (o1.length() &lt; o2.length()) &#123; return -1; &#125; else if (o1.length() &gt; o2.length()) &#123; return 1; &#125; else &#123; return o1.compareTo(o2); &#125; &#125; &#125;); for (int countIdx = 0; countIdx &lt; count; countIdx++) &#123; String word = br.readLine(); words.add(word); &#125; words.stream().forEach(x -&gt; System.out.println(x)); &#125;&#125; 파이썬 소스 코드파이썬에서는 sorted 메소드에 정렬 기준을 넘겨주면 해당 정렬 기준을 이용해 정렬을 하게 된다. n = int(input())s = set()for i in range(n): s.add(input())s = sorted(sorted(s), key=len)for a in s: print(a)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"자료구조","slug":"Programming/Beakjoon/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"SET","slug":"Programming/Beakjoon/자료구조/SET","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/SET/"}],"tags":[{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"}]},{"title":"백준 12100 - 2048","slug":"algorithm/baekjoon/시뮬레이션/12100-2048","date":"2021-04-15T13:39:03.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2021/04/15/algorithm/baekjoon/시뮬레이션/12100-2048/","link":"","permalink":"https://ckck803.github.io/2021/04/15/algorithm/baekjoon/%E1%84%89%E1%85%B5%E1%84%86%E1%85%B2%E1%86%AF%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB/12100-2048/","excerpt":"https://www.acmicpc.net/problem/12100 백준 12100 - 2048문제 풀이보드를 상하좌우로 움직이면서 블록이 최대값이 나올 수 있는 경우를 찾는 문제이다. 한 보드를 상하좌우로 움직이고 원래데로 되돌린 후 다시 시도하기 위해 백트레킹 기법이 필요하다. 블록을 상하좌우중 한 방향으로 움직인다. 5번 움직이면 블록을 스캔해 최대값을 찾는다. 이전 단계로 되돌린 후 다른방향으로 움직이면서 최대값을 찾아본다. 문제 예외 처리 한번 합처진 블록은 연속적으로 합처질 수 없다. 합처지는 순서는 이동하려고 하는 쪽의 칸이 먼저 합쳐진다. 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;int maxValue = 0;int board[22][22];int boardSize = 0;void initBoard(int size) &#123; for (int i = 0; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123; cin &gt;&gt; board[i][j]; &#125; &#125;&#125;void moveTop() &#123; int check[22][22]; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; check[col][row] = false; &#125; &#125; for (int row = 0; row &lt; boardSize; row++) &#123; for (int col = 0; col &lt; boardSize; col++) &#123; int cntRow = row; int cntCol = col; if (board[cntRow][cntCol] == 0) &#123; continue; &#125; while (cntRow - 1 &gt;= 0 &amp;&amp; (board[cntRow - 1][cntCol] == board[cntRow][cntCol] || board[cntRow - 1][cntCol] == 0)) &#123; if (board[cntRow - 1][cntCol] == board[cntRow][cntCol]) &#123; if (check[cntRow - 1][cntCol] == false &amp;&amp; check[cntRow][cntCol] == false) &#123; board[cntRow - 1][cntCol] += board[cntRow][cntCol]; check[cntRow - 1][cntCol] = true; board[cntRow][cntCol] = 0; &#125; else &#123; break; &#125; &#125; else &#123; swap(board[cntRow - 1][cntCol], board[cntRow][cntCol]); &#125; cntRow--; &#125; &#125; &#125;&#125;void moveButton() &#123; int check[22][22]; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; check[col][row] = false; &#125; &#125; for (int row = boardSize - 1; row &gt;= 0; row--) &#123; for (int col = 0; col &lt; boardSize; col++) &#123; int cntCol = col; int cntRow = row; if (board[cntRow][cntCol] == 0) &#123; continue; &#125; while (cntRow + 1 &lt; boardSize &amp;&amp; (board[cntRow + 1][cntCol] == board[cntRow][cntCol] || board[cntRow + 1][cntCol] == 0)) &#123; if (board[cntRow + 1][cntCol] == board[cntRow][cntCol]) &#123; if (check[cntRow + 1][cntCol] == false &amp;&amp; check[cntRow][cntCol] == false) &#123; board[cntRow + 1][cntCol] += board[cntRow][cntCol]; check[cntRow + 1][cntCol] = true; board[cntRow][cntCol] = 0; &#125; else &#123; break; &#125; &#125; else &#123; swap(board[cntRow + 1][cntCol], board[cntRow][cntCol]); &#125; cntRow++; &#125; &#125; &#125;&#125;void moveLeft() &#123; int check[22][22]; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; check[col][row] = false; &#125; &#125; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; int cntCol = col; int cntRow = row; if (board[cntRow][cntCol] == 0) &#123; continue; &#125; while (cntCol - 1 &gt;= 0 &amp;&amp; (board[cntRow][cntCol - 1] == board[cntRow][cntCol] || board[cntRow][cntCol - 1] == 0)) &#123; if (board[cntRow][cntCol - 1] == board[cntRow][cntCol]) &#123; if (check[cntRow][cntCol - 1] == false &amp;&amp; check[cntRow][cntCol] == false) &#123; board[cntRow][cntCol - 1] += board[cntRow][cntCol]; check[cntRow][cntCol - 1] = true; board[cntRow][cntCol] = 0; &#125; else &#123; break; &#125; &#125; else &#123; swap(board[cntRow][cntCol - 1], board[cntRow][cntCol]); &#125; cntCol--; &#125; &#125; &#125;&#125;void moveRight() &#123; int check[22][22]; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; check[col][row] = false; &#125; &#125; for (int col = boardSize - 1; col &gt;= 0; col--) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; int cntRow = row; int cntCol = col; if (board[cntRow][cntCol] == 0) &#123; continue; &#125; while (cntCol + 1 &lt; boardSize &amp;&amp; (board[cntRow][cntCol + 1] == board[cntRow][cntCol] || board[cntRow][cntCol + 1] == 0)) &#123; if (board[cntRow][cntCol + 1] == board[cntRow][cntCol]) &#123; if (check[cntRow][cntCol + 1] == false &amp;&amp; check[cntRow][cntCol] == false) &#123; board[cntRow][cntCol + 1] += board[cntRow][cntCol]; check[cntRow][cntCol + 1] = true; board[cntRow][cntCol] = 0; &#125; else &#123; break; &#125; &#125; else &#123; swap(board[cntRow][cntCol], board[cntRow][cntCol + 1]); &#125; cntCol++; &#125; &#125; &#125;&#125;void returnBoard(int (*board)[22], int (*copy)[22]) &#123; for (int i = 0; i &lt; boardSize; i++) &#123; for (int j = 0; j &lt; boardSize; j++) &#123; board[i][j] = copy[i][j]; &#125; &#125;&#125;void moveBoard(int depth) &#123; int copyBoard[22][22]; for (int i = 0; i &lt; boardSize; i++) &#123; for (int j = 0; j &lt; boardSize; j++) &#123; copyBoard[i][j] = board[i][j]; &#125; &#125; if (depth == 5) &#123; for (int i = 0; i &lt; boardSize; i++) &#123; for (int j = 0; j &lt; boardSize; j++) &#123; if (board[i][j] &gt; maxValue) &#123; maxValue = board[i][j]; &#125; &#125; &#125; return; &#125; moveTop(); moveBoard(depth + 1); returnBoard(board, copyBoard); moveButton(); moveBoard(depth + 1); returnBoard(board, copyBoard); moveLeft(); moveBoard(depth + 1); returnBoard(board, copyBoard); moveRight(); moveBoard(depth + 1); returnBoard(board, copyBoard);&#125;int main(void) &#123; cin &gt;&gt; boardSize; initBoard(boardSize); moveBoard(0); cout &lt;&lt; maxValue &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","text":"https://www.acmicpc.net/problem/12100 백준 12100 - 2048문제 풀이보드를 상하좌우로 움직이면서 블록이 최대값이 나올 수 있는 경우를 찾는 문제이다. 한 보드를 상하좌우로 움직이고 원래데로 되돌린 후 다시 시도하기 위해 백트레킹 기법이 필요하다. 블록을 상하좌우중 한 방향으로 움직인다. 5번 움직이면 블록을 스캔해 최대값을 찾는다. 이전 단계로 되돌린 후 다른방향으로 움직이면서 최대값을 찾아본다. 문제 예외 처리 한번 합처진 블록은 연속적으로 합처질 수 없다. 합처지는 순서는 이동하려고 하는 쪽의 칸이 먼저 합쳐진다. 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;int maxValue = 0;int board[22][22];int boardSize = 0;void initBoard(int size) &#123; for (int i = 0; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123; cin &gt;&gt; board[i][j]; &#125; &#125;&#125;void moveTop() &#123; int check[22][22]; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; check[col][row] = false; &#125; &#125; for (int row = 0; row &lt; boardSize; row++) &#123; for (int col = 0; col &lt; boardSize; col++) &#123; int cntRow = row; int cntCol = col; if (board[cntRow][cntCol] == 0) &#123; continue; &#125; while (cntRow - 1 &gt;= 0 &amp;&amp; (board[cntRow - 1][cntCol] == board[cntRow][cntCol] || board[cntRow - 1][cntCol] == 0)) &#123; if (board[cntRow - 1][cntCol] == board[cntRow][cntCol]) &#123; if (check[cntRow - 1][cntCol] == false &amp;&amp; check[cntRow][cntCol] == false) &#123; board[cntRow - 1][cntCol] += board[cntRow][cntCol]; check[cntRow - 1][cntCol] = true; board[cntRow][cntCol] = 0; &#125; else &#123; break; &#125; &#125; else &#123; swap(board[cntRow - 1][cntCol], board[cntRow][cntCol]); &#125; cntRow--; &#125; &#125; &#125;&#125;void moveButton() &#123; int check[22][22]; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; check[col][row] = false; &#125; &#125; for (int row = boardSize - 1; row &gt;= 0; row--) &#123; for (int col = 0; col &lt; boardSize; col++) &#123; int cntCol = col; int cntRow = row; if (board[cntRow][cntCol] == 0) &#123; continue; &#125; while (cntRow + 1 &lt; boardSize &amp;&amp; (board[cntRow + 1][cntCol] == board[cntRow][cntCol] || board[cntRow + 1][cntCol] == 0)) &#123; if (board[cntRow + 1][cntCol] == board[cntRow][cntCol]) &#123; if (check[cntRow + 1][cntCol] == false &amp;&amp; check[cntRow][cntCol] == false) &#123; board[cntRow + 1][cntCol] += board[cntRow][cntCol]; check[cntRow + 1][cntCol] = true; board[cntRow][cntCol] = 0; &#125; else &#123; break; &#125; &#125; else &#123; swap(board[cntRow + 1][cntCol], board[cntRow][cntCol]); &#125; cntRow++; &#125; &#125; &#125;&#125;void moveLeft() &#123; int check[22][22]; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; check[col][row] = false; &#125; &#125; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; int cntCol = col; int cntRow = row; if (board[cntRow][cntCol] == 0) &#123; continue; &#125; while (cntCol - 1 &gt;= 0 &amp;&amp; (board[cntRow][cntCol - 1] == board[cntRow][cntCol] || board[cntRow][cntCol - 1] == 0)) &#123; if (board[cntRow][cntCol - 1] == board[cntRow][cntCol]) &#123; if (check[cntRow][cntCol - 1] == false &amp;&amp; check[cntRow][cntCol] == false) &#123; board[cntRow][cntCol - 1] += board[cntRow][cntCol]; check[cntRow][cntCol - 1] = true; board[cntRow][cntCol] = 0; &#125; else &#123; break; &#125; &#125; else &#123; swap(board[cntRow][cntCol - 1], board[cntRow][cntCol]); &#125; cntCol--; &#125; &#125; &#125;&#125;void moveRight() &#123; int check[22][22]; for (int col = 0; col &lt; boardSize; col++) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; check[col][row] = false; &#125; &#125; for (int col = boardSize - 1; col &gt;= 0; col--) &#123; for (int row = 0; row &lt; boardSize; row++) &#123; int cntRow = row; int cntCol = col; if (board[cntRow][cntCol] == 0) &#123; continue; &#125; while (cntCol + 1 &lt; boardSize &amp;&amp; (board[cntRow][cntCol + 1] == board[cntRow][cntCol] || board[cntRow][cntCol + 1] == 0)) &#123; if (board[cntRow][cntCol + 1] == board[cntRow][cntCol]) &#123; if (check[cntRow][cntCol + 1] == false &amp;&amp; check[cntRow][cntCol] == false) &#123; board[cntRow][cntCol + 1] += board[cntRow][cntCol]; check[cntRow][cntCol + 1] = true; board[cntRow][cntCol] = 0; &#125; else &#123; break; &#125; &#125; else &#123; swap(board[cntRow][cntCol], board[cntRow][cntCol + 1]); &#125; cntCol++; &#125; &#125; &#125;&#125;void returnBoard(int (*board)[22], int (*copy)[22]) &#123; for (int i = 0; i &lt; boardSize; i++) &#123; for (int j = 0; j &lt; boardSize; j++) &#123; board[i][j] = copy[i][j]; &#125; &#125;&#125;void moveBoard(int depth) &#123; int copyBoard[22][22]; for (int i = 0; i &lt; boardSize; i++) &#123; for (int j = 0; j &lt; boardSize; j++) &#123; copyBoard[i][j] = board[i][j]; &#125; &#125; if (depth == 5) &#123; for (int i = 0; i &lt; boardSize; i++) &#123; for (int j = 0; j &lt; boardSize; j++) &#123; if (board[i][j] &gt; maxValue) &#123; maxValue = board[i][j]; &#125; &#125; &#125; return; &#125; moveTop(); moveBoard(depth + 1); returnBoard(board, copyBoard); moveButton(); moveBoard(depth + 1); returnBoard(board, copyBoard); moveLeft(); moveBoard(depth + 1); returnBoard(board, copyBoard); moveRight(); moveBoard(depth + 1); returnBoard(board, copyBoard);&#125;int main(void) &#123; cin &gt;&gt; boardSize; initBoard(boardSize); moveBoard(0); cout &lt;&lt; maxValue &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"시뮬레이션","slug":"Programming/Beakjoon/시뮬레이션","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://ckck803.github.io/tags/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://ckck803.github.io/tags/%EC%82%BC%EC%84%B1-%EA%B8%B0%EC%B6%9C/"}]},{"title":"백준 1920 - 수 찾기","slug":"algorithm/baekjoon/BinarySearch/1920-수찾기","date":"2021-04-04T08:21:14.000Z","updated":"2024-02-18T16:19:54.510Z","comments":true,"path":"2021/04/04/algorithm/baekjoon/BinarySearch/1920-수찾기/","link":"","permalink":"https://ckck803.github.io/2021/04/04/algorithm/baekjoon/BinarySearch/1920-%EC%88%98%EC%B0%BE%EA%B8%B0/","excerpt":"백준 1920 - 수 찾기문제 풀이범위 1~10만개의 숫자들 중에서 M개의 주어진 값이 존재하는지 확인하는 문제이다. 일반적인 탐색을 진행할 경우 O(N*N)의 시간복잡도를 갖게 되므로 O(logN)의 시간복잡도를 갖는 이분 탐색을 이용해 문제를 해결하도록 한다. 전체 소스#include &lt;bits/stdc++.h&gt;using namespace std;int binarySearch(vector&lt;int&gt;&amp; arr, int value) &#123; int begin = 0; int end = arr.size() - 1; while (begin &lt;= end) &#123; int mid = (begin + end) / 2; int midValue = arr[mid]; if (value == midValue) &#123; return 1; &#125; else if (value &gt; midValue) &#123; begin = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; return 0;&#125;vector&lt;int&gt; solution(vector&lt;int&gt; arr, vector&lt;int&gt; values) &#123; vector&lt;int&gt; results; for (int valuesIndex = 0; valuesIndex &lt; values.size(); valuesIndex++) &#123; int result = binarySearch(arr, values[valuesIndex]); results.push_back(result); &#125; return results;&#125;int main(void) &#123; int n, m; vector&lt;int&gt; arr; vector&lt;int&gt; values; cin &gt;&gt; n; arr = vector&lt;int&gt;(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; sort(arr.begin(), arr.end()); cin &gt;&gt; m; values = vector&lt;int&gt;(m); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; values[i]; &#125; vector&lt;int&gt; results = solution(arr, values); for (int value : results) &#123; cout &lt;&lt; value &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125;","text":"백준 1920 - 수 찾기문제 풀이범위 1~10만개의 숫자들 중에서 M개의 주어진 값이 존재하는지 확인하는 문제이다. 일반적인 탐색을 진행할 경우 O(N*N)의 시간복잡도를 갖게 되므로 O(logN)의 시간복잡도를 갖는 이분 탐색을 이용해 문제를 해결하도록 한다. 전체 소스#include &lt;bits/stdc++.h&gt;using namespace std;int binarySearch(vector&lt;int&gt;&amp; arr, int value) &#123; int begin = 0; int end = arr.size() - 1; while (begin &lt;= end) &#123; int mid = (begin + end) / 2; int midValue = arr[mid]; if (value == midValue) &#123; return 1; &#125; else if (value &gt; midValue) &#123; begin = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; return 0;&#125;vector&lt;int&gt; solution(vector&lt;int&gt; arr, vector&lt;int&gt; values) &#123; vector&lt;int&gt; results; for (int valuesIndex = 0; valuesIndex &lt; values.size(); valuesIndex++) &#123; int result = binarySearch(arr, values[valuesIndex]); results.push_back(result); &#125; return results;&#125;int main(void) &#123; int n, m; vector&lt;int&gt; arr; vector&lt;int&gt; values; cin &gt;&gt; n; arr = vector&lt;int&gt;(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; sort(arr.begin(), arr.end()); cin &gt;&gt; m; values = vector&lt;int&gt;(m); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; values[i]; &#125; vector&lt;int&gt; results = solution(arr, values); for (int value : results) &#123; cout &lt;&lt; value &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"이분탐색","slug":"Programming/Beakjoon/이분탐색","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/"}],"tags":[]},{"title":"백준 2343 - 기타 레슨","slug":"algorithm/baekjoon/BinarySearch/2343-기타레슨","date":"2021-04-04T08:21:14.000Z","updated":"2024-02-18T16:19:54.510Z","comments":true,"path":"2021/04/04/algorithm/baekjoon/BinarySearch/2343-기타레슨/","link":"","permalink":"https://ckck803.github.io/2021/04/04/algorithm/baekjoon/BinarySearch/2343-%EA%B8%B0%ED%83%80%EB%A0%88%EC%8A%A8/","excerpt":"백준 2343 - 기타 레슨https://www.acmicpc.net/problem/2343 문제 풀이탐색 범위는 (1~10억)이고 연산을 N번 해야 함으로 O(N) or O(NlogN)의 시간복잡도 내에 문제를 해결해야 한다. 탐색 시간을 줄이기 위해서 O(logN)시간 복잡도 내에 탐색을 끝낼 수 있는 이분탐색을 이용해 문제를 해결해야 한다. 이 문제의 함정은 조건 중 순서가 뒤바뀌면 안된다는 조껀이 있기 때문에 레슨이 들어온 순서를 sorting할 경우 틀리게 된다. begin을 1로 end를 들어온 값의 합을 준다. begin과 end 범위 내에서 이분 탐색을 진행한다. 이분탐색을 진행하면서 블루레이를 녹화할 수 있는 영상의 길이가 한 영상의 길이보다 작으면 begin을 움직인다. 블루레이에 녹화하는 갯수가 블루레이보다 총 갯수보다 작거나 같을 경우 end를 움직인다. 블루레이에 녹화하는 갯수가 블루레이보다 작을 경우 begin을 움직인다. 전체 소스#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(vector&lt;int&gt; arr, int mid, int M) &#123; int sum = 0; int count = 1; for (int arrIndex = 0; arrIndex &lt; arr.size(); arrIndex++) &#123; int value = arr[arrIndex]; if (value &gt; mid) &#123; return true; &#125; if (sum + value &lt;= mid) &#123; sum += value; &#125; else &#123; count += 1; sum = value; &#125; &#125; // 길이가 너무 짧다. begin을 늘려줘야 한다. return count &gt; M;&#125;int binarySearch(vector&lt;int&gt; arr, int N, int M) &#123; int begin = 1; int end = 0; for (int arrIndex = 0; arrIndex &lt; arr.size(); arrIndex++) &#123; end += arr[arrIndex]; &#125; while (begin &lt;= end) &#123; int mid = (begin + end) / 2; if (cmp(arr, mid, M)) &#123; begin = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; return begin;&#125;int solution(vector&lt;int&gt; arr, int N, int M) &#123; int result = 0; result = binarySearch(arr, N, M); return result;&#125;int main(void) &#123; int N, M; vector&lt;int&gt; arr; cin &gt;&gt; N &gt;&gt; M; arr = vector&lt;int&gt;(N); for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; arr[i]; &#125; cout &lt;&lt; solution(arr, N, M) &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","text":"백준 2343 - 기타 레슨https://www.acmicpc.net/problem/2343 문제 풀이탐색 범위는 (1~10억)이고 연산을 N번 해야 함으로 O(N) or O(NlogN)의 시간복잡도 내에 문제를 해결해야 한다. 탐색 시간을 줄이기 위해서 O(logN)시간 복잡도 내에 탐색을 끝낼 수 있는 이분탐색을 이용해 문제를 해결해야 한다. 이 문제의 함정은 조건 중 순서가 뒤바뀌면 안된다는 조껀이 있기 때문에 레슨이 들어온 순서를 sorting할 경우 틀리게 된다. begin을 1로 end를 들어온 값의 합을 준다. begin과 end 범위 내에서 이분 탐색을 진행한다. 이분탐색을 진행하면서 블루레이를 녹화할 수 있는 영상의 길이가 한 영상의 길이보다 작으면 begin을 움직인다. 블루레이에 녹화하는 갯수가 블루레이보다 총 갯수보다 작거나 같을 경우 end를 움직인다. 블루레이에 녹화하는 갯수가 블루레이보다 작을 경우 begin을 움직인다. 전체 소스#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(vector&lt;int&gt; arr, int mid, int M) &#123; int sum = 0; int count = 1; for (int arrIndex = 0; arrIndex &lt; arr.size(); arrIndex++) &#123; int value = arr[arrIndex]; if (value &gt; mid) &#123; return true; &#125; if (sum + value &lt;= mid) &#123; sum += value; &#125; else &#123; count += 1; sum = value; &#125; &#125; // 길이가 너무 짧다. begin을 늘려줘야 한다. return count &gt; M;&#125;int binarySearch(vector&lt;int&gt; arr, int N, int M) &#123; int begin = 1; int end = 0; for (int arrIndex = 0; arrIndex &lt; arr.size(); arrIndex++) &#123; end += arr[arrIndex]; &#125; while (begin &lt;= end) &#123; int mid = (begin + end) / 2; if (cmp(arr, mid, M)) &#123; begin = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; return begin;&#125;int solution(vector&lt;int&gt; arr, int N, int M) &#123; int result = 0; result = binarySearch(arr, N, M); return result;&#125;int main(void) &#123; int N, M; vector&lt;int&gt; arr; cin &gt;&gt; N &gt;&gt; M; arr = vector&lt;int&gt;(N); for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; arr[i]; &#125; cout &lt;&lt; solution(arr, N, M) &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"이분탐색","slug":"Programming/Beakjoon/이분탐색","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/"}],"tags":[]},{"title":"백준 3015 - 오아시스 재결합","slug":"algorithm/baekjoon/자료구조/STACK/3015-오아시스_재결합","date":"2021-04-03T11:10:40.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2021/04/03/algorithm/baekjoon/자료구조/STACK/3015-오아시스_재결합/","link":"","permalink":"https://ckck803.github.io/2021/04/03/algorithm/baekjoon/%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9/STACK/3015-%EC%98%A4%EC%95%84%EC%8B%9C%EC%8A%A4_%EC%9E%AC%EA%B2%B0%ED%95%A9/","excerpt":"백준 3015 - 오아시스 재결합https://www.acmicpc.net/problem/1920 문제 해설입력되는 값이 총 50만개이다. 이 문제는 O(N) or O(NlogN)의 시간복잡도를 갖고 해결을 해야하는 문제이다. 현재 값을 이전 값과 비교해가면서 문제를 해결 하는 방식이다. 스택의 역할은 서로불 수 있는 값의 쌍을 저장하기 위한 역할을 한다. 스택내의 값은 점점 작은 값이 추가 되야 한다. 들어오는 값이 top보다 클 경우 들어오는 값보다 큰 값이 나타날 때까지 pop을 진행하면서 pop을 진행할 때 해당 인원수 만큼 값을 더해준다. 같은 값이 들어올 경우을 어떻게 해결하는 것이 이 문제의 어려운 점이다. 자료구조 pair를 이용한다. first에는 사람의 키를 second에는 같은 키인 사람의 수를 저장한다. 키가 같은 사람이 들어올 경우 같은 키를 갖는 사람만큼 값을 추가해주고 사람수를 + 1 해주고 해당 키를 다시 push해준다. 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;long long solution(vector&lt;int&gt; heights) &#123; stack&lt;pair&lt;int, int&gt;&gt; st; long long result = 0; for (int heightsIndex = 0; heightsIndex &lt; heights.size(); heightsIndex++) &#123; int height = heights[heightsIndex]; while (!st.empty() &amp;&amp; height &gt; st.top().first) &#123; result += st.top().second; st.pop(); &#125; if (!st.empty()) &#123; if (st.top().first == height) &#123; pair&lt;int, int&gt; temp = st.top(); st.pop(); result += temp.second; if (!st.empty()) &#123; result += 1; &#125; st.push(&#123;height, temp.second + 1&#125;); &#125; else &#123; result += 1; st.push(&#123;height, 1&#125;); &#125; &#125; else &#123; st.push(&#123;height, 1&#125;); &#125; &#125; return result;&#125;int main(void) &#123; int numOfPeople; vector&lt;int&gt; heights; cin &gt;&gt; numOfPeople; for (int peopleIndex = 0; peopleIndex &lt; numOfPeople; peopleIndex++) &#123; int height; cin &gt;&gt; height; heights.push_back(height); &#125; cout &lt;&lt; solution(heights) &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","text":"백준 3015 - 오아시스 재결합https://www.acmicpc.net/problem/1920 문제 해설입력되는 값이 총 50만개이다. 이 문제는 O(N) or O(NlogN)의 시간복잡도를 갖고 해결을 해야하는 문제이다. 현재 값을 이전 값과 비교해가면서 문제를 해결 하는 방식이다. 스택의 역할은 서로불 수 있는 값의 쌍을 저장하기 위한 역할을 한다. 스택내의 값은 점점 작은 값이 추가 되야 한다. 들어오는 값이 top보다 클 경우 들어오는 값보다 큰 값이 나타날 때까지 pop을 진행하면서 pop을 진행할 때 해당 인원수 만큼 값을 더해준다. 같은 값이 들어올 경우을 어떻게 해결하는 것이 이 문제의 어려운 점이다. 자료구조 pair를 이용한다. first에는 사람의 키를 second에는 같은 키인 사람의 수를 저장한다. 키가 같은 사람이 들어올 경우 같은 키를 갖는 사람만큼 값을 추가해주고 사람수를 + 1 해주고 해당 키를 다시 push해준다. 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;long long solution(vector&lt;int&gt; heights) &#123; stack&lt;pair&lt;int, int&gt;&gt; st; long long result = 0; for (int heightsIndex = 0; heightsIndex &lt; heights.size(); heightsIndex++) &#123; int height = heights[heightsIndex]; while (!st.empty() &amp;&amp; height &gt; st.top().first) &#123; result += st.top().second; st.pop(); &#125; if (!st.empty()) &#123; if (st.top().first == height) &#123; pair&lt;int, int&gt; temp = st.top(); st.pop(); result += temp.second; if (!st.empty()) &#123; result += 1; &#125; st.push(&#123;height, temp.second + 1&#125;); &#125; else &#123; result += 1; st.push(&#123;height, 1&#125;); &#125; &#125; else &#123; st.push(&#123;height, 1&#125;); &#125; &#125; return result;&#125;int main(void) &#123; int numOfPeople; vector&lt;int&gt; heights; cin &gt;&gt; numOfPeople; for (int peopleIndex = 0; peopleIndex &lt; numOfPeople; peopleIndex++) &#123; int height; cin &gt;&gt; height; heights.push_back(height); &#125; cout &lt;&lt; solution(heights) &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"자료구조","slug":"Programming/Beakjoon/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"Programming/Beakjoon/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"}],"tags":[]},{"title":"백준 - 세그먼트 트리","slug":"algorithm/category/baekjoon-segment-tree","date":"2021-03-25T17:12:13.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-segment-tree/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-segment-tree/","excerpt":"백준 세그먼트 트리세그먼트 트리 문제 이름 틀린 횟수 정리여부 비고 2042 구간 합 구하기 기본 유형","text":"백준 세그먼트 트리세그먼트 트리 문제 이름 틀린 횟수 정리여부 비고 2042 구간 합 구하기 기본 유형","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 슬라이딩 윈도우","slug":"algorithm/category/baekjoon-sliding-window","date":"2021-03-25T17:10:47.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-sliding-window/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-sliding-window/","excerpt":"백준 슬라이딩 윈도우슬라이딩 윈도우 문제 이름 틀린 횟수 정리여부 비고 2075 N번째 큰 수 슬라이딩 윈도우 기본 유형 2096 내려가기","text":"백준 슬라이딩 윈도우슬라이딩 윈도우 문제 이름 틀린 횟수 정리여부 비고 2075 N번째 큰 수 슬라이딩 윈도우 기본 유형 2096 내려가기","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 수학","slug":"algorithm/category/baekjoon-math","date":"2021-03-25T17:09:10.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-math/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-math/","excerpt":"백준 - 수학수학 문제 이름 링크 정리여부 비고 1085 직사각형에서 탈출 https://www.acmicpc.net/problem/1085 1644 소수의 연속합 https://www.acmicpc.net/problem/1644 1712 손익분기점 https://www.acmicpc.net/problem/1712 1722 순열의 순서 https://www.acmicpc.net/problem/1722 1978 알파벳 https://www.acmicpc.net/problem/1978 1990 소수인팬린드롬 https://www.acmicpc.net/problem/1990 2292 벌집 https://www.acmicpc.net/problem/2292 2839 설탈배달 https://www.acmicpc.net/problem/2839 2960 에라토스테네스의 체 https://www.acmicpc.net/problem/2960 10819 차이를 최대로 https://www.acmicpc.net/problem/10819 순열, next_permutation 10950 A+B - 3 https://www.acmicpc.net/problem/10950 10952 A+B - 5 https://www.acmicpc.net/problem/10952 11021 A+B - 7 https://www.acmicpc.net/problem/11021 11022 A+B - 8 https://www.acmicpc.net/problem/11022","text":"백준 - 수학수학 문제 이름 링크 정리여부 비고 1085 직사각형에서 탈출 https://www.acmicpc.net/problem/1085 1644 소수의 연속합 https://www.acmicpc.net/problem/1644 1712 손익분기점 https://www.acmicpc.net/problem/1712 1722 순열의 순서 https://www.acmicpc.net/problem/1722 1978 알파벳 https://www.acmicpc.net/problem/1978 1990 소수인팬린드롬 https://www.acmicpc.net/problem/1990 2292 벌집 https://www.acmicpc.net/problem/2292 2839 설탈배달 https://www.acmicpc.net/problem/2839 2960 에라토스테네스의 체 https://www.acmicpc.net/problem/2960 10819 차이를 최대로 https://www.acmicpc.net/problem/10819 순열, next_permutation 10950 A+B - 3 https://www.acmicpc.net/problem/10950 10952 A+B - 5 https://www.acmicpc.net/problem/10952 11021 A+B - 7 https://www.acmicpc.net/problem/11021 11022 A+B - 8 https://www.acmicpc.net/problem/11022","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 비트마스킹","slug":"algorithm/category/baekjoon-bitmasking","date":"2021-03-25T17:07:50.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-bitmasking/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-bitmasking/","excerpt":"백준 - 비트 마스킹비트 마스크 문제 이름 틀린 횟수 정리여부 비고 2064 IP 주소 토크나이징, 비트 연산 11723 집합 기본유형","text":"백준 - 비트 마스킹비트 마스크 문제 이름 틀린 횟수 정리여부 비고 2064 IP 주소 토크나이징, 비트 연산 11723 집합 기본유형","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 유니온 파인드","slug":"algorithm/category/baekjoon-union-find","date":"2021-03-25T17:06:18.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-union-find/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-union-find/","excerpt":"백준 유니온 파인드유니온 파인드 문제 이름 틀린 횟수 정리여부 비고 1717 집합의 표현 1976 여행가자 4195 친구 네트워크 10774 저지 10775 공항","text":"백준 유니온 파인드유니온 파인드 문제 이름 틀린 횟수 정리여부 비고 1717 집합의 표현 1976 여행가자 4195 친구 네트워크 10774 저지 10775 공항","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 최소 스패닝 트리","slug":"algorithm/category/baekjoon-minimum-spaning-tree","date":"2021-03-25T17:04:36.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-minimum-spaning-tree/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-minimum-spaning-tree/","excerpt":"백준 최소 스패닝 트리최소 스패닝 트리 문제 이름 틀린 횟수 정리여부 비고 1196 최소 스패닝 트리 최소 스패닝 트리 기본 유형 9372 상근이의 여행 17472 다리 만들기 2 삼성, 최소 스패닝 트리","text":"백준 최소 스패닝 트리최소 스패닝 트리 문제 이름 틀린 횟수 정리여부 비고 1196 최소 스패닝 트리 최소 스패닝 트리 기본 유형 9372 상근이의 여행 17472 다리 만들기 2 삼성, 최소 스패닝 트리","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 투 포인터","slug":"algorithm/category/baekjoon-twopointer","date":"2021-03-25T17:02:50.000Z","updated":"2024-02-18T16:19:54.513Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-twopointer/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-twopointer/","excerpt":"백준 - 투 포인터투 포인터 문제 이름 틀린 횟수 정리여부 비고 1484 다이어트 1806 부분합 2003 수들의 합 2 기본 유형 2230 수 고르기","text":"백준 - 투 포인터투 포인터 문제 이름 틀린 횟수 정리여부 비고 1484 다이어트 1806 부분합 2003 수들의 합 2 기본 유형 2230 수 고르기","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 백트래킹","slug":"algorithm/category/baekjoon-backtracking","date":"2021-03-25T17:01:10.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-backtracking/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-backtracking/","excerpt":"백준 백트래킹백트래킹 문제 이름 링크 정리여부 비고 1987 병든 나이트 https://www.acmicpc.net/problem/1987 2580 스도쿠 https://www.acmicpc.net/problem/2580 4574 스도미노쿠 https://www.acmicpc.net/problem/4574 6603 로또 https://www.acmicpc.net/problem/6603 9663 N-Queen https://www.acmicpc.net/problem/9663 16987 계란으로 계란치기 https://www.acmicpc.net/problem/16987","text":"백준 백트래킹백트래킹 문제 이름 링크 정리여부 비고 1987 병든 나이트 https://www.acmicpc.net/problem/1987 2580 스도쿠 https://www.acmicpc.net/problem/2580 4574 스도미노쿠 https://www.acmicpc.net/problem/4574 6603 로또 https://www.acmicpc.net/problem/6603 9663 N-Queen https://www.acmicpc.net/problem/9663 16987 계란으로 계란치기 https://www.acmicpc.net/problem/16987","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 이분탐색","slug":"algorithm/category/baekjoon-binary","date":"2021-03-25T16:58:58.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-binary/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-binary/","excerpt":"백준 이분탐색이분 탐색 문제 이름 링크 정리여부 비고 1920 수찾기 https://www.acmicpc.net/problem/1920 1939 중량제한 https://www.acmicpc.net/problem/13397 2110 공유기 설치 https://www.acmicpc.net/problem/2210 2343 기타레슨 https://www.acmicpc.net/problem/2343 O 겁나 많이 틀림 2792 보석상자 https://www.acmicpc.net/problem/2792 O 중요! 다시 풀어보기 2805 나무자르기 https://www.acmicpc.net/problem/2805 2869 달팽이는 올라가고 싶다 https://www.acmicpc.net/problem/2869 3020 개똥벌레 https://www.acmicpc.net/problem/3020 10815 숫자카드 https://www.acmicpc.net/problem/10815 10816 숫자카드2 https://www.acmicpc.net/problem/10816 13397 구간 나누기2 https://www.acmicpc.net/problem/13397","text":"백준 이분탐색이분 탐색 문제 이름 링크 정리여부 비고 1920 수찾기 https://www.acmicpc.net/problem/1920 1939 중량제한 https://www.acmicpc.net/problem/13397 2110 공유기 설치 https://www.acmicpc.net/problem/2210 2343 기타레슨 https://www.acmicpc.net/problem/2343 O 겁나 많이 틀림 2792 보석상자 https://www.acmicpc.net/problem/2792 O 중요! 다시 풀어보기 2805 나무자르기 https://www.acmicpc.net/problem/2805 2869 달팽이는 올라가고 싶다 https://www.acmicpc.net/problem/2869 3020 개똥벌레 https://www.acmicpc.net/problem/3020 10815 숫자카드 https://www.acmicpc.net/problem/10815 10816 숫자카드2 https://www.acmicpc.net/problem/10816 13397 구간 나누기2 https://www.acmicpc.net/problem/13397","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - BFS","slug":"algorithm/category/baekjoon-bfs","date":"2021-03-25T16:57:16.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-bfs/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-bfs/","excerpt":"백준 BFSBFS기본 유형 문제 이름 틀린횟수 정리여부 비고 c++ java python 1260 DFS와 BFS 기초 O 1953 팀 배분 0 O 이분 그래프 2178 미로 탐색 최단 거리 O O O 전체 문제 문제 이름 틀린횟수 정리여부 비고 c++ java python 1012 유기농 배추 2 O 1194 달이 차오른다, 가자\u001c 1 O 1260 DFS와 BFS 기초 O O 1600 말이 되고픈 원숭이 5 O 1707 이분 그래프 4 O 1726 로봇 1 O 1939 중량제한 3 O 1953 팀 배분 0 O 이분 그래프 O 1963 소수 경로 0 O 1967 트리의 지름 2 O 2146 다리 만들기 5 O 2178 미로 탐색 최단 거리 O O O 2206 벽 부수고 이동하기 5 2251 물통 0 2234 성곽 0 2468 안전 영역 2 2573 빙산 3 2583 영역 구하기 1 2589 보물섬 0 2606 바이러스 0 2644 촌수 계산 0 2667 단지번호 붙이기 4 2933 미네랄 5 5014 스타트와 링크 1 5213 과외맨 6 5427 불 2 6087 레이저 통신 0 6593 상범 빌딩 1 7576 토마토 1 9019 DSLR 4 9205 맥주 마시면서 걸어가기 3 9372 상근이의 여행 1 12886 돌 그룹 1 15558 점프 게임 11 16236 아기 상어 4 O bfs를 통해 거리구하기 16397 탈출 5 16933 벽 부수고 이동하기3 6 16959 체스판 여행 1 0 17471 게리맨더링 4 O 조합, bfs, 삼성 17836 공주님을 구해라 5 18809 Gaaaaaaaaaarden 0 조합, bfs, 삼성","text":"백준 BFSBFS기본 유형 문제 이름 틀린횟수 정리여부 비고 c++ java python 1260 DFS와 BFS 기초 O 1953 팀 배분 0 O 이분 그래프 2178 미로 탐색 최단 거리 O O O 전체 문제 문제 이름 틀린횟수 정리여부 비고 c++ java python 1012 유기농 배추 2 O 1194 달이 차오른다, 가자\u001c 1 O 1260 DFS와 BFS 기초 O O 1600 말이 되고픈 원숭이 5 O 1707 이분 그래프 4 O 1726 로봇 1 O 1939 중량제한 3 O 1953 팀 배분 0 O 이분 그래프 O 1963 소수 경로 0 O 1967 트리의 지름 2 O 2146 다리 만들기 5 O 2178 미로 탐색 최단 거리 O O O 2206 벽 부수고 이동하기 5 2251 물통 0 2234 성곽 0 2468 안전 영역 2 2573 빙산 3 2583 영역 구하기 1 2589 보물섬 0 2606 바이러스 0 2644 촌수 계산 0 2667 단지번호 붙이기 4 2933 미네랄 5 5014 스타트와 링크 1 5213 과외맨 6 5427 불 2 6087 레이저 통신 0 6593 상범 빌딩 1 7576 토마토 1 9019 DSLR 4 9205 맥주 마시면서 걸어가기 3 9372 상근이의 여행 1 12886 돌 그룹 1 15558 점프 게임 11 16236 아기 상어 4 O bfs를 통해 거리구하기 16397 탈출 5 16933 벽 부수고 이동하기3 6 16959 체스판 여행 1 0 17471 게리맨더링 4 O 조합, bfs, 삼성 17836 공주님을 구해라 5 18809 Gaaaaaaaaaarden 0 조합, bfs, 삼성","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - DFS","slug":"algorithm/category/baekjoon-dfs","date":"2021-03-25T16:55:55.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-dfs/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-dfs/","excerpt":"백준 DFSDFS(깊이 우선 탐색) 문제 이름 틀린횟수 정리여부 비고 c++ java python 1260 DFS와 BFS 1325 효율적인 해킹 9466 텀 프로젝트 10026 적록색약 15649 N과 M(1) 15650 N과 M(2) 15651 N과 M(3) 15652 N과 M(4)","text":"백준 DFSDFS(깊이 우선 탐색) 문제 이름 틀린횟수 정리여부 비고 c++ java python 1260 DFS와 BFS 1325 효율적인 해킹 9466 텀 프로젝트 10026 적록색약 15649 N과 M(1) 15650 N과 M(2) 15651 N과 M(3) 15652 N과 M(4)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 문자열 처리","slug":"algorithm/category/baekjoon-string","date":"2021-03-25T16:52:49.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-string/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-string/","excerpt":"백준 문자열 처리문자열 처리 문제 이름 정리여부 비고 cpp java python 1032 명령 프롬프트 문자열 속 문자, 문자열 비교 O O O 1152 단어의 개수 문자열 분리, 문자열 토큰화 O O 1157 단어 공부 소문자 -&gt; 대문자 O O 1296 데이트 문자열 정렬 O O O 1316 그룹 단어 체커 문자열 속 문자 찾기 O O O 1475 방 번호 문자열 속 문자 O O 2064 IP 주소 토크나이징 O 2743 단어 길이 재기 문자열 길이 O O O 2857 FBI 문자열 속 단어 찾기 O O O 2902 KMP는 왜 KMP일까? 문자열 토큰화 O O O 2908 상수 문자열 뒤집기 O O 2941 크로아티아 문자 문자열 속 문자 찾기, 문자열 대치 O O O 5586 JOI와 IOI 문자열 분리substr O O O 10808 알파벳 갯수 10809 알파벳 찾기 문자 check하는 방법, dic 사용 방법 O 11654 아스키 코드 아스키 코드 변환 O","text":"백준 문자열 처리문자열 처리 문제 이름 정리여부 비고 cpp java python 1032 명령 프롬프트 문자열 속 문자, 문자열 비교 O O O 1152 단어의 개수 문자열 분리, 문자열 토큰화 O O 1157 단어 공부 소문자 -&gt; 대문자 O O 1296 데이트 문자열 정렬 O O O 1316 그룹 단어 체커 문자열 속 문자 찾기 O O O 1475 방 번호 문자열 속 문자 O O 2064 IP 주소 토크나이징 O 2743 단어 길이 재기 문자열 길이 O O O 2857 FBI 문자열 속 단어 찾기 O O O 2902 KMP는 왜 KMP일까? 문자열 토큰화 O O O 2908 상수 문자열 뒤집기 O O 2941 크로아티아 문자 문자열 속 문자 찾기, 문자열 대치 O O O 5586 JOI와 IOI 문자열 분리substr O O O 10808 알파벳 갯수 10809 알파벳 찾기 문자 check하는 방법, dic 사용 방법 O 11654 아스키 코드 아스키 코드 변환 O","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 삼성 기출문제","slug":"algorithm/category/baekjoon-samsung","date":"2021-03-25T16:50:28.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-samsung/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-samsung/","excerpt":"백준 삼성 기출문제삼성 기출 문제 문제 이름 링크 정리여부 비고 1012 유기농 배추 https://www.acmicpc.net/problem/1012 1600 말이 되고픈 원숭이 https://www.acmicpc.net/problem/1600 1707 이분 그래프 https://www.acmicpc.net/problem/1707 1726 로봇 https://www.acmicpc.net/problem/1726 1939 중량제한 https://www.acmicpc.net/problem/1939 1953 팀 배분 https://www.acmicpc.net/problem/1953 O 이분 그래프 1963 소수 경로 https://www.acmicpc.net/problem/1963 1967 트리의 지름 https://www.acmicpc.net/problem/1967 2146 다리 만들기 https://www.acmicpc.net/problem/2146 2206 벽 부수고 이동하기 https://www.acmicpc.net/problem/2206 2251 물통 https://www.acmicpc.net/problem/2251 2468 안전 영역 https://www.acmicpc.net/problem/2468 2573 빙산 https://www.acmicpc.net/problem/2573 2583 영역 구하기 https://www.acmicpc.net/problem/2583 2589 보물섬 https://www.acmicpc.net/problem/2589 2606 바이러스 https://www.acmicpc.net/problem/2606 2644 촌수 계산 https://www.acmicpc.net/problem/2644 2667 단지번호 붙이기 https://www.acmicpc.net/problem/2667 2933 미네랄 https://www.acmicpc.net/problem/2933 5014 스타트와 링크 https://www.acmicpc.net/problem/5014 5213 과외맨 https://www.acmicpc.net/problem/5213 5427 불 https://www.acmicpc.net/problem/5427 6087 레이저 통신 https://www.acmicpc.net/problem/6087 6593 상범 빌딩 https://www.acmicpc.net/problem/5427 7576 토마토 https://www.acmicpc.net/problem/7576 9019 DSLR https://www.acmicpc.net/problem/9019 9205 맥주 마시면서 걸어가기 https://www.acmicpc.net/problem/9205 9372 상근이의 여행 https://www.acmicpc.net/problem/9372 12886 돌 그룹 https://www.acmicpc.net/problem/12886 16236 아기 상어 https://www.acmicpc.net/problem/16236 O bfs를 통해 거리구하기 16397 탈출 https://www.acmicpc.net/problem/16397 17471 게리맨더링 https://www.acmicpc.net/problem/17471 O 조합, bfs 17836 공주님을 구해라 https://www.acmicpc.net/problem/17836 브루트 포스 문제 이름 링크 정리여부 비고 1051 숫자 직사각형 https://www.acmicpc.net/problem/1051 1065 한수 https://www.acmicpc.net/problem/1065 1182 부분수열의 합 https://www.acmicpc.net/problem/1182 1436 영화감독 슘 https://www.acmicpc.net/problem/1436 1748 수 이어쓰기1 https://www.acmicpc.net/problem/1748 2231 분해 합 https://www.acmicpc.net/problem/2231 2309 일곱 난쟁이 https://www.acmicpc.net/problem/2309 2798 블랙잭 https://www.acmicpc.net/problem/2798 3085 사탕 게임 https://www.acmicpc.net/problem/3085 7568 덩치 https://www.acmicpc.net/problem/7568 10448 유레카 이론 https://www.acmicpc.net/problem/10448 12100 2048(Easy) https://www.acmicpc.net/problem/12100 12738 가장 긴 증가하는 부분 수열3 https://www.acmicpc.net/problem/12738 13460 구슬 탈출2 https://www.acmicpc.net/problem/13460 O while문을 이용한 bfs 14502 연구소 https://www.acmicpc.net/problem/14502 14888 연산자 끼워넣기 https://www.acmicpc.net/problem/14888 14889 스타크와 링크 https://www.acmicpc.net/problem/14889 15653 구슬 탈출4 https://www.acmicpc.net/problem/15653 O while문을 이용한 bfs 15683 감시 https://www.acmicpc.net/problem/15683 15684 사다리 조작 https://www.acmicpc.net/problem/15684 15686 치킨 배달 https://www.acmicpc.net/problem/14686 16198 에너지 모으기 https://www.acmicpc.net/problem/16198 17127 벚꽃이 정보섬에 피어난 이유 https://www.acmicpc.net/problem/17127 17142 연구소 3 https://www.acmicpc.net/problem/17142 O 조합, 경우의 수 탐색bfs 17779 게리멘더링2 https://www.acmicpc.net/problem/17779 O 영역 나누어 탐색하기","text":"백준 삼성 기출문제삼성 기출 문제 문제 이름 링크 정리여부 비고 1012 유기농 배추 https://www.acmicpc.net/problem/1012 1600 말이 되고픈 원숭이 https://www.acmicpc.net/problem/1600 1707 이분 그래프 https://www.acmicpc.net/problem/1707 1726 로봇 https://www.acmicpc.net/problem/1726 1939 중량제한 https://www.acmicpc.net/problem/1939 1953 팀 배분 https://www.acmicpc.net/problem/1953 O 이분 그래프 1963 소수 경로 https://www.acmicpc.net/problem/1963 1967 트리의 지름 https://www.acmicpc.net/problem/1967 2146 다리 만들기 https://www.acmicpc.net/problem/2146 2206 벽 부수고 이동하기 https://www.acmicpc.net/problem/2206 2251 물통 https://www.acmicpc.net/problem/2251 2468 안전 영역 https://www.acmicpc.net/problem/2468 2573 빙산 https://www.acmicpc.net/problem/2573 2583 영역 구하기 https://www.acmicpc.net/problem/2583 2589 보물섬 https://www.acmicpc.net/problem/2589 2606 바이러스 https://www.acmicpc.net/problem/2606 2644 촌수 계산 https://www.acmicpc.net/problem/2644 2667 단지번호 붙이기 https://www.acmicpc.net/problem/2667 2933 미네랄 https://www.acmicpc.net/problem/2933 5014 스타트와 링크 https://www.acmicpc.net/problem/5014 5213 과외맨 https://www.acmicpc.net/problem/5213 5427 불 https://www.acmicpc.net/problem/5427 6087 레이저 통신 https://www.acmicpc.net/problem/6087 6593 상범 빌딩 https://www.acmicpc.net/problem/5427 7576 토마토 https://www.acmicpc.net/problem/7576 9019 DSLR https://www.acmicpc.net/problem/9019 9205 맥주 마시면서 걸어가기 https://www.acmicpc.net/problem/9205 9372 상근이의 여행 https://www.acmicpc.net/problem/9372 12886 돌 그룹 https://www.acmicpc.net/problem/12886 16236 아기 상어 https://www.acmicpc.net/problem/16236 O bfs를 통해 거리구하기 16397 탈출 https://www.acmicpc.net/problem/16397 17471 게리맨더링 https://www.acmicpc.net/problem/17471 O 조합, bfs 17836 공주님을 구해라 https://www.acmicpc.net/problem/17836 브루트 포스 문제 이름 링크 정리여부 비고 1051 숫자 직사각형 https://www.acmicpc.net/problem/1051 1065 한수 https://www.acmicpc.net/problem/1065 1182 부분수열의 합 https://www.acmicpc.net/problem/1182 1436 영화감독 슘 https://www.acmicpc.net/problem/1436 1748 수 이어쓰기1 https://www.acmicpc.net/problem/1748 2231 분해 합 https://www.acmicpc.net/problem/2231 2309 일곱 난쟁이 https://www.acmicpc.net/problem/2309 2798 블랙잭 https://www.acmicpc.net/problem/2798 3085 사탕 게임 https://www.acmicpc.net/problem/3085 7568 덩치 https://www.acmicpc.net/problem/7568 10448 유레카 이론 https://www.acmicpc.net/problem/10448 12100 2048(Easy) https://www.acmicpc.net/problem/12100 12738 가장 긴 증가하는 부분 수열3 https://www.acmicpc.net/problem/12738 13460 구슬 탈출2 https://www.acmicpc.net/problem/13460 O while문을 이용한 bfs 14502 연구소 https://www.acmicpc.net/problem/14502 14888 연산자 끼워넣기 https://www.acmicpc.net/problem/14888 14889 스타크와 링크 https://www.acmicpc.net/problem/14889 15653 구슬 탈출4 https://www.acmicpc.net/problem/15653 O while문을 이용한 bfs 15683 감시 https://www.acmicpc.net/problem/15683 15684 사다리 조작 https://www.acmicpc.net/problem/15684 15686 치킨 배달 https://www.acmicpc.net/problem/14686 16198 에너지 모으기 https://www.acmicpc.net/problem/16198 17127 벚꽃이 정보섬에 피어난 이유 https://www.acmicpc.net/problem/17127 17142 연구소 3 https://www.acmicpc.net/problem/17142 O 조합, 경우의 수 탐색bfs 17779 게리멘더링2 https://www.acmicpc.net/problem/17779 O 영역 나누어 탐색하기","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"백준 - 자료구조","slug":"algorithm/category/baekjoon-structure","date":"2021-03-25T16:43:37.000Z","updated":"2024-02-18T16:19:54.512Z","comments":true,"path":"2021/03/26/algorithm/category/baekjoon-structure/","link":"","permalink":"https://ckck803.github.io/2021/03/26/algorithm/category/baekjoon-structure/","excerpt":"백준 자료구조vector 문제 이름 틀린 횟수 정리여부 비고 1158 요세푸스 문제 1 스택 문제 이름 링크 정리여부 비고 1406 에디터 https://www.acmicpc.net/problem/1406 1918 후위표기식 https://www.acmicpc.net/problem/1918 3015 오아시스 재결합 https://www.acmicpc.net/problem/3015 O 다시 풀어보기 9012 괄호 https://www.acmicpc.net/problem/9012 10799 쇠막대기 https://www.acmicpc.net/problem/10799 Set 문제 이름 틀린 횟수 정리여부 비고 1181 단어 정렬 1539 이진 검색 트리 2210 숫자판 점프 7785 회사에 있는 사람 map 문제 이름 틀린 횟수 정리여부 비고 1302 1539 9375","text":"백준 자료구조vector 문제 이름 틀린 횟수 정리여부 비고 1158 요세푸스 문제 1 스택 문제 이름 링크 정리여부 비고 1406 에디터 https://www.acmicpc.net/problem/1406 1918 후위표기식 https://www.acmicpc.net/problem/1918 3015 오아시스 재결합 https://www.acmicpc.net/problem/3015 O 다시 풀어보기 9012 괄호 https://www.acmicpc.net/problem/9012 10799 쇠막대기 https://www.acmicpc.net/problem/10799 Set 문제 이름 틀린 횟수 정리여부 비고 1181 단어 정렬 1539 이진 검색 트리 2210 숫자판 점프 7785 회사에 있는 사람 map 문제 이름 틀린 횟수 정리여부 비고 1302 1539 9375 이진 검색 트리 문제 이름 틀린 횟수 정리여부 비고 5639 이진 검색 트리 1 트라이 문제 이름 틀린 횟수 정리여부 비고 5052 전화번호 목록 5670 휴대폰 자판 13505","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"1194-달이차오른다_가자","slug":"algorithm/baekjoon/BFS/1194-달이차오른다-가자","date":"2021-03-19T17:21:07.000Z","updated":"2024-02-18T16:19:54.509Z","comments":true,"path":"2021/03/20/algorithm/baekjoon/BFS/1194-달이차오른다-가자/","link":"","permalink":"https://ckck803.github.io/2021/03/20/algorithm/baekjoon/BFS/1194-%EB%8B%AC%EC%9D%B4%EC%B0%A8%EC%98%A4%EB%A5%B8%EB%8B%A4-%EA%B0%80%EC%9E%90/","excerpt":"백준 1194 - 달이 차오른다. 가자https://www.acmicpc.net/problem/1194 문제 해설기존 BFS문제를 푸는 형식에 비트마스킹까지 더해진 문제이다. 비트마스킹을 통해 키를 가지고 있는 각각의 상태들을 체크할 수 있다. 키는 총 6개가 주어지기 때문에 50x50x64 = 160,000 의 공간 복잡도를 갖게 돼 메모리 제한에 걸리지 않는다. 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;int N, M;char Map[55][55];bool check[1 &lt;&lt; 6][55][55];int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;queue&lt;pair&lt;int, int&gt;&gt; q;int startY, startX;struct point &#123; int y; int x; int key; int count;&#125;;int bfs() &#123; queue&lt;point&gt; q; q.push(&#123;startY, startX, 0, 0&#125;); check[0][startY][startX] = true; while (!q.empty()) &#123; int cntY = q.front().y; int cntX = q.front().x; int cntKey = q.front().key; int cntCount = q.front().count; q.pop(); if (Map[cntY][cntX] == &#x27;1&#x27;) &#123; return cntCount; &#125; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &gt;= ny || ny &gt; N || 0 &gt;= nx || nx &gt; M) &#123; continue; &#125; if (check[cntKey][ny][nx] == true) &#123; continue; &#125; if (Map[ny][nx] == &#x27;.&#x27;) &#123; check[cntKey][ny][nx] = true; q.push(&#123;ny, nx, cntKey, cntCount + 1&#125;); &#125; else &#123; // 열쇠에 마주쳤을 경우 if (&#x27;a&#x27; &lt;= Map[ny][nx] &amp;&amp; Map[ny][nx] &lt;= &#x27;f&#x27;) &#123; int key = (1 &lt;&lt; (Map[ny][nx] - &#x27;a&#x27;)); check[cntKey | key][ny][nx] = true; q.push(&#123;ny, nx, cntKey | key, cntCount + 1&#125;); &#125; // 문을 만났을 경우 if (&#x27;A&#x27; &lt;= Map[ny][nx] &amp;&amp; Map[ny][nx] &lt;= &#x27;F&#x27;) &#123; int door = (1 &lt;&lt; (Map[ny][nx] - &#x27;A&#x27;)); if (door &amp; cntKey) &#123; check[cntKey][ny][nx] = true; q.push(&#123;ny, nx, cntKey, cntCount + 1&#125;); &#125; &#125; // 출구를 만났을 경우 if (Map[ny][nx] == &#x27;1&#x27;) &#123; q.push(&#123;ny, nx, cntKey, cntCount + 1&#125;); &#125; &#125; &#125; &#125; return -1;&#125;void init() &#123; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) &#123; cin &gt;&gt; Map[i][j]; if (Map[i][j] == &#x27;0&#x27;) &#123; startY = i; startX = j; Map[i][j] = &#x27;.&#x27;; &#125; &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; N &gt;&gt; M; init(); cout &lt;&lt; bfs() &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","text":"백준 1194 - 달이 차오른다. 가자https://www.acmicpc.net/problem/1194 문제 해설기존 BFS문제를 푸는 형식에 비트마스킹까지 더해진 문제이다. 비트마스킹을 통해 키를 가지고 있는 각각의 상태들을 체크할 수 있다. 키는 총 6개가 주어지기 때문에 50x50x64 = 160,000 의 공간 복잡도를 갖게 돼 메모리 제한에 걸리지 않는다. 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;int N, M;char Map[55][55];bool check[1 &lt;&lt; 6][55][55];int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;queue&lt;pair&lt;int, int&gt;&gt; q;int startY, startX;struct point &#123; int y; int x; int key; int count;&#125;;int bfs() &#123; queue&lt;point&gt; q; q.push(&#123;startY, startX, 0, 0&#125;); check[0][startY][startX] = true; while (!q.empty()) &#123; int cntY = q.front().y; int cntX = q.front().x; int cntKey = q.front().key; int cntCount = q.front().count; q.pop(); if (Map[cntY][cntX] == &#x27;1&#x27;) &#123; return cntCount; &#125; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &gt;= ny || ny &gt; N || 0 &gt;= nx || nx &gt; M) &#123; continue; &#125; if (check[cntKey][ny][nx] == true) &#123; continue; &#125; if (Map[ny][nx] == &#x27;.&#x27;) &#123; check[cntKey][ny][nx] = true; q.push(&#123;ny, nx, cntKey, cntCount + 1&#125;); &#125; else &#123; // 열쇠에 마주쳤을 경우 if (&#x27;a&#x27; &lt;= Map[ny][nx] &amp;&amp; Map[ny][nx] &lt;= &#x27;f&#x27;) &#123; int key = (1 &lt;&lt; (Map[ny][nx] - &#x27;a&#x27;)); check[cntKey | key][ny][nx] = true; q.push(&#123;ny, nx, cntKey | key, cntCount + 1&#125;); &#125; // 문을 만났을 경우 if (&#x27;A&#x27; &lt;= Map[ny][nx] &amp;&amp; Map[ny][nx] &lt;= &#x27;F&#x27;) &#123; int door = (1 &lt;&lt; (Map[ny][nx] - &#x27;A&#x27;)); if (door &amp; cntKey) &#123; check[cntKey][ny][nx] = true; q.push(&#123;ny, nx, cntKey, cntCount + 1&#125;); &#125; &#125; // 출구를 만났을 경우 if (Map[ny][nx] == &#x27;1&#x27;) &#123; q.push(&#123;ny, nx, cntKey, cntCount + 1&#125;); &#125; &#125; &#125; &#125; return -1;&#125;void init() &#123; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) &#123; cin &gt;&gt; Map[i][j]; if (Map[i][j] == &#x27;0&#x27;) &#123; startY = i; startX = j; Map[i][j] = &#x27;.&#x27;; &#125; &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; N &gt;&gt; M; init(); cout &lt;&lt; bfs() &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"틀렸습니다 5","slug":"틀렸습니다-5","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-5/"}]},{"title":"Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper","slug":"spring/spring-security/security/configure/web-security-configurer","date":"2021-03-19T13:25:35.000Z","updated":"2024-02-26T16:26:56.989Z","comments":true,"path":"2021/03/19/spring/spring-security/security/configure/web-security-configurer/","link":"","permalink":"https://ckck803.github.io/2021/03/19/spring/spring-security/security/configure/web-security-configurer/","excerpt":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 Spring Security 설정하기 - WebSecurityConfigurerAdatper스프링 Scurity에 대한 설정은 WebSecurityConfigurer 인터페이스 구현하거나 WebSecurityConfigurerAdapter 클래스를 상속해 설정을 할 수 있다. 인증 방식 설정 configure(AuthenticationManagerBuilder auth) 인증 방식과 관련된 설정을 하기 위한 메소드 AuthenticationManagerBuilder는 인증객체(AuthenticationManager)를 생성하기 위한 클래스이다. In Memory authentication나 UserDetailsService를 사용하는 다양한 인증 방식을 손 쉽게 구축할 수 있도록 지원한다. configure(AuthenticationManagerBuilder auth) private final CustomUserDetailsService customUserDetailsService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserDetailsService);&#125;","text":"목차 Spring Security 권한 계층 사용하기 - @RoleHierarcy Spring Security - DelegateFilterProxy Spring Security - Remember Me와 관련된 인증 API - RememberMeConfigurer Spring Security - RembmerMeAuthenticationFilter Spring Security - SessionManagementFilter &amp; ConcurrentSessionFilter Spring Security - 인가 API ExpressionUrlAuthorizationConfigurer Spring Security - Security 설정을 위한 WebSecurityConfigurerAdatper Spring Security - AuthenticationProvider Spring Security - AuthenticationManager Spring Security - UsernamePasswordAuthenticationFilter &amp; AbstractAuthenticationProcessingFilter Spring Security - SecurityContextHolder 와 SecurityContext Spring Security - Authentication 객체 Spring Security 설정하기 - WebSecurityConfigurerAdatper스프링 Scurity에 대한 설정은 WebSecurityConfigurer 인터페이스 구현하거나 WebSecurityConfigurerAdapter 클래스를 상속해 설정을 할 수 있다. 인증 방식 설정 configure(AuthenticationManagerBuilder auth) 인증 방식과 관련된 설정을 하기 위한 메소드 AuthenticationManagerBuilder는 인증객체(AuthenticationManager)를 생성하기 위한 클래스이다. In Memory authentication나 UserDetailsService를 사용하는 다양한 인증 방식을 손 쉽게 구축할 수 있도록 지원한다. configure(AuthenticationManagerBuilder auth) private final CustomUserDetailsService customUserDetailsService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserDetailsService);&#125; 전역적인 Security 설정 configure(WebSecurity web) 전역적인 Security 설정을 하기 위해 사용하는 메소드 정적 파일에 대한 보안 예외처리와 같이 Security Filter Chain에 대한 예외처리를 할 때 사용한다. WebSecurity 클래스는 Spring Security에서 FilterChainProxy를 생성한다. configure(WebSecurity web) @Overridepublic void configure(WebSecurity web) throws Exception &#123; web .ignoring() .antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;) .antMatchers(&quot;/favicon.ico&quot;, &quot;/resources/**&quot;, &quot;/error&quot;);&#125; Resource별로 Security를 설정 configure(HttpSecurity http) Resource별로 Security를 설정하기 위한 메소드이다. HttpSecurity 클래스를 통해 인증, 인가와 관련된 Web 기반의 보안 설정을 할 수 있다. 인증 : Form Login, Http Basic, OAuth2 Login 등 인가 : Matchers, Role, Authenticate, permit 등 configure(HttpSecurity http) @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; // 인가 http .authorizeRequests() // 인가에 대한 설정을 한다. .antMatchers(&quot;/loginPage&quot;).permitAll() // /loginPage 접근시에는 인증이 필요하지 않다. .anyRequest().authenticated(); // 다른 모든 리소스에 접그하기 위해서는 인증이 필요하다 // 인증 http .formLogin() // Form Login 방식의 인증을 사용한다. .loginPage(&quot;/loginPage&quot;) // 로그인 페이지를 설정한다. .defaultSuccessUrl(&quot;/&quot;) // Login을 성공한 후 / 페이지로 이동하게 된다. .failureUrl(&quot;/loginPage&quot;) // 로그인 실패시 /loginPage로 이동하게 된다. .usernameParameter(&quot;username&quot;) // 요청 파라미터에서 username을 usernameParameter로 사용한다. .passwordParameter(&quot;password&quot;) // 요청 파라미터에서 password를 passwordParameter로 사용한다. .loginProcessingUrl(&quot;/login_proc&quot;) // 로그인을 진행하기 위한 URL // 로그인이 성공했을 때 처리하기 위한 Handler .successHandler(new AuthenticationSuccessHandler() &#123; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest , HttpServletResponse httpServletResponse , Authentication authentication) throws IOException, ServletException &#123; httpServletResponse.sendRedirect(&quot;/&quot;); &#125; &#125;) // 로그인이 실패했을 때 처리하기 위한 Handler .failureHandler(new AuthenticationFailureHandler() &#123; @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest , HttpServletResponse httpServletResponse , AuthenticationException e) throws IOException, ServletException &#123; httpServletResponse.sendRedirect(&quot;/loginPage&quot;); &#125; &#125;);&#125; 패스워드 암호화Spring Boot에서는 사용자의 Password는 암호화된 상태로 저장이 돼야 한다. 암호화가 안된 상태로 저장하게 되면 사용자 인증시에 오류가 발생하게 된다. 그래서 Password를 암호화된 상태로 저장할 수 있도록 PasswordEncoder 인터페이스를 제공한다. PasswordEncoder PasswordEncoder 인터페이스는 보통 패스워드를 단방향으로 변환한다. 즉 다시 원래대로 되돌릴 수 없다는 의미이다. 그래서 Hash 알고리즘을 사용한다. BcryptPasswordEncoder Argon2PasswordEncoder Pbkdf2PasswordEncoder SCryptPasswordEncoder @Beanpublic PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Security","slug":"Spring/Spring-Security/Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Security/"},{"name":"Config","slug":"Spring/Spring-Security/Security/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Security/Config/"}],"tags":[]},{"title":"백준 1406 - 후위표기식","slug":"algorithm/baekjoon/자료구조/STACK/1918-후위표기식","date":"2021-03-15T11:10:40.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2021/03/15/algorithm/baekjoon/자료구조/STACK/1918-후위표기식/","link":"","permalink":"https://ckck803.github.io/2021/03/15/algorithm/baekjoon/%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9/STACK/1918-%ED%9B%84%EC%9C%84%ED%91%9C%EA%B8%B0%EC%8B%9D/","excerpt":"https://www.acmicpc.net/problem/1918 문제 해설문제를 해결할 때 후위 표기식에 대한 명확한 이해와 연산자 우선순위에 대해 고려 해야 한다. 연산자를 별도의 stack에 쌓아가면서 후위 표기식을 만든다. stack에 연산자를 넣기 전에 연산자 비교를 통해 stack에 넣을 려는 연산자 우선순위 보다 stack에 있는 연산자의 우선순위가 작을 때까지 계속해서 stack에서 연산자를 꺼내 후위 표기식에 추가해준다. 연산자 우선순위 (가 제일 높은 우선순위다. * 와 /가 그 다음 우선순위 + 와 -가 다음 우선순위를 갖고 있다. )가 제일 낮은 우선순위다. (를 만날때까지 모든 연산자를 stack에서 꺼낸다. 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;string str;string result;int main(void) &#123; cin &gt;&gt; str; stack&lt;char&gt; operation; for (int i = 0; i &lt; str.length(); i++) &#123; char cntChar = str[i]; if (cntChar == &#x27;(&#x27;) &#123; operation.push(cntChar); &#125; else if (cntChar == &#x27;*&#x27; || cntChar == &#x27;/&#x27;) &#123; while (!operation.empty() &amp;&amp; (operation.top() == &#x27;*&#x27; || operation.top() == &#x27;/&#x27;)) &#123; result += operation.top(); operation.pop(); &#125; operation.push(cntChar); &#125; else if (cntChar == &#x27;+&#x27; || cntChar == &#x27;-&#x27;) &#123; while (!operation.empty() &amp;&amp; (operation.top() != &#x27;(&#x27;)) &#123; result += operation.top(); operation.pop(); &#125; operation.push(cntChar); &#125; else if (cntChar == &#x27;)&#x27;) &#123; while (!operation.empty() &amp;&amp; operation.top() != &#x27;(&#x27;) &#123; result += operation.top(); operation.pop(); &#125; operation.pop(); &#125; else &#123; result += cntChar; &#125; &#125; while (!operation.empty()) &#123; result += operation.top(); operation.pop(); &#125; cout &lt;&lt; result &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","text":"https://www.acmicpc.net/problem/1918 문제 해설문제를 해결할 때 후위 표기식에 대한 명확한 이해와 연산자 우선순위에 대해 고려 해야 한다. 연산자를 별도의 stack에 쌓아가면서 후위 표기식을 만든다. stack에 연산자를 넣기 전에 연산자 비교를 통해 stack에 넣을 려는 연산자 우선순위 보다 stack에 있는 연산자의 우선순위가 작을 때까지 계속해서 stack에서 연산자를 꺼내 후위 표기식에 추가해준다. 연산자 우선순위 (가 제일 높은 우선순위다. * 와 /가 그 다음 우선순위 + 와 -가 다음 우선순위를 갖고 있다. )가 제일 낮은 우선순위다. (를 만날때까지 모든 연산자를 stack에서 꺼낸다. 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;string str;string result;int main(void) &#123; cin &gt;&gt; str; stack&lt;char&gt; operation; for (int i = 0; i &lt; str.length(); i++) &#123; char cntChar = str[i]; if (cntChar == &#x27;(&#x27;) &#123; operation.push(cntChar); &#125; else if (cntChar == &#x27;*&#x27; || cntChar == &#x27;/&#x27;) &#123; while (!operation.empty() &amp;&amp; (operation.top() == &#x27;*&#x27; || operation.top() == &#x27;/&#x27;)) &#123; result += operation.top(); operation.pop(); &#125; operation.push(cntChar); &#125; else if (cntChar == &#x27;+&#x27; || cntChar == &#x27;-&#x27;) &#123; while (!operation.empty() &amp;&amp; (operation.top() != &#x27;(&#x27;)) &#123; result += operation.top(); operation.pop(); &#125; operation.push(cntChar); &#125; else if (cntChar == &#x27;)&#x27;) &#123; while (!operation.empty() &amp;&amp; operation.top() != &#x27;(&#x27;) &#123; result += operation.top(); operation.pop(); &#125; operation.pop(); &#125; else &#123; result += cntChar; &#125; &#125; while (!operation.empty()) &#123; result += operation.top(); operation.pop(); &#125; cout &lt;&lt; result &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"자료구조","slug":"Programming/Beakjoon/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"Programming/Beakjoon/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"}],"tags":[]},{"title":"프로그래머스 - 수식 최대화 (Cpp)","slug":"algorithm/programmers/자료구조/스택/67257-수식최대화-Cpp","date":"2021-03-15T11:10:40.000Z","updated":"2024-02-18T16:19:54.515Z","comments":true,"path":"2021/03/15/algorithm/programmers/자료구조/스택/67257-수식최대화-Cpp/","link":"","permalink":"https://ckck803.github.io/2021/03/15/algorithm/programmers/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/67257-%EC%88%98%EC%8B%9D%EC%B5%9C%EB%8C%80%ED%99%94-Cpp/","excerpt":"https://programmers.co.kr/learn/courses/30/lessons/67257 문제 해설경우의 수 문제이다. 모든 경우의 연산자 우선순위를 만들어 해당 연산자 우선순위를 이용해 연산을 진행하면 된다. 중위표기식으로 나타난 식을 후위 표기식으로 바꿔서 문제를 해결 했다. 경우의 수 만들기만들 수 있는 모든 연산자 우선순위를 만들어줘야 한다. DFS를 이용해 모든 경우의 수를 만들어 줬다. void makeAllCase(int depth) &#123; if (depth == 3) &#123; allCase.push_back(cntCase); &#125; for (int i = 0; i &lt; 3; i++) &#123; int cntOper = operation[i]; if (check[i] == false) &#123; check[i] = true; cntCase[depth] = cntOper; makeAllCase(depth + 1); check[i] = false; &#125; &#125;&#125; 연산자 우선순위를 가반으로 한 연산 가장 높은 우선순위의 연산자가 들어왔을 때 Stack을 확인해 같은 먼저 들어온 같은 우선순위의 연산자가 있는지 확인한다. 같은 우선순위의 연산자가 Stack에 있는 경우 pop 해서 해당 연산을 진행한 후 지금 들어온 연산자를 push한다. 없는 경우에는 Stack에 push 한다. 두번째 우선 순위가 연산자가 들어온 경우 Stack을 확인해 우선순위가 같거나 큰 연산자가 없어질 때까지 연산을 진행한 후 pop 한다. Stack에 우선순위가 같거나 큰 연산자가 없을 경우에는 Stack에 push 한다. 세번째 우선 순위의 연산자가 들어온 경우 Stack을 확인해 우선순위가 같거나 큰 연산자가 없어질 때까지 연산을 진행한 후 pop 한다. Stack에 우선순위가 같거나 큰 연산자가 없을 경우에는 Stack에 push 한다.","text":"https://programmers.co.kr/learn/courses/30/lessons/67257 문제 해설경우의 수 문제이다. 모든 경우의 연산자 우선순위를 만들어 해당 연산자 우선순위를 이용해 연산을 진행하면 된다. 중위표기식으로 나타난 식을 후위 표기식으로 바꿔서 문제를 해결 했다. 경우의 수 만들기만들 수 있는 모든 연산자 우선순위를 만들어줘야 한다. DFS를 이용해 모든 경우의 수를 만들어 줬다. void makeAllCase(int depth) &#123; if (depth == 3) &#123; allCase.push_back(cntCase); &#125; for (int i = 0; i &lt; 3; i++) &#123; int cntOper = operation[i]; if (check[i] == false) &#123; check[i] = true; cntCase[depth] = cntOper; makeAllCase(depth + 1); check[i] = false; &#125; &#125;&#125; 연산자 우선순위를 가반으로 한 연산 가장 높은 우선순위의 연산자가 들어왔을 때 Stack을 확인해 같은 먼저 들어온 같은 우선순위의 연산자가 있는지 확인한다. 같은 우선순위의 연산자가 Stack에 있는 경우 pop 해서 해당 연산을 진행한 후 지금 들어온 연산자를 push한다. 없는 경우에는 Stack에 push 한다. 두번째 우선 순위가 연산자가 들어온 경우 Stack을 확인해 우선순위가 같거나 큰 연산자가 없어질 때까지 연산을 진행한 후 pop 한다. Stack에 우선순위가 같거나 큰 연산자가 없을 경우에는 Stack에 push 한다. 세번째 우선 순위의 연산자가 들어온 경우 Stack을 확인해 우선순위가 같거나 큰 연산자가 없어질 때까지 연산을 진행한 후 pop 한다. Stack에 우선순위가 같거나 큰 연산자가 없을 경우에는 Stack에 push 한다. // 첫번째 우선순위의 연산자가 들어온 경우if (cntChar == cnt_priority[0]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty() &amp;&amp; operation.top() == cnt_priority[0]) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar);&#125;// 두번째 우선순위의 연산자가 들어온 경우if (cntChar == cnt_priority[1]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty() &amp;&amp; operation.top() != cnt_priority[2]) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar);&#125;// 세번째 우선순위의 연산자가 들어온 경우if (cntChar == cnt_priority[2]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty()) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar);&#125; Stack을 이용한 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;char operation[3] = &#123;&#x27;*&#x27;, &#x27;+&#x27;, &#x27;-&#x27;&#125;;bool check[3];vector&lt;char&gt; cntCase(3);vector&lt;vector&lt;char&gt;&gt; allCase;void makeAllCase(int depth) &#123; if (depth == 3) &#123; allCase.push_back(cntCase); &#125; for (int i = 0; i &lt; 3; i++) &#123; int cntOper = operation[i]; if (check[i] == false) &#123; check[i] = true; cntCase[depth] = cntOper; makeAllCase(depth + 1); check[i] = false; &#125; &#125;&#125;long long calValue1Value2(long long value1, long long value2, char oper) &#123; long long result = 0; if (oper == &#x27;*&#x27;) &#123; result = value2 * value1; &#125; else if (oper == &#x27;+&#x27;) &#123; result = value2 + value1; &#125; else &#123; result = value2 - value1; &#125; return result;&#125;long long solveExpression(string expression) &#123; long long maxValue = 0; for (vector&lt;char&gt; cnt_priority : allCase) &#123; stack&lt;long long&gt; opernand; stack&lt;char&gt; operation; string value = &quot;&quot;; for (int i = 0; i &lt; expression.size(); i++) &#123; char cntChar = expression[i]; if (&#x27;0&#x27; &lt;= cntChar &amp;&amp; cntChar &lt;= &#x27;9&#x27;) &#123; value += cntChar; &#125; if (cntChar == cnt_priority[0]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty() &amp;&amp; operation.top() == cnt_priority[0]) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar); &#125; if (cntChar == cnt_priority[1]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty() &amp;&amp; operation.top() != cnt_priority[2]) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar); &#125; if (cntChar == cnt_priority[2]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty()) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar); &#125; &#125; opernand.push(stol(value)); while (!operation.empty()) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(abs(result)); &#125; if (maxValue &lt; opernand.top()) &#123; maxValue = opernand.top(); &#125; &#125; return maxValue;&#125;long long solution(string expression) &#123; long long answer = 0; makeAllCase(0); answer = solveExpression(expression); return answer;&#125; dq를 이용한 문제 해결#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char operation[3] = &#123;&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;&#125;;bool check[3];vector&lt;char&gt; op(3);vector&lt;vector&lt;char&gt;&gt; operations;deque&lt;long long&gt; dq_opernand;deque&lt;char&gt; dq_operator;ll max_value = 0;void nPr(int depth) &#123; if (3 == depth) &#123; vector&lt;char&gt; v(op); operations.push_back(op); return; &#125; for (int i = 0; i &lt; 3; i++) &#123; if (check[i] == true) continue; op[depth] = operation[i]; check[i] = true; nPr(depth + 1); check[i] = false; &#125;&#125;void divideOperaion(string expression) &#123; string s; for (int i = 0; i &lt; expression.size(); i++) &#123; if (&#x27;0&#x27; &lt;= expression[i] &amp;&amp; expression[i] &lt;= &#x27;9&#x27;) &#123; s += expression[i]; &#125; else &#123; dq_opernand.push_back(stol(s)); dq_operator.push_back(expression[i]); s = &quot;&quot;; &#125; &#125; dq_opernand.push_back(stol(s));&#125;long long operValue(ll a, ll b, char op) &#123; if (op == &#x27;+&#x27;) &#123; return a + b; &#125; else if (op == &#x27;-&#x27;) &#123; return a - b; &#125; else &#123; return a * b; &#125;&#125;void operate(string expression) &#123; deque&lt;ll&gt; temp_opernand; deque&lt;char&gt; temp_operator; for (auto o : operations) &#123; deque&lt;ll&gt; copy_opernand(dq_opernand); deque&lt;char&gt; copy_operator(dq_operator); for (int i = 0; i &lt; 3; i++) &#123; char cnt_operation = o[i]; while (!copy_operator.empty()) &#123; if (copy_operator.front() == cnt_operation) &#123; ll value1 = copy_opernand.front(); copy_opernand.pop_front(); ll value2 = copy_opernand.front(); copy_opernand.pop_front(); char oper = copy_operator.front(); copy_operator.pop_front(); ll result = operValue(value1, value2, oper); copy_opernand.push_front(result); &#125; else &#123; temp_opernand.push_back(copy_opernand.front()); temp_operator.push_back(copy_operator.front()); copy_opernand.pop_front(); copy_operator.pop_front(); &#125; &#125; while (!copy_opernand.empty()) &#123; temp_opernand.push_back(copy_opernand.front()); copy_opernand.pop_front(); &#125; while (!temp_operator.empty()) &#123; copy_operator.push_back(temp_operator.front()); temp_operator.pop_front(); &#125; while (!temp_opernand.empty()) &#123; copy_opernand.push_back(temp_opernand.front()); temp_opernand.pop_front(); &#125; &#125; max_value = max(max_value, abs(copy_opernand.front())); &#125;&#125;long long solution(string expression) &#123; long long answer; nPr(0); divideOperaion(expression); operate(expression); answer = max_value; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"자료구조","slug":"Programming/프로그래머스/자료구조","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"Programming/프로그래머스/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://ckck803.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"Cpp","slug":"Cpp","permalink":"https://ckck803.github.io/tags/Cpp/"}]},{"title":"백준 1406 - 에디터","slug":"algorithm/baekjoon/자료구조/STACK/1406-에디터","date":"2021-03-15T06:23:54.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2021/03/15/algorithm/baekjoon/자료구조/STACK/1406-에디터/","link":"","permalink":"https://ckck803.github.io/2021/03/15/algorithm/baekjoon/%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9/STACK/1406-%EC%97%90%EB%94%94%ED%84%B0/","excerpt":"https://www.acmicpc.net/problem/1406 문제 해설Stack을 이용한 문제 풀이기본적인 자료구조를 사용해 문제를 해결하는 문제이다. 두개의 스택을 이용해서 커서를 기점으로 커서 왼쪽에 있는 것들은 left 스택에 커서 오른쪽에 있는 단어들은 right 스택에 넣어서 관리를 한다. import java.io.IOException;import java.util.Scanner;import java.util.Stack;public class Main &#123; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(System.in); String str = sc.nextLine(); Stack&lt;Character&gt; left = new Stack&lt;&gt;(); Stack&lt;Character&gt; right = new Stack&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; left.push(str.charAt(i)); &#125; int numOfCmd = sc.nextInt(); for (int i = 0; i &lt; numOfCmd; i++) &#123; String cmd = sc.next(); if (cmd.equals(&quot;L&quot;)) &#123; if (!left.isEmpty()) &#123; right.push(left.peek()); left.pop(); &#125; &#125; else if (cmd.equals(&quot;D&quot;)) &#123; if (!right.isEmpty()) &#123; left.push(right.peek()); right.pop(); &#125; &#125; else if (cmd.equals(&quot;B&quot;)) &#123; if (!left.isEmpty()) &#123; left.pop(); &#125; &#125; else if (cmd.equals(&quot;P&quot;)) &#123; char value = sc.next().charAt(0); left.push(value); &#125; &#125; while (!left.isEmpty()) &#123; right.push(left.peek()); left.pop(); &#125; StringBuilder stringBuilder = new StringBuilder(); while (!right.isEmpty()) &#123; stringBuilder.append(right.peek()); right.pop(); &#125; System.out.println(stringBuilder.toString()); &#125;&#125; LinkedList와 ListIterator를 이용한 문제 풀이해당 문제는 LinkedList를 이용해서도 문제를 해결할 수 있다. LinkedList의 원소에 List로 접근을 하게 되면 O(n) 의 시간이 걸려 시간 초과가 뜨게 된다. 때문에 다행이 문제는 Cursor위치를 한칸씩 밖에 못 움직이므로 ListIterator 라는 객체를 이용해 LinkedList를 관리하도록 한다. public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter wr = new BufferedWriter(new OutputStreamWriter(System.out)); String[] str = br.readLine().split(&quot;&quot;); List&lt;Character&gt; charList = new LinkedList&lt;&gt;(); ListIterator&lt;Character&gt; iter = charList.listIterator(); for (int i = 0; i &lt; str.length; i++) &#123; iter.add(str[i].charAt(0)); &#125; int index = charList.size(); int numOfCmd = Integer.parseInt(br.readLine()); for (int i = 0; i &lt; numOfCmd; i++) &#123; char[] inputs = br.readLine().toCharArray(); if (inputs[0] == &#x27;L&#x27;) &#123; if (iter.hasPrevious()) &#123; iter.previous(); &#125; &#125; else if (inputs[0] == &#x27;D&#x27;) &#123; if (iter.hasNext()) &#123; iter.next(); &#125; &#125; else if (inputs[0] == &#x27;B&#x27;) &#123; if (iter.hasPrevious()) &#123; iter.previous(); iter.remove(); &#125; &#125; else if (inputs[0] == &#x27;P&#x27;) &#123; char value = inputs[2]; iter.add(value); &#125; &#125; for (char c : charList) &#123; wr.write(c); &#125; wr.flush(); &#125;&#125;","text":"https://www.acmicpc.net/problem/1406 문제 해설Stack을 이용한 문제 풀이기본적인 자료구조를 사용해 문제를 해결하는 문제이다. 두개의 스택을 이용해서 커서를 기점으로 커서 왼쪽에 있는 것들은 left 스택에 커서 오른쪽에 있는 단어들은 right 스택에 넣어서 관리를 한다. import java.io.IOException;import java.util.Scanner;import java.util.Stack;public class Main &#123; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(System.in); String str = sc.nextLine(); Stack&lt;Character&gt; left = new Stack&lt;&gt;(); Stack&lt;Character&gt; right = new Stack&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; left.push(str.charAt(i)); &#125; int numOfCmd = sc.nextInt(); for (int i = 0; i &lt; numOfCmd; i++) &#123; String cmd = sc.next(); if (cmd.equals(&quot;L&quot;)) &#123; if (!left.isEmpty()) &#123; right.push(left.peek()); left.pop(); &#125; &#125; else if (cmd.equals(&quot;D&quot;)) &#123; if (!right.isEmpty()) &#123; left.push(right.peek()); right.pop(); &#125; &#125; else if (cmd.equals(&quot;B&quot;)) &#123; if (!left.isEmpty()) &#123; left.pop(); &#125; &#125; else if (cmd.equals(&quot;P&quot;)) &#123; char value = sc.next().charAt(0); left.push(value); &#125; &#125; while (!left.isEmpty()) &#123; right.push(left.peek()); left.pop(); &#125; StringBuilder stringBuilder = new StringBuilder(); while (!right.isEmpty()) &#123; stringBuilder.append(right.peek()); right.pop(); &#125; System.out.println(stringBuilder.toString()); &#125;&#125; LinkedList와 ListIterator를 이용한 문제 풀이해당 문제는 LinkedList를 이용해서도 문제를 해결할 수 있다. LinkedList의 원소에 List로 접근을 하게 되면 O(n) 의 시간이 걸려 시간 초과가 뜨게 된다. 때문에 다행이 문제는 Cursor위치를 한칸씩 밖에 못 움직이므로 ListIterator 라는 객체를 이용해 LinkedList를 관리하도록 한다. public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter wr = new BufferedWriter(new OutputStreamWriter(System.out)); String[] str = br.readLine().split(&quot;&quot;); List&lt;Character&gt; charList = new LinkedList&lt;&gt;(); ListIterator&lt;Character&gt; iter = charList.listIterator(); for (int i = 0; i &lt; str.length; i++) &#123; iter.add(str[i].charAt(0)); &#125; int index = charList.size(); int numOfCmd = Integer.parseInt(br.readLine()); for (int i = 0; i &lt; numOfCmd; i++) &#123; char[] inputs = br.readLine().toCharArray(); if (inputs[0] == &#x27;L&#x27;) &#123; if (iter.hasPrevious()) &#123; iter.previous(); &#125; &#125; else if (inputs[0] == &#x27;D&#x27;) &#123; if (iter.hasNext()) &#123; iter.next(); &#125; &#125; else if (inputs[0] == &#x27;B&#x27;) &#123; if (iter.hasPrevious()) &#123; iter.previous(); iter.remove(); &#125; &#125; else if (inputs[0] == &#x27;P&#x27;) &#123; char value = inputs[2]; iter.add(value); &#125; &#125; for (char c : charList) &#123; wr.write(c); &#125; wr.flush(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"자료구조","slug":"Programming/Beakjoon/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"Programming/Beakjoon/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"}],"tags":[]},{"title":"Spring-JWT(JSON Web Token) - 4. JWT 다루기","slug":"spring/spring-security/jwt/spring-jwt-04","date":"2021-03-14T17:20:47.000Z","updated":"2024-02-26T16:22:12.462Z","comments":true,"path":"2021/03/15/spring/spring-security/jwt/spring-jwt-04/","link":"","permalink":"https://ckck803.github.io/2021/03/15/spring/spring-security/jwt/spring-jwt-04/","excerpt":"4. JWT 다루기목차 Spring-JWT(JSON Web Token) - 4. JWT 다루기 Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기 Spring-JWT(JSON Web Token) - 2. 회원가입 Spring-JWT(JSON Web Token) - 1. JWT 알아보기 JWT를 다루기 위한 Util Class만들기 JwtUtil 객체는 Jwts.builder를 이용해 JWT를 생성하고 Jwts.parserBuilder를 이용해 Token을 JWT로 변환시켜 데이터를 가져오도록 한다. Jwts.builder(JwtBuilder) setHeader JWT의 Header 에 대한 설정을 위한 메소드 setSubject, setExpiration, setIssuer, setAudience, setNotBefore, setIssuedAt Registed Payload는 각각에 해당하는 set 메소드들이 제공된다. setClaims JWT의 Claim 데이터 를 추가하기 위한 메소드 signWith Header와 Payload를 갖고 Secret Key 로 서명한다. 암호화 알고리즘으로는 보통 HMAC or RSA 알고리즘을 사용한다. Jwts.parserBuilder(JwtParser) setSigningKey 데이터 위변조 확인을 위해 secretKey를 이용해 JWS에 대한 유효성 검증을 한다. secretKey를 이용한 검증 실패시 해당 JWT는 사용하지 못한다. parseClaimsJws token을 JWS로 파싱해준다.","text":"4. JWT 다루기목차 Spring-JWT(JSON Web Token) - 4. JWT 다루기 Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기 Spring-JWT(JSON Web Token) - 2. 회원가입 Spring-JWT(JSON Web Token) - 1. JWT 알아보기 JWT를 다루기 위한 Util Class만들기 JwtUtil 객체는 Jwts.builder를 이용해 JWT를 생성하고 Jwts.parserBuilder를 이용해 Token을 JWT로 변환시켜 데이터를 가져오도록 한다. Jwts.builder(JwtBuilder) setHeader JWT의 Header 에 대한 설정을 위한 메소드 setSubject, setExpiration, setIssuer, setAudience, setNotBefore, setIssuedAt Registed Payload는 각각에 해당하는 set 메소드들이 제공된다. setClaims JWT의 Claim 데이터 를 추가하기 위한 메소드 signWith Header와 Payload를 갖고 Secret Key 로 서명한다. 암호화 알고리즘으로는 보통 HMAC or RSA 알고리즘을 사용한다. Jwts.parserBuilder(JwtParser) setSigningKey 데이터 위변조 확인을 위해 secretKey를 이용해 JWS에 대한 유효성 검증을 한다. secretKey를 이용한 검증 실패시 해당 JWT는 사용하지 못한다. parseClaimsJws token을 JWS로 파싱해준다. JwtUtil.java @Componentpublic class JwtUtil &#123; private final String secretKey = &quot;ThisIsA_SecretKeyForJwtExample&quot;; public String generateToken(String username) &#123; String JSONWebToken = Jwts.builder() .setHeader(createHeader()) .setClaims(createClaims(username)) .setExpiration(createExpireDateForOneYear()) .signWith(SignatureAlgorithm.HS256, secretKey) .compact(); return JSONWebToken; &#125; private Map&lt;String, Object&gt; createHeader() &#123; Map&lt;String, Object&gt; header = new HashMap&lt;&gt;(); header.put(&quot;typ&quot;, &quot;JWT&quot;); header.put(&quot;alg&quot;, &quot;HS256&quot;); header.put(&quot;regDate&quot;, System.currentTimeMillis()); return header; &#125; private Map&lt;String, Object&gt; createClaims(String username) &#123; Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(&quot;username&quot;, username); &#125; private Date createExpireDateForOneYear() &#123; // 토큰 만료시간은 30일으로 설정 Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DATE, 30); return calendar.getTime(); &#125; private Claims getAllClaims(String token) &#123; return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(token) .getBody(); &#125; public String getUsername(String token) &#123; Claims claims = getAllClaims(token); String username = claims.get(&quot;username&quot;, String.class); return username; &#125; public Date getExpiration(String token) &#123; Claims claims = getAllClaims(token); return claims.getExpiration(); &#125; public Boolean validateToken(String token, UserDetails userDetails) &#123; final String username = getUsername(token); return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token)); &#125; private Boolean isTokenExpired(String token) &#123; return getExpiration(token).before(new Date()); &#125;&#125; JWT를 이용한 인증을 위해 새로운 Filter정의하기OncePerRequestFilter를 상속 받아 JWT로 인증을 진행하는 JwtAuthenticationFilter를 생성한다.JwtAuthenticationFilter에서는 요청이 들어왔을 때 Token이 있는지 확인하고 해당 Token을 이용해 인증을 진행한 후 AuthenticationToken을 생성해 SecurityContextHolder에 저장한다. UsernamePasswordAuthenticationToken 사용자의 Username과 Password를 이용하여 AuthenticationToken을 생성한다. JwtAuthenticationFilter.java @Componentpublic class JwtAuthenticationFilter extends OncePerRequestFilter &#123; private final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class); @Autowired private JwtUtil jwtUtil; @Autowired private CustomUserDetailsService service; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; // Http 요청이 들어왔을 때 header를 검사해 Authorization 값을 가져온다. String authorizationHeader = request.getHeader(&quot;Authorization&quot;); String token = null; String username = null; // 인증 토큰을 받았을 경우 // Bearer 토큰인지 확인한다. if (authorizationHeader != null &amp;&amp; authorizationHeader.startsWith(&quot;Bearer &quot;)) &#123; token = authorizationHeader.substring(7); username = jwtUtil.extractUsername(token); &#125; // Bearer 토큰으로부터 추출한 username을 이용해 // 해당 유저가 등록된 유저인지 검증한다. if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123; UserDetails userDetails = service.loadUserByUsername(username); if (jwtUtil.validateToken(token, userDetails)) &#123; UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities()); usernamePasswordAuthenticationToken .setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken); &#125; &#125; filterChain.doFilter(request, response); &#125;&#125; 로그인을 위한 Controller 추가Username과 Password를 이용해 /api/user/login 경로로 인증을 시도하면 AuthenticationManager 객체를 이용해 인증을 진행하고 인증이 성공적으로 완료 되면 JWT를 생성해 Header에 JWT를 넣어 Status code : 200과 함께 반환한다. JwtController.java ....private final AuthenticationManager authenticationManager;private final JwtUtil jwtUtil;@PostMapping(&quot;/login&quot;)public ResponseEntity login(@RequestBody AuthRequest authRequest) throws Exception &#123; String username = authRequest.getUsername(); String password = authRequest.getPassword(); try &#123; // AuthnRequest로부터 받은 username과 password를 이용하여 UsernamePasswordAuthenticationToken을 생성한 후 // 생성된 토큰을 이용해 인증을 시도한다. authenticationManager.authenticate( new UsernamePasswordAuthenticationToken(username, password)); &#125; catch (Exception ex) &#123; throw new Exception(&quot;inavalid username/password&quot;); &#125; String token = jwtUtil.generateToken(authRequest.getUsername()); HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.add(&quot;Authorization&quot;, &quot;Bearer &quot; +token); // 인증이 정상적으로 이루어진 경우 username을 이용해 JWT를 생성해 반환한다. return new ResponseEntity(httpHeaders, HttpStatus.OK);&#125; 권한을 갖고 접근하기 위한 Controller 추가 반환받은 JWT를 갖고 /api/user/access 경로로 접근하면 Permission to Access 문구가 반환된다. JwtController.java @GetMapping(&quot;/access&quot;)public String accessByToken()&#123; return &quot;Permission to Access&quot;;&#125; Security 설정 추가하기AuthenticationManagerBuilder객체의 userDetailsService 메소드를 이용해 사용자가 정의한 CustomUserDetailsService 객체를 사용하도록 등록한다. SecurityConfig.java @Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; // 사용자가 정의한 UserDetailsService를 사용한다. auth.userDetailsService(customUserDetailsService);&#125; 회원가입을 위한 /api/user/signup 경로와 로그인을 위한 /api/user/login 경로는 인증전에 접근하기 위한 경로이므로 권한 없이 접근 가능해야 한다. 그외 모든 경로는 인증된 사용자만 접근 할 수 있도록 설정한다. 사용자 정의 Filter인 JwtAuthenticationFilter를 Spring Filter에 추가한다. SecurityConfig.java @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable().authorizeRequests() .antMatchers(&quot;/api/user/login&quot;).permitAll() .antMatchers(&quot;/api/user/signup&quot;).permitAll() .anyRequest().authenticated() .and() // 토큰을 활용하면 세션이 필요 없으므로 STATELESS로 설정하여 Session을 사용하지 않는다. .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() // form 기반의 로그인에 대해 비활성화 한다. .formLogin().disable() // 새롭게 정의한 Filter를 등록한다. .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"JWT","slug":"Spring/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/JWT/"}],"tags":[]},{"title":"Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기","slug":"spring/spring-security/jwt/spring-jwt-03","date":"2021-03-14T15:49:30.000Z","updated":"2024-02-26T16:22:04.002Z","comments":true,"path":"2021/03/15/spring/spring-security/jwt/spring-jwt-03/","link":"","permalink":"https://ckck803.github.io/2021/03/15/spring/spring-security/jwt/spring-jwt-03/","excerpt":"3. 로그인목차 Spring-JWT(JSON Web Token) - 4. JWT 다루기 Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기 Spring-JWT(JSON Web Token) - 2. 회원가입 Spring-JWT(JSON Web Token) - 1. JWT 알아보기 의존성 추가Spring Boot에 Security를 적용하기 위해 Spring Security 의존성과 JWT를 사용하기위해 jjwt 의존성을 추가해주도록 한다. build.gradle dependencies &#123; .... implementation &#x27;org.thymeleaf.extras:thymeleaf-extras-springsecurity5&#x27; // https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt implementation group: &#x27;io.jsonwebtoken&#x27;, name: &#x27;jjwt&#x27;, version: &#x27;0.9.1&#x27; ....&#125; Security 설정하기Spring Security는 인증에 필요한 사용자 정보를 저장할 때 비밀번호는 PasswordEncoder 객체를 이용해 암호화된 Password로 저장돼야 한다. 현재 프로젝트에서는 PasswordEncoder를 구현한 BcryptPasswordEncoder 객체를 이용해 암호화를 할 것이다.","text":"3. 로그인목차 Spring-JWT(JSON Web Token) - 4. JWT 다루기 Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기 Spring-JWT(JSON Web Token) - 2. 회원가입 Spring-JWT(JSON Web Token) - 1. JWT 알아보기 의존성 추가Spring Boot에 Security를 적용하기 위해 Spring Security 의존성과 JWT를 사용하기위해 jjwt 의존성을 추가해주도록 한다. build.gradle dependencies &#123; .... implementation &#x27;org.thymeleaf.extras:thymeleaf-extras-springsecurity5&#x27; // https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt implementation group: &#x27;io.jsonwebtoken&#x27;, name: &#x27;jjwt&#x27;, version: &#x27;0.9.1&#x27; ....&#125; Security 설정하기Spring Security는 인증에 필요한 사용자 정보를 저장할 때 비밀번호는 PasswordEncoder 객체를 이용해 암호화된 Password로 저장돼야 한다. 현재 프로젝트에서는 PasswordEncoder를 구현한 BcryptPasswordEncoder 객체를 이용해 암호화를 할 것이다. 정적자원에 대한 접근은 Spring Filter를 거치지 않도록 설정을 추가한다. SecurityConfig.java @EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/static/&quot; , &quot;classpath:/public/&quot; , &quot;classpath:/&quot; , &quot;classpath:/resources/&quot; , &quot;classpath:/META-INF/resources/&quot; , &quot;classpath:/META-INF/resources/webjars/&quot; &#125;; @Override public void configure(WebSecurity web) &#123; web.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations()); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable().authorizeRequests() .antMatchers(&quot;/api/user/signup&quot;).permitAll() .anyRequest().authenticated() .and() // 토큰을 활용하면 세션이 필요 없으므로 STATELESS로 설정하여 Session을 사용하지 않는다. .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() // form 기반의 로그인에 대해 비활성화 한다. .formLogin().disable(); &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 회원 가입 Service에 암호화 적용하기PasswordEncoder 객체를 이용해 암호화된 Password를 갖는 Account 객체를 생성하도록 변경한다. AccountService.java @Service@RequiredArgsConstructorpublic class AccountService &#123; private final AccountRepository accountRepository; private final PasswordEncoder passwordEncoder; public Account saveAccount(SignUpRequest signUpRequest) &#123; Account newAccount = Account.builder() .username(signUpRequest.getUsername()) .password(passwordEncoder.encode(signUpRequest.getPassword())) .role(Role.USER) .build(); return accountRepository.save(newAccount); &#125;&#125; username을 이용한 Account 객체 조회 조건 추가하기 AccountRepository.java @Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, String&gt; &#123; Optional&lt;Account&gt; findByUsername(String username);&#125; 인증에 필요한 User 객체 생성하기CustomUserDetailsService는 저장된 Account객체를 가져와 UserDetails객체로 변환해주는 역할을 한다. CustomUserDetailsService.java @Service@RequiredArgsConstructorpublic class CustomUserDetailsService implements UserDetailsService &#123; private final AccountRepository accountRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; Account account = accountRepository .findByUsername(username) .orElseThrow(() -&gt; new UsernameNotFoundException(username + &quot;사용자 없음&quot;)); return new User(account.getUsername(), account.getPassword(), AuthorityUtils.createAuthorityList(account.getRole().getValue())); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"JWT","slug":"Spring/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/JWT/"}],"tags":[]},{"title":"Spring-JWT(JSON Web Token) - 2. 회원가입","slug":"spring/spring-security/jwt/spring-jwt-02","date":"2021-03-14T13:11:14.000Z","updated":"2024-02-26T16:21:59.236Z","comments":true,"path":"2021/03/14/spring/spring-security/jwt/spring-jwt-02/","link":"","permalink":"https://ckck803.github.io/2021/03/14/spring/spring-security/jwt/spring-jwt-02/","excerpt":"2. 회원가입목차 Spring-JWT(JSON Web Token) - 4. JWT 다루기 Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기 Spring-JWT(JSON Web Token) - 2. 회원가입 Spring-JWT(JSON Web Token) - 1. JWT 알아보기 의존성 관계build.gradle dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-security&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; compileOnly &#x27;org.projectlombok:lombok&#x27; developmentOnly &#x27;org.springframework.boot:spring-boot-devtools&#x27; runtimeOnly &#x27;com.h2database:h2&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27; testImplementation &#x27;org.springframework.security:spring-security-test&#x27;&#125; 회원가입을 위한 DTO 만들기SignUpRequest.java @Data@AllArgsConstructor@NoArgsConstructorpublic class SignUpRequest &#123; private String username; private String password;&#125;","text":"2. 회원가입목차 Spring-JWT(JSON Web Token) - 4. JWT 다루기 Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기 Spring-JWT(JSON Web Token) - 2. 회원가입 Spring-JWT(JSON Web Token) - 1. JWT 알아보기 의존성 관계build.gradle dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-security&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; compileOnly &#x27;org.projectlombok:lombok&#x27; developmentOnly &#x27;org.springframework.boot:spring-boot-devtools&#x27; runtimeOnly &#x27;com.h2database:h2&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27; testImplementation &#x27;org.springframework.security:spring-security-test&#x27;&#125; 회원가입을 위한 DTO 만들기SignUpRequest.java @Data@AllArgsConstructor@NoArgsConstructorpublic class SignUpRequest &#123; private String username; private String password;&#125; 회원 정보를 저장하기 위한 Entity 생성Account.java @Data@NoArgsConstructor@AllArgsConstructor@Entity@Builderpublic class Account &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @Column(unique = true) private String username; private String password; private Role role;&#125; Account를 저장하기 위한 Repository 생성@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, String&gt; &#123;&#125; 회원 가입 요청을 처리하기 위한 Service 생성@Service@RequiredArgsConstructorpublic class AccountService &#123; private final AccountRepository accountRepository; public Account saveAccount(SignUpRequest signUpRequest) &#123; Account newAccount = Account.builder() .username(signUpRequest.getUsername()) .password(signUpRequest.getPassword()) .role(Role.USER) .build(); return accountRepository.save(newAccount); &#125;&#125; Controller회원가입에 필요한 Username과 Password를 갖고 /api/user/signup에 Post 요청을 보내면 회원가입이 정상적으로 이루어진 경우 Status Code : 200이 반환되게 된다. JwtController.java @RestController@RequestMapping(&quot;/api/user&quot;)@RequiredArgsConstructorpublic class UserController &#123; private final AccountService accountService; @PostMapping(&quot;/signup&quot;) public ResponseEntity signup(@RequestBody SignUpRequest signUpRequest)&#123; accountService.saveAccount(signUpRequest); return ResponseEntity.ok().build(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"JWT","slug":"Spring/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/JWT/"}],"tags":[]},{"title":"메모리 관리","slug":"computer-science/os/memory-management","date":"2021-03-07T15:16:13.000Z","updated":"2024-02-18T16:19:54.520Z","comments":true,"path":"2021/03/08/computer-science/os/memory-management/","link":"","permalink":"https://ckck803.github.io/2021/03/08/computer-science/os/memory-management/","excerpt":"메모리 관리 기본적인 메모리 관리 swapping 가상 메모리 Page replacement 알고리즘 세그멘테이션 프로그래머들이 가장 바라는 메모리는 바로 크고 빠르고 비 휘발성인것을 원한다. Memory Manager(메모리 관리자) 메모리 계층을 관리하는 운영체제의 일부분 사용하고 있는 메모리와 사용하고있지 않는 메모리를 계속해서 추적한다. 메모리를 프로세스에 할당하고 해제한다. 프로세스의 용량이 커서 메모리에 용량이 작을 경우 메모리와 디스크를 swapping한다. 기본적인 메모리 관리 기법paging이나 swapping이 없는 단일 프로그램메모리보다 더 큰 Program의 등장프로그램이 점점 커지다 보니 우리가 사용하는 메인 메모리보다 큰 프로그램이 생겨나게 됐다.이를 해결하기 위한 방법으로 overlay와 virtual memory 방법이 나왔다.","text":"메모리 관리 기본적인 메모리 관리 swapping 가상 메모리 Page replacement 알고리즘 세그멘테이션 프로그래머들이 가장 바라는 메모리는 바로 크고 빠르고 비 휘발성인것을 원한다. Memory Manager(메모리 관리자) 메모리 계층을 관리하는 운영체제의 일부분 사용하고 있는 메모리와 사용하고있지 않는 메모리를 계속해서 추적한다. 메모리를 프로세스에 할당하고 해제한다. 프로세스의 용량이 커서 메모리에 용량이 작을 경우 메모리와 디스크를 swapping한다. 기본적인 메모리 관리 기법paging이나 swapping이 없는 단일 프로그램메모리보다 더 큰 Program의 등장프로그램이 점점 커지다 보니 우리가 사용하는 메인 메모리보다 큰 프로그램이 생겨나게 됐다.이를 해결하기 위한 방법으로 overlay와 virtual memory 방법이 나왔다. overlay와 virtual memory의 기본 아이디어는 하나의 프로그램을 여러가지 조각으로 나누어 실행한다는 공통점이 있다. 하지만, overlay의 경우에는 프로그래머가 직접 프로그램들을 나누어야 하고 virtual memory의 경우에는 컴퓨터가 대신해준다는 차이점이 있다. Virtual MemoryVirtual Memory는 paging기법과 segmentation 기법을 이용한다. paging : 고정분할 segmentation : 가변분할","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Process","slug":"CS/Process","permalink":"https://ckck803.github.io/categories/CS/Process/"}],"tags":[]},{"title":"네트워크 - TCP","slug":"computer-science/network/TCP","date":"2021-03-07T14:21:17.000Z","updated":"2024-02-18T16:19:54.518Z","comments":true,"path":"2021/03/07/computer-science/network/TCP/","link":"","permalink":"https://ckck803.github.io/2021/03/07/computer-science/network/TCP/","excerpt":"TCP(Transmission Control Protocol) TCP 서비스 연결 지향의 신뢰성이 있는 바이트 스트림 서비스를 제공한다. 양방향 통신을 지원한다.(Full-Duplex Communication) 흐름제어와 에러제어, 그리고 혼잡제어를 제공한다.(신뢰성 있는 전송) 신뢰성 있는 전송이란? 데이터가 손실, 중복되지 않고 순서가 어긋나지 않는 전송방식 바이트 스트림 서비스란? 데이터 송 수신시 버퍼 기능을 이용해 Byte 단위로 처리","text":"TCP(Transmission Control Protocol) TCP 서비스 연결 지향의 신뢰성이 있는 바이트 스트림 서비스를 제공한다. 양방향 통신을 지원한다.(Full-Duplex Communication) 흐름제어와 에러제어, 그리고 혼잡제어를 제공한다.(신뢰성 있는 전송) 신뢰성 있는 전송이란? 데이터가 손실, 중복되지 않고 순서가 어긋나지 않는 전송방식 바이트 스트림 서비스란? 데이터 송 수신시 버퍼 기능을 이용해 Byte 단위로 처리 TCP는 데이터 송&#x2F;수신시 버퍼를 이용하기 때문에 흐름제어를 할 수 있다. Connection Oriented Protocal(연결 지향 프로토콜)연결지향 프로토콜은 다음과 같은 3가지 단계를 거치게 된다. 연결 데이터 전송 연결 종료 3-way handskaing 클라이언트가 서버로 SYN 패킷을 보낸다. 그리고 클라이언트는 SYN&#x2F;ACK응답을 기다리는 SYN_SENT상태가 된다. 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK와 SYN flog가 설정된 패킷을 발송하고 클라이언트가 ACK로 응답하기를 기다린다. 서버는 SYN_RECEIVED 상태가 된다. 클라이언트는 서버로 ACK를 보내게 되면 서버와 클라이언트가 연결이 이루어진다. 서버 상태는 ESTABLISHED가 된다. SYN(클라이언트) -&gt; SYN&#x2F;ACK(서버) -&gt; ACK(클라이언트)SYN_SENT(클라이언트) -&gt; SYN_RECEIVED(서버) -&gt; ESTABLISED(서버) 4-way handshaking 클라이언트가 연결을 종료하겠다는 FIN 패킷을 전송한다. FIN 패킷을 받은 서버는 클라이언트에서 서버로 데이터를 전송하는 연결을 끊는다. 서버에서 클라이언트로 데이터를 전송하는 연결은 아직 살아있다.(Half-closed) 서버에서 클라이언트로의 통신이 끝나게 되면 서버에서 FIN 패킷을 전송한다. FIN 패킷을 받은 클라이언트는 마지막으로 ACK패킷을 보내게 되면 연결이 끊기게 된다. TCP에 사용되는 flag(control field) ACK(Acknowledgment) : 확인을 위한 flag SYN(Synchronize sequence numbers) : TCP를 이용해 연결을 만들 때 사용하는 flag FIN(Terminate the connection) : TCP 연결을 끊을 때 사용한다. URG(Urgent) : urgent data가 존재함을 알려준다. urgent data는 다른 데이터를 무시하고 바로 process로 보내진다. RST(Reset the connection) : 비정상적으로 connection을 끊을 때 사용한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"}],"tags":[]},{"title":"클라우드 서비스","slug":"computer-science/network/cloud","date":"2021-03-07T14:16:32.000Z","updated":"2024-02-18T16:19:54.518Z","comments":true,"path":"2021/03/07/computer-science/network/cloud/","link":"","permalink":"https://ckck803.github.io/2021/03/07/computer-science/network/cloud/","excerpt":"클라우드 서비스 종류IaaS(Infrastructure as a Service)인프라를 제공하는 방식 - 컴퓨터를 대여해주는 거라고 생각하면 이해하기 쉽다. 아마존의 AWS, MS의 Azure, 구글의 GCP Platform as a Service플랫폼을 제공하는 방식 - IaaS 서비스에 Runtime환경까지 설정이 이미 되어 있기 때문에 Software as a Service특정 소프트웨어를 제공하는 방식 - 드랍박스, 구글 Docs, 오피스365 장점 컴퓨팅 환경을 빠르게 구축할 수 있다는 장점이 있다. 사용한 만큼만 돈을 지불하면 된다. 특정기간 트래픽이 폭주하는 경우에 자원의 리소스 추가와 삭제가 기존의 on-premise방식에 비해 용이하다. 서버를 관리하기 위한 물리적 공간과 인적 자원에 대해 신경쓸 필요가 없어진다.","text":"클라우드 서비스 종류IaaS(Infrastructure as a Service)인프라를 제공하는 방식 - 컴퓨터를 대여해주는 거라고 생각하면 이해하기 쉽다. 아마존의 AWS, MS의 Azure, 구글의 GCP Platform as a Service플랫폼을 제공하는 방식 - IaaS 서비스에 Runtime환경까지 설정이 이미 되어 있기 때문에 Software as a Service특정 소프트웨어를 제공하는 방식 - 드랍박스, 구글 Docs, 오피스365 장점 컴퓨팅 환경을 빠르게 구축할 수 있다는 장점이 있다. 사용한 만큼만 돈을 지불하면 된다. 특정기간 트래픽이 폭주하는 경우에 자원의 리소스 추가와 삭제가 기존의 on-premise방식에 비해 용이하다. 서버를 관리하기 위한 물리적 공간과 인적 자원에 대해 신경쓸 필요가 없어진다. 단점 트래픽처리에 따른 초과비용 위험 보안 이슈 - 자사의 프라이빗 서버에 저장하는것이 다른 외부인이 볼 수 있다는 단점이 있다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"}],"tags":[]},{"title":"Spring Boot Logging 설정","slug":"spring/logging/logging","date":"2021-03-06T12:59:57.000Z","updated":"2024-11-22T09:01:55.487Z","comments":true,"path":"2021/03/06/spring/logging/logging/","link":"","permalink":"https://ckck803.github.io/2021/03/06/spring/logging/logging/","excerpt":"로그 레벨 ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE 스프링에서 제공하는 로깅 레벨은 총 5가지 입니다. 로깅 레벨은 ERROR 가 제일 높고 TRACE 가 가장 낮습니다. 로킹 레벨 설정시 현재 레벨이상의 로그 정보를 합께 보여줍니다. 따라서 로그 레벨은 TRACE로 갈 수록 표현되는 Log의 양이 많아지고 ERROR로 갈 수록 표현되는 Log의 양이 적어집니다. Configure 파일 문법Logback Configure파일을 구성하는 3가지 태그가 있다. appender 로그의 출력 위치, 출력 형식및 로깅에 대한 설정(ex. 기간, 용량 등)을 지정한다 root 전역적인 로그 설정을 위해 사용한다. appender를 사용해 appender에 정의된 형식과 위치로 로그를 출력 여러개의 appender를 사용할 수 있다. logger root와는 반대로 class나 Package단위로 Logging 정책을 설정할 수 있다. 로그 메시지를 작성하기 위해 사용하는 클래스를 명시하고 appender를 사용해 appender에 정의된 형식과 위치로 로그를 출력한다. 여러개의 appender를 사용할 수 있다. appender 클래스의 종류","text":"로그 레벨 ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE 스프링에서 제공하는 로깅 레벨은 총 5가지 입니다. 로깅 레벨은 ERROR 가 제일 높고 TRACE 가 가장 낮습니다. 로킹 레벨 설정시 현재 레벨이상의 로그 정보를 합께 보여줍니다. 따라서 로그 레벨은 TRACE로 갈 수록 표현되는 Log의 양이 많아지고 ERROR로 갈 수록 표현되는 Log의 양이 적어집니다. Configure 파일 문법Logback Configure파일을 구성하는 3가지 태그가 있다. appender 로그의 출력 위치, 출력 형식및 로깅에 대한 설정(ex. 기간, 용량 등)을 지정한다 root 전역적인 로그 설정을 위해 사용한다. appender를 사용해 appender에 정의된 형식과 위치로 로그를 출력 여러개의 appender를 사용할 수 있다. logger root와는 반대로 class나 Package단위로 Logging 정책을 설정할 수 있다. 로그 메시지를 작성하기 위해 사용하는 클래스를 명시하고 appender를 사용해 appender에 정의된 형식과 위치로 로그를 출력한다. 여러개의 appender를 사용할 수 있다. appender 클래스의 종류 ch.qos.logback.core.ConsoleAppender 콘솔에 로그를 찍음 ch.qos.logback.core.FileAppender 파일에 로그를 찍음 ch.qos.logback.core.rolling.RollingFileAppender 여러개의 파일을 순회하면서 로그를 찍음 ch.qos.logback.classic.net.SMTPAppender 로그를 메일에 찍어 보냄 ch.qos.logback.classic.db.DBAppender 데이터베이스에 로그를 찍음 의존성 추가하기쿼리 로그를 저장하기 위해서는 log4jdbc 의존성을 추가해줄 필요가 있다. build.gradle implementation group: &#x27;com.integralblue&#x27;, name: &#x27;log4jdbc-spring-boot-starter&#x27;, version: &#x27;2.0.0&#x27; 설정 추가하기 jdbc.sqlonly SQL문만을 로그로 남긴다. jdbc.sqltiming SQL문과 해당 SQL을 수행한 시간을 로그로 남긴다. jdbc.audit ResultSet을 제외한 모든 JDBC 호출 정보를 로그로 남긴다. 많은 양의 로그를 생성하므로 JDBC 문제를 추적해야 할 필요를 죄외하고는 사용하지 않는다. jdbc.resultset ResultSet을 포함한 모든 JDBC 호출 정보를 로그로 남긴다. 많은 양의 로그를 생성하므로 JDBC 문제를 추적해야 할 필요를 죄외하고는 사용하지 않는다. jdbc.resultsettable SQL문을 수행한 후 조회된 table을 로그로 남긴다. logback-spring.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;property name=&quot;LOGS_PATH&quot; value=&quot;./logs&quot;/&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name=&quot;jdbc.sqlonly&quot; level=&quot;INFO&quot;/&gt; &lt;root level=&quot;off&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;&gt;&lt;/appender-ref&gt; &lt;/root&gt;&lt;/configuration&gt; DataBase 접속 설정 추가하기DataBase 접속 URL과 Driver를 변경해줄 필요가 있다. URL에서는 jdbc하고 접속하고 싶은 DB사이에 log4jdbc를 추가해주면 된다. Driver는 log4jdbc에서 제공해주는 Driver를 사용하면 된다. url: jdbc:log4jdbc:h2:mem:testdb driver-class-name: net.sf.log4jdbc.sql.jdbcapi.DriverSpy appplication.yml datasource: # url: jdbc:h2:mem:testdb url: jdbc:log4jdbc:h2:mem:testdb driver-class-name: net.sf.log4jdbc.sql.jdbcapi.DriverSpy username: sa password: Console에 SQL문이 찍히는 것을 확인할 수 있다. 이상하게 Memory DB를 사용하는 경우 SQL문이 중복으로 찍힌다. MySQL 접속 설정 변경하기H2 DataBase했던 것과 마찬가지로 Driver와 URL을 변경해준다. application-mysql.yml spring: datasource: driver-class-name: net.sf.log4jdbc.sql.jdbcapi.DriverSpy# driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:log4jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;characterEncoding=UTF-8# url: jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: [DataBase ID] password: [DataBase Password] Create시 engine&#x3D;InnoDB가 나타난 것을 보아 MySQL을 이용한 SQL문이 제대로 생성됨을 알 수 있다. 파일에 Log 출력하기파일에 로그를 남기기 위해 appender 클래스로 ch.qos.logback.core.FileAppender를 사용할 것이다. 로그파일을 관리하는 정책 세우기rollingPolicy 태그를 이용해 로그파일을 관리하는 정책을 세울 수 있다. rollingPolicy ch.qos.logback.core.rolling.RollingFileAppender 일자별로 로그파일을 관리한다. 일자가 바뀌면 fileNamePattern에 따라 별도의 로그파일이 생성된다. timeBasedFileNamingAndTriggeringPolicy 일자 외에도 파일의 용량에 따라 별도의 로그파일이 생성된다. maxFileSize보다 로그 파일의 크기가 커지면 별도의 로그파일이 생성된다. logback-spring.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;property name=&quot;LOGS_PATH&quot; value=&quot;./logs&quot;/&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;LOGS_PATH&#125;/logback.log&lt;/file&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125;- %-5level - %msg%n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;LOGS_PATH&#125;/$&#123;LOG_PREFIX&#125;.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt;&lt;!-- &lt;logger name=&quot;jdbc.sqlonly&quot; level=&quot;INFO&quot;/&gt;--&gt; &lt;logger name=&quot;jdbc.sqlonly&quot; level=&quot;INFO&quot;/&gt; &lt;root level=&quot;off&quot;&gt; &lt;appender-ref ref=&quot;FILE&quot;&gt;&lt;/appender-ref&gt; &lt;/root&gt;&lt;/configuration&gt; logs라는 폴더가 생성되고 여기에 logback.log라는 파일이 생성되 로그가 찍히는 것을 확인할 수 있다. logback.log http://logback.qos.ch/manual/index.html","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Logging","slug":"Spring/Logging","permalink":"https://ckck803.github.io/categories/Spring/Logging/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 22 - Github Action 사용하기","slug":"spring/sample-board/board-22-github-action","date":"2021-03-06T05:12:05.000Z","updated":"2024-02-26T15:50:08.187Z","comments":true,"path":"2021/03/06/spring/sample-board/board-22-github-action/","link":"","permalink":"https://ckck803.github.io/2021/03/06/spring/sample-board/board-22-github-action/","excerpt":"22. Github Action 사용하기이전에 Jenkins를 이용해 CI 환경을 구성했다. Jenkins를 이용한 CI 환경의 가장 큰 단점은 Github로부터 Web Hook을 받을 수 있게 Port를 열어둬야 한다는 것이다. ngrok을 이용하더라도 계속해서 Port를 열어둘 수는 없는 노릇이라서 Github에서 제공하는 CI 도구인 Github Action을 이용하기로 했다. Github Action Workflow Template 선택하기Github에서 프로젝트를 선택하면 상단에 Action을 선택하면 본인의 환경에 맞는 Build 환경을 위한 Template를 선택할 수 있다. Gradle을 이용해 Spring Boot 프로젝트를 진행하고 있으므로 Gradle을 선택하도록 한다. Template 수정하기Gradle을 선택하게 되면 기본적으로 Gradle을 이용한 Build Plan Template가 주어진다. 기본적인 Template에서는 JDK 버전이 1.8인데 프로젝트는 JDK 11을 이용해 진행하고 있으므로 변경해줄 필요가 있다. 그 외에 운영체제나 원하는 Build Branch들을 선택할 수 있다.","text":"22. Github Action 사용하기이전에 Jenkins를 이용해 CI 환경을 구성했다. Jenkins를 이용한 CI 환경의 가장 큰 단점은 Github로부터 Web Hook을 받을 수 있게 Port를 열어둬야 한다는 것이다. ngrok을 이용하더라도 계속해서 Port를 열어둘 수는 없는 노릇이라서 Github에서 제공하는 CI 도구인 Github Action을 이용하기로 했다. Github Action Workflow Template 선택하기Github에서 프로젝트를 선택하면 상단에 Action을 선택하면 본인의 환경에 맞는 Build 환경을 위한 Template를 선택할 수 있다. Gradle을 이용해 Spring Boot 프로젝트를 진행하고 있으므로 Gradle을 선택하도록 한다. Template 수정하기Gradle을 선택하게 되면 기본적으로 Gradle을 이용한 Build Plan Template가 주어진다. 기본적인 Template에서는 JDK 버전이 1.8인데 프로젝트는 JDK 11을 이용해 진행하고 있으므로 변경해줄 필요가 있다. 그 외에 운영체제나 원하는 Build Branch들을 선택할 수 있다. on-push-branch Push를 했을 때 Build를 진행할 Branch를 선택한다. 현재는 master에서 Push가 일어났을 때만 Build를 진행한다. on-pull_request-branch Pull Request를 진행했을 때 Build를 진행할 Branch를 선택한다. 현재는 master로 Pull Requst를 진행할 때만 Build를 진행한다. jobs-build-runs-on Build를 진행할 환경(운영체제)를 선택한다. jobs-build-steps Build를 진행할 단계를 정의한다. jobs-build-steps-name Build 단계 이름을 명시한다. jobs-build-steps-uses Build 단계에서 사용할 것들을 나타낸다. actions&#x2F;checkout@v2 : 현재 Repository의 Project를 확인한다. actions&#x2F;setup-java@v1 : 사용할 자바 버전을 명시한다. with를 사용해 사용 버전까지 명시 jobs-build-steps-run 명령어들을 수핸한다. chmod +x .&#x2F;gradlew : gradlew에 대한 실행 권한을 부여한다. .&#x2F;gradlew clean build : gradlew를 이용해서 Build를 진행한다. Github Action을 통한 Build 진행하기Template 작성을 완료한 후 우측 상단의 commit을 누르게 되면 Build가 진행되게 된다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"복수의 테이블 다루기","slug":"database/sql/union-join","date":"2021-03-06T01:02:35.000Z","updated":"2024-02-18T16:19:54.524Z","comments":true,"path":"2021/03/06/database/sql/union-join/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/sql/union-join/","excerpt":"07장 복수의 테이블 다루기UNION으로 합집합 구하기UNION으로 합집합 구하기SELECT * FROM sample71_a;+------+| a |+------+| 1 || 2 || 3 |+------+3 rows in set (0.00 sec) SELECT * FROM sample71_b;+------+| b |+------+| 2 || 10 || 11 |+------+3 rows in set (0.00 sec) 두개의 SELECT 명령을 UNION해서 합집합 구하기SELECT * FROM sample71_aUNIONSELECT * FROM sample71_b; 결과 +------+| a |+------+| 1 || 2 || 3 || 10 || 11 |+------+5 rows in set (0.00 sec)","text":"07장 복수의 테이블 다루기UNION으로 합집합 구하기UNION으로 합집합 구하기SELECT * FROM sample71_a;+------+| a |+------+| 1 || 2 || 3 |+------+3 rows in set (0.00 sec) SELECT * FROM sample71_b;+------+| b |+------+| 2 || 10 || 11 |+------+3 rows in set (0.00 sec) 두개의 SELECT 명령을 UNION해서 합집합 구하기SELECT * FROM sample71_aUNIONSELECT * FROM sample71_b; 결과 +------+| a |+------+| 1 || 2 || 3 || 10 || 11 |+------+5 rows in set (0.00 sec) UNION 연산을 하기 위해서는 SELECT 명령의 열의 내용이 서로 일치해야 한다. UNION을 사용할 경우 각 SECECT명령에 ORDER BY를 지정해 정렬할 수는 없다. 마지막 SELECT 명령에만 지정하도록 한다. 두개의 SELECT 명령에 UNION ALL을 적용해 합집합 구하기SELECT * FROM sample71_aUNION ALLSELECT * FROM sample71_b; 결과 +------+| a |+------+| 1 || 2 || 3 || 2 || 10 || 11 |+------+6 rows in set (0.00 sec) 테이블 결합교차 결합FROM 구로 곱집합 구하기 FROM구에 테이블 두개를 지정해 곱집합 구하기 SELECT * FROM sample72_x, sample72_y; 결과 +------+------+| x | y |+------+------+| A | 1 || B | 1 || C | 1 || A | 2 || B | 2 || C | 2 || A | 3 || B | 3 || C | 3 |+------+------+9 rows in set (0.00 sec) 내부 결합상품 테이블과 재고수 테이블을 교차결합하기SELECT * FROM 상품, 재고수; 결과 +--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+| 상품코드 | 상품명 | 메이커명 | 가격 | 상품분류 | 상품코드 | 입고일 | 재고수 |+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+| 0001 | 상품1 | 메이커1 | 100 | 식료품 | 0001 | 2014-01-03 | 200 || 0002 | 상품2 | 메이커2 | 200 | 식료품 | 0001 | 2014-01-03 | 200 || 0003 | 상품3 | 메이커3 | 1980 | 생활용품 | 0001 | 2014-01-03 | 200 || 0001 | 상품1 | 메이커1 | 100 | 식료품 | 0002 | 2014-02-10 | 500 || 0002 | 상품2 | 메이커2 | 200 | 식료품 | 0002 | 2014-02-10 | 500 || 0003 | 상품3 | 메이커3 | 1980 | 생활용품 | 0002 | 2014-02-10 | 500 || 0001 | 상품1 | 메이커1 | 100 | 식료품 | 0003 | 2014-02-14 | 10 || 0002 | 상품2 | 메이커2 | 200 | 식료품 | 0003 | 2014-02-14 | 10 || 0003 | 상품3 | 메이커3 | 1980 | 생활용품 | 0003 | 2014-02-14 | 10 |+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+9 rows in set (0.00 sec) 상품코드가 같은 행을 검색하기SELECT* FROM 상품, 재고수 WHERE 상품. 상품코드 = 재고수.상품코드; 결과 +--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+| 상품코드 | 상품명 | 메이커명 | 가격 | 상품분류 | 상품코드 | 입고일 | 재고수 |+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+| 0001 | 상품1 | 메이커1 | 100 | 식료품 | 0001 | 2014-01-03 | 200 || 0002 | 상품2 | 메이커2 | 200 | 식료품 | 0002 | 2014-02-10 | 500 || 0003 | 상품3 | 메이커3 | 1980 | 생활용품 | 0003 | 2014-02-14 | 10 |+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+ 검색할 행과 반환할 열 제한하기SELECT 상품.상품명, 재고수.재고수 FROM 상품, 재고수WHERE 상품.상품코드 = 재고수.상품코드AND 상품.상품분류 = &#x27;식료품&#x27;; 결과 +-----------+-----------+| 상품명 | 재고수 |+-----------+-----------+| 상품1 | 200 || 상품2 | 500 |+-----------+-----------+2 rows in set (0.00 sec) 내부결합을 활용한 데이터 관리상품 테이블과 메이커 테이블을 내부 결합하기SELECT S.상품명, M.메이커명FROM 상품2 S INNER JOIN 메이커 MON S.메이커코드 = M.메이커코드; 결과 +-----------+--------------+| 상품명 | 메이커명 |+-----------+--------------+| 상품1 | 메이커1 || 상품2 | 메이커1 || 상품3 | 메이커2 |+-----------+--------------+3 rows in set (0.01 sec) 상품 테이블을 자기결합 하기SELECT S1.상품명, S2.상품명FROM 상품 S1 INNER JOIN 상품 S2ON S1.상품코드 = S2.상품코드; 결과 +-----------+-----------+| 상품명 | 상품명 |+-----------+-----------+| 상품1 | 상품1 || 상품2 | 상품2 || 상품3 | 상품3 |+-----------+-----------+3 rows in set (0.00 sec) 내부결합에서는 상품코드가 0009인 상품이 제외된다.SELECT 상품3.상품명, 재고수.재고수FROM 상품3 INNER JOIN 재고수ON 상품3.상품코드 = 재고수.상품코드WHERE 상품3.상품분류=&#x27;식료품&#x27;; 결과 +-----------+-----------+| 상품명 | 재고수 |+-----------+-----------+| 상품1 | 200 || 상품2 | 500 |+-----------+-----------+2 rows in set (0.01 sec) 외부결합으로 상품코드 0009인 상품도 결과에 포함하기SELECT 상품3.상품명, 재고수.재고수FROM 상품3 LEFT JOIN 재고수ON 상품3.상품코드 = 재고수.상품코드WHERE 상품3.상품분류 = &#x27;식료품&#x27;; 결과 +--------------+-----------+| 상품명 | 재고수 |+--------------+-----------+| 상품1 | 200 || 상품2 | 500 || 추가상품 | NULL |+--------------+-----------+3 rows in set (0.00 sec)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"데이터베이스 객체 작성과 삭제","slug":"database/sql/delete","date":"2021-03-06T01:01:46.000Z","updated":"2024-02-18T16:19:54.523Z","comments":true,"path":"2021/03/06/database/sql/delete/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/sql/delete/","excerpt":"6장 데이터베이스 객체 작성과 삭제26장 테이블 작성, 삭제, 변경CREATE TABLE로 테이블 작성하기CREATE TABLE sample62( no INTEGER NOT NULL, a VARCHAR(30), b DATE);) 결과 mysql&gt; DESC sample62;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 데이터 행 삭제 TRUNCATE TABLE [테이블명] ALTER TABLE로 테이블에 열 추가하기","text":"6장 데이터베이스 객체 작성과 삭제26장 테이블 작성, 삭제, 변경CREATE TABLE로 테이블 작성하기CREATE TABLE sample62( no INTEGER NOT NULL, a VARCHAR(30), b DATE);) 결과 mysql&gt; DESC sample62;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 데이터 행 삭제 TRUNCATE TABLE [테이블명] ALTER TABLE로 테이블에 열 추가하기 명령어 ALTER TABLE sample62 ADD newcol INTEGER; 결과 DESC sample62;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | || newcol | int | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) ALTER TABLE ADD로 테이블에 열을 추가할 수 있다. ALTER TABLE로 열 속성 변경하기 명령어 ALTER TABLE sample62 MODIFY newcol VARCHAR(20); 결과 DESC sample62;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | || newcol | varchar(20) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) ALTER TABLE로 열 이름 변경하기 명령어 ALTER TABLE sample62 CHANGE newcol c VARCHAR(20); 결과 DESC sample62;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | || c | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) ALTER TABLE로 열 삭제하기 명령어 ALTER TABLE smaple62 DROP c; 결과 DESC sample62;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 27장 제약테이블 열에 제약 정의하기 명령어 CREATE TABLE sample631( a INTEGER NOT NULL, b INTEGER NOT NULL UNIQUE, c VARCHAR(30)); 결과 DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 테이블에 ‘테이블 제약’ 정의하기 명령어 CREATE TABLE sample632( no INTEGER NOT NULL, sub_no INTEGER NOT NULL, name VARCHAR(30), PRIMARY KEY(no, sub_no)); 결과 DESC sample632;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| no | int | NO | PRI | NULL | || sub_no | int | NO | PRI | NULL | || name | varchar(30) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) ‘테이블 제약’에 이름 부이기 명령어 CREATE TABLE sample632( no INTEGER NOT NULL, sub_no INTEGER NOT NULL, name VARCHAR(30), CONSTRAINT pkey_sample PRIMARY KEY(no, sub_no)); 결과 DESC sample632;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| no | int | NO | PRI | NULL | || sub_no | int | NO | PRI | NULL | || name | varchar(30) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 열 제약 추가하기 기존 테이블 DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 명령어 ALTER TABLE sample631 MODIFY c VARCHAR(30) NOT NULL; DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 테이블 제약 추가하기 기존 테이블 DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 기본키 제약 추가하기 ALTER TABLE sample631 ADD CONSTRAINT pkey_sample631 PRIMARY KEY(a); 결과 DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | PRI | NULL | || b | int | NO | UNI | NULL | || c | varchar(30) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 제약 삭제열 제약 삭제하기 기존 테이블 +-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | PRI | NULL | || b | int | NO | UNI | NULL | || c | varchar(30) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec) c 열의 NOT NULL 제약 없애기 ALTER TABLE sample631 MODIFY c VARCHAR(30); 결과 DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | PRI | NULL | || b | int | NO | UNI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 테이블 제약 삭제하기 기존 테이블 DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | PRI | NULL | || b | int | NO | UNI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) pkey_sample631 제약 삭제하기 ALTER TABLE sample631 DROP CONSTRAINT pkey_sample631; my_sql의 경우 ALTER TABLE sample631 DROP PRIMARY KEY; 결과 DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 기본키sample634 테이블 작성하기CREATE TABLE sample634( p INTEGER NOT NULL, a VARCHAR(30), CONSTRAINT pkey_sample634 PRIMARY KEY(p)); sample634에 행 추가하기INSERT INTO sample634 VALUES(1, &#x27;첫째줄&#x27;);INSERT INTO sample634 VALUES(2, &#x27;둘째줄&#x27;);INSERT INTO sample634 VALUES(3, &#x27;셋째줄&#x27;); saple634에 중복하는 행 추가하기INSERT INTO sample634 VALUES(2, &#x27;둘째줄&#x27;); 결과 ERROR 1062 (23000): Duplicate entry &#x27;2&#x27; for key &#x27;sample634.PRIMARY&#x27; sample634을 중복된 값으로 갱신하기UPDATE sample634 SET p=2 WHERE p=3; ERROR 1062 (23000): Duplicate entry &#x27;2&#x27; for key &#x27;sample634.PRIMARY&#x27; 29장 인덱스 작성과 삭제30장 뷰 작성과 삭제","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"집계와 서브쿼리","slug":"database/sql/subquery","date":"2021-03-06T01:01:04.000Z","updated":"2024-02-18T16:19:54.524Z","comments":true,"path":"2021/03/06/database/sql/subquery/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/sql/subquery/","excerpt":"집계와 서브쿼리행 개수 구하기 - COUNTCOUNT로 행 개수 구하기 테이블 SELECT* FROM sample51;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+------+------+----------+5 rows in set (0.00 sec) 명령어 SELECT COUNT(*) FROM sample51; 결과 +----------+| COUNT(*) |+----------+| 5 |+----------+1 row in set (0.00 sec)","text":"집계와 서브쿼리행 개수 구하기 - COUNTCOUNT로 행 개수 구하기 테이블 SELECT* FROM sample51;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+------+------+----------+5 rows in set (0.00 sec) 명령어 SELECT COUNT(*) FROM sample51; 결과 +----------+| COUNT(*) |+----------+| 5 |+----------+1 row in set (0.00 sec) 행 개수를 WHERE 구를 지정하여 구하기 테이블 SELECT* FROM sample51 WHERE name=&#x27;A&#x27;;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 |+------+------+----------+2 rows in set (0.00 sec) 명령어 SELECT COUNT(*) FROM sample51 WHERE name = &#x27;A&#x27;; 결과 +----------+| COUNT(*) |+----------+| 2 |+----------+1 row in set (0.00 sec) 집계함수와 NULL값 명령어 SELECT COUNT(no), COUNT(name) FROM sample51; 결과 +-----------+-------------+| COUNT(no) | COUNT(name) |+-----------+-------------+| 5 | 4 |+-----------+-------------+1 row in set (0.00 sec) DISTINCT로 중복 제거 테이블 SELECT* FROM sample51;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+------+------+----------+5 rows in set (0.00 sec) 명령어 SELECT DISTINCT name FROM sample51; +------+| name |+------+| A || B || C || NULL |+------+4 rows in set (0.00 sec) 집계함수에서 DISTINCT 명령어 SELECT COUNT(ALL name), COUNT(DISTINCT name) FROM sample51; 결과 +-----------------+----------------------+| COUNT(ALL name) | COUNT(DISTINCT name) |+-----------------+----------------------+| 4 | 3 |+-----------------+----------------------+1 row in set (0.00 sec) COUNT 이외의 집계함수SUM으로 합계 구하기 테이블 SELECT* FROM sample51;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+------+------+----------+5 rows in set (0.00 sec) 명령어 SELECT SUM(quantity) FROM sample51; 결과 +---------------+| SUM(quantity) |+---------------+| 16 |+---------------+1 row in set (0.00 sec) AVG로 평균내기 명령어 SELECT AVG(quantity), SUM(quantity)/COUNT(quantity) FROM sample51; 결과 +---------------+-------------------------------+| AVG(quantity) | SUM(quantity)/COUNT(quantity) |+---------------+-------------------------------+| 4.0000 | 4.0000 |+---------------+-------------------------------+1 row in set (0.01 sec) MIN, MAX로 최솟값, 최댓값 구하기 명령어 SELECT MIN(quantity), MAX(quantity), MIN(name), MAX(name) FROM sample51; 결과 +---------------+---------------+-----------+-----------+| MIN(quantity) | MAX(quantity) | MIN(name) | MAX(name) |+---------------+---------------+-----------+-----------+| 1 | 10 | A | C |+---------------+---------------+-----------+-----------+1 row in set (0.00 sec) 그룹화 - GROUP BYGROUP BY로 그룹화 명령어 SELECT name FROM sample51 GROUP BY name; 결과 +------+| name |+------+| A || B || C || NULL |+------+4 rows in set (0.00 sec) name 열을 그룹화해 계산하기 명령어 SELECT name, COUNT(name), SUM(quantity) FROM sample51 GROUP BY name; 결과 +------+-------------+---------------+| name | COUNT(name) | SUM(quantity) |+------+-------------+---------------+| A | 2 | 3 || B | 1 | 10 || C | 1 | 3 || NULL | 0 | NULL |+------+-------------+---------------+4 rows in set (0.00 sec) HAVING 구로 조건 지정 테이블 SELECT name, COUNT(name) FROM sample51 GROUP BY name;+------+-------------+| name | COUNT(name) |+------+-------------+| A | 2 || B | 1 || C | 1 || NULL | 0 |+------+-------------+4 rows in set (0.00 sec) 명령어 SELECT name, COUNT(name) FROM sample51 GROUP BY name HAVING COUNT(name) = 1; 결과 +------+-------------+| name | COUNT(name) |+------+-------------+| B | 1 || C | 1 |+------+-------------+2 rows in set (0.00 sec) 내부 처리 순서WHERE 구 -&gt; GROUP BY 구 -&gt; HAVING 구 -&gt; SELECT 구 -&gt; ORDER BY 구 복수열의 그룹화 테이블 SELECT* FROM sample51;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+------+------+----------+5 rows in set (0.00 sec) GROUP BY를 사용할 때 주의할 점 : GROUP BY 에 지정한 열 이외의 열은 집계함수를 사용하지 않은 채 SELECT구에 기술해서는 안된다. 명령어 SELECT no, name, quantity FROM sample51 GROUP BY name; 결과 ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;sample.sample51.no&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by GROUP BY로 그룹화 하면 클라이언트로 반환되는 결과는 그룹당 하나의 행이 된다. 하지만, name 열 값이 A인 그룹의 quantity 열 값은 1과 2로 두개이므로, 어떤 값을 반환할지 몰라 에러가 뜬다. 명령어 SELECT MIN(no), name, SUM(quantity) FROM sample51 GROUP BY name; 결과 +---------+------+---------------+| MIN(no) | name | SUM(quantity) |+---------+------+---------------+| 1 | A | 3 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+---------+------+---------------+4 rows in set (0.00 sec) 결과 값 정렬SELECT name, COUNT(name), SUM(quantity) FROM sample51 GROUP BY name ORDER BY SUM(quantity) DESC; +------+-------------+---------------+| name | COUNT(name) | SUM(quantity) |+------+-------------+---------------+| B | 1 | 10 || A | 2 | 3 || C | 1 | 3 || NULL | 0 | NULL |+------+-------------+---------------+4 rows in set (0.01 sec) 서브 쿼리DELETE의 WHERE 구에서 서브쿼리 사용하기 테이블 SELECT* FROM sample54;+------+------+| no | a |+------+------+| 1 | 100 || 2 | 900 || 3 | 20 || 4 | 80 |+------+------+4 rows in set (0.01 sec) 최솟값을 가지는 행 삭제하기 명령어 DELETE FROM sample54 WHERE a=(SELECT MIN(a) FROM sample54); 결과 ERROR 1093 (HY000): You can&#x27;t specify target table &#x27;sample54&#x27; for update in FROM clause 데이터를 추가하거나 갱신할 경우 동일한 테이블을 서브쿼리에서 사용할 수 없도록 되어 있기 때문에 이런 에러가 뜬다. 명령어 DELETE FROM sample54 WHERE a=(SELECT a FROM(SELECT MIN(a) AS a FROM sample54) AS x); 결과 SELECT* FROM sample54;+------+------+| no | a |+------+------+| 1 | 100 || 2 | 900 || 4 | 80 |+------+------+3 rows in set (0.00 sec) 스칼라 값하나의 값을 반환하는 패턴 명령어 SELECT MIN(a) FROM sample54; 결과 +--------+| MIN(a) |+--------+| 80 |+--------+1 row in set (0.00 sec) 복수의 행이 반환되지만 열은 하나인 패턴 명령어 SELECT no FROM sample54; 결과 +------+| no |+------+| 1 || 2 || 4 |+------+3 rows in set (0.00 sec) 하나의 행이 반환되지만 열이 복수인 패턴 명령어 SELECT MIN(a), MAX(no) FROM sample54; 결과 +--------+---------+| MIN(a) | MAX(no) |+--------+---------+| 80 | 4 |+--------+---------+1 row in set (0.00 sec) 복수의 행, 복수의 열이 반환되는 패턴 명령어 SELECT no, a FROM sample54; 결과 +------+------+| no | a |+------+------+| 1 | 100 || 2 | 900 || 4 | 80 |+------+------+3 rows in set (0.00 sec) SELECT 명령이 하나의 값만 반환하는 것을 스칼라 값을 반환한다.고 한다. SELECT 구에서 서브쿼리 사용하기 명령어 SELECT (SELECT COUNT(*) FROM sample51) AS sq1, (SELECT COUNT(*) FROM sample51) AS sq2; My SQL에서는 FROM 구를 생략할 수 있다. 하지만 Oracle등 전통적인 데이터 베이스 제품에서는 FROM을 생략할 수 없습니다. 결과 +------+------+| sq1 | sq2 |+------+------+| 5 | 5 |+------+------+1 row in set (0.00 sec) SET 구에서 서브쿼리 사용하기 명령어 UPDATE sample54 SET a = (SELECT a FROM (SELECT MAX(a) AS a FROM sample54)as x); 결과 SELECT* FROM sample54;+------+------+| no | a |+------+------+| 1 | 900 || 2 | 900 || 4 | 900 |+------+------+3 rows in set (0.00 sec) FROM 구에서 서브쿼리 사용하기 명령어 SELECT* FROM (SELECT* FROM sample54) sq; 결과 +------+------+| no | a |+------+------+| 1 | 900 || 2 | 900 || 4 | 900 |+------+------+3 rows in set (0.00 sec) INSERT 명령과 서브쿼리 명령어 INSERT INTO sample541 VALUES( (SELECT COUNT(*) FROM sample51), (SELECT COUNT(*) FROM sample54)); 결과 SELECT* FROM sample541;+------+------+| a | b |+------+------+| 5 | 3 |+------+------+1 row in set (0.00 sec) INSERT SELECT 명령어 INSERT INTO sample541 SELECT 1,2; 결과 SELECT* FROM sample541;+------+------+| a | b |+------+------+| 5 | 3 || 1 | 2 |+------+------+2 rows in set (0.00 sec) 상관 서브쿼리EXISTS 테이블 SELECT* FROM sample551;+------+------+| no | a |+------+------+| 1 | NULL || 2 | NULL || 3 | NULL || 4 | NULL || 5 | NULL |+------+------+ 테이블 SELECT* FROM sample552;+------+| no2 |+------+| 3 || 5 |+------+2 rows in set (0.00 sec) sample 552 테이블에 있는지를 조사한 결과 값을 넣고 싶다. 명령어 UPDATE sample551 SET a = &#x27;있음&#x27; WHERE EXISTS (SELECT* FROM sample552 WHERE no2 = no); SELECT* FROM sample551;+------+--------+| no | a |+------+--------+| 1 | NULL || 2 | NULL || 3 | 있음 || 4 | NULL || 5 | 있음 |+------+--------+5 rows in set (0.00 sec) NOT EXISTS 명령어 UPDATE sample551 SET a = &#x27;없음&#x27; WHERE NOT EXISTS (SELECT* FROM sample552 WHERE no2 = no); 결과 SELECT* FROM sample551;+------+--------+| no | a |+------+--------+| 1 | 없음 || 2 | 없음 || 3 | 있음 || 4 | 없음 || 5 | 있음 |+------+--------+ 테이블 명 붙이기양쪽 테이블에 동일한 이름의 열이 있을 경우 상관 서브 쿼리가 제대로 작동하지 않으므로 테이블 명을 붙일 필요가 있다. UPDATE sample551 SET a = &#x27;있음&#x27; WHERE EXISTS (SELECT* FROM sample552 WHERE sample552.no2 = sample551.no); IN집합 안의 값이 존재하는지를 조사할 수 있다. 명령어 SELECT* FROM sample551 WHERE no IN(3, 5); 결과 +------+--------+| no | a |+------+--------+| 3 | 있음 || 5 | 있음 |+------+--------+ IN의 오른쪽을 서브쿼리로 지정하기 명령어 SELECT* FROM sample551 WHERE no IN(SELECT no2 FROM sample552); 결과 +------+--------+| no | a |+------+--------+| 3 | 있음 || 5 | 있음 |+------+--------+2 rows in set (0.00 sec)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"데이터 추가, 삭제, 갱신","slug":"database/sql/dml","date":"2021-03-06T01:00:09.000Z","updated":"2024-02-18T16:19:54.523Z","comments":true,"path":"2021/03/06/database/sql/dml/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/sql/dml/","excerpt":"데이터 추가, 삭제, 갱신행 추가하기 - INSERT 명령어 SELECT * FROM sample41; 결과 Empty set (0.00 sec) 현재는 비어있는 테이블이다. sample41 열 구성 확인하기 명령어","text":"데이터 추가, 삭제, 갱신행 추가하기 - INSERT 명령어 SELECT * FROM sample41; 결과 Empty set (0.00 sec) 현재는 비어있는 테이블이다. sample41 열 구성 확인하기 명령어 DESC sample41; 결과 +-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) no 열은 int(11)이므로 수치형 데이터를 저장할 수 있다. a 열은 varchar(30)이므로 최대 길이가 30인 문자열을 저장할 수 있다. b 열은 날짜 시간형 데이터를 저장할 수 있다. 행 추가 하기 명령어 INSERT INTO sample41 VALUES(1, &#x27;ABC&#x27;, &#x27;2014-01-25&#x27;); 결과 Query OK, 1 row affected (0.00 sec) 확인하기 명령어 SELECT* FROM sample41; 결과 +----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 |+----+------+------------+1 row in set (0.00 sec) 값을 저장할 열 지정하기 명령어 INSERT INTO sample41(a, no) VALUES(&#x27;XYZ&#x27;, 2);Query OK, 1 row affected (0.00 sec) 결과 SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL |+----+------+------------+2 rows in set (0.00 sec) NOT NULL 제약 명령어 INSERT INTO sample41(no, a, b) VALUES(NULL, NULL, NULL);ERROR 1048 (23000): Column &#x27;no&#x27; cannot be null 행에 값이 없는 상태(NULL)로 두고 싶을 경우 VALUES구에서 NULL로 값을 지정할 수 있다. no 열에 대해서는 NULL값을 허용하지 않으므로 위 명령어는 에러가 발생한다. 명령어 INSERT INTO sample41(no, a, b) VALUES(3, NULL, NULL);Query OK, 1 row affected (0.01 sec) 결과 SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL || 3 | NULL | NULL |+----+------+------------+3 rows in set (0.00 sec) DEFAULT에 대해 알아보기 명령어 DESC sample411; 결과 +-------+------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------+------+-----+---------+-------+| no | int | NO | | NULL | || d | int | YES | | 0 | |+-------+------+------+-----+---------+-------+2 rows in set (0.01 sec) sample411테이블 d 열에 대해서는 디폴트 값으로 0이 설정되어 있다. 값을 생략하지 앟고 행 추가하기 명령어 INSERT INTO sample411(no, d) VALUES(1,1);Query OK, 1 row affected (0.00 sec) 결과 SELECT * FROM sample411;+----+------+| no | d |+----+------+| 1 | 1 |+----+------+ DEFAULT로 값을 지정해 행 추가하기 명령어 INSERT INTO sample411(no, d) VALUES(2, DEFAULT);Query OK, 1 row affected (0.00 sec) 결과 SELECT * FROM sample411;+----+------+| no | d |+----+------+| 1 | 1 || 2 | 0 |+----+------+ 암묵적으로 디폴트값을 가지는 행 추가하기 명령어 INSERT INTO sample411(no) VALUES(3);Query OK, 1 row affected (0.00 sec) 결과 SELECT * FROM sample411;+----+------+| no | d |+----+------+| 1 | 1 || 2 | 0 || 3 | 0 |+----+------+3 rows in set (0.00 sec) 열을 지정하지 않으면 디폴트값으로 행이 추가된다. 삭제하기 - DELETE 테이블 SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL || 3 | NULL | NULL |+----+------+------------+3 rows in set (0.00 sec) DELETE FROM sample41;로 DELETE 명령을 실행하면 sample41 테이블의 모든 데이터가 삭제된다. 행 삭제하기 명령어 DELETE FROM sample41 WHERE no=3; 결과 +----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL |+----+------+------------+2 rows in set (0.00 sec) DELETE 명령은 WHERE 조건에 일치하는 모든 행을 삭제한다. 데이터 갱신하기 - UPDATE 테이블 SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL |+----+------+------------+2 rows in set (0.00 sec) DELETE와 달리UPDATE는 셀 단위로 데이터를 갱신할 수 있다.UPDATE 명령에서는 set구를 사용하여 갱신할 열과 값을 지정한다. SET 열명 = 값 이때 =는 비교연산자가 아닌, 값을 대입하는 대입 연산자이다. 명령어 UPDATE sample41 SET b = &#x27;2014-09-08&#x27; WHERE no=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 결과 SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | 2014-09-08 |+----+------+------------+2 rows in set (0.00 sec) UPDATE 명령에서는 WHERE 조건에 일치하는 ‘모든 행’이 갱신된다. UPDATE 명령으로 증가 연산하기 명령어 UPDATE sample41 SET no = no+1;Query OK, 2 rows affected (0.00 sec)Rows matched: 2 Changed: 2 Warnings: 0 결과 SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 2 | ABC | 2014-01-25 || 3 | XYZ | 2014-09-08 |+----+------+------------+2 rows in set (0.00 sec) 모든 행의 no값에 1씩 더해진 것을 알 수 있다. 복수열 갱신 명령어 UPDATE sample41 SET a=&#x27;xxx&#x27;, b=&#x27;2014-01-01&#x27; WHERE no=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 콤마,로 구분하여 갱신할 열을 여러 개 지정할 수 있다. 결과 SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 2 | xxx | 2014-01-01 || 3 | XYZ | 2014-09-08 |+----+------+------------+2 rows in set (0.00 sec) NULL로 갱신하기 명령어 UPDATE sample41 SET a=NULL;Query OK, 2 rows affected (0.00 sec)Rows matched: 2 Changed: 2 Warnings: 0 결과 SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 2 | NULL | 2014-01-01 || 3 | NULL | 2014-09-08 |+----+------+------------+2 rows in set (0.00 sec) NOT NULL 제약이 설정되어 있는 열은 NULL이 허용되지 않는다. 물리 삭제와 논리 삭제 물리삭제 : SQL의 DELETE 명령을 사용해 직접 데이터를 삭제하는 방법 논리삭제 : 삭제 플래그와 같은 열을 미리 준비해 서 삭제 플레그의 값을 유효하게 갱신해두는 삭제 방법(실제 테이블안에 데이터는 남아있다.)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"정렬과 연산","slug":"database/sql/sort-and-operation","date":"2021-03-06T00:58:46.000Z","updated":"2024-02-18T16:19:54.524Z","comments":true,"path":"2021/03/06/database/sql/sort-and-operation/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/sql/sort-and-operation/","excerpt":"정렬과 연산정렬하기 - ORDER BY 기존 테이블 mysql&gt; SELECT * FROM sample31;+------+------+---------------------------+| name | age | address |+------+------+---------------------------+| A씨 | 36 | 대구광역시 중구 || B씨 | 18 | 부산광역시 연제구 || C씨 | 25 | 서울특별시 중구 |+------+------+---------------------------+3 rows in set (0.00 sec) age를 기준으로 테이블 정렬하기 명령어 SELECT* FROM sample31 ORDER BY age; 나이를 기준으로 테이블sample31을 정렬하였다. 결과","text":"정렬과 연산정렬하기 - ORDER BY 기존 테이블 mysql&gt; SELECT * FROM sample31;+------+------+---------------------------+| name | age | address |+------+------+---------------------------+| A씨 | 36 | 대구광역시 중구 || B씨 | 18 | 부산광역시 연제구 || C씨 | 25 | 서울특별시 중구 |+------+------+---------------------------+3 rows in set (0.00 sec) age를 기준으로 테이블 정렬하기 명령어 SELECT* FROM sample31 ORDER BY age; 나이를 기준으로 테이블sample31을 정렬하였다. 결과 +------+------+---------------------------+| name | age | address |+------+------+---------------------------+| B씨 | 18 | 부산광역시 연제구 || C씨 | 25 | 서울특별시 중구 || A씨 | 36 | 대구광역시 중구 |+------+------+---------------------------+3 rows in set (0.01 sec) 오름차순으로 정렬되었음을 확인할 수 있다. address를 기준으로 테이블 정리하기 명령어 SELECT* FROM sample31 ORDER BY address; address를 기준으로 테이블을 정렬 시켰다. 결과 +------+------+---------------------------+| name | age | address |+------+------+---------------------------+| A씨 | 36 | 대구광역시 중구 || B씨 | 18 | 부산광역시 연제구 || C씨 | 25 | 서울특별시 중구 |+------+------+---------------------------+ 사전순으로 테이블이 정렬되었다. 내림 차순으로 정렬하기 - DESC 명령어 SELECT* FROM sample31 ORDER BY age DESC; DESC를 붙임으로써 테이블을 내림차순으로 정렬한다. 결과 +------+------+---------------------------+| name | age | address |+------+------+---------------------------+| A씨 | 36 | 대구광역시 중구 || C씨 | 25 | 서울특별시 중구 || B씨 | 18 | 부산광역시 연제구 |+------+------+---------------------------+3 rows in set (0.00 sec) 오름 차순으로 정렬하기 - AES 명령어 SELECT* FROM sample31 ORDER BY age ASC; ASC를 붙임으로써 테이블을 오름차순으로 정렬한다. ASC는 생략 가능 +------+------+---------------------------+| name | age | address |+------+------+---------------------------+| B씨 | 18 | 부산광역시 연제구 || C씨 | 25 | 서울특별시 중구 || A씨 | 36 | 대구광역시 중구 |+------+------+---------------------------+3 rows in set (0.00 sec) 복수의 열을 지정해 정렬하기SELECT* FROM sample32 ORDER BY a; 결과+------+------+| a | b |+------+------+| 1 | 1 || 1 | 3 || 1 | 2 || 2 | 1 || 2 | 2 |+------+------+5 rows in set (0.00 sec) SELECT* FROM sample32 ORDER BY b,a; 결과+------+------+| a | b |+------+------+| 1 | 1 || 2 | 1 || 1 | 2 || 2 | 2 || 1 | 3 |+------+------+5 rows in set (0.00 sec) 정렬방법 지정하기SELECT* FROM sample32 ORDER BY a ASC, b DESC; 결과+------+------+| a | b |+------+------+| 1 | 3 || 1 | 2 || 1 | 1 || 2 | 2 || 2 | 1 |+------+------+5 rows in set (0.00 sec) 결과 행 제한하기 - LIMIT 테이블 +------+| no |+------+| 1 || 2 || 3 || 4 || 5 || 6 || 7 |+------+7 rows in set (0.00 sec) 명령어 SELECT* FROM sample33 LIMIT 3; 결과 +------+| no |+------+| 1 || 2 || 3 |+------+3 rows in set (0.00 sec) 정렬 후 LIMIT로 행수 제한하기 명령어 SELECT* FROM sample33 ORDER BY no DESC LIMIT 3; 결과 +------+| no |+------+| 7 || 6 || 5 |+------+3 rows in set (0.00 sec) LIMIT를 사용할 수 없는 데이터베이스에서의 행 제한 SQL Server SELECT TOP 3 * FROM sample33; ORACLE SELECT * FROM sample33 WHERE ROWNUM&lt;=3; 오프셋 지정 - OFFSET 명령어 SELECT* FROM sample33 LIMIT 3 OFFSET 0; 수치 연산 기본 테이블 mysql&gt; SELECT* FROM sample34;+------+-------+----------+| no | price | quantity |+------+-------+----------+| 1 | 100 | 10 || 2 | 230 | 24 || 3 | 1980 | 1 |+------+-------+----------+3 rows in set (0.01 sec) 명령어 SELECT*, price*quantity FROM sample34; 결과 +------+-------+----------+----------------+| no | price | quantity | price*quantity |+------+-------+----------+----------------+| 1 | 100 | 10 | 1000 || 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 |+------+-------+----------+----------------+3 rows in set (0.00 sec) 열의 별명 - AS 명령어 SELECT*, price*quantity AS amount FROM sample34; 결과 +------+-------+----------+--------+| no | price | quantity | amount |+------+-------+----------+--------+| 1 | 100 | 10 | 1000 || 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 |+------+-------+----------+--------+3 rows in set (0.00 sec) 명령어 SELECT*, price*quantity &quot;금액&quot; FROM sample34; 결과 +------+-------+----------+--------+| no | price | quantity | 금액 |+------+-------+----------+--------+| 1 | 100 | 10 | 1000 || 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 |+------+-------+----------+--------+3 rows in set (0.00 sec) WHERE 구에서 계산, 검색하기 명령어 SELECT*, price*quantity AS amount FROM sample34 WHERE price*quantity &gt;= 2000; 결과 +------+-------+----------+--------+| no | price | quantity | amount |+------+-------+----------+--------+| 2 | 230 | 24 | 5520 |+------+-------+----------+--------+1 row in set (0.00 sec) 명령어 SELECT*, price*quantity AS amount FROM sample34 WHERE amount &gt;= 2000; 결과 ERROR 1054 (42S22): Unknown column &#x27;amount&#x27; in &#x27;where clause&#x27; 명령어 SELECT*, price*quantity AS amount FROM sample34 ORDER BY price*quantity DESC; 결과 +------+-------+----------+--------+| no | price | quantity | amount |+------+-------+----------+--------+| 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 || 1 | 100 | 10 | 1000 |+------+-------+----------+--------+3 rows in set (0.01 sec) 명령어 SELECT*, price*quantity AS amount FROM sample34 ORDER BY amount DESC; 결과 +------+-------+----------+--------+| no | price | quantity | amount |+------+-------+----------+--------+| 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 || 1 | 100 | 10 | 1000 |+------+-------+----------+--------+3 rows in set (0.01 sec) ROUND 함수 - 반올림 기존 테이블 SELECT* FROM sample341;+---------+| amount |+---------+| 5961.60 || 2138.40 || 1080.00 |+---------+3 rows in set (0.00 sec) 명령어 SELECT amount, ROUND(amount) FROM sample341; 결과 +---------+---------------+| amount | ROUND(amount) |+---------+---------------+| 5961.60 | 5962 || 2138.40 | 2138 || 1080.00 | 1080 |+---------+---------------+3 rows in set (0.00 sec) 소수점 둘째 자리에서 반올림하기 명령어 SELECT amount, ROUND(amount, 1) FROM sample341; 결과 +---------+------------------+| amount | ROUND(amount, 1) |+---------+------------------+| 5961.60 | 5961.6 || 2138.40 | 2138.4 || 1080.00 | 1080.0 |+---------+------------------+3 rows in set (0.00 sec) 10 단위를 반올림 하기 명령어 SELECT amount, ROUND(amount, -2) FROM sample341; 결과 +---------+-------------------+| amount | ROUND(amount, -2) |+---------+-------------------+| 5961.60 | 6000 || 2138.40 | 2100 || 1080.00 | 1100 |+---------+-------------------+3 rows in set (0.00 sec) 문자열 연산문자열 결합 - CONCAT 테이블 select * from sample35;+------+-------+----------+------+| no | price | quantity | unit |+------+-------+----------+------+| 1 | 100 | 10 | 개 || 2 | 230 | 24 | 통 || 3 | 1980 | 1 | 장 |+------+-------+----------+------+3 rows in set (0.00 sec) 명령어 SELECT CONCAT(quantity, unit) FROM sample35; 결과 +------------------------+| CONCAT(quantity, unit) |+------------------------+| 10개 || 24통 || 1장 |+------------------------+3 rows in set (0.04 sec) CASE 문으로 데이터 변환하기CASE로 NULL 값을 0으로 변환하기SELECT a, CASE WHEN a IS NULL THEN 0 ELSE a END &quot;a(null=0)&quot; FROM sample37; +------+-----------+| a | a(null=0) |+------+-----------+| 1 | 1 || 2 | 2 || NULL | 0 |+------+-----------+3 rows in set (0.00 sec) COALESCE 함수를 이용한 NULL값 변환 테이블 SELECT * FROM sample37;+------+| a |+------+| 1 || 2 || NULL |+------+3 rows in set (0.00 sec) 명령어 SELECT a, COALESCE(a,0) FROM sample37; 결과 +------+---------------+| a | COALESCE(a,0) |+------+---------------+| 1 | 1 || 2 | 2 || NULL | 0 |+------+---------------+3 rows in set (0.00 sec) CASE로 NULL 값을 0으로 반환하기 명령어 SELECT a AS &quot;코드&quot;, CASE WHEN a=1 THEN &#x27;남자&#x27; WHEN a=2 THEN &#x27;여자&#x27; ELSE &#x27;미지정&#x27; END AS &quot;성별&quot; FROM sample37; 결과 +--------+-----------+| 코드 | 성별 |+--------+-----------+| 1 | 남자 || 2 | 여자 || NULL | 미지정 |+--------+-----------+3 rows in set (0.00 sec)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"테이블에서 데이터 검색","slug":"database/sql/search","date":"2021-03-06T00:56:37.000Z","updated":"2024-02-18T16:19:54.524Z","comments":true,"path":"2021/03/06/database/sql/search/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/sql/search/","excerpt":"테이블에서 데이터 검색use sample SELECT 명령어SELECT * FROM sample21; SELECT는 DML에 속하는 멸령으로 SQL에서 자주 사용된다.SELECT명령으로 데이터 베이스의 데이터를 읽어올 수 있다.*는 모든 열을 의미하는 메타문자이다.FROM은 처리 대상 테이블을 지정하는 키워드 결과+------+-----------+------------+---------------------------+| no | name | birthday | address |+------+-----------+------------+---------------------------+| 1 | 박준용 | 1976-10-18 | 대구광역시 수성구 || 2 | 김재진 | NULL | 대구광역시 동구 || 3 | 홍길동 | NULL | 서울특별시 마포구 |+------+-----------+------------+---------------------------+3 rows in set (0.00 sec) NULL은 데이터 값으로 아무것도 저장되어 있지 않은 상태를 의미한다. DESC 명령어","text":"테이블에서 데이터 검색use sample SELECT 명령어SELECT * FROM sample21; SELECT는 DML에 속하는 멸령으로 SQL에서 자주 사용된다.SELECT명령으로 데이터 베이스의 데이터를 읽어올 수 있다.*는 모든 열을 의미하는 메타문자이다.FROM은 처리 대상 테이블을 지정하는 키워드 결과+------+-----------+------------+---------------------------+| no | name | birthday | address |+------+-----------+------------+---------------------------+| 1 | 박준용 | 1976-10-18 | 대구광역시 수성구 || 2 | 김재진 | NULL | 대구광역시 동구 || 3 | 홍길동 | NULL | 서울특별시 마포구 |+------+-----------+------------+---------------------------+3 rows in set (0.00 sec) NULL은 데이터 값으로 아무것도 저장되어 있지 않은 상태를 의미한다. DESC 명령어DESC sample21; 테이블에 어떤 열이 정의도어 있는지 알 수 있다. 결과+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| no | int | YES | | NULL | || name | varchar(20) | YES | | NULL | || birthday | date | YES | | NULL | || address | varchar(40) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+4 rows in set (0.01 sec) int : Integer를 의미한다.char(N) : 문자열형의 하나, 문자열을 저장할 수 있는 자료형이다. 문자열형에서는 열의 최대 길이를 저장해야 한다.VARCHAR : 문자열을 저장할 수 있는 자료형. 데이터 크기에 맞춰 저장공간의 크기도 변경된다.(가변 길이 문자열)DATE : 날짜값을 저장할 수 있는 자료형TIME : 시간을 저장할 수 있는 자료형 Null : NULL 값을 허용할 것인지 아닌지를 나타내는 제약사항 YES : NULL값을 허용 NO : NULL값을 허용하지 않는다. Default : 열에 주어진 기본값(생략했을 경우 적용되는 값) WHERE 명령어일치하는 결과값만 가져오기SELECT * FROM sample21 WHERE no = 2; 행 속에서 필요한 데이터만 검색하기 위한 명령어WHERE구는 생략이 가능하다. 결과+------+-----------+----------+------------------------+| no | name | birthday | address |+------+-----------+----------+------------------------+| 2 | 김재진 | NULL | 대구광역시 동구 |+------+-----------+----------+------------------------+1 row in set (0.00 sec) 제외하고 검색하기SELECT * FROM sample21 WHERE no &lt;&gt; 2; 결과+------+-----------+------------+---------------------------+| no | name | birthday | address |+------+-----------+------------+---------------------------+| 1 | 박준용 | 1976-10-18 | 대구광역시 수성구 || 3 | 홍길동 | NULL | 서울특별시 마포구 |+------+-----------+------------+---------------------------+2 rows in set (0.00 sec) 문자열 검색하기SELECT* FROM sample21 WHERE name=&#x27;박준용&#x27;; (&#39; &#39;)작은 따옴표로 문자를 묶어서 검색해야 한다. 결과+------+-----------+------------+---------------------------+| no | name | birthday | address |+------+-----------+------------+---------------------------+| 1 | 박준용 | 1976-10-18 | 대구광역시 수성구 |+------+-----------+------------+---------------------------+1 row in set (0.00 sec) NULL값 검색하기SELECT* FROM sample21 WHERE birthday IS NULL; NULL인 행은 =연산자를 이용하여 검색할 수 없다.IS NULL을 이용하여 검색해야 한다. +------+-----------+----------+---------------------------+| no | name | birthday | address |+------+-----------+----------+---------------------------+| 2 | 김재진 | NULL | 대구광역시 동구 || 3 | 홍길동 | NULL | 서울특별시 마포구 |+------+-----------+----------+---------------------------+2 rows in set (0.00 sec) 조건 조합하기AND 연산자SELECT * FROM sample24 WHERE a&lt;&gt;0 AND b&lt;&gt;0; 좌우의 식 모두 참일 경우 AND 연산자는 참을 반환한다.모든 조건을 만족하는 경우 조건식은 참이된다고 할때 AND 연산자로 조건식을 조합한다.AND 연산은 논리곱을 계산하는 논리 연산자이다. 결과+------+------+------+------+| no | a | b | c |+------+------+------+------+| 4 | 2 | 2 | 0 |+------+------+------+------+1 row in set (0.00 sec) OR 연산자SELECT* FROM sample24 WHERE no=1 OR no=2; 어느 쪽이든 하나만 참이 되는 조건식은 참이 된다.라고 할 경우 OR로 조건식을 연결한다.OR연산자는 논리합을 계산하는 논리 연산자이다. +------+------+------+------+| no | a | b | c |+------+------+------+------+| 1 | 1 | 0 | 0 || 2 | 0 | 1 | 0 |+------+------+------+------+2 rows in set (0.00 sec) NOT 연산자SELECT* FROM sample24 WHERE NOT(a&lt;&gt;0 OR b&lt;&gt;0); NOT연산자는 단항 연산자이다. +------+------+------+------+| no | a | b | c |+------+------+------+------+| 3 | 0 | 0 | 1 |+------+------+------+------+1 row in set (0.00 sec) 패턴 매칭에 의한 검색특정 문자나 문자열이 포함되어 있는지를 검색하고 싶은 경우 사용한다. LIKE로 패턴 매칭하기SELECT * FROM sample25 WHERE text LIKE &#x27;SQL%&#x27;; LIKE술어를 사용하면 열 값이 부분적으로 일치하는 경우에도 참이 된다.%, _ 같은 특수 문자와 함께 사용한다.% : 임의의 문자열을 의미한다._ :임의의 문자 하나를 의미한다. +------+---------------------------------------------------+| no | text |+------+---------------------------------------------------+| 1 | SQL은 RDBMS를 조작하기 위한 언어이다. |+------+---------------------------------------------------+1 row in set (0.01 sec) SQL로 시작하는 문자열을 검색했다. SELECT* FROM sample25 WHERE text LIKE &#x27;%SQL%&#x27;; SQL이 들어간 문자열 모두를 검색한다. +------+-----------------------------------------------------------------+| no | text |+------+-----------------------------------------------------------------+| 1 | SQL은 RDBMS를 조작하기 위한 언어이다. || 3 | LIKE는 SQL에서 사용할 수 있는 술어 중 하나이다. |+------+-----------------------------------------------------------------+2 rows in set (0.00 sec) SELECT* FROM sample25 WHERE text LIKE &#x27;%\\%%&#x27;; +------+------------------------------------------------------------+| no | text |+------+------------------------------------------------------------+| 2 | LIKE에서는 메타문자 %와 _를 사용할 수 있다. |+------+------------------------------------------------------------+1 row in set (0.00 sec)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"데이터 베이스 - B Tree","slug":"database/btree","date":"2021-03-05T16:21:23.000Z","updated":"2024-02-18T16:19:54.522Z","comments":true,"path":"2021/03/06/database/btree/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/btree/","excerpt":"B Tree자식 노드가 최대 두개인 이진 트리와는 다르게 B-Tree 는 M 개의 자식 노드를 가질 수 있다. Node 의 Key 개수가 N 개면 자식 Node 의 개수는 N+1 개다. Node 내 Key 값은 항상 정렬된 상태 여야 한다. Root Node 는 항상 2개 이상의 자식 Node 를 갖는다. 모든 Leaf Node 들은 항상 같은 Level 에 있어야 한다. B treeB-트리는 데이터를 저장하고 검색하기 위한 트리 자료 구조로, 데이터베이스의 인덱스와 파일 시스템 등에서 널리 사용됩니다. B-트리는 각 노드에 여러 개의 자식을 가질 수 있으며, 이를 통해 대량의 데이터를 효율적으로 저장할 수 있습니다. B-트리는 일반적으로 다음과 같은 특징을 가집니다. 균형 트리: B-트리는 노드의 균형을 유지하여 검색, 삽입, 삭제 연산에 대한 시간 복잡도를 보장합니다. 각 노드는 여러 개의 자식을 가지며, 자식 노드의 개수가 비슷한 것이 특징입니다. 다단계 인덱스: B-트리는 매우 높은 성능으로 인덱스 검색을 수행하므로 대부분의 데이터베이스에서 인덱스 구조로 사용됩니다. B-트리는 다단계 인덱스를 구성하여 빠른 검색 성능을 제공합니다. 블록 단위 입출력: B-트리는 블록 단위로 입출력을 수행하여 입출력 연산을 최소화합니다. 이는 데이터베이스나 파일 시스템에서 대량의 데이터를 다룰 때 매우 효과적입니다. 삽입, 삭제 연산: B-트리는 노드의 균형을 유지하여 삽입, 삭제 연산의 시간 복잡도를 로그 시간으로 보장합니다. 이는 대규모 데이터를 다룰 때 매우 효과적입니다. B-트리는 데이터베이스, 파일 시스템, 검색 엔진 등에서 널리 사용되는 자료 구조입니다. 또한 B+트리와 같은 변형 형태도 있으며, 이러한 변형 형태는 대규모 데이터를 다룰 때 더욱 효과적입니다. B tree 검색 알고리즘 루트 노드에서 시작합니다. 현재 노드에서 키 값을 검색합니다. 검색한 키 값이 현재 노드에 있으면 해당 포인터를 따라 해당 자식 노드로 이동합니다. 검색한 키 값이 현재 노드에 없으면, 키 값이 들어갈 위치를 찾고 해당 위치의 자식 노드로 이동합니다. 자식 노드로 이동한 후, 2단계로 돌아가서 검색을 계속합니다.","text":"B Tree자식 노드가 최대 두개인 이진 트리와는 다르게 B-Tree 는 M 개의 자식 노드를 가질 수 있다. Node 의 Key 개수가 N 개면 자식 Node 의 개수는 N+1 개다. Node 내 Key 값은 항상 정렬된 상태 여야 한다. Root Node 는 항상 2개 이상의 자식 Node 를 갖는다. 모든 Leaf Node 들은 항상 같은 Level 에 있어야 한다. B treeB-트리는 데이터를 저장하고 검색하기 위한 트리 자료 구조로, 데이터베이스의 인덱스와 파일 시스템 등에서 널리 사용됩니다. B-트리는 각 노드에 여러 개의 자식을 가질 수 있으며, 이를 통해 대량의 데이터를 효율적으로 저장할 수 있습니다. B-트리는 일반적으로 다음과 같은 특징을 가집니다. 균형 트리: B-트리는 노드의 균형을 유지하여 검색, 삽입, 삭제 연산에 대한 시간 복잡도를 보장합니다. 각 노드는 여러 개의 자식을 가지며, 자식 노드의 개수가 비슷한 것이 특징입니다. 다단계 인덱스: B-트리는 매우 높은 성능으로 인덱스 검색을 수행하므로 대부분의 데이터베이스에서 인덱스 구조로 사용됩니다. B-트리는 다단계 인덱스를 구성하여 빠른 검색 성능을 제공합니다. 블록 단위 입출력: B-트리는 블록 단위로 입출력을 수행하여 입출력 연산을 최소화합니다. 이는 데이터베이스나 파일 시스템에서 대량의 데이터를 다룰 때 매우 효과적입니다. 삽입, 삭제 연산: B-트리는 노드의 균형을 유지하여 삽입, 삭제 연산의 시간 복잡도를 로그 시간으로 보장합니다. 이는 대규모 데이터를 다룰 때 매우 효과적입니다. B-트리는 데이터베이스, 파일 시스템, 검색 엔진 등에서 널리 사용되는 자료 구조입니다. 또한 B+트리와 같은 변형 형태도 있으며, 이러한 변형 형태는 대규모 데이터를 다룰 때 더욱 효과적입니다. B tree 검색 알고리즘 루트 노드에서 시작합니다. 현재 노드에서 키 값을 검색합니다. 검색한 키 값이 현재 노드에 있으면 해당 포인터를 따라 해당 자식 노드로 이동합니다. 검색한 키 값이 현재 노드에 없으면, 키 값이 들어갈 위치를 찾고 해당 위치의 자식 노드로 이동합니다. 자식 노드로 이동한 후, 2단계로 돌아가서 검색을 계속합니다. B tree 에서 삽입 알고리즘은 다음과 같습니다. 삽입할 키 값을 루트 노드에서부터 검색합니다. 키 값을 삽입할 위치를 찾습니다. 해당 위치에 새로운 키 값을 삽입합니다. 노드의 키 값이 오름차순으로 유지되도록 키 값을 정렬합니다. 노드의 키 개수가 최대치를 초과하면 노드를 분할합니다. 분할된 노드의 중간 값은 부모 노드에 삽입됩니다. 부모 노드의 키 값도 오름차순으로 유지되도록 키 값을 정렬합니다. 삽입이 완료됩니다. B-트리에서 삭제 알고리즘 삭제할 키 값을 루트 노드에서부터 검색합니다. 삭제할 키 값을 찾습니다. 삭제할 키 값을 가진 노드가 리프 노드인 경우, 해당 키 값을 삭제합니다. 삭제할 키 값을 가진 노드가 리프 노드가 아닌 경우, 대체 키 값을 찾아서 삭제합니다. 대체 키 값을 가진 노드로 이동하여 2단계로 돌아가서 삭제를 계속합니다. 삭제 후, 노드의 키 개수가 최소치를 초과하지 않도록 노드를 조정합니다. 노드의 키 값이 오름차순으로 유지되도록 키 값을 정렬합니다. 삭제가 완료됩니다. Key 검색 과정Root Node 부터 시작해 하향식으로 검색을 수행한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"Scan","slug":"CS/DataBase/Scan","permalink":"https://ckck803.github.io/categories/CS/DataBase/Scan/"}],"tags":[]},{"title":"데이터 베이스 - Index","slug":"database/index-scan","date":"2021-03-05T16:21:23.000Z","updated":"2024-02-18T16:19:54.522Z","comments":true,"path":"2021/03/06/database/index-scan/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/index-scan/","excerpt":"데이터 베이스 - Index Index 란 오라클에서는 인덱스의 모든 컬럼이 NULL 인 경우 인덱스를 만들지 않는다. 데이터 베이스 - Index Scan Table Full Scan : 테이블 전체 탐색 Index Unique Scan : 인덱스 수직 탐색 Index Full Sacn : 인덱스 전체 탐색 Index Range Scan : 인덱스 범위 탐색 Index Skip Scan : 인덱스 스킵 탐색 Table Full Scan - 테이블 전체 스캔 인덱스 루트에서 시작해 수평적으로 리프 블럭까지 스캔하는 방식 Index Unique Scan 단 한건의 데이터를 찾을 때 사용하는 Scan 방식","text":"데이터 베이스 - Index Index 란 오라클에서는 인덱스의 모든 컬럼이 NULL 인 경우 인덱스를 만들지 않는다. 데이터 베이스 - Index Scan Table Full Scan : 테이블 전체 탐색 Index Unique Scan : 인덱스 수직 탐색 Index Full Sacn : 인덱스 전체 탐색 Index Range Scan : 인덱스 범위 탐색 Index Skip Scan : 인덱스 스킵 탐색 Table Full Scan - 테이블 전체 스캔 인덱스 루트에서 시작해 수평적으로 리프 블럭까지 스캔하는 방식 Index Unique Scan 단 한건의 데이터를 찾을 때 사용하는 Scan 방식 루트 블록에서 시작해 브랜치 블록을 거처 리프블록까지 내려가 최종 데이터가 저장된 테이블 블록을 읽어 단 한건을 찾는다. unique Index 를 통해 = 조건으로 탐색하는 경우 Index Range Scan 인덱스를 루트에서 수직 탐색하다가 리프 블록에 도달해 시작점을 찾고 필요한 범위 만큼 Scan 하는 방식 Index Full ScanIndex Skip Scan","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"Scan","slug":"CS/DataBase/Scan","permalink":"https://ckck803.github.io/categories/CS/DataBase/Scan/"}],"tags":[]},{"title":"SQL - DDL DML DCL","slug":"database/sql/ddl-dml-dcl","date":"2021-03-05T16:21:23.000Z","updated":"2024-02-18T16:19:54.523Z","comments":true,"path":"2021/03/06/database/sql/ddl-dml-dcl/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/sql/ddl-dml-dcl/","excerpt":"DDL DML DCLDDL 데이터 베이스 스키마를 정의하기 하거나 조작하기 위한 명령어 명령어 설명 CREATE 데이터 베이스, 테이블을 생성하기 위한 명령어 ALTER 테이블을 수정하기 위한 명령어 DROP 데이터베이스, 테이블을 삭제하기 위한 명령어 RENAME TRUNCATE 데이터베이스를 초기화 시키기 위한 명령어 DML 데이터 베이스에 저장된 데이터를 조회, 수정, 삽입, 삭제하기 위한 언어 명령어 설명 SELECT 데이터를 조회 하기 위한 명령어 INSERT 데이터를 삽입하기 위한 명령어 UPDATE 데이터를 수정하기 위한 명령어 DELETE 데이터를 삭제하기 위한 명령어 DCL 데이터 베이스에 접근하거나 객체에 권한을 주는 역할을 하는 언어","text":"DDL DML DCLDDL 데이터 베이스 스키마를 정의하기 하거나 조작하기 위한 명령어 명령어 설명 CREATE 데이터 베이스, 테이블을 생성하기 위한 명령어 ALTER 테이블을 수정하기 위한 명령어 DROP 데이터베이스, 테이블을 삭제하기 위한 명령어 RENAME TRUNCATE 데이터베이스를 초기화 시키기 위한 명령어 DML 데이터 베이스에 저장된 데이터를 조회, 수정, 삽입, 삭제하기 위한 언어 명령어 설명 SELECT 데이터를 조회 하기 위한 명령어 INSERT 데이터를 삽입하기 위한 명령어 UPDATE 데이터를 수정하기 위한 명령어 DELETE 데이터를 삭제하기 위한 명령어 DCL 데이터 베이스에 접근하거나 객체에 권한을 주는 역할을 하는 언어 명령어 설명 GRANT 데이터 베이스 사용자에게 특정 작업에 대한 권한을 주기 위한 명령어 REVOKE 데이터 베이스 사용자에게 특정 작업에 대한 권한을 회수, 박탈 하기 위한 명령어 COMMIT 트랜잭션 작업 결과를 반영하기 위한 명령어 ROLLBACK 트랜잭션 작업을 취소 및 원래대로 복구하기 위한 명령어","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"트랜잭션과 ACID","slug":"database/transaction/ACID","date":"2021-03-05T16:15:42.000Z","updated":"2024-02-18T16:19:54.525Z","comments":true,"path":"2021/03/06/database/transaction/ACID/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/transaction/ACID/","excerpt":"목차 트랜잭션과 ACID 트랜잭션 격리수준 (Isolation Level) 트랜잭션과 ACID 원자성(Atomicity) 일관성(Consistency) 격리성(Isolation) 지속성(Durability) 원자성 보장 트랜잭션 원자성은 All or Nothing 으로 부분적으로 실행되거나 중단되지 않음을 보장한다. 즉, 분해가 불가능한 최소 단위인 하나의 원자처럼 동작한다는 의미 트랜잭션에 의한 변경 내용을 유지하면서, 이전에 Commit 된 시점의 데이터를 임시영역에 따로 저장함으로써 원자성을 보장한다. 현재 수행하고 있는 트랜잭션에 오류가 나면 현재 내역을 날려버리고 임시 영역에 저장했던 상태로 Rollback 을 한다. 이전 데이터들이 저장된 영역을 롤백 세그먼트라고 부른다. 현재 수행중인 트랜잭션에 의해 새롭게 변경되는 내역을 데이터베이스 테이블이라 부른다. 트랜잭션의 원자성은 롤백 세그먼트에 의해 보장이 된다. Consistency - 일관성 보장 트랜잭션 수행 전, 후 데이터 베이스 제약 조건 이나, 자료형 이 변하지 않음을 보장한다.","text":"목차 트랜잭션과 ACID 트랜잭션 격리수준 (Isolation Level) 트랜잭션과 ACID 원자성(Atomicity) 일관성(Consistency) 격리성(Isolation) 지속성(Durability) 원자성 보장 트랜잭션 원자성은 All or Nothing 으로 부분적으로 실행되거나 중단되지 않음을 보장한다. 즉, 분해가 불가능한 최소 단위인 하나의 원자처럼 동작한다는 의미 트랜잭션에 의한 변경 내용을 유지하면서, 이전에 Commit 된 시점의 데이터를 임시영역에 따로 저장함으로써 원자성을 보장한다. 현재 수행하고 있는 트랜잭션에 오류가 나면 현재 내역을 날려버리고 임시 영역에 저장했던 상태로 Rollback 을 한다. 이전 데이터들이 저장된 영역을 롤백 세그먼트라고 부른다. 현재 수행중인 트랜잭션에 의해 새롭게 변경되는 내역을 데이터베이스 테이블이라 부른다. 트랜잭션의 원자성은 롤백 세그먼트에 의해 보장이 된다. Consistency - 일관성 보장 트랜잭션 수행 전, 후 데이터 베이스 제약 조건 이나, 자료형 이 변하지 않음을 보장한다. 트랜잭션이 성공적으로 수행되면 일관적인 DB상태를 유지함을 보장한다. 데이터 베이스에 저장된 데이터들은 각 제약 조건이나 자료형들을 모두 만족한 상태로 저장돼 있다. 조건에 위배되는 쿼리가 들어오게 되면 트랜잭션은 종료된다. Isolation - 격리성 보장 하나의 트랜잭션이 수행 중에는 다른 트랜잭션이 수행될 수 없음을 보장한다. 트랜잭션이 수행되고 있을 때 다른 트랜잭션의 작업이 끼어들지 않음을 보장한다. 트랜잭션끼리는 서로 간섭할 수 없다. lock &amp; excute unlock 을 통해 고립성을 보장한다. 데이터를 쓸 때는 문을 잠궈서 다른 트랜잭션이 접근하지 않도록 고립성을 보장하고, 수행을 마치면 unlock을 통해 데이터를 다른 트랜잭션이 접근할 수 있도록 허용하는 방식이다. shared lock(공유 락) 트랜잭션에서 데이터를 읽을 때 다른 트랜잭션들이 읽을 수는 있도록 허용하는 lock exelusive lock(베타 락) 한 트랜잭션에서 데이터를 수정하고 있을 경우 다른 트랜잭션들이 접근을 못하도록하는 lock Durability - 지속성 보장 트랜잭션이 수행된 후 저장된 데이터는 영구적으로 보관됨 을 보장한다. 데이터는 비휘발성 저장소에 기록되며 H&#x2F;W, S&#x2F;W 장애가 발생하더라도 데이터는 계속 보존돼야 한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"sql.md","slug":"database/sql/sql-md","date":"2021-03-05T16:10:22.000Z","updated":"2024-02-18T16:19:54.524Z","comments":true,"path":"2021/03/06/database/sql/sql-md/","link":"","permalink":"https://ckck803.github.io/2021/03/06/database/sql/sql-md/","excerpt":"SQL 첫걸음 My SQL 설치하기 1장 데이터 베이스 구축 2장 테이블에서 데이터 검색 3장 정렬과 연산 4장 데이터 추가, 삭제, 갱신 5장 집계와 서브쿼리 6장 데이터베이스 객체 작성과 삭제 7장 복수의 테이블 다루기 SELECTFROMWHEREGROUP BYHAVINGORDER BYIFNULL, ISNULL, COALESCE, NVL","text":"SQL 첫걸음 My SQL 설치하기 1장 데이터 베이스 구축 2장 테이블에서 데이터 검색 3장 정렬과 연산 4장 데이터 추가, 삭제, 갱신 5장 집계와 서브쿼리 6장 데이터베이스 객체 작성과 삭제 7장 복수의 테이블 다루기 SELECTFROMWHEREGROUP BYHAVINGORDER BYIFNULL, ISNULL, COALESCE, NVLJOIN INNER JOIN : 두 테이블이 공통적으로 가지고 있는 레코드를 반환한다. LEFT JOIN : 두 테이블이 공통적으로 가지고 있는 레코드와 왼쪽 테이블의 모든 레코드를 반환한다. RIGHT JOIN : 두 테이블이 공통적으로 가지고 있는 레코드와 오른쪽 테이블의 모든 레코드를 반환한다. FULL OUTER JOIN : 두 테이블이 공통적으로 가지고 있는 레코드와 왼쪽 오른쪽 테이블의 레코드를 반환한다. SQL 내 함수숫자 함수 ABS(n) : n의 절대값을 반환한다. CEIL(n), FLOOR(n) : n보다 같거나 큰 함수를 반환한다. ROUND(n, i) : n을 소수점 i+1번째 자리에서 반올림 한다. TRUNC(n, i) : n을 소수점 i+1번째 자리에서 버린다. POWER(n1, n2) : n1을 n2로 거듭제곱한다. MOD(n1, n2) : n1을 n2로 나눈 나머지 값 ROUND &amp; TRUNC 자릿 값 소수쪽으로 가게 되면 양수를 정수쪽으로 가게 되면 음수값을 취하면 된다. 문자 함수 UPPER(char) : char를 대문자로 변환한다. LOWER(char) : char를 소문자로 반환한다. LENGTH(char) : char의 길이를 반환한다. UPPER 명령어 select UPPER(&#x27;hello&#x27;); 결과 +----------------+| UPPER(&#x27;hello&#x27;) |+----------------+| HELLO |+----------------+1 row in set (0.00 sec) LOWER 명령어 mysql&gt; select LOWER(&#x27;HELLO&#x27;); 결과 +----------------+| LOWER(&#x27;HELLO&#x27;) |+----------------+| hello |+----------------+1 row in set (0.00 sec) LENGTH 명령어 select LENGTH(&#x27;hello&#x27;); 결과 +-----------------+| LENGTH(&#x27;hello&#x27;) |+-----------------+| 5 |+-----------------+1 row in set (0.00 sec) 날짜 함수 year(DATE), year(DATETIME) hour(TIME), hour(DATETIME) minute(TIME), minute(DATETIME) second(TIME), second(DATETIME) DATE_FORMAT(DATE, format) year(DATE) 명령어 select year(&#x27;2020-06-05&#x27;); 결과 +--------------------+| year(&#x27;2020-06-05&#x27;) |+--------------------+| 2020 |+--------------------+1 row in set (0.00 sec) hour(TIME) 명령어 select hour(&#x27;11:42:55&#x27;); 결과 +------------------+| hour(&#x27;11:42:55&#x27;) |+------------------+| 11 |+------------------+1 row in set (0.00 sec) minute(TIME) 명령어 select minute(&#x27;11:42:55&#x27;); 결과 +--------------------+| minute(&#x27;11:42:55&#x27;) |+--------------------+| 42 |+--------------------+1 row in set (0.00 sec) second(TIME) 명령어 select second(&#x27;11:42:55&#x27;); 결과 +--------------------+| second(&#x27;11:42:55&#x27;) |+--------------------+| 55 |+--------------------+1 row in set (0.00 sec) DATE_FORMATSELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#x27;%y-%m-%d&#x27;) AS &#x27;날짜&#x27;from ANIMAL_INSorder by ANIMAL_ID 모두 소문자로 데이터 형식을 표시하게 되면 2글자 형식으로 표현을 한다. SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#x27;%Y-%m-%d&#x27;) AS &#x27;날짜&#x27;from ANIMAL_INSorder by ANIMAL_ID 년도를 대문자로 데이텨 형식을 표현하게 되면 구체적인 년도를 표시한다. SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#x27;%y-%M-%d&#x27;) AS &#x27;날짜&#x27;from ANIMAL_INSorder by ANIMAL_ID 달을 대문자로 표시하게 되면 영문으로 해당 달을 표시해준다. SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#x27;%y-%m-%D&#x27;) AS &#x27;날짜&#x27;from ANIMAL_INSorder by ANIMAL_ID 일을 대문자로 표시하게 되면 기수로 해당 일을 표시해준다. SQL문 처리순서 FROM WHERE GROUP BY HAVING SELECT ORDER BY 원하는 테이블을 찾아가(FROM) 조건을 이용해 원하는 데이터를 검색한 후(WHERE) 그룹으로 묶은 뒤(GROUP BY) 그룹화된 데이터를 조건을 이용해 검색한 후(HAVING) 원하는 데이터를 선택해(SELECT) 정렬해서 내보낸다.(ORDER BY) 프로그래머스 sql문제select 문 모든 레코드 조회하기 https://programmers.co.kr/learn/courses/30/lessons/59034 역순 정렬하기 https://programmers.co.kr/learn/courses/30/lessons/59035 아픈 동물 찾기 https://programmers.co.kr/learn/courses/30/lessons/59036 어린 동물 찾기 https://programmers.co.kr/learn/courses/30/lessons/59037 동물의 아이디와 이름 https://programmers.co.kr/learn/courses/30/lessons/59403 여러 기준으로 정렬하기 https://programmers.co.kr/learn/courses/30/lessons/59404 상위 n개 레코드 https://programmers.co.kr/learn/courses/30/lessons/59405 집계함수 (SUM, MAX, MIN) 최댓 값 구하기 https://programmers.co.kr/learn/courses/30/parts/17043 최솟 값 구하 https://programmers.co.kr/learn/courses/30/lessons/59038 동물 수 구하기 https://programmers.co.kr/learn/courses/30/lessons/59406 중복 제거하기 https://programmers.co.kr/learn/courses/30/lessons/59408 그룹화 (GROUP BY) 고양이와 개는 몇마리 있을까 https://programmers.co.kr/learn/courses/30/lessons/59040 동명 동물 수 찾기 https://programmers.co.kr/learn/courses/30/lessons/59041 입양 시각 구하기 https://programmers.co.kr/learn/courses/30/lessons/59412 입양 시각 구하기2 https://programmers.co.kr/learn/courses/30/lessons/59413 NULL 처리하기 이름이 없는 동물의 아이디 https://programmers.co.kr/learn/courses/30/lessons/59039 이름이 있는 동물의 아이디 https://programmers.co.kr/learn/courses/30/lessons/59407 NULL 처리하기 https://programmers.co.kr/learn/courses/30/lessons/59410 JOIN문 없어진 기록 찾기 https://programmers.co.kr/learn/courses/30/lessons/59042 있었는데요 없었습니다. https://programmers.co.kr/learn/courses/30/lessons/59043 오랜 기간 보호한 동물(1) https://programmers.co.kr/learn/courses/30/lessons/59044 보호소에서 중성화한 동물 https://programmers.co.kr/learn/courses/30/lessons/59045 String, Date 루시와 엘라 찾기 https://programmers.co.kr/learn/courses/30/lessons/59046 이름에 el이 들어가는 동물 찾기 https://programmers.co.kr/learn/courses/30/lessons/59047 중성화 여부 파악하기 https://programmers.co.kr/learn/courses/30/lessons/59409 오랜기간 보호한 동물(2) https://programmers.co.kr/learn/courses/30/lessons/59411 DATETIME에서 DATE로 형 변환 https://programmers.co.kr/learn/courses/30/lessons/59414","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"스프링 MVC 시작하기 - XML로 세팅하기","slug":"spring/spring5-mvc/Spring5MVC-1-xml-setting","date":"2021-03-04T06:42:21.000Z","updated":"2024-02-26T16:08:02.226Z","comments":true,"path":"2021/03/04/spring/spring5-mvc/Spring5MVC-1-xml-setting/","link":"","permalink":"https://ckck803.github.io/2021/03/04/spring/spring5-mvc/Spring5MVC-1-xml-setting/","excerpt":"스프링 MVC 시작하기 - XML로 세팅하기 Web.xml 설정하기 root-context.xml 설정하기 servlet-context 설정하기 의존관계 설정하기&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springMVCstep3&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;javax.servlet-version&gt;4.0.1&lt;/javax.servlet-version&gt; &lt;javax.servlet.jsp-version&gt;2.3.3&lt;/javax.servlet.jsp-version&gt; &lt;javax.servlet.jsp.jstl-version&gt;1.2&lt;/javax.servlet.jsp.jstl-version&gt; &lt;org.springframework-version&gt;5.2.2.RELEASE&lt;/org.springframework-version&gt; &lt;!-- &lt;org.springframework-version&gt;4.3.25.RELEASE&lt;/org.springframework-version&gt; --&gt; &lt;/properties&gt; &lt;!-- 라이브러리 셋팅 --&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet-version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet.jsp-version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet.jsp.jstl-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springMVCstep3&lt;/finalName&gt; &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;src/test/java&lt;/testSourceDirectory&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;configuration&gt; &lt;warSourceDirectory&gt;WebContent&lt;/warSourceDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;!-- 라이브러리 버전관리 --&gt;&lt;/project&gt; Web.xml 설정하기 톰캣 DispatcherServlet 을 스프링 DispatcherServlet 으로 바꾸기 Bean을 정의할 xml 파일을 정의하기 Listener 를 설정한다. 파라미터 인코더 를 설정한다. &lt;!-- 현재 웹 애플리케이션에서 받아들이는 모든 요청에 대해 appServlet이라는 이름으로 정의되어 있는 서블릿을 사용하겠다. --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- 요청 정보를 분석해서 컨트롤러를 선택하는 서블릿을 지정한다. --&gt;&lt;servlet&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;!-- Spring MVC에서 제공하고 있는 기본 서블릿을 지정한다. --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Spring MVC 설정을 위한 xml 파일을 지정한다. --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/config/servlet-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; &lt;!-- Bean을 정의할 xml 파일을 지정한다. --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/config/root-context.xml&lt;/param-value&gt;&lt;/context-param&gt; &lt;!-- 리스너설정 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;","text":"스프링 MVC 시작하기 - XML로 세팅하기 Web.xml 설정하기 root-context.xml 설정하기 servlet-context 설정하기 의존관계 설정하기&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springMVCstep3&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;javax.servlet-version&gt;4.0.1&lt;/javax.servlet-version&gt; &lt;javax.servlet.jsp-version&gt;2.3.3&lt;/javax.servlet.jsp-version&gt; &lt;javax.servlet.jsp.jstl-version&gt;1.2&lt;/javax.servlet.jsp.jstl-version&gt; &lt;org.springframework-version&gt;5.2.2.RELEASE&lt;/org.springframework-version&gt; &lt;!-- &lt;org.springframework-version&gt;4.3.25.RELEASE&lt;/org.springframework-version&gt; --&gt; &lt;/properties&gt; &lt;!-- 라이브러리 셋팅 --&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet-version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet.jsp-version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet.jsp.jstl-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springMVCstep3&lt;/finalName&gt; &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;src/test/java&lt;/testSourceDirectory&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;configuration&gt; &lt;warSourceDirectory&gt;WebContent&lt;/warSourceDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;!-- 라이브러리 버전관리 --&gt;&lt;/project&gt; Web.xml 설정하기 톰캣 DispatcherServlet 을 스프링 DispatcherServlet 으로 바꾸기 Bean을 정의할 xml 파일을 정의하기 Listener 를 설정한다. 파라미터 인코더 를 설정한다. &lt;!-- 현재 웹 애플리케이션에서 받아들이는 모든 요청에 대해 appServlet이라는 이름으로 정의되어 있는 서블릿을 사용하겠다. --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- 요청 정보를 분석해서 컨트롤러를 선택하는 서블릿을 지정한다. --&gt;&lt;servlet&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;!-- Spring MVC에서 제공하고 있는 기본 서블릿을 지정한다. --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Spring MVC 설정을 위한 xml 파일을 지정한다. --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/config/servlet-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; &lt;!-- Bean을 정의할 xml 파일을 지정한다. --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/config/root-context.xml&lt;/param-value&gt;&lt;/context-param&gt; &lt;!-- 리스너설정 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; &lt;!-- 파라미터 인코딩 필터 설정 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;4.0&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;&gt; &lt;!-- 요청 정보를 분석해서 컨트롤러를 선택하는 서블릿을 지정한다. --&gt; &lt;servlet&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;!-- Spring MVC에서 제공하고 있는 기본 서블릿을 지정한다. --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Spring MVC 설정을 위한 xml 파일을 지정한다. --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/config/servlet-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 현재 웹 애플리케이션에서 받아들이는 모든 요청에 대해 appServlet이라는 이름으로 정의되어 있는 서블릿을 사용하겠다. --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- Bean을 정의할 xml 파일을 지정한다. --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/config/root-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 리스너설정 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 파라미터 인코딩 필터 설정 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; root-context.xml 설정하기&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; servlet-context 설정하기 어노테이션을 가진 클래스들을 Bean으로 등록 Component들을 Scan할 위치를 지정한다. View경로를 위한 prefix, suffix를 지정한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring 5","slug":"Spring/Spring-5","permalink":"https://ckck803.github.io/categories/Spring/Spring-5/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 21 - 젠킨스를 이용해 배포하기","slug":"spring/sample-board/board-21-jenkins-deploy","date":"2021-03-01T15:13:12.000Z","updated":"2024-02-26T15:50:12.154Z","comments":true,"path":"2021/03/02/spring/sample-board/board-21-jenkins-deploy/","link":"","permalink":"https://ckck803.github.io/2021/03/02/spring/sample-board/board-21-jenkins-deploy/","excerpt":"21. 젠킨스를 이용해 배포하기플러그인 설치Jenkins 관리 &gt; 플러그인 관리 Publish Over SSH를 설치해준다. 원격 서버 접속 설정하기","text":"21. 젠킨스를 이용해 배포하기플러그인 설치Jenkins 관리 &gt; 플러그인 관리 Publish Over SSH를 설치해준다. 원격 서버 접속 설정하기","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 20 - 프록시 서버 이용하기","slug":"spring/sample-board/board-20-nginx","date":"2021-03-01T05:07:30.000Z","updated":"2024-02-26T15:48:03.781Z","comments":true,"path":"2021/03/01/spring/sample-board/board-20-nginx/","link":"","permalink":"https://ckck803.github.io/2021/03/01/spring/sample-board/board-20-nginx/","excerpt":"20. 프록시 서버 이용하기현재는 client 가 Web Application에 접근하기 위해서는 8080포트를 사용해야 한다. client가 쉽게 접근 할 수 있도록 80번 포트로 어플리케이션을 띄어야 하는데 ubuntu에서는 일반 사용자가 80번 포트를 사용할 수 있는 권한이 없다. 만약 80번 포트로 프로그램을 실행하게 되면 아래와 같은 권한 오류가 뜨게 된다. 그렇다고 어플리케이션을 띄울 때 마다 매번 sudo권한으로 실행시킬 수도 없는 노릇이다. 맥에서는 80번 포트로 잘 열리는데 우분투에서 오류가 떠서 당황 했다. 우분투에서 1024미만 포트는 일반 사용자가 사용할 수 없는 포트이다. Caused by: java.net.SocketException: Permission denied at java.base/sun.nio.ch.Net.bind0(Native Method) ~[na:na] at java.base/sun.nio.ch.Net.bind(Net.java:455) ~[na:na] at java.base/sun.nio.ch.Net.bind(Net.java:447) ~[na:na] at java.base/sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:227) ~[na:na] at java.base/sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:80) ~[na:na] at org.apache.tomcat.util.net.NioEndpoint.initServerSocket(NioEndpoint.java:228) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.tomcat.util.net.NioEndpoint.bind(NioEndpoint.java:211) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.tomcat.util.net.AbstractEndpoint.bindWithCleanup(AbstractEndpoint.java:1159) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.tomcat.util.net.AbstractEndpoint.start(AbstractEndpoint.java:1245) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.coyote.AbstractProtocol.start(AbstractProtocol.java:603) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.catalina.connector.Connector.startInternal(Connector.java:1064) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] ... 29 common frames omitted nginx를 이용해 프록시 서버 만들어주기80번 포트를 사용하기 위해 Proxy 서버를 띄어 놓고 Proxy 서버로 요청이 들어오면 Spring Boot 프로그램으로 Forwarding 해주도록 설정을 할 것이다. sudo 명령어를 사용해 프로그램을 시키는 방법도 있지만, 매번하기에는 번거롭다는 단점도 있고 &#x2F;etc&#x2F;sudoers에 패스워드 권한을 풀어줄 수도 있지만 보안상의 문제가 있어서 가장 안전한 방법으로 Proxy 서버를 이용하기로 했다. nginx 설치하기","text":"20. 프록시 서버 이용하기현재는 client 가 Web Application에 접근하기 위해서는 8080포트를 사용해야 한다. client가 쉽게 접근 할 수 있도록 80번 포트로 어플리케이션을 띄어야 하는데 ubuntu에서는 일반 사용자가 80번 포트를 사용할 수 있는 권한이 없다. 만약 80번 포트로 프로그램을 실행하게 되면 아래와 같은 권한 오류가 뜨게 된다. 그렇다고 어플리케이션을 띄울 때 마다 매번 sudo권한으로 실행시킬 수도 없는 노릇이다. 맥에서는 80번 포트로 잘 열리는데 우분투에서 오류가 떠서 당황 했다. 우분투에서 1024미만 포트는 일반 사용자가 사용할 수 없는 포트이다. Caused by: java.net.SocketException: Permission denied at java.base/sun.nio.ch.Net.bind0(Native Method) ~[na:na] at java.base/sun.nio.ch.Net.bind(Net.java:455) ~[na:na] at java.base/sun.nio.ch.Net.bind(Net.java:447) ~[na:na] at java.base/sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:227) ~[na:na] at java.base/sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:80) ~[na:na] at org.apache.tomcat.util.net.NioEndpoint.initServerSocket(NioEndpoint.java:228) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.tomcat.util.net.NioEndpoint.bind(NioEndpoint.java:211) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.tomcat.util.net.AbstractEndpoint.bindWithCleanup(AbstractEndpoint.java:1159) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.tomcat.util.net.AbstractEndpoint.start(AbstractEndpoint.java:1245) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.coyote.AbstractProtocol.start(AbstractProtocol.java:603) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.catalina.connector.Connector.startInternal(Connector.java:1064) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] ... 29 common frames omitted nginx를 이용해 프록시 서버 만들어주기80번 포트를 사용하기 위해 Proxy 서버를 띄어 놓고 Proxy 서버로 요청이 들어오면 Spring Boot 프로그램으로 Forwarding 해주도록 설정을 할 것이다. sudo 명령어를 사용해 프로그램을 시키는 방법도 있지만, 매번하기에는 번거롭다는 단점도 있고 &#x2F;etc&#x2F;sudoers에 패스워드 권한을 풀어줄 수도 있지만 보안상의 문제가 있어서 가장 안전한 방법으로 Proxy 서버를 이용하기로 했다. nginx 설치하기sudo apt-get install nginx nginx 실행sudo service nginx start 프로그램을 실행행한 후 80번 포트로 접속하게 되면 환영한다는 nginx 페이지가 보인다. nginx 설정 확인하기nignx의 기본적인 설정은 nginx.conf파일에 저장돼 있다. 마지막 부분을 보면 conf.d폴더에 nginx에 추가적인 설정 정보를 불러오게 하는 설정이 있다. 여기에 80번 요청이 들어오면 8080포트로 포워딩 할 수 있게 설정 파일을 만들어 주도록한다. 설정 파일을 살펴보면 conf.d 디렉터리와 sites-enabled(sites-available) 디렉터리 내의 구성을 읽어오는 부분이 있다.sites-enabled에는 nginx에 대한 기본 설정값이 있다. 둘 중 아무곳에나 설정 값을 넣어도 되지만, 설정과 관련된 부분이라 conf.d 디렉터리에 저장하도록 했다. &#x2F;etc&#x2F;nginx&#x2F;nginx.conf http &#123; ... include /etc/nginx/conf.d/*.conf; # include /etc/nginx/sites-enabled/*; 덮어쓰기를 방지하기 위한 주석 처리&#125; &#x2F;etc&#x2F;nginx&#x2F;conf.d 폴더로 이동해 포트 포워딩 설정을 위한 server.conf파일을 생성한다.nginx listen 포트로는 80번 포트를 사용하고 해당 url로 들어오는 모든 요청을 8080포트로 보내주는 설정을 추가한다. proxy_set_header X-Real-Ip $remote_addr : X-Real-Ip 헤더 값으로 Client의 IP값을 넣어준다.proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for : X-Forwarded-For 헤더 값으로 포워딩 된 프록시 서버의 IP값을 넣어준다.proxy_set_header Host $http_host : Host 헤더에는 서버의 주소 or 도메인을 넣어준다. (도메인 정보를 매핑하고 싶을 때도 사용) &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;server.conf server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://localhost:8080; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; &#125;&#125; 80번 포트로 접근 했을 때 8080포트에 떠있는 Web Application이 나타나는 것을 확인할 수 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 19 - Build시 DB 연결 Bug Fix 및 Profile 설정","slug":"spring/sample-board/board-19-profile","date":"2021-02-25T23:03:09.000Z","updated":"2024-02-26T15:47:47.632Z","comments":true,"path":"2021/02/26/spring/sample-board/board-19-profile/","link":"","permalink":"https://ckck803.github.io/2021/02/26/spring/sample-board/board-19-profile/","excerpt":"19. Build시 DB 연결 Bug Fix 및 Profile 설정Jenkins에서 build 오류Jenkins에서 Build를 진행하면 Test시 해당 오류가 발생하게 된다. Test를 진행하면서 DBConfigByYml 클래스내 필드를 Application-mysql.yml 를 이용해 채우게 되는데 Application-mysql.yml 파일이 Github에는 올라가 있지 않아 문제가 생기게 되는 것이다. &gt; Task :testSampleBoardApplicationTests &gt; contextLoads() FAILED java.lang.IllegalStateException at DefaultCacheAwareContextLoaderDelegate.java:132 Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException at ConstructorResolver.java:800 Caused by: org.springframework.beans.factory.BeanCreationException at AutowiredAnnotationBeanPostProcessor.java:405 Caused by: java.lang.IllegalArgumentException at PropertyPlaceholderHelper.java:1782021-02-24 16:17:02.458 INFO 1610 --- [extShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService &#x27;applicationTaskExecutor&#x27;17 tests completed, 1 failed&gt; Task :test FAILEDFAILURE: Build failed with an exception.* What went wrong:Execution failed for task &#x27;:test&#x27;.&gt; There were failing tests. See the report at: file:///var/jenkins_home/workspace/sample-board/build/reports/tests/test/index.html* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 53s7 actionable tasks: 7 executedBuild step &#x27;Invoke Gradle script&#x27; changed build result to FAILUREBuild step &#x27;Invoke Gradle script&#x27; marked build as failureFinished: FAILURE 여러개의 @PropertySource 사용하기첫번째로 해결한 방법은 @PropertySource를 두개 사용하여 test를 진행할 시에는 H2 database를 바라보게 하고 운영시에는 MySQL을 바라 볼 수 있게 설정 파일을 두게 만들어 사용했다. @PropertySource는 순서에 따라 아래 값이 이전 값을 덮어 쓰게 된다. DBConfigByYml.java @Configuration@PropertySource(value = &quot;classpath:application-h2.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)@PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)public class DBConfigByYml &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource() &#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125;&#125; 여러개의 PropertySource 묶기","text":"19. Build시 DB 연결 Bug Fix 및 Profile 설정Jenkins에서 build 오류Jenkins에서 Build를 진행하면 Test시 해당 오류가 발생하게 된다. Test를 진행하면서 DBConfigByYml 클래스내 필드를 Application-mysql.yml 를 이용해 채우게 되는데 Application-mysql.yml 파일이 Github에는 올라가 있지 않아 문제가 생기게 되는 것이다. &gt; Task :testSampleBoardApplicationTests &gt; contextLoads() FAILED java.lang.IllegalStateException at DefaultCacheAwareContextLoaderDelegate.java:132 Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException at ConstructorResolver.java:800 Caused by: org.springframework.beans.factory.BeanCreationException at AutowiredAnnotationBeanPostProcessor.java:405 Caused by: java.lang.IllegalArgumentException at PropertyPlaceholderHelper.java:1782021-02-24 16:17:02.458 INFO 1610 --- [extShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService &#x27;applicationTaskExecutor&#x27;17 tests completed, 1 failed&gt; Task :test FAILEDFAILURE: Build failed with an exception.* What went wrong:Execution failed for task &#x27;:test&#x27;.&gt; There were failing tests. See the report at: file:///var/jenkins_home/workspace/sample-board/build/reports/tests/test/index.html* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 53s7 actionable tasks: 7 executedBuild step &#x27;Invoke Gradle script&#x27; changed build result to FAILUREBuild step &#x27;Invoke Gradle script&#x27; marked build as failureFinished: FAILURE 여러개의 @PropertySource 사용하기첫번째로 해결한 방법은 @PropertySource를 두개 사용하여 test를 진행할 시에는 H2 database를 바라보게 하고 운영시에는 MySQL을 바라 볼 수 있게 설정 파일을 두게 만들어 사용했다. @PropertySource는 순서에 따라 아래 값이 이전 값을 덮어 쓰게 된다. DBConfigByYml.java @Configuration@PropertySource(value = &quot;classpath:application-h2.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)@PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)public class DBConfigByYml &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource() &#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125;&#125; 여러개의 PropertySource 묶기PropertySources 어노테이션을 사용하면 여러개의 PropertySource를 묶을 수 있다. @PropertySources(&#123; @PropertySource(value = &quot;classpath:application-h2.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true), @PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)&#125;) Profile 어노테이션을 이용한 방법두번째로 해결한 방법은 Profile 어노테이션을 사용해 운영시에만 설정을 구성하도록 했다. 운영외에는 MySQL 설정을 구성하지 않도록 해 오류가 발생하지 않게 했다. DBConfigByYml.java @Configuration@Profile(&quot;prod&quot;)@PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)public class DBConfigByYml &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource() &#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 18 - 외부로부터 설정 받기(yml)","slug":"spring/sample-board/board-18-yml","date":"2021-02-24T12:34:39.000Z","updated":"2024-02-26T15:47:44.028Z","comments":true,"path":"2021/02/24/spring/sample-board/board-18-yml/","link":"","permalink":"https://ckck803.github.io/2021/02/24/spring/sample-board/board-18-yml/","excerpt":"18. 외부로부터 설정 받기(yml)YamlPropertySourceFactory.java public class YamlPropertySourceFactory implements PropertySourceFactory &#123; @Override public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123; Properties propertiesFromYaml = loadYamlIntoProperties(resource); String sourceName = name != null ? name : resource.getResource().getFilename(); return new PropertiesPropertySource(sourceName, propertiesFromYaml); &#125; private Properties loadYamlIntoProperties(EncodedResource resource) throws FileNotFoundException &#123; try &#123; YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean(); factory.setResources(resource.getResource()); factory.afterPropertiesSet(); return factory.getObject(); &#125; catch (IllegalStateException e) &#123; // for ignoreResourceNotFound Throwable cause = e.getCause(); if (cause instanceof FileNotFoundException) &#123; throw (FileNotFoundException) e.getCause(); &#125; throw e; &#125; &#125;&#125; DBConfigByYml.java @Configuration@PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class)public class DBConfigByYml &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125;&#125;","text":"18. 외부로부터 설정 받기(yml)YamlPropertySourceFactory.java public class YamlPropertySourceFactory implements PropertySourceFactory &#123; @Override public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123; Properties propertiesFromYaml = loadYamlIntoProperties(resource); String sourceName = name != null ? name : resource.getResource().getFilename(); return new PropertiesPropertySource(sourceName, propertiesFromYaml); &#125; private Properties loadYamlIntoProperties(EncodedResource resource) throws FileNotFoundException &#123; try &#123; YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean(); factory.setResources(resource.getResource()); factory.afterPropertiesSet(); return factory.getObject(); &#125; catch (IllegalStateException e) &#123; // for ignoreResourceNotFound Throwable cause = e.getCause(); if (cause instanceof FileNotFoundException) &#123; throw (FileNotFoundException) e.getCause(); &#125; throw e; &#125; &#125;&#125; DBConfigByYml.java @Configuration@PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class)public class DBConfigByYml &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 17 - 외부로부터 설정 받기(property)","slug":"spring/sample-board/board-17-properties","date":"2021-02-24T10:31:58.000Z","updated":"2024-02-26T15:47:39.672Z","comments":true,"path":"2021/02/24/spring/sample-board/board-17-properties/","link":"","permalink":"https://ckck803.github.io/2021/02/24/spring/sample-board/board-17-properties/","excerpt":"17. 외부로부터 설정 받기(property)Github에 프로젝트를 올릴때 데이터 베이스 접속 연결과 같은 민감한 정보는 다른 사람이 열람해서는 안되는 정보라 형상관리에서 제외한 상태로 올리게 된다. .gitignore **/application-mysql.yml**/application-mysql.properties 데이터베이스 접속을 위한 properties 만들기application-mysql.properties spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/&#123;테이블&#125;serverTimezone=UTC&amp;characterEncoding=UTF-8spring.datasource.username=&#123;Username&#125;spring.datasource.password=&#123;Password&#125; TransactionManagementConfigurer은 Spring에서 데티어베이스 연결을 지원한다. DBConfig.java","text":"17. 외부로부터 설정 받기(property)Github에 프로젝트를 올릴때 데이터 베이스 접속 연결과 같은 민감한 정보는 다른 사람이 열람해서는 안되는 정보라 형상관리에서 제외한 상태로 올리게 된다. .gitignore **/application-mysql.yml**/application-mysql.properties 데이터베이스 접속을 위한 properties 만들기application-mysql.properties spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/&#123;테이블&#125;serverTimezone=UTC&amp;characterEncoding=UTF-8spring.datasource.username=&#123;Username&#125;spring.datasource.password=&#123;Password&#125; TransactionManagementConfigurer은 Spring에서 데티어베이스 연결을 지원한다. DBConfig.java @Configuration@PropertySource(value = &quot;classpath:/application-mysql.properties&quot;)public class DBConfig implements TransactionManagementConfigurer &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125; @Override public TransactionManager annotationDrivenTransactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"스프링 핵심 원리4 - 싱글톤 컨테이너","slug":"spring/spring-core/basic/basic4-singleton","date":"2021-02-22T14:45:34.000Z","updated":"2024-03-04T10:44:12.496Z","comments":true,"path":"2021/02/22/spring/spring-core/basic/basic4-singleton/","link":"","permalink":"https://ckck803.github.io/2021/02/22/spring/spring-core/basic/basic4-singleton/","excerpt":"스프링 핵심 원리4 - 싱글톤 컨테이너","text":"스프링 핵심 원리4 - 싱글톤 컨테이너","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Core","slug":"Spring/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring/Spring-Core/"}],"tags":[]},{"title":"스프링 핵심 원리 이해 - 객체 지향 원리 적용","slug":"spring/spring-core/basic/basic2","date":"2021-02-20T07:58:27.000Z","updated":"2024-03-04T10:44:08.949Z","comments":true,"path":"2021/02/20/spring/spring-core/basic/basic2/","link":"","permalink":"https://ckck803.github.io/2021/02/20/spring/spring-core/basic/basic2/","excerpt":"목차 Post not found: spring-boot/spring-core/basic/basic2 객체 지향 설계 5원칙 SOLID DIP 원칙 위반 - 추상화와 구체화 둘다 의존MemberServiceImpl 클래스는 MemberRepository 인터페이스를 의존하면서 구현 클래스인 MemoryMemberRepository도 의존하고 있다. public class MemberServiceImpl implements MemberService&#123; // MemberServiceImpl 클래스는 MemberRepository 인터페이스와 구현체인 MemoryMemberRepository 둘다 의존하고 있다. private final MemberRepository memberRepository = new MemoryMemberRepository(); @Override public void join(Member member) &#123; memberRepository.save(member); &#125; @Override public Member findMember(Long memberId) &#123; return memberRepository.findById(memberId); &#125;&#125; OrderServiceImpl 클래스는 MemberRepository 인터페이스와 DiscountPolicy 인터페이스를 의존하면서 구현 클래스인 MemoryMemberRepository 와 RateDiscountPolicy 를 의존하고 있다. 추상화와 구체화 둘다 의존하는 문제가 있다.–&gt; DIP 위반 DIP의 원칙을 지키기 위해 의존 class내에서 구현 클래스를 가져오는 부분을 삭제하게 되면 객체가 존재하지 않아서 nullPointException이 발생한다. public class OrderServiceImpl implements OrderService &#123; // OrderServiceImpl 클래스는 MemberRepository 인터페이스와 구현체인 MemoryMemberRepository // DiscountPolicy 인터페이스와 구현체인 RateDiscountPolicy 를 의존하는 문제점이 있다. private final MemberRepository memberRepository = new MemoryMemberRepository(); private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); @Override public Order createOrder(Long memberId, String itemName, int itemPrice) &#123; Member member = memberRepository.findById(memberId); int discountPrice = discountPolicy.discount(member, itemPrice); return new Order(memberId, itemName, itemPrice, discountPrice); &#125;&#125;","text":"목차 Post not found: spring-boot/spring-core/basic/basic2 객체 지향 설계 5원칙 SOLID DIP 원칙 위반 - 추상화와 구체화 둘다 의존MemberServiceImpl 클래스는 MemberRepository 인터페이스를 의존하면서 구현 클래스인 MemoryMemberRepository도 의존하고 있다. public class MemberServiceImpl implements MemberService&#123; // MemberServiceImpl 클래스는 MemberRepository 인터페이스와 구현체인 MemoryMemberRepository 둘다 의존하고 있다. private final MemberRepository memberRepository = new MemoryMemberRepository(); @Override public void join(Member member) &#123; memberRepository.save(member); &#125; @Override public Member findMember(Long memberId) &#123; return memberRepository.findById(memberId); &#125;&#125; OrderServiceImpl 클래스는 MemberRepository 인터페이스와 DiscountPolicy 인터페이스를 의존하면서 구현 클래스인 MemoryMemberRepository 와 RateDiscountPolicy 를 의존하고 있다. 추상화와 구체화 둘다 의존하는 문제가 있다.–&gt; DIP 위반 DIP의 원칙을 지키기 위해 의존 class내에서 구현 클래스를 가져오는 부분을 삭제하게 되면 객체가 존재하지 않아서 nullPointException이 발생한다. public class OrderServiceImpl implements OrderService &#123; // OrderServiceImpl 클래스는 MemberRepository 인터페이스와 구현체인 MemoryMemberRepository // DiscountPolicy 인터페이스와 구현체인 RateDiscountPolicy 를 의존하는 문제점이 있다. private final MemberRepository memberRepository = new MemoryMemberRepository(); private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); @Override public Order createOrder(Long memberId, String itemName, int itemPrice) &#123; Member member = memberRepository.findById(memberId); int discountPrice = discountPolicy.discount(member, itemPrice); return new Order(memberId, itemName, itemPrice, discountPrice); &#125;&#125; OCP 원칙 위반 - 정책 변경시 client 코드를 수정DiscountPolicy 의 구현체가 FixDiscountPolicy 에서 RateDiscountPolicy 로 바뀌게 되면 OrderServiceImpl 에서 FixDiscountPolicy를 RateDiscountPolicy로 변경하기 위해서 코드를 수정해줘야 한다. 구현 객체를 변경하기 위해서 클라이언트 코드를 변경–&gt; OCP 위반 OrderServiceImpl.java public class OrderServiceImpl implements OrderService &#123; private final MemberRepository memberRepository = new MemoryMemberRepository(); // FixDiscountPolicy 에서 RateDiscountPolicy 로 구현체를 변경하기 위해서는 Client 코드를 변경해야 하는 문제점이 있다. // private final DiscountPolicy discountPolicy = new FixDiscountPolicy(); private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); @Override public Order createOrder(Long memberId, String itemName, int itemPrice) &#123; Member member = memberRepository.findById(memberId); int discountPrice = discountPolicy.discount(member, itemPrice); return new Order(memberId, itemName, itemPrice, discountPrice); &#125;&#125; 객체의 생성 및 연결과 실행하는 부분을 분리애플리케이션의 전체 동작방식을 구성하기 위해 구현 객체 생성 및 연결 을 위한 별도의 설정 class 를 만들어준다. 관심사의 분리가 이루어지게 됐다.–&gt; 객체 생성 및 연결과 실행하는 부분의 logic이 분리가 됐다. AppConfig 클래스 내의 memberService 메소드는 MemberService의 구현체인 MemberServiceImpl를 반환한다.MemberServiceImpl 객체를 생성할 때 MemberRepository의 구현체인 MemoryMemberRepository 객체를 주입해준다. MemberServiceImpl 생성자를 통해 MemoryMemberRepository 객체를 주입해주는 것을 생성자를 통한 의존성 주입이라 한다. AppConfig.java public class AppConfig &#123; // memberService 메소드에서 MemberServiceImpl 객체 생성 및 MemberRepository 객체에 대한 의존성 주입을 해준다. // 의존성 주입시 인터페이스 및 추상 클래스에 대한 구현 객체가 들어가기 된다. MemoryMemberRepository public MemberService memberService()&#123; return new MemberServiceImpl(new MemoryMemberRepository()); &#125; // orderService 메소드에서 OrderServiceImpl 객체 생성 및 MemberRepository 객체와 DiscountPolicy 객체에 대한 의존성 주입을 한다. public OrderService orderService()&#123; return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy()); &#125;&#125; 의존성을 주입 받기 위한 방법으로 생성자를 만들어 줬다. MemberServiceImpl 는 객체 생성시 외부로부터 MemberRepository 에 대한 의존성을 주입 받게 된다. MemberRepository 에 대한 구현 클래스 관리는 더 이상 MemberServiceImpl 에서 관리하지 않고 외부에서 관리하게 됐다. MemberServiceImpl 는 이제 MemberRepository 인터페이스에만 의존하게 되므로 DIP 원칙을 지키게 됐다. MemberServiceImpl.java public class MemberServiceImpl implements MemberService&#123; private final MemberRepository memberRepository; public MemberServiceImpl(MemberRepository memberRepository)&#123; this.memberRepository = memberRepository; &#125; @Override public void join(Member member) &#123; memberRepository.save(member); &#125; @Override public Member findMember(Long memberId) &#123; return memberRepository.findById(memberId); &#125;&#125; OrderServiceImpl 클래스 역시 객체 셍성시 의존 객체를 주입 받기 위해 생성자를 만들어 줬다. OrderServiceImpl 객체 셍성시 MemberRepository 와 DiscountPolicy 에 대한 구현 클래스를 주입 받게 된다. OrderServiceImpl 클래스 내에서 구현 클래스를 곤리하는 부분이 없어졌으므로 DIP 원칙 을 지키게 됐다. OrderServiceImpl.java public class OrderServiceImpl implements OrderService &#123; private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy)&#123; this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; &#125; @Override public Order createOrder(Long memberId, String itemName, int itemPrice) &#123; Member member = memberRepository.findById(memberId); int discountPrice = discountPolicy.discount(member, itemPrice); return new Order(memberId, itemName, itemPrice, discountPrice); &#125;&#125; MemberServiceImpl와 OrderServiceImpl는 인터페이스에만 의존하게 함으로 코드상으로는 어떤 구현 객체가 들어올지는 알 수 없고, 생성자를 통해 외부에서 구현객체를 주입 받게 된다. AppConfig를 통해 객체의 생성과 연결을 진행 하고MemberServiceImpl와 OrderServiceImpl는 실행만 하면 되므로 역할이 분리가 됐다.또한 외부에서 MemberServiceImpl와 OrderServiceImpl에 구현객체를 넣어주는 것을 보고 의존성 주입이라 한다. AppConfig 리펙터링AppConfig.java public class AppConfig &#123; public MemberService memberService()&#123; return new MemberServiceImpl(memberRepository()); &#125; private MemberRepository memberRepository() &#123; return new MemoryMemberRepository(); &#125; public OrderService orderService()&#123; return new OrderServiceImpl(memberRepository(), discountPolicy()); &#125; private DiscountPolicy discountPolicy() &#123; return new FixDiscountPolicy(); &#125;&#125; 메소드명과 return 타입을 통해 역할을 할 수 있게 됐고, 반환 객체를 통해 구현 객체를 알기 쉽게 됐다. 구현 객체 변경AppConfig.java public class AppConfig &#123; public MemberService memberService()&#123; return new MemberServiceImpl(memberRepository()); &#125; private MemberRepository memberRepository() &#123; return new MemoryMemberRepository(); &#125; public OrderService orderService()&#123; return new OrderServiceImpl(memberRepository(), discountPolicy()); &#125; private DiscountPolicy discountPolicy() &#123;// return new FixDiscountPolicy(); return new RateDiscountPolicy(); &#125;&#125; 구현 객체를 변경하게 되면 AppConfig만 변경하면 된다. AppConfig의 등장으로 구현 객체들은 자신의 로직을 실행하는 역할만 담당하게 됐다. 프로그램의 제어 흐름은 이제 AppConfig에서 담당한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Core","slug":"Spring/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring/Spring-Core/"}],"tags":[]},{"title":"Spring Boot - 독립적으로 실행 가능한 JAR","slug":"spring/spring-framework/springboot-jar","date":"2021-02-18T16:05:00.000Z","updated":"2024-02-26T16:06:26.746Z","comments":true,"path":"2021/02/19/spring/spring-framework/springboot-jar/","link":"","permalink":"https://ckck803.github.io/2021/02/19/spring/spring-framework/springboot-jar/","excerpt":"독립적으로 실행 가능한 JAR앱을 어딘가에 배포하거나 도커 이미지로 만들거나 하기 위해서는 jar패키지로 패키징한 후 jar파일을 실행하는게 유용하다. jar파일 생성mvn package mvn pakcage명령어를 통해 앱을 jar파일로 생성한다. jar파일이 생성됨을 확인할 수 있다. jar파일 안에는 앱을 실행하기 위한 의존성(library)들이 전부 다 포함되어 있다. jar 파일 실행java -jar springinit-1.0-SNAPSHOT.jar","text":"독립적으로 실행 가능한 JAR앱을 어딘가에 배포하거나 도커 이미지로 만들거나 하기 위해서는 jar패키지로 패키징한 후 jar파일을 실행하는게 유용하다. jar파일 생성mvn package mvn pakcage명령어를 통해 앱을 jar파일로 생성한다. jar파일이 생성됨을 확인할 수 있다. jar파일 안에는 앱을 실행하기 위한 의존성(library)들이 전부 다 포함되어 있다. jar 파일 실행java -jar springinit-1.0-SNAPSHOT.jar java -jar명령어를 통해 jar파일을 실행할 수 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring/Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/Spring-Framework/"}],"tags":[]},{"title":"Spring Boot - 내장 웹 서버 응용 2부(HTTPS와 HTTP2)","slug":"spring/spring-framework/springboot-http2","date":"2021-02-18T16:01:22.000Z","updated":"2024-02-26T16:06:07.877Z","comments":true,"path":"2021/02/19/spring/spring-framework/springboot-http2/","link":"","permalink":"https://ckck803.github.io/2021/02/19/spring/spring-framework/springboot-http2/","excerpt":"내장 웹 서버 응용 2부 : HTTPS와 HTTP2https를 사용하기 위해서는 키스토어가 필요하다. 키스토어 생성# 저는 줄 바꿈 문자 해결 했습니당 ^^keytool -genkey \\ -alias tomcat \\ -storetype PKCS12 \\ -keyalg RSA \\ -keysize 2048 \\ -keystore keystore.p12 \\ -validity 4000 위 명령어를 사용하여 키 스토어를 생성할 수 있다. 키 저장소 비밀번호 입력:새 비밀번호 다시 입력:이름과 성을 입력하십시오. [Unknown]: dongwoo yang조직 단위 이름을 입력하십시오. [Unknown]: island조직 이름을 입력하십시오. [Unknown]: ceo구/군/시 이름을 입력하십시오? [Unknown]: seongbuk시/도 이름을 입력하십시오. [Unknown]: seoul이 조직의 두 자리 국가 코드를 입력하십시오. [Unknown]: krCN=dongwoo yang, OU=island, O=ceo, L=seongbuk, ST=seoul, C=kr이(가) 맞습니까? [아니오]: 예 해당 질문들이 나오는데, 마지막에 “네” 혹은 “yes”를 하게 되면 무한루프에 빠지게 된다….. 예라고 꼭!!!! 적어주도록…. key를 생성하게 된 다음에 git을 사용하고 있는 중이라면 꼭!!! gitignore에 추가하자!!! 키스토어 사용을 위한 세팅해주기","text":"내장 웹 서버 응용 2부 : HTTPS와 HTTP2https를 사용하기 위해서는 키스토어가 필요하다. 키스토어 생성# 저는 줄 바꿈 문자 해결 했습니당 ^^keytool -genkey \\ -alias tomcat \\ -storetype PKCS12 \\ -keyalg RSA \\ -keysize 2048 \\ -keystore keystore.p12 \\ -validity 4000 위 명령어를 사용하여 키 스토어를 생성할 수 있다. 키 저장소 비밀번호 입력:새 비밀번호 다시 입력:이름과 성을 입력하십시오. [Unknown]: dongwoo yang조직 단위 이름을 입력하십시오. [Unknown]: island조직 이름을 입력하십시오. [Unknown]: ceo구/군/시 이름을 입력하십시오? [Unknown]: seongbuk시/도 이름을 입력하십시오. [Unknown]: seoul이 조직의 두 자리 국가 코드를 입력하십시오. [Unknown]: krCN=dongwoo yang, OU=island, O=ceo, L=seongbuk, ST=seoul, C=kr이(가) 맞습니까? [아니오]: 예 해당 질문들이 나오는데, 마지막에 “네” 혹은 “yes”를 하게 되면 무한루프에 빠지게 된다….. 예라고 꼭!!!! 적어주도록…. key를 생성하게 된 다음에 git을 사용하고 있는 중이라면 꼭!!! gitignore에 추가하자!!! 키스토어 사용을 위한 세팅해주기 application.properties server.ssl.key-store=keystore.p12server.ssl.key-store-type=PKCS12server.ssl.key-store-password=123456server.ssl.key-alias=tomcat Application.java @SpringBootApplication@RestControllerpublic class Application &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;Hello Spring&quot;; &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; localhost:8080으로 http 접속을 하게 되면 해당 결과를 받게 된다.이제부터 우리는 https를 이용하여 접속해야 한다. https://localhost:8080 형식으로 접속을 시도 하면 위의 문구가 뜨게 된다.(웹 브라우저마다 살짝 다르게 표시됨.) 이는 웹 브라우저가 public키를 가지고 있지 않기 때문에 이렇게 뜨는 것이다. 우리가 만든 인증서는 브라우저가 모르는 인증서이기 때문에 보안 문구가 뜨게 되는 것이다. (이젠 다음으로 넘어가는 것도 안되는 듯….) Curl 명령curl -I -k --http2 https://localhost:8080/hello Get 요청해보기curl -k -X GET --http2 https://localhost:8080/hello curl 명령어를 이용해 터미널 환경에서도 반환 값을 확인 할 수 있다. 결과HTTP/1.1 200Content-Type: text/plain;charset=UTF-8Content-Length: 12Date: Sun, 15 Mar 2020 16:50:14 GMT -I에 대한 요청 정보로 해더를 보여준다. Hello Spring Get요청에 대한 결과로 Hello Spring이 반환되었다. 커넥터 생성하기https를 사용하게 되면 더 이상 http를 사용할 수 없게 된다. HTTP 커넥터가 한개인데, 그 커넥터에 ssl을 적용함으로써 HTTPS로 사용하고 있기 때문이다. 만약 HTTP도 사용하고 싶으면 또 하나의 커넥터를 만들어 주어야 한다. Application.java에 내용 추가 ......@Beanpublic ServletWebServerFactory serverFactory()&#123; TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory(); tomcat.addAdditionalTomcatConnectors(createStandardConnector()); return tomcat;&#125;private Connector createStandardConnector()&#123; Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;); connector.setPort(8080); return connector;&#125; application.properties에 내용 추가 ......server.port=8443 HTTP연결의 경우 8080포트를 사용하게 되고, HTTPS연결의 경우는 8443포트를 사용하게 된다. HTTP2 활성화 하기 application.properties에 내용 추가 ...server.http2.enabled=true application.properties에 http2사용에 대한 설정을 추가해주고 각 servlet 컨테이너 마다 다른 설정을 해주어야 한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring/Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/Spring-Framework/"}],"tags":[]},{"title":"Spring Boot - 내장 웹 서버 응용 1부(컨테이너와 포트)","slug":"spring/spring-framework/springboot-webserver2","date":"2021-02-18T15:58:27.000Z","updated":"2024-02-26T16:06:47.546Z","comments":true,"path":"2021/02/19/spring/spring-framework/springboot-webserver2/","link":"","permalink":"https://ckck803.github.io/2021/02/19/spring/spring-framework/springboot-webserver2/","excerpt":"내장 웹 서버 응용 1부 : 컨테이너와 포트https://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-web-servers.html에 다른 서블릿 컨테이너를 사용하는 방법이 적혀져 있다. tomcat 빼기 일단, spring-boot-starter-web에 적재되어 있는 tomcat을 뺄 필요가 있다. &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 톰켓을 뺀 후 아무것도 추가하지 않으면 웹 어플리케이션으로 작동하지 않고 어플리케이션으로 작동하기 때문에 그냥 종료된다. 다른 컨테이너 추가하기Jetty","text":"내장 웹 서버 응용 1부 : 컨테이너와 포트https://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-web-servers.html에 다른 서블릿 컨테이너를 사용하는 방법이 적혀져 있다. tomcat 빼기 일단, spring-boot-starter-web에 적재되어 있는 tomcat을 뺄 필요가 있다. &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 톰켓을 뺀 후 아무것도 추가하지 않으면 웹 어플리케이션으로 작동하지 않고 어플리케이션으로 작동하기 때문에 그냥 종료된다. 다른 컨테이너 추가하기Jetty&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 새로운 서블릿 컨테이너로 jetty를 추가해 주었다. tomcat은 빠지고 jetty가 추가된 것을 볼 수 있다. 결과Jetty started on port(s) 8080 (http/1.1) with context path &#x27;/&#x27; 스프링 부트를 실행해 보면 Jetty가 실행된 것을 볼 수 있다. undertow&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt; 다른 서블릿 컨테이너로 undertow를 추가해봤다. properties를 사용하는 방법웹 어플리케이션 타입 끄기 application.properties spring.main.web-application-type=none spring.main.web-application-type에 none을 주게 되면 의존성이 있다고 해도 none web-application으로 작동을 하고 실행하고 바로 끝내게 된다. . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.5.RELEASE)2020-03-15 23:58:13.136 INFO 80825 --- [ main] com.example.Application : Starting Application on yangdong-uui-MacBookPro.local with PID 80825 (/Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_7/springbootgettingstarted/target/classes started by dongwoo-yang in /Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_7/springbootgettingstarted)2020-03-15 23:58:13.139 INFO 80825 --- [ main] com.example.Application : No active profile set, falling back to default profiles: default2020-03-15 23:58:13.724 INFO 80825 --- [ main] com.example.Application : Started Application in 0.919 seconds (JVM running for 1.529)Process finished with exit code 0 바로 종료가 됨을 확인할 수 있다. 포트 변경 하기 application.properties server.port=7070 7070포트로 변경하였다. 결과Undertow started on port(s) 7070 (http) with context path &#x27;&#x27; 8080(기본)포트에서 7070포트로 바뀐 것을 확인할 수 있따. 랜덤 포트server.port=0 포트번호로 0을 주게 되면 비어있는 포트를 선택해서 만들어준다. 실시간으로 포트정보 알아보기@Componentpublic class PortListener implements ApplicationListener&lt;ServletWebServerInitializedEvent&gt; &#123; @Override public void onApplicationEvent(ServletWebServerInitializedEvent event) &#123; // getApplicationContext()메소드를 이용하여 ApplicationContext를 얻는다. // ApplicationContext는 servlet ApplicationContext이기 때문 웹 서버를 알 수 있다. ServletWebServerApplicationContext applicationContext = event.getApplicationContext(); // 얻어진 웹서버를 통해 포트를 알아낼 수 있다. System.out.println(applicationContext.getWebServer().getPort()); &#125;&#125; ApplicationListner&lt;ServletWebServerInitializedEvent&gt;인터페이스를 구현함으로써 포트번호를 알아 낼 수 있다.ApplicationListner&lt;ServletWebServerInitializedEvent&gt;를 구현한 PortListener는 웹서버가 초기화가 되면 호출 된다. 이벤트 발생시 얻어진 ServletWebServerInitializedEvent인스턴스에 getApplicationContext()메소드를 이용하여 ApplicationContext객체를 얻어낼 수 있다. 얻어진 ApplicationContext객체는 servlet ApplicationContext 객체이므로 웹 서버를 알 수 있고 얻어진 웹 서버를 통해 포트를 알아낼 수 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring/Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/Spring-Framework/"}],"tags":[]},{"title":"Spring Boot - 내장 웹 서버 이해","slug":"spring/spring-framework/springboot-webserver","date":"2021-02-18T15:56:18.000Z","updated":"2024-02-26T16:06:42.147Z","comments":true,"path":"2021/02/19/spring/spring-framework/springboot-webserver/","link":"","permalink":"https://ckck803.github.io/2021/02/19/spring/spring-framework/springboot-webserver/","excerpt":"내장 웹 서버 이해내장 서버를 스프링 부트 없이 만들어 보기 springbootgetttingstarted public class Application &#123; public static void main(String[] args) throws LifecycleException &#123; // 톰캣 만들기 Tomcat tomcat = new Tomcat(); tomcat.setPort(8888); Context context = tomcat.addContext(&quot;/&quot;, &quot;/&quot;); // servlet 만들기 HttpServlet servlet = new HttpServlet()&#123; @Override // get요청에 관한 메소드 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // response 객체의 writer객체를 반환받아 // 응답으로 전해줄 servlet을 작성해준다. PrintWriter writer = resp.getWriter(); writer.println(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;); writer.println(&quot;Hey, Tomcat&quot;); writer.println(&quot;&lt;/title&gt;&lt;/head&gt;&quot;); writer.println(&quot;&lt;body&gt;&lt;h1&gt;Hello Tomcat&lt;/h1&gt;&lt;/body&gt;&quot;); writer.println(&quot;&lt;/html&gt;&quot;); &#125; &#125;; String servletName = &quot;helloServlet&quot;; // 톰켓에 서블릿을 추가해준 후 tomcat.addServlet(&quot;/&quot;, servletName, servlet); // /hello url과 해당 서블릿을 매핑 시켜준다. context.addServletMappingDecoded(&quot;/hello&quot;, servletName); tomcat.getConnector(); tomcat.start(); tomcat.getServer().await(); &#125;&#125; tomcat9부터는 tomcat.start()를 하기 전에 tomcat.getConnector()를 해야 실행이 된다. tomcat 객체를 생성 servlet 객체를 생성했다. 결과 스프링 부트에서는 위와 같은 설정을 AutoConfiguration에서 자동으로 잡아준다.","text":"내장 웹 서버 이해내장 서버를 스프링 부트 없이 만들어 보기 springbootgetttingstarted public class Application &#123; public static void main(String[] args) throws LifecycleException &#123; // 톰캣 만들기 Tomcat tomcat = new Tomcat(); tomcat.setPort(8888); Context context = tomcat.addContext(&quot;/&quot;, &quot;/&quot;); // servlet 만들기 HttpServlet servlet = new HttpServlet()&#123; @Override // get요청에 관한 메소드 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // response 객체의 writer객체를 반환받아 // 응답으로 전해줄 servlet을 작성해준다. PrintWriter writer = resp.getWriter(); writer.println(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;); writer.println(&quot;Hey, Tomcat&quot;); writer.println(&quot;&lt;/title&gt;&lt;/head&gt;&quot;); writer.println(&quot;&lt;body&gt;&lt;h1&gt;Hello Tomcat&lt;/h1&gt;&lt;/body&gt;&quot;); writer.println(&quot;&lt;/html&gt;&quot;); &#125; &#125;; String servletName = &quot;helloServlet&quot;; // 톰켓에 서블릿을 추가해준 후 tomcat.addServlet(&quot;/&quot;, servletName, servlet); // /hello url과 해당 서블릿을 매핑 시켜준다. context.addServletMappingDecoded(&quot;/hello&quot;, servletName); tomcat.getConnector(); tomcat.start(); tomcat.getServer().await(); &#125;&#125; tomcat9부터는 tomcat.start()를 하기 전에 tomcat.getConnector()를 해야 실행이 된다. tomcat 객체를 생성 servlet 객체를 생성했다. 결과 스프링 부트에서는 위와 같은 설정을 AutoConfiguration에서 자동으로 잡아준다. spring-boot-autoconfigure&#x2F;spring.factories ServletWebServerFactoryAutoConfiguration는 서블릿 웹 서버를 설정해주는 자동 설정이다.TomcatServletWebServerFactoryCustomizer을 통해 톰켓을 커스터 마이징 한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring/Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/Spring-Framework/"}],"tags":[]},{"title":"Spring Boot - 자동 설정 만들기 1부","slug":"spring/spring-framework/configuration/springboot-cutome-autoconfigure2","date":"2021-02-18T15:52:54.000Z","updated":"2024-02-26T15:53:34.637Z","comments":true,"path":"2021/02/19/spring/spring-framework/configuration/springboot-cutome-autoconfigure2/","link":"","permalink":"https://ckck803.github.io/2021/02/19/spring/spring-framework/configuration/springboot-cutome-autoconfigure2/","excerpt":"자동 설정 만들기 2부EnableAutoConfiguration이 불러오는 같은 Bean 무시하기 maplespringbootstarter 프로젝트 @Configurationpublic class HolomanConfiguration &#123; @Bean @ConditionalOnMissingBean public Holoman holoman()&#123; Holoman holoman = new Holoman(); holoman.setHowLong(5); holoman.setName(&quot;maple&quot;); return holoman; &#125;&#125; @ConditionalOnMissingBean을 사용하면 해당 Bean이 없는 경우에만 EnableAutoConfiguration을 통해 Bean이 추가 된다. 결과2020-03-15 21:31:49.936 INFO 67228 --- [ main] com.example.Application : Starting Application on yangdong-uui-MacBookPro.local with PID 67228 (/Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted/target/classes started by dongwoo-yang in /Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted)2020-03-15 21:31:49.938 INFO 67228 --- [ main] com.example.Application : No active profile set, falling back to default profiles: default2020-03-15 21:31:50.581 INFO 67228 --- [ main] com.example.Application : Started Application in 0.937 seconds (JVM running for 1.598)Holoman&#123;name=&#x27;동장군&#x27;, howLong=60&#125;Process finished with exit code 0 springbootgetttingstarted프로젝트의 Bean이 출력됨을 확인할 수 있다. application.properties를 이용한 방법","text":"자동 설정 만들기 2부EnableAutoConfiguration이 불러오는 같은 Bean 무시하기 maplespringbootstarter 프로젝트 @Configurationpublic class HolomanConfiguration &#123; @Bean @ConditionalOnMissingBean public Holoman holoman()&#123; Holoman holoman = new Holoman(); holoman.setHowLong(5); holoman.setName(&quot;maple&quot;); return holoman; &#125;&#125; @ConditionalOnMissingBean을 사용하면 해당 Bean이 없는 경우에만 EnableAutoConfiguration을 통해 Bean이 추가 된다. 결과2020-03-15 21:31:49.936 INFO 67228 --- [ main] com.example.Application : Starting Application on yangdong-uui-MacBookPro.local with PID 67228 (/Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted/target/classes started by dongwoo-yang in /Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted)2020-03-15 21:31:49.938 INFO 67228 --- [ main] com.example.Application : No active profile set, falling back to default profiles: default2020-03-15 21:31:50.581 INFO 67228 --- [ main] com.example.Application : Started Application in 0.937 seconds (JVM running for 1.598)Holoman&#123;name=&#x27;동장군&#x27;, howLong=60&#125;Process finished with exit code 0 springbootgetttingstarted프로젝트의 Bean이 출력됨을 확인할 수 있다. application.properties를 이용한 방법 springbootgetttingstarted 프로젝트 src&#x2F;resource에 application.properties파일을 생성 holoman.name = 아 집에 가고 싶다.holoman.how-long = 10000 application.propertie에 해당 내용을 추가 의존성 추가 maplespringbootstarter 프로젝트 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; @ConfigurationProperties를 사용하기 위해서는 해당 의존성을 추가해주어야 한다. HolomanProperties maplespringbootstarter 프로젝트 @ConfigurationProperties(&quot;holoman&quot;)public class HolomanProperties &#123; private String name; private int howLong; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getHowLong() &#123; return howLong; &#125; public void setHowLong(int howLong) &#123; this.howLong = howLong; &#125;&#125; HolomanConfiguration 수정 maplespringbootstarter 프로젝트 @Configuration@EnableConfigurationProperties(HolomanProperties.class)public class HolomanConfiguration &#123; @Bean @ConditionalOnMissingBean public Holoman holoman(HolomanProperties properties)&#123; Holoman holoman = new Holoman(); holoman.setHowLong(properties.getHowLong()); holoman.setName(properties.getName()); return holoman; &#125;&#125; @EnableConfigurationProperties를 추가Bean을 만들 때 HolomanProperties를 참조해서 Bean을 생성한다.springbootgetttingstarted의 application.properties를 가져다가 Bean을 생성한다. springbootgetttingstarted내의 holoman Bean을 없애주어야 한다…. 오류 잡느라 시간 오래 걸렸다. 결과2020-03-15 22:07:53.804 INFO 70087 --- [ main] com.example.Application : Starting Application on yangdong-uui-MacBookPro.local with PID 70087 (/Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted/target/classes started by dongwoo-yang in /Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted)2020-03-15 22:07:53.808 INFO 70087 --- [ main] com.example.Application : No active profile set, falling back to default profiles: default2020-03-15 22:07:54.628 INFO 70087 --- [ main] com.example.Application : Started Application in 1.148 seconds (JVM running for 1.631)Holoman&#123;name=&#x27;A... I want to go home&#x27;, howLong=10000&#125;Process finished with exit code 0","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"}],"tags":[]},{"title":"Spring Boot - 자동 설정 만들기 1부","slug":"spring/spring-framework/configuration/springboot-cutome-autoconfigure","date":"2021-02-18T15:45:34.000Z","updated":"2024-02-26T15:53:39.741Z","comments":true,"path":"2021/02/19/spring/spring-framework/configuration/springboot-cutome-autoconfigure/","link":"","permalink":"https://ckck803.github.io/2021/02/19/spring/spring-framework/configuration/springboot-cutome-autoconfigure/","excerpt":"자동 설정 만들기 1부 Xxx-Spring-Boot-Autoconfigure 모듈: 자동 설정 Xxx-Spring-Boot-Starter 모듈: 필요한 의존성 정의 그냥 하나로 만들고 싶을 때는?Xxx-Spring-Boot-Starter spring-boot-starter 만들기 프로젝트 명 : maplespringbootstarter ArtifactId : maple-spring-boot-starter 의존성 추가 maplespringbootstarter 프로젝트 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;","text":"자동 설정 만들기 1부 Xxx-Spring-Boot-Autoconfigure 모듈: 자동 설정 Xxx-Spring-Boot-Starter 모듈: 필요한 의존성 정의 그냥 하나로 만들고 싶을 때는?Xxx-Spring-Boot-Starter spring-boot-starter 만들기 프로젝트 명 : maplespringbootstarter ArtifactId : maple-spring-boot-starter 의존성 추가 maplespringbootstarter 프로젝트 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; Holoman.java maplespringbootstarter 프로젝트 package com.example;public class Holoman &#123; String name; int howLong; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getHowLong() &#123; return howLong; &#125; public void setHowLong(int howLong) &#123; this.howLong = howLong; &#125; @Override public String toString() &#123; return &quot;Holoman&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, howLong=&quot; + howLong + &#x27;&#125;&#x27;; &#125;&#125; HolomanConfiguration maplespringbootstarter 프로젝트 @Configurationpublic class HolomanConfiguration &#123; @Bean public Holoman holoman()&#123; Holoman holoman = new Holoman(); holoman.setHowLong(5); holoman.setName(&quot;maple&quot;); return holoman; &#125;&#125; Holoman 인스턴스를 반환하는 설정 파일을 만들었다. 자동 설정 파일 추가 src&#x2F;main&#x2F;resource&#x2F;위치에 META-INF폴더를 생성한다. org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.example.HolomanConfiguration META-INF폴더에 spring.factories파일을 생성한 후 위 내용을 추가해준다.해당 프로젝트를 의존성에 추가한 프로젝트는 EnableAutoConfiguration이 HolomanConfiguration을 scan하여 configuration의 Bean을 추가해 준다. mvn install install을 더블클릭하거나콘솔에가서 mvn install명령어를 실행하면 된다. mvn install 프로젝트가 빌드되고 jar파일이 생성된다. 다른 maven 프로젝트에서 가져다 쓸 수 있도록 local maven저장소에 설치를 한다. 의존성 추가 springbootgetttingstarted 프로젝트를 새로 생성 &lt;groupId&gt;org.example&lt;/groupId&gt;&lt;artifactId&gt;maple-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; pom.xml에 dependency를 추가한다. maple-spring-boot-starter가 추가 된 것을 확인할 수 있다. HolomanRunner.java springbootgettingstarted 프로젝트 @Componentpublic class HolomanRunner implements ApplicationRunner &#123; // maple-spring-boot-starter에서 Holoman Bean을 가져와 의존성을 주입해준다. @Autowired Holoman holoman; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(holoman); &#125;&#125; Holoman Bean이 추가된 것을 확인하기 위한 코드해당 프로젝트에는 Holoman에 관한 Configuration이 없는 상태이므로 Holoman Bean이 추가되었는지 해당 코드를 통해 확인 할 수 있다. 결과 . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.5.RELEASE)2020-03-15 20:29:06.744 INFO 53354 --- [ main] com.example.Application : Starting Application on yangdong-uui-MacBookPro.local with PID 53354 (/Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_4/springbootgettingstarted/target/classes started by dongwoo-yang in /Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_4/springbootgettingstarted)2020-03-15 20:29:06.749 INFO 53354 --- [ main] com.example.Application : No active profile set, falling back to default profiles: default2020-03-15 20:29:07.495 INFO 53354 --- [ main] com.example.Application : Started Application in 1.395 seconds (JVM running for 2.439)Holoman&#123;name=&#x27;maple&#x27;, howLong=5&#125;Process finished with exit code 0 Holoman&#123;name=&#39;maple&#39;, howLong=5&#125;을 통해 정상적으로 작동함을 알 수 있다. 만약 프로젝트에 같은 같은 Bean이 있는 경우 springbootgettingstarted 프로젝트 @SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication springApplication = new SpringApplication(Application.class); springApplication.setWebApplicationType(WebApplicationType.NONE); springApplication.run(args); &#125; @Bean public Holoman holoman()&#123; Holoman holoman = new Holoman(); holoman.setName(&quot;동장군&quot;); holoman.setHowLong(60); return holoman; &#125;&#125; 해당 프로젝트의 Bean이 무시가 된다. ComponentScan을 통해 먼저 Bean이 등록이 되고 EnableAutoConfiguration을 통해 Bean이 등록이 될때 해당 Bean을 덮어쓰게 된다. 다른 결과***************************APPLICATION FAILED TO START***************************Description:The bean &#x27;holoman&#x27;, defined in class path resource [com/example/HolomanConfiguration.class], could not be registered. A bean with that name has already been defined in com.example.Application and overriding is disabled.Action:Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=trueProcess finished with exit code 1 스프링 부트 2.2로 올라가면서 Bean 오버라이딩이 막혀서 에러 메시지가 뜨게 된다. 만약 Bean 오버라이딩을 하려고 하면 spring.main.allow-bean-definition-overriding=true 설정을 추가하면 Bean 오버라이딩이 가능해 진다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"}],"tags":[]},{"title":"Spring Boot - 자동 설정 이해","slug":"spring/spring-framework/configuration/springboot-autoconfiguration","date":"2021-02-17T23:09:05.000Z","updated":"2024-02-26T15:52:43.510Z","comments":true,"path":"2021/02/18/spring/spring-framework/configuration/springboot-autoconfiguration/","link":"","permalink":"https://ckck803.github.io/2021/02/18/spring/spring-framework/configuration/springboot-autoconfiguration/","excerpt":"Spring Boot - 자동 설정 이해 @SpringBootApplication 은 크게 3가지 어노테이션으로 이루어져 있다. @ComponentScan에서 1차적으로 @Bean을 읽어들인 후 @EnableAutoConfiguration에서 2차적으로 @Bean을 읽어들인다. @SpringBootConfiguration @SpringBootConfiguration은 기존의 Configuration과 비슷하다. @ComponentScan @ComponentScan 은 value 혹은 basePackages 속성을 이용해 component scan 을 시작하는 위치를 설정한다. 기본 값은 @ComponentScan 가 작성된 하위 패키지의 모든 @Component 와 @Bean 을 찾아 Spring Bean 으로 등록한다. @EnableAutoConfiguration Spring Boot가 제공하는 클래스를 Spring Bean으로 등록하는 방법이다. 즉 springboot는 Bean을 두번 등록하는 작업을 거친다. @ComponentScan@ComponentScan은 Application.class에 있다. 위 그림에서는 a와 b 패키지의 경우는 ComponentScan의 대상이 되나 maple 패키지의 경우 ComponentScan의 대상이 되지 않는다. @ComponentScan에서 Scan 대상","text":"Spring Boot - 자동 설정 이해 @SpringBootApplication 은 크게 3가지 어노테이션으로 이루어져 있다. @ComponentScan에서 1차적으로 @Bean을 읽어들인 후 @EnableAutoConfiguration에서 2차적으로 @Bean을 읽어들인다. @SpringBootConfiguration @SpringBootConfiguration은 기존의 Configuration과 비슷하다. @ComponentScan @ComponentScan 은 value 혹은 basePackages 속성을 이용해 component scan 을 시작하는 위치를 설정한다. 기본 값은 @ComponentScan 가 작성된 하위 패키지의 모든 @Component 와 @Bean 을 찾아 Spring Bean 으로 등록한다. @EnableAutoConfiguration Spring Boot가 제공하는 클래스를 Spring Bean으로 등록하는 방법이다. 즉 springboot는 Bean을 두번 등록하는 작업을 거친다. @ComponentScan@ComponentScan은 Application.class에 있다. 위 그림에서는 a와 b 패키지의 경우는 ComponentScan의 대상이 되나 maple 패키지의 경우 ComponentScan의 대상이 되지 않는다. @ComponentScan에서 Scan 대상 @Component @Configuration @Repository @Service @Controller @RestController 위 어노테이션을 가진 class들을 scan하여 Bean으로 등록을 한다. @ComponentScan을 가진 class부터 시작하여 하위 package들을 scan해 위 어노테이션이 달려 있는 것들을 Bean으로 등록한다. scan을 할 때는 TypeExcludeFilter.class와 AutoConfigurationExcludeFilter.class들을 제외하여 scan한다. @EnableAutoConfiguration스프링부트에서 @EnableAutoConfiguration 이 없어도 작동은 하지만 문제가 생긴다. @SpringBootConfiguration@ComponentScan//@EnableAutoConfigurationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 오류코드 Caused by: org.springframework.context.ApplicationContextException: Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean. 스프링부트는 코드를 웹 어플리케이션 형태로 제작하는데, 웹 어플리케이션으로 만드는 과정에서 EnableAutoConfiguration에서 읽어들어들이는 ServletWebServerFactory bean을 사용하기 때문에 문제가 생기게 된다. SpringApplication.run()을 바로 사용하게 되면 웹 어플리케이션 형태로 작동을 한다. EnableAutoConfiguration없이는 웹 어플리케이션으로 만드는 것이 불가능 하므로 바로 사용할 수 없다. 웹 어플리케이션 설정 꺼주기@SpringBootConfiguration@ComponentScan//@EnableAutoConfigurationpublic class Application &#123; public static void main(String[] args) &#123; // SpringApplication.run(Application.class, args); // SpringApplication 인스턴스를 생성하면 커스터마이징 해서 사용이 가능하다. SpringApplication application = new SpringApplication(Application.class); // webApplication만드는 설정을 꺼준다. application.setWebApplicationType(WebApplicationType.NONE); application.run(args); &#125;&#125; SpringApplication 인스턴스를 생성한 후에 setWebApplicationType()메소드를 이용하여 WebApplicationType.NONE인자 값을 넘겨주면 webApplication으로 만들어 주는 설정을 끌 수 있다. 작동은 가능하나 웹 어플리케이션으로 작동하지는 않는다. @EnableAutoConfiguration EnableAutoConfiguration은 Spring boot의 META file을 읽어 들인다. @ConditionalOnXxxYyyZzz @ConditionalOnWebApplication(type &#x3D; Type.SERVLET) 웹 어플리케이션 타입에 따라 설정을 다르게 한다. @ConditionalOnMissingBean(HiddenHttpMethodFilter.class) 해당 Bean이 없으면 다른 것을 등록 한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"}],"tags":[]},{"title":"Spring Boot의 의존성","slug":"spring/spring-framework/springboot-dependency","date":"2021-02-17T23:03:58.000Z","updated":"2024-02-26T16:05:43.988Z","comments":true,"path":"2021/02/18/spring/spring-framework/springboot-dependency/","link":"","permalink":"https://ckck803.github.io/2021/02/18/spring/spring-framework/springboot-dependency/","excerpt":"Spring Boot의 의존성pom.xml파일에 의존성 추가&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 스프링이 제공하는 의존성 관리 기능 덕분에의존성 정의시 version을 따로 명시하지 않아도 적절한 version을 가져온다. 의존성 상속 관계spring-boot-starter-parent&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; spring-boot-dependencies","text":"Spring Boot의 의존성pom.xml파일에 의존성 추가&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 스프링이 제공하는 의존성 관리 기능 덕분에의존성 정의시 version을 따로 명시하지 않아도 적절한 version을 가져온다. 의존성 상속 관계spring-boot-starter-parent&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; spring-boot-dependencies&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;...&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt;... spring-boot-starter-parent -&gt; spring-boot-dependencies로 가게 되면dependencyManagement태그를 통해 스프링 부트에서 관리하는 의존성과 version들을 확인할 수 있다. spring-boot-dependencies라는 pom안에 정의 되어 있는 것들 중에 하나라도 쓰게 된다면직접 version을 명시하지 않아도 된다. dependencyManagement 기능이 있어서 수 많은 Library들이 들어오게 된다.따라서, 우리가 관리해야 할 의존성의 수가 줄어든다. dependency 확인 Maven Projects Tab에서 dependency들을 쉽게 볼 수 있다. 의존성 추가starter 위주로 의존성을 추가하며 된다.만약 pom에서 지원하지 않는 의존성 추가시 version까지 명시해 주어야 한다.springboot dependency에서 관리하는 의존성은 굳이 version을 명시하지 않아도 되나 특별히 원하는 version이 있으면 version을 명시해 주면 override(덮어쓰기)가 된다. springboot 의존성 관리&lt;parent&gt;를 통해서 의존성을 관리해준다. 만약, 해당 프로젝트에서 parent.pom을 사용하지 않을 경우 project가 상속하는 parent에 spring-boot-starter-parent를 상속하는 방법 &lt;dependencyManagement&gt;색션을 사용하는 방법 &lt;dependecyManagement&gt;를 사용하게 되면 문제점이 생기는데,spring-boot-starter-parent가 단순히 의존성만을 가져오는 것이 아닌 여러가지 설정들을 함께 가져 오기 때문이다. ex) 자바 버전, 문자 인코딩 방식, resource(스프링 부트가 사용하는 properties와 yaml파일들)과 spring-boot를 최정화 시켜주는 여러가지 설정들","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring/Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/Spring-Framework/"}],"tags":[]},{"title":"Spring-JWT(JSON Web Token) - 1. JWT 알아보기","slug":"spring/spring-security/jwt/spring-jwt-01","date":"2021-02-17T03:41:39.000Z","updated":"2024-02-26T16:21:52.559Z","comments":true,"path":"2021/02/17/spring/spring-security/jwt/spring-jwt-01/","link":"","permalink":"https://ckck803.github.io/2021/02/17/spring/spring-security/jwt/spring-jwt-01/","excerpt":"1. JWT(JSON Web Token) 알아보기목차 Spring-JWT(JSON Web Token) - 4. JWT 다루기 Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기 Spring-JWT(JSON Web Token) - 2. 회원가입 Spring-JWT(JSON Web Token) - 1. JWT 알아보기 참고 https://jwt.io/ JWT 란? JWT는 JSON Web Token의 약자로 사용자 정보와 데이터 속성과 같은 Claim 정보를 JSON 을 이용해 표현한 Web TokenJWT는 Token내에 필요한 모든 정보를 가지고 전달해주는 자가수용적인 특징이 있다 JWT는 Header, Payload, Signature 세가지로 구성돼 있다. 각 부분은 Json 형태 로 이뤄져 있으며 base64로 인코딩 돼 .로 나뉘어 구분된다.","text":"1. JWT(JSON Web Token) 알아보기목차 Spring-JWT(JSON Web Token) - 4. JWT 다루기 Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기 Spring-JWT(JSON Web Token) - 2. 회원가입 Spring-JWT(JSON Web Token) - 1. JWT 알아보기 참고 https://jwt.io/ JWT 란? JWT는 JSON Web Token의 약자로 사용자 정보와 데이터 속성과 같은 Claim 정보를 JSON 을 이용해 표현한 Web TokenJWT는 Token내에 필요한 모든 정보를 가지고 전달해주는 자가수용적인 특징이 있다 JWT는 Header, Payload, Signature 세가지로 구성돼 있다. 각 부분은 Json 형태 로 이뤄져 있으며 base64로 인코딩 돼 .로 나뉘어 구분된다. Header 토큰 타입 과 암호 알고리즘 에 대한 정보가 담겨 있다. alg Signature에서 사용하는 암호 알고리즘 에 대한 정보가 담겨 있다. 보통은 HMACSHA256(Hash-Based Message Authentication Code) 알고리즘을 사용하거나 공개키&#x2F;개인키 방식인 RSA 암호화 방식 도 사용한다 typ 토큰 타입을 지정한다. JWT(JSON Web Token) Payload Claim 정보를 담고 있다. Payload에 담기는 key-value 한쌍이 Claim이다.Claim 이란 사용자 정보나 데이터 속성 정보를 의미한다. Claim은 크게 Registered Claim, Public Claim, Private Claim 3가지로 구분이 된다. Registered Claim 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터이며, 선택적으로 작성이 가능하다. Claim Claim Name 설명 iss issuer 토큰 발급자 sub subject 토큰의 제목 aud audience 토큰 대상자 exp expiration 토큰 만료 시간, NumericDate 형식으로 작성 nbf not before 토큰 활성 날짜 : 이 날이 지나기 전까지 토큰이 활성화 되지 않는다. iat issued at 토큰 발급 시간 : 토큰 발급 이후의 경과 시간을 알 수 있다. jti JWT ID JWT 토큰 식별자 Public Claim Public Claim은 사용자 정의 Claim으로, 보통 공개용 정보를 표현하기 위해 사용한다. 보통은 충돌 방지를 위해 URI 포맷을 이용해야 한다. Private Claim Public Claim이 아니면서 서버와 클라이언트 사이에서 임의로 정한 정보를 저장하기 위해 만들어진 Claim Signature Signature(서명) 은 Token 의 유효성 을 입증하기 위한 암호화된 코드다. 서명은 Base64 로 인코딩 된 Header 와 Payload 를 합친 후 비밀키(secrete key) 를 이용해 Header 에 정의된 알고리즘으로 해싱하고 결과를 Base64 로 인코딩해 생성한다. JWT의 장점JWT의 단점 Token 탈취 위험이 남아 있다. JWT 는 결국 사용자에게 저장되는 값이기 때문에 Server 에서","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"JWT","slug":"Spring/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/JWT/"}],"tags":[]},{"title":"Spring - BeanDefinition","slug":"spring/spring-core/spring-BeanDefinition","date":"2021-02-16T20:14:19.000Z","updated":"2024-03-16T07:42:31.647Z","comments":true,"path":"2021/02/17/spring/spring-core/spring-BeanDefinition/","link":"","permalink":"https://ckck803.github.io/2021/02/17/spring/spring-core/spring-BeanDefinition/","excerpt":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - 스프링 컨테이너 BeanDefinition 스프링 컨테이너는 BeanDefinition 을 이용해 스플링 빈을 생성합니다. 스프링 컨테이너는 BeanDefinition 에 정의된 빈 메타정보를 이용해 스프링 빈을 생성합니다. 빈 메타 정보는 XML, 자바코드 등으로 작성되며 @Bean, &lt;bean&gt; 당 하나씩 메타정보가 생성됩니다. 스프링은 정의된 메타정보들을 읽어와 BeanDefinition 을 생성합니다. 서로 다른 방식으로 정의된 빈 메타정보를 BeanDefinition 으로 생성하기 위해 스프링은 다양한 BeanDefinitionReader 를 제공합니다. AnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader 를 사용해서 AppConfig.class 를 읽고 BeanDefinition 을 생성합니다. GenericXmlApplicationContext 는 XmlBeanDefinitionReader 를 사용해서 appConfig.xml 설정 정보를 읽고 BeanDefinition 을 생성합니다.","text":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - 스프링 컨테이너 BeanDefinition 스프링 컨테이너는 BeanDefinition 을 이용해 스플링 빈을 생성합니다. 스프링 컨테이너는 BeanDefinition 에 정의된 빈 메타정보를 이용해 스프링 빈을 생성합니다. 빈 메타 정보는 XML, 자바코드 등으로 작성되며 @Bean, &lt;bean&gt; 당 하나씩 메타정보가 생성됩니다. 스프링은 정의된 메타정보들을 읽어와 BeanDefinition 을 생성합니다. 서로 다른 방식으로 정의된 빈 메타정보를 BeanDefinition 으로 생성하기 위해 스프링은 다양한 BeanDefinitionReader 를 제공합니다. AnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader 를 사용해서 AppConfig.class 를 읽고 BeanDefinition 을 생성합니다. GenericXmlApplicationContext 는 XmlBeanDefinitionReader 를 사용해서 appConfig.xml 설정 정보를 읽고 BeanDefinition 을 생성합니다. 새로운 형식의 설정 정보가 추가되면, XxxBeanDefinitionReader를 만들어서 BeanDefinition 을 생성하면 된다. BeanDefinition 확인Bean을 등록하는 방법은 크게 두가지가 있다 Bean을 직접 등록하는 방법과 FactoryMethod 를 이용한 방법이 있습니다. Bean 을 직정 등록하는 방법은 XML 파일에 Bean 정보를 직정 등록하는 방식이고 FactoryMethod 를 이용한 방식은 class 와 어노테이션을 이용해 등록하는 방식입니다. public class BeanDefinitionTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName(&quot;빈 설정 메타정보 확인&quot;) void findApplicationBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION)&#123; System.out.println(&quot;beanDefinition = &quot; + beanDefinition + &quot;beanDefinition = &quot; + beanDefinition); &#125; &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Core","slug":"Spring/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring/Spring-Core/"}],"tags":[]},{"title":"Spring - 스프링 컨테이너 생성과 Bean 등록","slug":"spring/spring-core/spring-container-bean","date":"2021-02-16T17:14:19.000Z","updated":"2024-03-10T00:17:20.369Z","comments":true,"path":"2021/02/17/spring/spring-core/spring-container-bean/","link":"","permalink":"https://ckck803.github.io/2021/02/17/spring/spring-core/spring-container-bean/","excerpt":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - 스프링 컨테이너 스프링 컨테이너 생성 과정과 Bean 등록 과정스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 한다. 구성 정보는 클래스나 xml 을 이용해 정의할 수 있습니다. //스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); 스프링 컨테이너 생성스프링 컨테이너 생성시 설정 정보를 이용해 스프링 컨에티너를 생성합니다. 아래에서는 AppConfig.class 를 설정 정보로 이용해 스프링 컨테이너를 생성합니다. 스프링 빈 등록","text":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - 스프링 컨테이너 스프링 컨테이너 생성 과정과 Bean 등록 과정스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 한다. 구성 정보는 클래스나 xml 을 이용해 정의할 수 있습니다. //스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); 스프링 컨테이너 생성스프링 컨테이너 생성시 설정 정보를 이용해 스프링 컨에티너를 생성합니다. 아래에서는 AppConfig.class 를 설정 정보로 이용해 스프링 컨테이너를 생성합니다. 스프링 빈 등록스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다. 아래에서는 AppConfig.class 애 정의된 객체를 Bean 으로 등록합니다. 스프링 빈 의존관계 설정 - 준비 스프링 빈 의존관계 설정 - 완료 등록된 모든 빈 확인ApplicationContext 에 등록된 모든 Bean 을 조회하고 싶을 경우 ApplicationContext 객체의 getBeanDefinitionNames 메소드를 사용하면 됩니다. @Test@DisplayName(&quot;모든 빈 출력하기&quot;)void findAllBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; Object bean = ac.getBean(beanDefinitionName); System.out.println(&quot;bean = &quot; + beanDefinitionName + &quot; object = &quot; + bean); &#125;&#125;@Test@DisplayName(&quot;애플리케이션 빈 출력하기&quot;)void findApplicationBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION)&#123; Object bean = ac.getBean(beanDefinitionName); System.out.println(&quot;name = &quot; + beanDefinitionName + &quot; object = &quot; + bean); &#125; &#125;&#125; 컨테이너에 등록된 Bean 조회 컨테이너에 등록된 Bean 조회시 getBean 메소드를 사용합니다. ApplicationContext 는 등록된 Bean 을 가져와 사용할 수 있게 getBean 메소드를 제공합니다. getBean 메소드를 통해 Bean 정보를 방법으로는 객체타입으로 조회하는 방법, 객체타입과 Bean 이름으로 조회하는 방법, 구체 객체타입으로 조회하는 방법이 있습니다. @Test@DisplayName(&quot;빈 이름으로 조회&quot;)void findBeanByName()&#123; MemberService memberService = ac.getBean(&quot;memberService&quot;, MemberService.class); assertThat(memberService).isInstanceOf(MemberServiceImpl.class);&#125;@Test@DisplayName(&quot;이름없이 타입으로 조회&quot;)void findBeanByType()&#123; MemberService memberService = ac.getBean(MemberService.class); assertThat(memberService).isInstanceOf(MemberServiceImpl.class);&#125;@Test@DisplayName(&quot;구체 타입으로 조회&quot;)void findBeanByType2()&#123; MemberServiceImpl memberService = ac.getBean(&quot;memberService&quot;, MemberServiceImpl.class); // 구체적으로 적는 것은 별로 않좋다. // 될 수 있는한 추상화한 인터페이스에 테스트를 맞춘다. assertThat(memberService).isInstanceOf(MemberServiceImpl.class);&#125;@Test@DisplayName(&quot;빈 이름으로 조회X&quot;)void findBeanByNameX()&#123; assertThatThrownBy(()-&gt;&#123; MemberService xxxxx = ac.getBean(&quot;xxxxx&quot;, MemberService.class); &#125;).isInstanceOf(NoSuchBeanDefinitionException.class);&#125; Bean 의 동일한 타입이 둘 이상인 경우같은 타입으로 등록된 빈이 여러개 있을 경우 getBean 을 이용해 Bean 을 가져오게 되면 NoUniqueBeanDefinitionException 에러가 발생하게 됩니다. 이때는 특정 Bean 을 가져올 수 있도록 등록된 Bean 이름 까지 같이 지정해주면 에러를 해결할 수 있습니다. 또한, ApplicationContext 에 특정 타입으로 등록된 모든 Bean 목록을 조회 하고 싶을 경우 ApplicationContext 객체의 getBeansOfType 메소드를 사용하면 됩니다. 같은 타입으로 여러개의 Bean 등록memberRepository1 와 memberRepository2 가 ApplicationContext 에 MemberRepository 타입 Bean 으로 등록됩니다. public class ApplicationContextExtendsFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class); @Configuration static class SameBeanConfig &#123; @Bean public MemberRepository memberRepository1() &#123; return new MemoryMemberRepository(); &#125; @Bean public MemberRepository memberRepository2() &#123; return new MemoryMemberRepository(); &#125; &#125;&#125; 같은 타입으로 여러개의 Bean 조회@Test@DisplayName(&quot;타입으로 조회시 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다.&quot;)void findBeanByTypeDuplicate()&#123; assertThatThrownBy(() -&gt;&#123; ac.getBean(MemberRepository.class); &#125;).isInstanceOf(NoUniqueBeanDefinitionException.class);&#125;@Test@DisplayName(&quot;타입으로 조회시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.&quot;)void findBeanByName()&#123; MemberRepository memberRepository = ac.getBean(&quot;memberRepository1&quot;, MemberRepository.class); assertThat(memberRepository).isEqualTo(MemberRepository.class);&#125;@Test@DisplayName(&quot;특정 타입을 모두 조회하기&quot;)void findAllBeanByType()&#123; Map&lt;String, MemberRepository&gt; beansOfType = ac.getBeansOfType(MemberRepository.class); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value =&quot; + beansOfType.get(key)); &#125; System.out.println(&quot;beansOfType = &quot; + beansOfType); assertThat(beansOfType.size()).isEqualTo(2);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Core","slug":"Spring/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring/Spring-Core/"}],"tags":[]},{"title":"Spring - 스프링 빈","slug":"spring/spring-core/spring-bean copy","date":"2021-02-16T16:14:19.000Z","updated":"2024-03-08T02:25:45.804Z","comments":true,"path":"2021/02/17/spring/spring-core/spring-bean copy/","link":"","permalink":"https://ckck803.github.io/2021/02/17/spring/spring-core/spring-bean%20copy/","excerpt":"목차 Spring - 의존성 주입 방식 Spring - 스프링 빈 Post not found: spring/spring-core/spring-bean-container 스프링 빈 스프링 IoC 컨테이너에 의해 생성되고 관리되는 객체를 보고 스프링 빈이라 부릅니다. Bean 객체는 스프링 컨테이너에 의해 생성 및 관리되며 일반적으로 싱글톤 객체로 생성됩니다. Bean 끼리 의존관계가 있을 경우 의존성 주입을 통해 사용할 수 있습니다. 스프링 컨테이너에 객체를 Bean 으로 등록하는 방법 XML 에 직접 등록하는 방법 @Configuration 과 @Bean 을 이용하여 직접적으로 등록을 하면 된다. Bean 어노테이션으로 정의할 때는 @Configuration 가지고 있는 클래스 안에 정의해야 한다. @Configuration 안에서 @Bean 을 사용해야 싱글톤을 보장 받을 수 있습니다. Component Scan을 이용하는 방법 Component 어노테이션이 붙어있는 클래스를 찾아서 Bean으로 등록해준다.","text":"목차 Spring - 의존성 주입 방식 Spring - 스프링 빈 Post not found: spring/spring-core/spring-bean-container 스프링 빈 스프링 IoC 컨테이너에 의해 생성되고 관리되는 객체를 보고 스프링 빈이라 부릅니다. Bean 객체는 스프링 컨테이너에 의해 생성 및 관리되며 일반적으로 싱글톤 객체로 생성됩니다. Bean 끼리 의존관계가 있을 경우 의존성 주입을 통해 사용할 수 있습니다. 스프링 컨테이너에 객체를 Bean 으로 등록하는 방법 XML 에 직접 등록하는 방법 @Configuration 과 @Bean 을 이용하여 직접적으로 등록을 하면 된다. Bean 어노테이션으로 정의할 때는 @Configuration 가지고 있는 클래스 안에 정의해야 한다. @Configuration 안에서 @Bean 을 사용해야 싱글톤을 보장 받을 수 있습니다. Component Scan을 이용하는 방법 Component 어노테이션이 붙어있는 클래스를 찾아서 Bean으로 등록해준다. Repository Service Controller XML 을 이용해 Bean 등록하기최근 스프링 부트의 등장으로 xml 을 이용해 스프링을 설정하는 방법은 잘 사용하지 않는 방식입니다. xml 을 이용해 스프링 컨테이너를 설정하는 것의 장점은 컴파일 없이 빈 설정 정보를 변경할 수 있다는 점이다. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;memberService&quot; class = &quot;com.example.springbasic.member.MemberServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;memberRepository&quot; ref=&quot;memberRepository&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;memberRepository&quot; class=&quot;com.example.springbasic.member.MemoryMemberRepository&quot;/&gt; &lt;bean id=&quot;orderService&quot; class=&quot;com.example.springbasic.order.OrderServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;memberRepository&quot; ref=&quot;memberRepository&quot;/&gt; &lt;constructor-arg name=&quot;discountPolicy&quot; ref=&quot;discountPolicy&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;discountPolicy&quot; class=&quot;com.example.springbasic.discount.RateDiscountPolicy&quot;/&gt;&lt;/beans&gt; xml 파일을 이용해 Bean 을 등록하고 사용하기 위해 GenericXmlApplicationContext 클래스를 사용합니다. GenericXmlApplicationContext 에 Bean 설정을 정의한 appConfig.xml 파일을 인자로 넘겨주면 스프링 컨테이너를 생성한 후 xml 파일에 정의된 객체들을 스프링 Bean 으로 등록해줍니다. ApplicationContext 객체내 getBean 을 사용하면 스프링 컨테이너에 저장된 Bean 객체를 가져와 사용할 수 있습니다. public class XmlAppContext &#123; @Test void xmlAppContext()&#123; ApplicationContext ac = new GenericXmlApplicationContext(&quot;appConfig.xml&quot;); MemberService memberService = ac.getBean(&quot;memberService&quot;, MemberService.class); assertThat(memberService).isInstanceOf(MemberService.class); &#125;&#125; @Configuration 과 @Bean 을 이용해 Bean 등록하기Configuration 어노테이션을 통해 AppConfig를 설정(구성) 정보로 사용한다.Bean 어노테이션을 통해 스프링 컨테이너에 등록한다. @Configurationpublic class AppConfig &#123; @Bean public MemberService memberService()&#123; return new MemberServiceImpl(memberRepository()); &#125; @Bean public MemberRepository memberRepository() &#123; return new MemoryMemberRepository(); &#125; @Bean public OrderService orderService()&#123; return new OrderServiceImpl(memberRepository(), discountPolicy()); &#125; @Bean public DiscountPolicy discountPolicy() &#123;// return new FixDiscountPolicy(); return new RateDiscountPolicy(); &#125;&#125; @Configuration 과 @Bean 를 사용해 정의한 Bean 객체를 등록 및 사용하기 위해 AnnotationConfigApplicationContext 클래스를 사용합니다. AnnotationConfigApplicationContext 에 Bean 설정을 정의한 AppConfig.class 를 넘겨주면 스프링 컨테이너를 생성한 후 @Bean 이 붙은 메소드를 호출해 반환받은 객체들을 스프링 Bean 으로 등록합니다. public class OrderApp &#123; public static void main(String[] args) &#123;// AppConfig appConfig = new AppConfig();//// MemberService memberService = appConfig.memberService();// OrderService orderService = appConfig.orderService(); ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MemberService memberService = applicationContext.getBean(&quot;memberService&quot;, MemberService.class); OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class); Long memberId = 1L; Member member = new Member(memberId, &quot;memberA&quot;, Grade.VIP); memberService.join(member); Order order = orderService.createOrder(memberId, &quot;itemA&quot;, 20000); System.out.println(&quot;order = &quot; + order); &#125;&#125; 스프링에 등록된 빈 확인하기등록된 모든 빈 확인@Test@DisplayName(&quot;모든 빈 출력하기&quot;)void findAllBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; Object bean = ac.getBean(beanDefinitionName); System.out.println(&quot;bean = &quot; + beanDefinitionName + &quot; object = &quot; + bean); &#125;&#125;@Test@DisplayName(&quot;애플리케이션 빈 출력하기&quot;)void findApplicationBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION)&#123; Object bean = ac.getBean(beanDefinitionName); System.out.println(&quot;name = &quot; + beanDefinitionName + &quot; object = &quot; + bean); &#125; &#125;&#125; 동일한 타입이 둘 이상public class ApplicationContextBasicFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName(&quot;빈 이름으로 조회&quot;) void findBeanByName()&#123; MemberService memberService = ac.getBean(&quot;memberService&quot;, MemberService.class); assertThat(memberService).isInstanceOf(MemberServiceImpl.class); &#125; @Test @DisplayName(&quot;이름없이 타입으로 조회&quot;) void findBeanByType()&#123; MemberService memberService = ac.getBean(MemberService.class); assertThat(memberService).isInstanceOf(MemberServiceImpl.class); &#125; @Test @DisplayName(&quot;구체 타입으로 조회&quot;) void findBeanByType2()&#123; MemberServiceImpl memberService = ac.getBean(&quot;memberService&quot;, MemberServiceImpl.class); // 구체적으로 적는 것은 별로 않좋다. // 될 수 있는한 추상화한 인터페이스에 테스트를 맞춘다. assertThat(memberService).isInstanceOf(MemberServiceImpl.class); &#125; @Test @DisplayName(&quot;빈 이름으로 조회X&quot;) void findBeanByNameX()&#123; assertThatThrownBy(()-&gt;&#123; MemberService xxxxx = ac.getBean(&quot;xxxxx&quot;, MemberService.class); &#125;).isInstanceOf(NoSuchBeanDefinitionException.class); &#125;&#125; 상속 관계public class ApplicationContextSameBeanFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class); @Test @DisplayName(&quot;타입으로 조회시 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다.&quot;) void findBeanByTypeDuplicate()&#123; assertThatThrownBy(() -&gt;&#123; ac.getBean(MemberRepository.class); &#125;).isInstanceOf(NoUniqueBeanDefinitionException.class); &#125; @Test @DisplayName(&quot;타입으로 조회시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.&quot;) void findBeanByName()&#123; MemberRepository memberRepository = ac.getBean(&quot;memberRepository1&quot;, MemberRepository.class); assertThat(memberRepository).isEqualTo(MemberRepository.class); &#125; @Test @DisplayName(&quot;특정 타입을 모두 조회하기&quot;) void findAllBeanByType()&#123; Map&lt;String, MemberRepository&gt; beansOfType = ac.getBeansOfType(MemberRepository.class); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value =&quot; + beansOfType.get(key)); &#125; System.out.println(&quot;beansOfType = &quot; + beansOfType); assertThat(beansOfType.size()).isEqualTo(2); &#125; @Configuration static class SameBeanConfig &#123; @Bean public MemberRepository memberRepository1() &#123; return new MemoryMemberRepository(); &#125; @Bean public MemberRepository memberRepository2() &#123; return new MemoryMemberRepository(); &#125; &#125;&#125; public class ApplicationContextExtendsFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); @Test @DisplayName(&quot;부모 타입으로 조회시, 자식이 둘 이상 있으면, 중복 오류가 발생한다.&quot;) void findBeanByParentTypeDuplicate()&#123; assertThatThrownBy(() -&gt; &#123; ac.getBean(DiscountPolicy.class); &#125;).isInstanceOf(NoUniqueBeanDefinitionException.class); &#125; @Test @DisplayName(&quot;부모 타입으로 조회시, 자식이 둘 이상 있으면, 빈 이름을 지정한다.&quot;) void findBeanByParentTypeBeanName()&#123; DiscountPolicy rateDiscountPolicy = ac.getBean(&quot;rateDiscountPolicy&quot;, DiscountPolicy.class); assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class); &#125; @Test @DisplayName(&quot;특정 하위 타입으로 조회&quot;) void findBeanBySubType()&#123; // 구체적인 타입을 지정 RateDiscountPolicy bean = ac.getBean(RateDiscountPolicy.class); assertThat(bean).isInstanceOf(RateDiscountPolicy.class); &#125; @Test @DisplayName(&quot;부모 타입으로 모두 조회하기&quot;) void findAllBeanByParentType()&#123; Map&lt;String, DiscountPolicy&gt; beansOfType = ac.getBeansOfType(DiscountPolicy.class); assertThat(beansOfType.size()).isEqualTo(2); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value = &quot; + beansOfType.get(key)); &#125; &#125; @Test @DisplayName(&quot;부모 타입으로 모두 조회하기 - Object&quot;) void findAllBeanByObjectType()&#123; Map&lt;String, Object&gt; beansOfType = ac.getBeansOfType(Object.class); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value = &quot; + beansOfType.get(key)); &#125; &#125; @Configuration static class TestConfig&#123; @Bean public DiscountPolicy rateDiscountPolicy()&#123; return new RateDiscountPolicy(); &#125; @Bean public DiscountPolicy fixDiscountPolicy()&#123; return new FixDiscountPolicy(); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Core","slug":"Spring/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring/Spring-Core/"}],"tags":[]},{"title":"Spring - 스프링 빈","slug":"spring/spring-core/spring-bean","date":"2021-02-16T16:14:19.000Z","updated":"2024-03-08T02:32:01.735Z","comments":true,"path":"2021/02/17/spring/spring-core/spring-bean/","link":"","permalink":"https://ckck803.github.io/2021/02/17/spring/spring-core/spring-bean/","excerpt":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - 스프링 컨테이너 스프링 빈 스프링 IoC 컨테이너에 의해 생성되고 관리되는 객체를 보고 스프링 빈이라 부릅니다. Bean 객체는 스프링 컨테이너에 의해 생성 및 관리되며 일반적으로 싱글톤 객체로 생성됩니다. Bean 끼리 의존관계가 있을 경우 의존성 주입을 통해 사용할 수 있습니다. 스프링 컨테이너에 객체를 Bean 으로 등록하는 방법 XML 에 직접 등록하는 방법 @Configuration 과 @Bean 을 이용하여 직접적으로 등록을 하면 된다. Bean 어노테이션으로 정의할 때는 @Configuration 가지고 있는 클래스 안에 정의해야 한다. @Configuration 안에서 @Bean 을 사용해야 싱글톤을 보장 받을 수 있습니다. XML 을 이용해 Bean 등록하기최근 스프링 부트의 등장으로 xml 을 이용해 스프링을 설정하는 방법은 잘 사용하지 않는 방식입니다. xml 을 이용해 스프링 컨테이너를 설정하는 것의 장점은 컴파일 없이 빈 설정 정보를 변경할 수 있다는 점이다.","text":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - 스프링 컨테이너 스프링 빈 스프링 IoC 컨테이너에 의해 생성되고 관리되는 객체를 보고 스프링 빈이라 부릅니다. Bean 객체는 스프링 컨테이너에 의해 생성 및 관리되며 일반적으로 싱글톤 객체로 생성됩니다. Bean 끼리 의존관계가 있을 경우 의존성 주입을 통해 사용할 수 있습니다. 스프링 컨테이너에 객체를 Bean 으로 등록하는 방법 XML 에 직접 등록하는 방법 @Configuration 과 @Bean 을 이용하여 직접적으로 등록을 하면 된다. Bean 어노테이션으로 정의할 때는 @Configuration 가지고 있는 클래스 안에 정의해야 한다. @Configuration 안에서 @Bean 을 사용해야 싱글톤을 보장 받을 수 있습니다. XML 을 이용해 Bean 등록하기최근 스프링 부트의 등장으로 xml 을 이용해 스프링을 설정하는 방법은 잘 사용하지 않는 방식입니다. xml 을 이용해 스프링 컨테이너를 설정하는 것의 장점은 컴파일 없이 빈 설정 정보를 변경할 수 있다는 점이다. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;memberService&quot; class = &quot;com.example.springbasic.member.MemberServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;memberRepository&quot; ref=&quot;memberRepository&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;memberRepository&quot; class=&quot;com.example.springbasic.member.MemoryMemberRepository&quot;/&gt; &lt;bean id=&quot;orderService&quot; class=&quot;com.example.springbasic.order.OrderServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;memberRepository&quot; ref=&quot;memberRepository&quot;/&gt; &lt;constructor-arg name=&quot;discountPolicy&quot; ref=&quot;discountPolicy&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;discountPolicy&quot; class=&quot;com.example.springbasic.discount.RateDiscountPolicy&quot;/&gt;&lt;/beans&gt; xml 파일을 이용해 Bean 을 등록하고 사용하기 위해 GenericXmlApplicationContext 클래스를 사용합니다. GenericXmlApplicationContext 에 Bean 설정을 정의한 appConfig.xml 파일을 인자로 넘겨주면 스프링 컨테이너를 생성한 후 xml 파일에 정의된 객체들을 스프링 Bean 으로 등록해줍니다. ApplicationContext 객체내 getBean 을 사용하면 스프링 컨테이너에 저장된 Bean 객체를 가져와 사용할 수 있습니다. public class XmlAppContext &#123; @Test void xmlAppContext()&#123; ApplicationContext ac = new GenericXmlApplicationContext(&quot;appConfig.xml&quot;); MemberService memberService = ac.getBean(&quot;memberService&quot;, MemberService.class); assertThat(memberService).isInstanceOf(MemberService.class); &#125;&#125; @Configuration 과 @Bean 을 이용해 Bean 등록하기Configuration 어노테이션을 통해 AppConfig를 설정(구성) 정보로 사용한다.Bean 어노테이션을 통해 스프링 컨테이너에 등록한다. @Configurationpublic class AppConfig &#123; @Bean public MemberService memberService()&#123; return new MemberServiceImpl(memberRepository()); &#125; @Bean public MemberRepository memberRepository() &#123; return new MemoryMemberRepository(); &#125; @Bean public OrderService orderService()&#123; return new OrderServiceImpl(memberRepository(), discountPolicy()); &#125; @Bean public DiscountPolicy discountPolicy() &#123;// return new FixDiscountPolicy(); return new RateDiscountPolicy(); &#125;&#125; @Configuration 과 @Bean 를 사용해 정의한 Bean 객체를 등록 및 사용하기 위해 AnnotationConfigApplicationContext 클래스를 사용합니다. AnnotationConfigApplicationContext 에 Bean 설정을 정의한 AppConfig.class 를 넘겨주면 스프링 컨테이너를 생성한 후 @Bean 이 붙은 메소드를 호출해 반환받은 객체들을 스프링 Bean 으로 등록합니다. public class OrderApp &#123; public static void main(String[] args) &#123;// AppConfig appConfig = new AppConfig();//// MemberService memberService = appConfig.memberService();// OrderService orderService = appConfig.orderService(); ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MemberService memberService = applicationContext.getBean(&quot;memberService&quot;, MemberService.class); OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class); Long memberId = 1L; Member member = new Member(memberId, &quot;memberA&quot;, Grade.VIP); memberService.join(member); Order order = orderService.createOrder(memberId, &quot;itemA&quot;, 20000); System.out.println(&quot;order = &quot; + order); &#125;&#125; 스프링에 등록된 빈 확인하기등록된 모든 빈 확인@Test@DisplayName(&quot;모든 빈 출력하기&quot;)void findAllBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; Object bean = ac.getBean(beanDefinitionName); System.out.println(&quot;bean = &quot; + beanDefinitionName + &quot; object = &quot; + bean); &#125;&#125;@Test@DisplayName(&quot;애플리케이션 빈 출력하기&quot;)void findApplicationBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION)&#123; Object bean = ac.getBean(beanDefinitionName); System.out.println(&quot;name = &quot; + beanDefinitionName + &quot; object = &quot; + bean); &#125; &#125;&#125; 동일한 타입이 둘 이상public class ApplicationContextBasicFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName(&quot;빈 이름으로 조회&quot;) void findBeanByName()&#123; MemberService memberService = ac.getBean(&quot;memberService&quot;, MemberService.class); assertThat(memberService).isInstanceOf(MemberServiceImpl.class); &#125; @Test @DisplayName(&quot;이름없이 타입으로 조회&quot;) void findBeanByType()&#123; MemberService memberService = ac.getBean(MemberService.class); assertThat(memberService).isInstanceOf(MemberServiceImpl.class); &#125; @Test @DisplayName(&quot;구체 타입으로 조회&quot;) void findBeanByType2()&#123; MemberServiceImpl memberService = ac.getBean(&quot;memberService&quot;, MemberServiceImpl.class); // 구체적으로 적는 것은 별로 않좋다. // 될 수 있는한 추상화한 인터페이스에 테스트를 맞춘다. assertThat(memberService).isInstanceOf(MemberServiceImpl.class); &#125; @Test @DisplayName(&quot;빈 이름으로 조회X&quot;) void findBeanByNameX()&#123; assertThatThrownBy(()-&gt;&#123; MemberService xxxxx = ac.getBean(&quot;xxxxx&quot;, MemberService.class); &#125;).isInstanceOf(NoSuchBeanDefinitionException.class); &#125;&#125; 상속 관계public class ApplicationContextSameBeanFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class); @Test @DisplayName(&quot;타입으로 조회시 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다.&quot;) void findBeanByTypeDuplicate()&#123; assertThatThrownBy(() -&gt;&#123; ac.getBean(MemberRepository.class); &#125;).isInstanceOf(NoUniqueBeanDefinitionException.class); &#125; @Test @DisplayName(&quot;타입으로 조회시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.&quot;) void findBeanByName()&#123; MemberRepository memberRepository = ac.getBean(&quot;memberRepository1&quot;, MemberRepository.class); assertThat(memberRepository).isEqualTo(MemberRepository.class); &#125; @Test @DisplayName(&quot;특정 타입을 모두 조회하기&quot;) void findAllBeanByType()&#123; Map&lt;String, MemberRepository&gt; beansOfType = ac.getBeansOfType(MemberRepository.class); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value =&quot; + beansOfType.get(key)); &#125; System.out.println(&quot;beansOfType = &quot; + beansOfType); assertThat(beansOfType.size()).isEqualTo(2); &#125; @Configuration static class SameBeanConfig &#123; @Bean public MemberRepository memberRepository1() &#123; return new MemoryMemberRepository(); &#125; @Bean public MemberRepository memberRepository2() &#123; return new MemoryMemberRepository(); &#125; &#125;&#125; public class ApplicationContextExtendsFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); @Test @DisplayName(&quot;부모 타입으로 조회시, 자식이 둘 이상 있으면, 중복 오류가 발생한다.&quot;) void findBeanByParentTypeDuplicate()&#123; assertThatThrownBy(() -&gt; &#123; ac.getBean(DiscountPolicy.class); &#125;).isInstanceOf(NoUniqueBeanDefinitionException.class); &#125; @Test @DisplayName(&quot;부모 타입으로 조회시, 자식이 둘 이상 있으면, 빈 이름을 지정한다.&quot;) void findBeanByParentTypeBeanName()&#123; DiscountPolicy rateDiscountPolicy = ac.getBean(&quot;rateDiscountPolicy&quot;, DiscountPolicy.class); assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class); &#125; @Test @DisplayName(&quot;특정 하위 타입으로 조회&quot;) void findBeanBySubType()&#123; // 구체적인 타입을 지정 RateDiscountPolicy bean = ac.getBean(RateDiscountPolicy.class); assertThat(bean).isInstanceOf(RateDiscountPolicy.class); &#125; @Test @DisplayName(&quot;부모 타입으로 모두 조회하기&quot;) void findAllBeanByParentType()&#123; Map&lt;String, DiscountPolicy&gt; beansOfType = ac.getBeansOfType(DiscountPolicy.class); assertThat(beansOfType.size()).isEqualTo(2); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value = &quot; + beansOfType.get(key)); &#125; &#125; @Test @DisplayName(&quot;부모 타입으로 모두 조회하기 - Object&quot;) void findAllBeanByObjectType()&#123; Map&lt;String, Object&gt; beansOfType = ac.getBeansOfType(Object.class); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value = &quot; + beansOfType.get(key)); &#125; &#125; @Configuration static class TestConfig&#123; @Bean public DiscountPolicy rateDiscountPolicy()&#123; return new RateDiscountPolicy(); &#125; @Bean public DiscountPolicy fixDiscountPolicy()&#123; return new FixDiscountPolicy(); &#125; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Core","slug":"Spring/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring/Spring-Core/"}],"tags":[]},{"title":"Spring - Spring 컨테이너","slug":"spring/spring-core/spring-container","date":"2021-02-16T15:14:19.000Z","updated":"2024-11-24T00:05:59.013Z","comments":true,"path":"2021/02/17/spring/spring-core/spring-container/","link":"","permalink":"https://ckck803.github.io/2021/02/17/spring/spring-core/spring-container/","excerpt":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - Spring 컨테이너 Spring 컨테이너와 IoC(Inversion of Control)객체의 생성, 객체간의 의존성 과 같은 프로그램의 흐름 을 개발자가 아니라 프레임워크나 외부 컨테이너에가 관리 해주는 것을 의미합니다. 즉, 프로그램에 대한 제어권이 개발자가 아니라 프레임워크나 외부 컨테이너에서 관리가 됩니다. Spring 의 핵심요소인 Spring 컨테이너는 객체의 생성과 관리, 의존성 주입, 생명주기등을 해주기 때문에 IoC 컨테이너 라고 불립니다. Spring 컨에티너의 주요 기능Spring 컨테이너는 객체를 생성하고 컨테이너에 등록합니다. 이때, Spring 컨테이너에 등록된 객체들을 Spring Bean 이라 부르고 컨테이너는 등록된 Bean 의 생성, 초기화, 소멸까지의 전체적인 생명주기를 관리합니다. Spring Bean 들이 생성된 후 Spring 컨테이너는 객체간의 관계를 확인 후 설정에 따라 의존성을 주입합니다. Bean 으로 등록되지 않은 객체에 대해서는 의존성 주입이 이뤄지지 않습니다.","text":"목차 Spring - 의존성 주입 방식 Spring - 스프링 컨테이너 생성과 Bean 등록 Spring - 스프링 빈 Spring - Spring 컨테이너 Spring 컨테이너와 IoC(Inversion of Control)객체의 생성, 객체간의 의존성 과 같은 프로그램의 흐름 을 개발자가 아니라 프레임워크나 외부 컨테이너에가 관리 해주는 것을 의미합니다. 즉, 프로그램에 대한 제어권이 개발자가 아니라 프레임워크나 외부 컨테이너에서 관리가 됩니다. Spring 의 핵심요소인 Spring 컨테이너는 객체의 생성과 관리, 의존성 주입, 생명주기등을 해주기 때문에 IoC 컨테이너 라고 불립니다. Spring 컨에티너의 주요 기능Spring 컨테이너는 객체를 생성하고 컨테이너에 등록합니다. 이때, Spring 컨테이너에 등록된 객체들을 Spring Bean 이라 부르고 컨테이너는 등록된 Bean 의 생성, 초기화, 소멸까지의 전체적인 생명주기를 관리합니다. Spring Bean 들이 생성된 후 Spring 컨테이너는 객체간의 관계를 확인 후 설정에 따라 의존성을 주입합니다. Bean 으로 등록되지 않은 객체에 대해서는 의존성 주입이 이뤄지지 않습니다. 코드를 통해 알아보기 - 생성자를 통한 의존성 주입Spring 컨테이너는 아래 코드가 동작하게 만들어줍니다. 코드를 보면 OwnerController 는 OwnerRepository 객체를 의존하는 상황에서 Spring 컨테이너 는 개발자 대신 객체를 생성하고 의존관계를 설정해줍니다. 즉, OwnerRepository 객체를 생성하고 OwnerController 에 주입합니다. IoC 컨테이너는 이런 객체 (Bean) 를 생성하고 의존성을 관리해줍니다. class OwnerController &#123; // new 를 통해 개발자가 직접 객체를 생성하지 않습니다. private OwnerRepository repo; // OwnerRepository 를 외부로 부터 주입받는다. // 생성자 주입을 통해 OwnerRepository 객체를 넣어줍니다. @Autowired public OwnerController(OwnerRepository repo) &#123; this.repo = repo; &#125;// repo를 사용합니다. &#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Core","slug":"Spring/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring/Spring-Core/"}],"tags":[]},{"title":"백준 - 14499 주사위 굴리기","slug":"algorithm/baekjoon/시뮬레이션/14499","date":"2021-02-15T22:51:54.000Z","updated":"2024-02-18T16:19:54.511Z","comments":true,"path":"2021/02/16/algorithm/baekjoon/시뮬레이션/14499/","link":"","permalink":"https://ckck803.github.io/2021/02/16/algorithm/baekjoon/%E1%84%89%E1%85%B5%E1%84%86%E1%85%B2%E1%86%AF%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB/14499/","excerpt":"https://www.acmicpc.net/problem/14499 체점 현황 문제 해설문제를 입력받는 곳에서 함정이 있다. 평소에 세로를 y, 가로를 x로 놓고 문제를 해결하는 사람들에게는 틀리기 너무 좋은 문제주사위의 현재 위치를 계속 추적하면서 주사위 상태도 계속해서 관리해야 한다. 위치를 쉽게 관리하기 위해서 전역변수를 통해 전역적으로 관리했다. #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m, x, y, k;int map[22][22];int cube[4][3];vector&lt;int&gt; command;void moveUp() &#123; if (x - 1 &gt;= 0) &#123; x -= 1; int temp01, temp11, temp21, temp31; temp01 = cube[0][1]; temp11 = cube[1][1]; temp21 = cube[2][1]; temp31 = cube[3][1]; cube[0][1] = temp11; cube[1][1] = temp21; cube[2][1] = temp31; cube[3][1] = temp01; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveDown() &#123; if (x + 1 &lt; n) &#123; x += 1; int temp01, temp11, temp21, temp31; temp01 = cube[0][1]; temp11 = cube[1][1]; temp21 = cube[2][1]; temp31 = cube[3][1]; cube[1][1] = temp01; cube[2][1] = temp11; cube[3][1] = temp21; cube[0][1] = temp31; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveRight() &#123; if (y + 1 &lt; m) &#123; y += 1; int temp11, temp12, temp31, temp10; temp11 = cube[1][1]; temp12 = cube[1][2]; temp31 = cube[3][1]; temp10 = cube[1][0]; cube[1][1] = temp10; cube[1][2] = temp11; cube[3][1] = temp12; cube[1][0] = temp31; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveLeft() &#123; if (y - 1 &gt;= 0) &#123; y -= 1; int temp11, temp12, temp31, temp10; temp11 = cube[1][1]; temp12 = cube[1][2]; temp31 = cube[3][1]; temp10 = cube[1][0]; cube[1][0] = temp11; cube[1][1] = temp12; cube[1][2] = temp31; cube[3][1] = temp10; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveCube() &#123; int commandNum = command.size(); for (int i = 0; i &lt; commandNum; i++) &#123; int cntCommand = command[i]; if (cntCommand == 1) &#123; moveRight(); &#125; if (cntCommand == 2) &#123; moveLeft(); &#125; if (cntCommand == 3) &#123; moveUp(); &#125; if (cntCommand == 4) &#123; moveDown(); &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; &#125; map[x][y] = 0; for (int i = 0; i &lt; k; i++) &#123; int temp = 0; cin &gt;&gt; temp; command.push_back(temp); &#125; moveCube(); return 0;&#125;","text":"https://www.acmicpc.net/problem/14499 체점 현황 문제 해설문제를 입력받는 곳에서 함정이 있다. 평소에 세로를 y, 가로를 x로 놓고 문제를 해결하는 사람들에게는 틀리기 너무 좋은 문제주사위의 현재 위치를 계속 추적하면서 주사위 상태도 계속해서 관리해야 한다. 위치를 쉽게 관리하기 위해서 전역변수를 통해 전역적으로 관리했다. #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m, x, y, k;int map[22][22];int cube[4][3];vector&lt;int&gt; command;void moveUp() &#123; if (x - 1 &gt;= 0) &#123; x -= 1; int temp01, temp11, temp21, temp31; temp01 = cube[0][1]; temp11 = cube[1][1]; temp21 = cube[2][1]; temp31 = cube[3][1]; cube[0][1] = temp11; cube[1][1] = temp21; cube[2][1] = temp31; cube[3][1] = temp01; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveDown() &#123; if (x + 1 &lt; n) &#123; x += 1; int temp01, temp11, temp21, temp31; temp01 = cube[0][1]; temp11 = cube[1][1]; temp21 = cube[2][1]; temp31 = cube[3][1]; cube[1][1] = temp01; cube[2][1] = temp11; cube[3][1] = temp21; cube[0][1] = temp31; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveRight() &#123; if (y + 1 &lt; m) &#123; y += 1; int temp11, temp12, temp31, temp10; temp11 = cube[1][1]; temp12 = cube[1][2]; temp31 = cube[3][1]; temp10 = cube[1][0]; cube[1][1] = temp10; cube[1][2] = temp11; cube[3][1] = temp12; cube[1][0] = temp31; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveLeft() &#123; if (y - 1 &gt;= 0) &#123; y -= 1; int temp11, temp12, temp31, temp10; temp11 = cube[1][1]; temp12 = cube[1][2]; temp31 = cube[3][1]; temp10 = cube[1][0]; cube[1][0] = temp11; cube[1][1] = temp12; cube[1][2] = temp31; cube[3][1] = temp10; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveCube() &#123; int commandNum = command.size(); for (int i = 0; i &lt; commandNum; i++) &#123; int cntCommand = command[i]; if (cntCommand == 1) &#123; moveRight(); &#125; if (cntCommand == 2) &#123; moveLeft(); &#125; if (cntCommand == 3) &#123; moveUp(); &#125; if (cntCommand == 4) &#123; moveDown(); &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; &#125; map[x][y] = 0; for (int i = 0; i &lt; k; i++) &#123; int temp = 0; cin &gt;&gt; temp; command.push_back(temp); &#125; moveCube(); return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"시뮬레이션","slug":"Programming/Beakjoon/시뮬레이션","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"}],"tags":[]},{"title":"백준 3190 - 뱀","slug":"algorithm/baekjoon/BFS/3190","date":"2021-02-15T22:44:52.000Z","updated":"2024-02-18T16:19:54.510Z","comments":true,"path":"2021/02/16/algorithm/baekjoon/BFS/3190/","link":"","permalink":"https://ckck803.github.io/2021/02/16/algorithm/baekjoon/BFS/3190/","excerpt":"https://www.acmicpc.net/problem/3190 체점 현황 전체 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;int board[110][110];int board_size;int num_of_apple;int num_of_command;map&lt;int, char&gt; command;// 동, 남, 서, 북int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123;0, 1, 0, -1&#125;;int direction[4] = &#123;0, 1, 2, 3&#125;;struct snake &#123; int y; int x; int dir;&#125;;int main(void) &#123; cin &gt;&gt; board_size &gt;&gt; num_of_apple; for (int i = 0; i &lt; num_of_apple; i++) &#123; int y, x; cin &gt;&gt; y &gt;&gt; x; board[y][x] = 1; &#125; cin &gt;&gt; num_of_command; for (int i = 0; i &lt; num_of_command; i++) &#123; int time; char dir; cin &gt;&gt; time &gt;&gt; dir; command[time] = dir; &#125; queue&lt;pair&lt;int, int&gt;&gt; snake_tail; int snake_head_y = 1; int snake_haed_x = 1; int snake_dir = 0; snake_tail.push(&#123;1, 1&#125;); board[1][1] = 2; int time = 0; while (true) &#123; time++; snake_head_y += dy[snake_dir]; snake_haed_x += dx[snake_dir]; snake_tail.push(&#123;snake_head_y, snake_haed_x&#125;); if (board[snake_head_y][snake_haed_x] == 2) &#123; cout &lt;&lt; time &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; if (0 &gt;= snake_head_y || snake_head_y &gt; board_size || 0 &gt;= snake_haed_x || snake_haed_x &gt; board_size) &#123; cout &lt;&lt; time &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; if (board[snake_head_y][snake_haed_x] == 1) &#123; board[snake_head_y][snake_haed_x] = 2; &#125; else &#123; board[snake_head_y][snake_haed_x] = 2; board[snake_tail.front().first][snake_tail.front().second] = 0; snake_tail.pop(); &#125; if (command.find(time) != command.end()) &#123; char com = command[time]; command.erase(time); if (com == &#x27;L&#x27;) &#123; snake_dir = (snake_dir + 3) % 4; &#125; else &#123; snake_dir = (snake_dir + 1) % 4; &#125; &#125; &#125; return 0;&#125;","text":"https://www.acmicpc.net/problem/3190 체점 현황 전체 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;int board[110][110];int board_size;int num_of_apple;int num_of_command;map&lt;int, char&gt; command;// 동, 남, 서, 북int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123;0, 1, 0, -1&#125;;int direction[4] = &#123;0, 1, 2, 3&#125;;struct snake &#123; int y; int x; int dir;&#125;;int main(void) &#123; cin &gt;&gt; board_size &gt;&gt; num_of_apple; for (int i = 0; i &lt; num_of_apple; i++) &#123; int y, x; cin &gt;&gt; y &gt;&gt; x; board[y][x] = 1; &#125; cin &gt;&gt; num_of_command; for (int i = 0; i &lt; num_of_command; i++) &#123; int time; char dir; cin &gt;&gt; time &gt;&gt; dir; command[time] = dir; &#125; queue&lt;pair&lt;int, int&gt;&gt; snake_tail; int snake_head_y = 1; int snake_haed_x = 1; int snake_dir = 0; snake_tail.push(&#123;1, 1&#125;); board[1][1] = 2; int time = 0; while (true) &#123; time++; snake_head_y += dy[snake_dir]; snake_haed_x += dx[snake_dir]; snake_tail.push(&#123;snake_head_y, snake_haed_x&#125;); if (board[snake_head_y][snake_haed_x] == 2) &#123; cout &lt;&lt; time &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; if (0 &gt;= snake_head_y || snake_head_y &gt; board_size || 0 &gt;= snake_haed_x || snake_haed_x &gt; board_size) &#123; cout &lt;&lt; time &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; if (board[snake_head_y][snake_haed_x] == 1) &#123; board[snake_head_y][snake_haed_x] = 2; &#125; else &#123; board[snake_head_y][snake_haed_x] = 2; board[snake_tail.front().first][snake_tail.front().second] = 0; snake_tail.pop(); &#125; if (command.find(time) != command.end()) &#123; char com = command[time]; command.erase(time); if (com == &#x27;L&#x27;) &#123; snake_dir = (snake_dir + 3) % 4; &#125; else &#123; snake_dir = (snake_dir + 1) % 4; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"틀렸습니다 5","slug":"틀렸습니다-5","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-5/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://ckck803.github.io/tags/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://ckck803.github.io/tags/%EC%82%BC%EC%84%B1-%EA%B8%B0%EC%B6%9C/"}]},{"title":"JPA - Entity의 생명주기","slug":"jpa/jpa-programming/persist/persistence","date":"2021-02-15T15:14:03.000Z","updated":"2024-02-18T16:19:54.531Z","comments":true,"path":"2021/02/16/jpa/jpa-programming/persist/persistence/","link":"","permalink":"https://ckck803.github.io/2021/02/16/jpa/jpa-programming/persist/persistence/","excerpt":"목차 JPA - Entity의 생명주기 JPA - Persist Context (영속성 컨텍스트) 엔티티 생명주기비영속 (new&#x2F;transient) Entity 객체가 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 Entity 객체가 생성돼 아직 영속성 컨텍스트에 저장되기 전 상태다. // 비영속 상태Member member = new Member();member.setId(101L);member.setName(&quot;HelloJPA&quot;); 영속 (managed) Entity 객체가 현재 영속성 컨텍스트에 관리되는 상태","text":"목차 JPA - Entity의 생명주기 JPA - Persist Context (영속성 컨텍스트) 엔티티 생명주기비영속 (new&#x2F;transient) Entity 객체가 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 Entity 객체가 생성돼 아직 영속성 컨텍스트에 저장되기 전 상태다. // 비영속 상태Member member = new Member();member.setId(101L);member.setName(&quot;HelloJPA&quot;); 영속 (managed) Entity 객체가 현재 영속성 컨텍스트에 관리되는 상태 해당 객체(Entity) 에 대한 변경 작업은 영속성 컨텍스트가 관리한다. EntityManager Persist 메소드를 이용해 Entity 객체를 영속성 컨텍스트에 저장할 수 있다. // 영속 상태em.persist(member); 준영속 (detached) 객체가 영속성 컨텍스트에 저장돼 있다가 현재는 영속성 컨텍스트에서 분리(삭제)된 상태, 더 이상 JPA 가 관리하지 않는다. 영속성 컨텍스트에서 분리(삭제) 됐을 뿐이지 데이터적으로의 삭제는 일어나지 않는다. 해당 객체(Entity) 에 대한 변경 작업이 일어나도 영속성 컨텍스트 및 Database에 반영되지 않는다. // 준 상태em.detach(member); 삭제 (removed) 데이터 적으로 삭제된 상태 // 삭제 상태em.remove(member);","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"백준 1753 - 최단 경로","slug":"algorithm/baekjoon/다익스트라/1753","date":"2021-02-15T15:13:22.000Z","updated":"2024-02-18T16:19:54.510Z","comments":true,"path":"2021/02/16/algorithm/baekjoon/다익스트라/1753/","link":"","permalink":"https://ckck803.github.io/2021/02/16/algorithm/baekjoon/%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1/1753/","excerpt":"https://www.acmicpc.net/problem/1753 문제 해설가장 기본적이고 정형화된 다익스트라 문제이다! 다익스트라 알고리즘에서는 우선순위 큐를 사용하는데 기본적으로 우선순위 큐는 값이 큰 것부터 우선적으로 나가게 된다. #include &lt;bits/stdc++.h&gt;using namespace std;#define INF 987654321int V, E;int startPoint;int dist[20002]; // dist[x] : 시작점으로부터 점 x까지의 최단 거리를 저장한다.vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;void dijkstra(int start) &#123; // 초기값은 무한대로 설정해 놓는다. for (int i = 1; i &lt; V + 1; i++) &#123; dist[i] = INF; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; pq; pq.push(&#123;0, start&#125;); dist[start] = 0; while (!pq.empty()) &#123; int cntDist = -pq.top().first; int cntVertex = pq.top().second; pq.pop(); // 현재 점까지의 거리와 저장된 최단거리를 비교한다. // 현재 점까지의 거리가 더 큰 경우는 나중에 최단거리가 갱신된 것이다. // 우리는 각 점에 최단거리로 간 상태에 대해서만 갱신을 진행하므로 밑의 연산은 진행하지 않는다. if (cntDist &gt; dist[cntVertex]) &#123; continue; &#125; // 아래 로직을 대신 사용해도 결과는 똑같이 나온다. // 즉 현재 점까지의 거리가 최단거리까지와 일치하는지 확인하는 단계이다. // if (cntDist != dist[cntVertex]) &#123; // continue; // &#125; for (int i = 0; i &lt; graph[cntVertex].size(); i++) &#123; int nextVertex = graph[cntVertex][i].first; int weight = graph[cntVertex][i].second; // cntDist 대신 dist[cntVertex]를 사용해도 결과는 동일하다 // int nextDist = dist[cntVertex] + weight; int nextDist = cntDist + weight; if (dist[nextVertex] &gt; nextDist) &#123; dist[nextVertex] = nextDist; // 값을 음수로 저장해 우선순위가 반대가 되도록 한다. pq.push(&#123;-nextDist, nextVertex&#125;); &#125; &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; V &gt;&gt; E; cin &gt;&gt; startPoint; graph = vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(V + 1); for (int i = 0; i &lt; E; i++) &#123; int a, b, weight; cin &gt;&gt; a &gt;&gt; b &gt;&gt; weight; graph[a].push_back(&#123;b, weight&#125;); &#125; dijkstra(startPoint); for (int i = 1; i &lt;= V; i++) &#123; if (dist[i] == INF) &#123; cout &lt;&lt; &quot;INF&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; cout &lt;&lt; dist[i] &lt;&lt; &#x27;\\n&#x27;; &#125; &#125; return 0;&#125; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; 우선순위 큐에 greater&lt;pair&lt;int, int&gt;&gt;&gt; pq 정렬 방식을 통해 값이 작은 것부터 우선적으로 나가게 된다. #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF 2000000000// 정점의 개수 : v, 간선의 개수 : eint v, e;vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;vector&lt;int&gt; dist;vector&lt;bool&gt; check;int start_node;void dijkstra()&#123; for (int i = 1; i &lt;= v; i++) dist[i] = INF; dist[start_node] = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; pq.push(&#123;0, start_node&#125;); while (!pq.empty()) &#123; int weight = pq.top().first; int cnt_node = pq.top().second; pq.pop(); if (check[cnt_node] == true) continue; check[cnt_node] = true; // 점 cnt_node에 연결된 간선의 개수 int edge_num = graph[cnt_node].size(); for (int j = 0; j &lt; edge_num; j++) &#123; // from : 현재 위치, to : 다음 위치, from_to_weight : 현재위치에서 다음위치 까지의 가중치 int from = cnt_node, to = graph[cnt_node][j].first, from_to_weight = graph[cnt_node][j].second; if (dist[to] &gt; dist[from] + from_to_weight) &#123; dist[to] = dist[from] + from_to_weight; pq.push(&#123;dist[to], to&#125;); &#125; &#125; &#125;&#125;int main(void)&#123; scanf(&quot;%d %d %d&quot;, &amp;v, &amp;e, &amp;start_node); dist = vector&lt;int&gt;(v + 1, INF); check = vector&lt;bool&gt;(v + 1, false); graph = vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(v + 1); for (int i = 0; i &lt; e; i++) &#123; int from, to, weight; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;weight); graph[from].push_back(&#123;to, weight&#125;); &#125; dijkstra(); for (int i = 1; i &lt;= v; i++) &#123; if (dist[i] == INF) printf(&quot;INF\\n&quot;); else &#123; printf(&quot;%d\\n&quot;, dist[i]); &#125; &#125; return 0;&#125;","text":"https://www.acmicpc.net/problem/1753 문제 해설가장 기본적이고 정형화된 다익스트라 문제이다! 다익스트라 알고리즘에서는 우선순위 큐를 사용하는데 기본적으로 우선순위 큐는 값이 큰 것부터 우선적으로 나가게 된다. #include &lt;bits/stdc++.h&gt;using namespace std;#define INF 987654321int V, E;int startPoint;int dist[20002]; // dist[x] : 시작점으로부터 점 x까지의 최단 거리를 저장한다.vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;void dijkstra(int start) &#123; // 초기값은 무한대로 설정해 놓는다. for (int i = 1; i &lt; V + 1; i++) &#123; dist[i] = INF; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; pq; pq.push(&#123;0, start&#125;); dist[start] = 0; while (!pq.empty()) &#123; int cntDist = -pq.top().first; int cntVertex = pq.top().second; pq.pop(); // 현재 점까지의 거리와 저장된 최단거리를 비교한다. // 현재 점까지의 거리가 더 큰 경우는 나중에 최단거리가 갱신된 것이다. // 우리는 각 점에 최단거리로 간 상태에 대해서만 갱신을 진행하므로 밑의 연산은 진행하지 않는다. if (cntDist &gt; dist[cntVertex]) &#123; continue; &#125; // 아래 로직을 대신 사용해도 결과는 똑같이 나온다. // 즉 현재 점까지의 거리가 최단거리까지와 일치하는지 확인하는 단계이다. // if (cntDist != dist[cntVertex]) &#123; // continue; // &#125; for (int i = 0; i &lt; graph[cntVertex].size(); i++) &#123; int nextVertex = graph[cntVertex][i].first; int weight = graph[cntVertex][i].second; // cntDist 대신 dist[cntVertex]를 사용해도 결과는 동일하다 // int nextDist = dist[cntVertex] + weight; int nextDist = cntDist + weight; if (dist[nextVertex] &gt; nextDist) &#123; dist[nextVertex] = nextDist; // 값을 음수로 저장해 우선순위가 반대가 되도록 한다. pq.push(&#123;-nextDist, nextVertex&#125;); &#125; &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; V &gt;&gt; E; cin &gt;&gt; startPoint; graph = vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(V + 1); for (int i = 0; i &lt; E; i++) &#123; int a, b, weight; cin &gt;&gt; a &gt;&gt; b &gt;&gt; weight; graph[a].push_back(&#123;b, weight&#125;); &#125; dijkstra(startPoint); for (int i = 1; i &lt;= V; i++) &#123; if (dist[i] == INF) &#123; cout &lt;&lt; &quot;INF&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; cout &lt;&lt; dist[i] &lt;&lt; &#x27;\\n&#x27;; &#125; &#125; return 0;&#125; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; 우선순위 큐에 greater&lt;pair&lt;int, int&gt;&gt;&gt; pq 정렬 방식을 통해 값이 작은 것부터 우선적으로 나가게 된다. #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF 2000000000// 정점의 개수 : v, 간선의 개수 : eint v, e;vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;vector&lt;int&gt; dist;vector&lt;bool&gt; check;int start_node;void dijkstra()&#123; for (int i = 1; i &lt;= v; i++) dist[i] = INF; dist[start_node] = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; pq.push(&#123;0, start_node&#125;); while (!pq.empty()) &#123; int weight = pq.top().first; int cnt_node = pq.top().second; pq.pop(); if (check[cnt_node] == true) continue; check[cnt_node] = true; // 점 cnt_node에 연결된 간선의 개수 int edge_num = graph[cnt_node].size(); for (int j = 0; j &lt; edge_num; j++) &#123; // from : 현재 위치, to : 다음 위치, from_to_weight : 현재위치에서 다음위치 까지의 가중치 int from = cnt_node, to = graph[cnt_node][j].first, from_to_weight = graph[cnt_node][j].second; if (dist[to] &gt; dist[from] + from_to_weight) &#123; dist[to] = dist[from] + from_to_weight; pq.push(&#123;dist[to], to&#125;); &#125; &#125; &#125;&#125;int main(void)&#123; scanf(&quot;%d %d %d&quot;, &amp;v, &amp;e, &amp;start_node); dist = vector&lt;int&gt;(v + 1, INF); check = vector&lt;bool&gt;(v + 1, false); graph = vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(v + 1); for (int i = 0; i &lt; e; i++) &#123; int from, to, weight; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;weight); graph[from].push_back(&#123;to, weight&#125;); &#125; dijkstra(); for (int i = 1; i &lt;= v; i++) &#123; if (dist[i] == INF) printf(&quot;INF\\n&quot;); else &#123; printf(&quot;%d\\n&quot;, dist[i]); &#125; &#125; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"다익스트라","slug":"Programming/Beakjoon/다익스트라","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"Spring Boot 게시판 만들기 15 - Github와 jenkins 연동하기","slug":"spring/sample-board/board-15-github-webhook","date":"2021-02-14T16:47:01.000Z","updated":"2024-02-26T15:47:30.066Z","comments":true,"path":"2021/02/15/spring/sample-board/board-15-github-webhook/","link":"","permalink":"https://ckck803.github.io/2021/02/15/spring/sample-board/board-15-github-webhook/","excerpt":"15. Github와 jenkins 연동하기Github webhookngrok을 이용해 외부접근이 가능하도록 네트워크 열기Push 이벤트가 일어났을 때 로컬 Jenkins가 해당 훅을 받기 위해서는 해당 네트워크(포트)를 외부접근이 가능하게 열어놔야 한다.ngrok 프로그램을 사용해 Github로부터 hook을 받을 수 있도록 Jenkins 포트를 열어준다. ngrok은 local PC를 외부에서 접근이 가능하도록 열어주는 프로그램이다. Webhook 추가하기Project Repository &gt; settings &gt; Webhooks &gt; add webhook 로 이동해 Payload URL에 http://[서버 IP주소]:[Port번호]/github-webhook/ 형식으로 날릴 주소를 기입하도록한다. 반드시 주소 뒤에 &#x2F;github-webhook&#x2F; 를 추가해야 한다. Push가 일어났을 때 Payload URL(Jenkins)로 Hook을 날린다.","text":"15. Github와 jenkins 연동하기Github webhookngrok을 이용해 외부접근이 가능하도록 네트워크 열기Push 이벤트가 일어났을 때 로컬 Jenkins가 해당 훅을 받기 위해서는 해당 네트워크(포트)를 외부접근이 가능하게 열어놔야 한다.ngrok 프로그램을 사용해 Github로부터 hook을 받을 수 있도록 Jenkins 포트를 열어준다. ngrok은 local PC를 외부에서 접근이 가능하도록 열어주는 프로그램이다. Webhook 추가하기Project Repository &gt; settings &gt; Webhooks &gt; add webhook 로 이동해 Payload URL에 http://[서버 IP주소]:[Port번호]/github-webhook/ 형식으로 날릴 주소를 기입하도록한다. 반드시 주소 뒤에 &#x2F;github-webhook&#x2F; 를 추가해야 한다. Push가 일어났을 때 Payload URL(Jenkins)로 Hook을 날린다. github에서 Webhook을 설정하면 github에서 hook을 날리는 것을 확인할 수 있다. 빌드 진행하기Push 하기 ngrok 로그 확인github로 push를 하게 되면 jenkins서버로 hook을 날리는 것을 확인할 수 있다. build History 확인하기jenkins에 새로운 build가 생성된 것을 확인할 수 있다. 콘솔 출력 확인build가 정상적으로 이루어지고 있는지 아니면 오류가 발생했는지를 확인할 수 있다. Github Hook Log 확인코드에 변화가 있을 경우에는 jenkins에서 해당 프로젝트를 build하지만 코드에 변화가 없을 경우에는 build를 진행하지 않는다. 코드에 변화가 있을 경우 로그 코드에 변화가 없을 경우 로그","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 16 - Github와 jenkins 연동하기","slug":"spring/sample-board/board-16-github-webhook","date":"2021-02-14T16:47:01.000Z","updated":"2024-02-26T15:47:34.200Z","comments":true,"path":"2021/02/15/spring/sample-board/board-16-github-webhook/","link":"","permalink":"https://ckck803.github.io/2021/02/15/spring/sample-board/board-16-github-webhook/","excerpt":"16. Github와 jenkins 연동하기Github webhookngrok을 이용해 외부접근이 가능하도록 네트워크 열기Push 이벤트가 일어났을 때 로컬 Jenkins가 해당 훅을 받기 위해서는 해당 네트워크(포트)를 외부접근이 가능하게 열어놔야 한다.ngrok 프로그램을 사용해 Github로부터 hook을 받을 수 있도록 Jenkins 포트를 열어준다. ngrok은 local PC를 외부에서 접근이 가능하도록 열어주는 프로그램이다. Webhook 추가하기Project Repository &gt; settings &gt; Webhooks &gt; add webhook 로 이동해 Payload URL에 http://[서버 IP주소]:[Port번호]/github-webhook/ 형식으로 날릴 주소를 기입하도록한다. 반드시 주소 뒤에 &#x2F;github-webhook&#x2F; 를 추가해야 한다. Push가 일어났을 때 Payload URL(Jenkins)로 Hook을 날린다.","text":"16. Github와 jenkins 연동하기Github webhookngrok을 이용해 외부접근이 가능하도록 네트워크 열기Push 이벤트가 일어났을 때 로컬 Jenkins가 해당 훅을 받기 위해서는 해당 네트워크(포트)를 외부접근이 가능하게 열어놔야 한다.ngrok 프로그램을 사용해 Github로부터 hook을 받을 수 있도록 Jenkins 포트를 열어준다. ngrok은 local PC를 외부에서 접근이 가능하도록 열어주는 프로그램이다. Webhook 추가하기Project Repository &gt; settings &gt; Webhooks &gt; add webhook 로 이동해 Payload URL에 http://[서버 IP주소]:[Port번호]/github-webhook/ 형식으로 날릴 주소를 기입하도록한다. 반드시 주소 뒤에 &#x2F;github-webhook&#x2F; 를 추가해야 한다. Push가 일어났을 때 Payload URL(Jenkins)로 Hook을 날린다. github에서 Webhook을 설정하면 github에서 hook을 날리는 것을 확인할 수 있다. 빌드 진행하기Push 하기 ngrok 로그 확인github로 push를 하게 되면 jenkins서버로 hook을 날리는 것을 확인할 수 있다. build History 확인하기jenkins에 새로운 build가 생성된 것을 확인할 수 있다. 콘솔 출력 확인build가 정상적으로 이루어지고 있는지 아니면 오류가 발생했는지를 확인할 수 있다. Github Hook Log 확인코드에 변화가 있을 경우에는 jenkins에서 해당 프로젝트를 build하지만 코드에 변화가 없을 경우에는 build를 진행하지 않는다. 코드에 변화가 있을 경우 로그 코드에 변화가 없을 경우 로그","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 14 - Jenkins 프로젝트 만들기","slug":"spring/sample-board/board-14-jenkins-plan","date":"2021-02-14T04:11:40.000Z","updated":"2024-02-26T15:47:22.274Z","comments":true,"path":"2021/02/14/spring/sample-board/board-14-jenkins-plan/","link":"","permalink":"https://ckck803.github.io/2021/02/14/spring/sample-board/board-14-jenkins-plan/","excerpt":"14. Jenkins 프로젝트 만들기 새 프로젝트 만들기 소스 코드 관리 소스 코드를 가져오기 위한 계정 추가하기 빌드 유발 선택 Build 선택하기 프로젝트 확인 프로젝트 build하기 프로젝트 결과 확인 새 프로젝트 만들기create a Job &gt; FreeStyle project 를 선택해 새 프로젝트를 만든다. 소스 코드 관리git을 선택한 후 Build할 Repository URL을 넣어준다. 계정 추가하기","text":"14. Jenkins 프로젝트 만들기 새 프로젝트 만들기 소스 코드 관리 소스 코드를 가져오기 위한 계정 추가하기 빌드 유발 선택 Build 선택하기 프로젝트 확인 프로젝트 build하기 프로젝트 결과 확인 새 프로젝트 만들기create a Job &gt; FreeStyle project 를 선택해 새 프로젝트를 만든다. 소스 코드 관리git을 선택한 후 Build할 Repository URL을 넣어준다. 계정 추가하기Credential 종류(kind)로는 Username with password 를 선택한 다음 username에는 Github Id를 Password에는 Github Password를 기입해 계정을 추가한다. 빌드 유발 선택Github hook trigger for GITScm polling 을 선택해 Github에 프로젝트를 Push했을 때 build가 진행될 수 있도록 한다. 개발자 Github로 PUSH를 날리게 되면 Github는 Web hook을 Jenkins으로 날려준다. Build 선택하기shell 명령어를 이용해 프로젝트를 빌드 할 것이므로 Execute shell 을 선택한 후 명령어는 .&#x2F;gradlew clean build 를 기입한다. Spring Boot 프로젝트는 gradle wrapper를 사용함으로 gradlew를 사용한 Build 방법도 사용할 수 있다. 개인적으론 gradlew를 사용한 Build방식이 더 좋은 것 같다. 프로젝트 확인Dashboard에 새로운 Jenkins 프로젝트가 생성된 것을 확인할 수 있다. 프로젝트 build하기새로운 프로젝트를 생성한 후 해당 프로젝트가 github로부터 파일을 제대로 읽어와 build할 수 있는지 확인하기 위해 Build Now 를 눌러 빌드를 진행해본다. 프로젝트 결과 확인빌드 후 성공했다는 메시지를 받을 수 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 13 - jenkins를 이용해 build 하기","slug":"spring/sample-board/board-13-jenkins","date":"2021-02-14T03:11:40.000Z","updated":"2024-02-26T15:47:18.295Z","comments":true,"path":"2021/02/14/spring/sample-board/board-13-jenkins/","link":"","permalink":"https://ckck803.github.io/2021/02/14/spring/sample-board/board-13-jenkins/","excerpt":"13. jenkins를 이용해 build하기jenkins를 로컬에 바로 설치해 사용해도 되지만 해당 프로젝트에서는 docker를 이용해 jenkins이미지를 불러와 빌드를 진행할 것이다. docker 설치하기도커는 https://docs.docker.com/get-docker/ 에서 본인 운영체제에 맞는 것을 선택해 다운로드 한다. 본인이 사용하는 프로젝트의 jdk 버전에 맞는 jenkins 파일 가져와야 build시에 jdk 버전 오류가 안생긴다. JDK11버전의 jenkins 이미지를 불러오도록 한다. docker images 명령어를 통해 이미지들을 확인할 수 있다. # lts버전의 jenkins 이미지docker pull jenkins/jenkins:lts# jdk11버전의 jenkins 이미지docker pull jenkins/jenkins:jdk11# 설치된 이미지들 확인docker images jenkins 이미지 실행하기","text":"13. jenkins를 이용해 build하기jenkins를 로컬에 바로 설치해 사용해도 되지만 해당 프로젝트에서는 docker를 이용해 jenkins이미지를 불러와 빌드를 진행할 것이다. docker 설치하기도커는 https://docs.docker.com/get-docker/ 에서 본인 운영체제에 맞는 것을 선택해 다운로드 한다. 본인이 사용하는 프로젝트의 jdk 버전에 맞는 jenkins 파일 가져와야 build시에 jdk 버전 오류가 안생긴다. JDK11버전의 jenkins 이미지를 불러오도록 한다. docker images 명령어를 통해 이미지들을 확인할 수 있다. # lts버전의 jenkins 이미지docker pull jenkins/jenkins:lts# jdk11버전의 jenkins 이미지docker pull jenkins/jenkins:jdk11# 설치된 이미지들 확인docker images jenkins 이미지 실행하기local의 8090포트를 container의 8080포트에 포워딩 시켜준다. container의 특성상 데이터 휘발성 때문에 container 내부에 데이터를 저장할 수 없다. v 옵션을 통해 local의 폴더와 conatainer의 폴더를 공유해 container에 저장한 내용이 그대로 local에도 저장되도록 한다. 8080포트는 평소 스프링 부트를 사용하기에 충돌을 막기 위해 8090포트를 선택했다. # lts버전으로 실행시docker run -d -p 8090:8080 -p 50000:50000 -v ~/docker/jenkins:/var/jenkins_home jenkins/jenkins:lts# jdk11버전으로 실행시docker run -d -p 8090:8080 -p 50000:50000 -v ~/docker/jenkins-jdk11:/var/jenkins_home jenkins/jenkins:jdk11# docker container Id3c29b7adb686ad8310bf474fe91406e1ab8c569568e2ef2b5d09f40525aa78ee jenkins 설정jenkins 초기 비밀번호localhost:8090 으로 들어가게 되면 다음과 같이 초기 비밀번호를 입력하라는 창이 뜬다. docker의 경우 log를 확인하면 jenkins 초기 비밀번호를 확인할 수 있다. docker logs [container Id] 명령어를 통해 console에서 docker 로그를 확인할 수 있다. docker를 통해 처음으로 jenkins 이미지를 실행하게 되면 log에 jenkins 초기 비밀번호를 확인할 수 있다. jenkins 플러그인 설치Install suggested plugins 로 플러그인들을 설치한 후 새로운 계정을 만들게 되면 jenkins에 접근할 수 있다. jenkins 프로젝트 만들기새 프로젝트 만들기새로운 Item 만들기 &gt; FreeStyle project 를 선택해 새 프로젝트를 만든다. 소스 코드 관리소스 코드 관리에서 git 을 선택한 후 build할 Repository URL을 넣어준다. 계정 추가하기Credential 종류(kind)로는 Username with password 를 선택한 다음 username에는 Github Id를 Password에는 Github Password를 기입해 계정을 추가한다. 빌드 유발 선택Github hook trigger for GITScm polling 을 선택해 Github에 프로젝트를 Push했을 때 build가 진행될 수 있도록 한다. Build 선택하기shell 명령어를 이용해 SpringBoot 프로젝트를 빌드 할 것이므로 Execute shell 을 선택한 후 명령어는 ./gradlew clean build 를 기입한다. 프로젝트 확인Dashboard에 새로운 jenkins 프로젝트가 생성된 것을 확인할 수 있다. 프로젝트 build하기새로운 프로젝트를 생성한 후 해당 프로젝트가 github로부터 파일을 제대로 읽어와 build할 수 있는지 확인하기 위해 Build Now 를 눌러 빌드를 진행해본다. 프로젝트 결과 확인빌드 후 성공했다는 메시지를 받을 수 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 12 - 타임리프 오류 해결하기","slug":"spring/sample-board/board-12-errors","date":"2021-02-13T17:23:28.000Z","updated":"2024-02-26T15:47:12.741Z","comments":true,"path":"2021/02/14/spring/sample-board/board-12-errors/","link":"","permalink":"https://ckck803.github.io/2021/02/14/spring/sample-board/board-12-errors/","excerpt":"12. 타임리프 오류 해결하기null 오류게시물이 하나도 없을 때 Thymeleaf에서 null인 객체를 참조하여 오류가 발생하는 것을 확인할 수 있었다. 객체를 반환할 때 데이터가 null인 경우 비어있는 객체를 생성해 반환하도록 한다. @GetMapping(&quot;/&quot;)public String board(@PageableDefault Pageable pageable, Model model) &#123; Page&lt;Post&gt; posts = postService.getPosts(pageable); if(posts == null)&#123; posts = new PageImpl&lt;Post&gt;(new ArrayList&lt;&gt;()); &#125; model.addAttribute(&quot;PostList&quot;, posts); return &quot;board&quot;;&#125; paging 오류데이터가 하나도 없는데 pagination 목록에서 1과 0이 떠있는 오류를 발견했다.","text":"12. 타임리프 오류 해결하기null 오류게시물이 하나도 없을 때 Thymeleaf에서 null인 객체를 참조하여 오류가 발생하는 것을 확인할 수 있었다. 객체를 반환할 때 데이터가 null인 경우 비어있는 객체를 생성해 반환하도록 한다. @GetMapping(&quot;/&quot;)public String board(@PageableDefault Pageable pageable, Model model) &#123; Page&lt;Post&gt; posts = postService.getPosts(pageable); if(posts == null)&#123; posts = new PageImpl&lt;Post&gt;(new ArrayList&lt;&gt;()); &#125; model.addAttribute(&quot;PostList&quot;, posts); return &quot;board&quot;;&#125; paging 오류데이터가 하나도 없는데 pagination 목록에서 1과 0이 떠있는 오류를 발견했다. startIdx= $&#123;PostList.totalPages == 0&#125; ? 0 : $&#123;T(Math).floor(PostList?.number/5)&#125;*5+1 조건을 추가해 page가 하나도 없을 경우 0을 반환하도록 해 페이지 목록에 0만 나타나게 한다. &lt;div class=&quot;text-center &quot;&gt; &lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot; th:with=&quot;startIdx= $&#123;PostList.totalPages == 0&#125; ? 0 : $&#123;T(Math).floor(PostList?.number/5)&#125;*5+1, lastIdx=($&#123;PostList.totalPages&#125; &gt; $&#123;startIdx&#125;+4) ? $&#123;startIdx&#125;+4 : $&#123;PostList.totalPages&#125;&quot; &gt; &lt;li th:class=&quot;$&#123;PostList.first&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.first&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;startIdx&#125;-1)&#125;&quot; aria-label=&quot;Previous&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:style=&quot;$&#123;PostList.first&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;)&#125;&quot;&gt;&amp;lsaquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;($&#123;page&#125; == $&#123;PostList.number&#125;+1)&quot; th:each=&quot;page: $&#123;#numbers.sequence(startIdx, lastIdx)&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:text=&quot;$&#123;page&#125;&quot; th:href=&quot;@&#123;/(page=$&#123;page&#125;)&#125;&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;li th:style=&quot;$&#123;PostList.last&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;+2)&#125;&quot;&gt;&amp;rsaquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;$&#123;PostList.last&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.last&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;lastIdx&#125;+1)&#125;&quot; aria-label=&quot;Next&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; pagation 목록에 0만 떠 있는 것을 확인할 수 있다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 11 - 페이징 처리하기","slug":"spring/sample-board/board-11-paging","date":"2021-02-13T02:59:50.000Z","updated":"2024-02-26T15:47:08.290Z","comments":true,"path":"2021/02/13/spring/sample-board/board-11-paging/","link":"","permalink":"https://ckck803.github.io/2021/02/13/spring/sample-board/board-11-paging/","excerpt":"11. 페이징 처리하기메인 게시판을 접근하게 되면 한번에 너무 많은 게시글들이 쏟아져 나오게 돼 보기가 좋지 않고 서버도 많은 양의 데이터를 한번에 보내야 하기 때문에 성능에서도 좋지 않다.사용자에게 전체 데이터에서 적당한 양의 데이터만 보여줘 사용자 입장에서도 서버 입장에서도 부담이 없게 한다. Control 로직 수정하기Spring에서 제공하는 Pageable 인터페이스를 사용하면 쉽게 페이징 기능을 사용할 수 있다. BoardController.java @Controller@RequiredArgsConstructorpublic class BoardController &#123; private final PostService postService;// @GetMapping(&quot;/&quot;)// public String board(Model model)&#123;// List&lt;Post&gt; posts = postService.getAllPosts();// model.addAttribute(&quot;PostList&quot;, posts);// return &quot;board&quot;;// &#125; @GetMapping(&quot;/&quot;) public String board(@PageableDefault Pageable pageable, Model model) &#123; Page&lt;Post&gt; posts = postService.getPosts(pageable); model.addAttribute(&quot;PostList&quot;, posts); return &quot;board&quot;; &#125;&#125; 테스트 코드 로직 변경@Test@DisplayName(&quot;모든 Post를 가져온다.&quot;)public void board() throws Exception &#123; List&lt;Post&gt; posts = new ArrayList&lt;&gt;(); posts.add(Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build() ); Page&lt;Post&gt; pagePosts = new PageImpl&lt;&gt;(posts); PageRequest pageRequest = PageRequest.of(1, 10); given(postService.getPosts(pageRequest)).willReturn(pagePosts); ResultActions resultActions = mockMvc.perform(get(&quot;/&quot;) .param(&quot;page&quot;, &quot;1&quot;)// .flashAttr(&quot;PostList&quot;, new ArrayList&lt;&gt;()) ); resultActions .andExpect(status().isOk()) .andDo(print()); verify(postService).getPosts(pageRequest);&#125; Servic 로직 추가","text":"11. 페이징 처리하기메인 게시판을 접근하게 되면 한번에 너무 많은 게시글들이 쏟아져 나오게 돼 보기가 좋지 않고 서버도 많은 양의 데이터를 한번에 보내야 하기 때문에 성능에서도 좋지 않다.사용자에게 전체 데이터에서 적당한 양의 데이터만 보여줘 사용자 입장에서도 서버 입장에서도 부담이 없게 한다. Control 로직 수정하기Spring에서 제공하는 Pageable 인터페이스를 사용하면 쉽게 페이징 기능을 사용할 수 있다. BoardController.java @Controller@RequiredArgsConstructorpublic class BoardController &#123; private final PostService postService;// @GetMapping(&quot;/&quot;)// public String board(Model model)&#123;// List&lt;Post&gt; posts = postService.getAllPosts();// model.addAttribute(&quot;PostList&quot;, posts);// return &quot;board&quot;;// &#125; @GetMapping(&quot;/&quot;) public String board(@PageableDefault Pageable pageable, Model model) &#123; Page&lt;Post&gt; posts = postService.getPosts(pageable); model.addAttribute(&quot;PostList&quot;, posts); return &quot;board&quot;; &#125;&#125; 테스트 코드 로직 변경@Test@DisplayName(&quot;모든 Post를 가져온다.&quot;)public void board() throws Exception &#123; List&lt;Post&gt; posts = new ArrayList&lt;&gt;(); posts.add(Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build() ); Page&lt;Post&gt; pagePosts = new PageImpl&lt;&gt;(posts); PageRequest pageRequest = PageRequest.of(1, 10); given(postService.getPosts(pageRequest)).willReturn(pagePosts); ResultActions resultActions = mockMvc.perform(get(&quot;/&quot;) .param(&quot;page&quot;, &quot;1&quot;)// .flashAttr(&quot;PostList&quot;, new ArrayList&lt;&gt;()) ); resultActions .andExpect(status().isOk()) .andDo(print()); verify(postService).getPosts(pageRequest);&#125; Servic 로직 추가PageRequest는 Pageable 인터페이스를 구현해 놓은 클래스이다. page, size, sort 를 변수를 설정함으로써 쉽게 paging 요청을 할 수 있다. page : 찾을 페이지size : 한 페이지 내에 가져올 목록(데이터)의 개수sort : 페이징을 정렬하는 방식 Paging은 sort를 통해 데이터들을 정렬하고 size를 통해 데이터들을 그룹으로 나눈 후 각 그룹에 번호를 붙이고 page를 통해 해당 그룹을 가져온다. PostService.java public Page&lt;Post&gt; getPosts(Pageable pageable) &#123; int page; if(pageable.getPageNumber() &lt;= 0)&#123; page = 0; &#125;else&#123; page = pageable.getPageNumber()-1; &#125; Pageable requestPageable = PageRequest.of(page, pageable.getPageSize()); return postRepository.findAll(requestPageable);&#125; Id 역순으로 정렬하기@Transactionalpublic void deletePostById(Long id)&#123; postRepository.deleteById(id);&#125;public Page&lt;Post&gt; getPosts(Pageable pageable) &#123; int page; if(pageable.getPageNumber() &lt;= 0)&#123; page = 0; &#125;else&#123; page = pageable.getPageNumber()-1; &#125; Pageable requestPageable = PageRequest.of(page, pageable.getPageSize(), Sort.by(Sort.Direction.DESC, &quot;id&quot;)); return postRepository.findAll(requestPageable);&#125; 타임리프에 paging관련 설정을 해주기Thymeleaf의 th:with 속성을 사용하면 지역변수를 사용할 수 있다. startIdx=$&#123;T(Math).floor(PostList.number/5)&#125;*5+1 : pagenation에서의 시작 번호 lastIdx=($&#123;PostList.totalPages&#125; &gt; $&#123;startIdx&#125;+4) ? $&#123;startIdx&#125;+4 : $&#123;PostList.totalPages&#125; : pagenation에서의 마지막 번호 &lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot; th:with=&quot;startIdx=$&#123;T(Math).floor(PostList.number/5)&#125;*5+1, lastIdx=($&#123;PostList.totalPages&#125; &gt; $&#123;startIdx&#125;+4) ? $&#123;startIdx&#125;+4 : $&#123;PostList.totalPages&#125;&quot;&gt; &lt;li th:class=&quot;$&#123;PostList.first&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.first&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;startIdx&#125;-1)&#125;&quot; aria-label=&quot;Previous&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:style=&quot;$&#123;PostList.first&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;)&#125;&quot;&gt;&amp;lsaquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;($&#123;page&#125; == $&#123;PostList.number&#125;+1)&quot; th:each=&quot;page: $&#123;#numbers.sequence(startIdx, lastIdx)&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:text=&quot;$&#123;page&#125;&quot; th:href=&quot;@&#123;/(page=$&#123;page&#125;)&#125;&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;li th:style=&quot;$&#123;PostList.last&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;+2)&#125;&quot;&gt;&amp;rsaquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;$&#123;PostList.last&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.last&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;lastIdx&#125;+1)&#125;&quot; aria-label=&quot;Next&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 이전 그룹으로 이동하기 PostList.first : 현재 페이지가 제일 첫페인지 아닌지 (boolean) PostList.last : 현재 페이지가 제일 마지막 페이지 인지 아닌지 (boolean) &lt;li th:class=&quot;$&#123;PostList.first&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.first&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;startIdx&#125;-1)&#125;&quot; aria-label=&quot;Previous&quot;&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt; 이전 페이지로 이동하기&lt;li th:style=&quot;$&#123;PostList.first&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;)&#125;&quot;&gt;&amp;lsaquo;&lt;/a&gt;&lt;/li&gt; 페이지 그룹 보여주기&lt;li th:class=&quot;($&#123;page&#125; == $&#123;PostList.number&#125;+1)&quot; th:each=&quot;page: $&#123;#numbers.sequence(startIdx, lastIdx)&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:text=&quot;$&#123;page&#125;&quot; th:href=&quot;@&#123;/(page=$&#123;page&#125;)&#125;&quot;&gt;&lt;/a&gt;&lt;/li&gt; 다음 페이지로 이동하기&lt;li th:style=&quot;$&#123;PostList.last&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;+2)&#125;&quot;&gt;&amp;rsaquo;&lt;/a&gt;&lt;/li&gt; 다음 그룹으로 이동하기&lt;li th:class=&quot;$&#123;PostList.last&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.last&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;lastIdx&#125;+1)&#125;&quot; aria-label=&quot;Next&quot;&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt; List 번호 수정하기페이지를 이동해도 List번호가 1~10 으로 밖에 표현되지 않았다. 각페이지를 이동할 때 페이지 번호에 각 세부 번호를 나타낼 수 있도록 표현을 바꿔준다. &lt;tbody class=&quot;text-center&quot;&gt;&lt;tr th:each=&quot;Post:$&#123;PostList&#125;&quot; th:id=&quot;*&#123;Post.id&#125;&quot;&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;PostStat.index + 1&#125; + $&#123;PostList.number&#125;*10&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot;&gt; &lt;a th:href=&quot;@&#123;/post/&#123;id&#125;(id=$&#123;Post.id&#125;)&#125;&quot; th:text=&quot;$&#123;Post.title&#125;&quot;&gt;&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.name&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.writeTime&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-center align-middle&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; th:href=&quot;@&#123;/post/&#123;id&#125;/revise(id=$&#123;Post.id&#125;)&#125;&quot;&gt;수정&lt;/a&gt; &lt;a href=&quot;#&quot; th:href=&quot;&#x27;javascript:deletePost(&#x27;+$&#123;Post.id&#125;+&#x27;)&#x27;&quot; class=&quot;btn btn-danger&quot;&gt;삭제&lt;/a&gt; &lt;!-- &lt;button id=&quot;delete-btn&quot; type=&quot;submit&quot; class=&quot;btn btn-danger&quot; th:onclick=&quot;deletePost([[ $&#123;Post.id&#125; ]]);&quot;&gt;삭제&lt;/button&gt;--&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 10 - 포스트 삭제하기","slug":"spring/sample-board/board-10-delete","date":"2021-02-12T16:19:00.000Z","updated":"2024-02-26T15:47:04.330Z","comments":true,"path":"2021/02/13/spring/sample-board/board-10-delete/","link":"","permalink":"https://ckck803.github.io/2021/02/13/spring/sample-board/board-10-delete/","excerpt":"10. 포스트 삭제하기PostController.java @PostMapping(&quot;/post/&#123;postId&#125;/delete&quot;)public String deletePost(@PathVariable(&quot;postId&quot;) Long id)&#123; postService.deletePostById(id); return &quot;redirect:/&quot;;&#125; PostService.java @Transactionalpublic void deletePostById(Long id)&#123; postRepository.deleteById(id);&#125; Post.html &lt;tbody class=&quot;text-center&quot;&gt;&lt;tr th:each=&quot;Post:$&#123;PostList&#125;&quot; th:id=&quot;*&#123;Post.id&#125;&quot;&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;PostStat.index+1&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot;&gt; &lt;a th:href=&quot;@&#123;/post/&#123;id&#125;(id=$&#123;Post.id&#125;)&#125;&quot; th:text=&quot;$&#123;Post.title&#125;&quot;&gt;&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.name&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.writeTime&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-center align-middle&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; th:href=&quot;@&#123;/post/&#123;id&#125;/revise(id=$&#123;Post.id&#125;)&#125;&quot;&gt;수정&lt;/a&gt; &lt;a href=&quot;#&quot; th:href=&quot;&#x27;javascript:deletePost(&#x27;+$&#123;Post.id&#125;+&#x27;)&#x27;&quot; class=&quot;btn btn-danger&quot;&gt;삭제&lt;/a&gt;&lt;!--&lt;button id=&quot;delete-btn&quot; type=&quot;submit&quot; class=&quot;btn btn-danger&quot; th:onclick=&quot;deletePost([[ $&#123;Post.id&#125; ]]);&quot;&gt;삭제&lt;/button&gt;--&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; function deletePost(id) &#123; if(confirm(id + &quot;번 게시글을 삭제하시겠습니까?&quot;)) &#123; const action = &quot;/post/&quot; + id + &quot;/delete&quot; let form = document.createElement(&quot;form&quot;); form.setAttribute(&quot;method&quot;, &quot;post&quot;); form.setAttribute(&quot;action&quot;, action); document.body.appendChild(form); form.submit(); &#125;&#125;// var table = document.getElementById(&#x27;PostTable&#x27;);//// async function deletePost(id) &#123;// url = &quot;http://localhost:8080/post/&quot; + id + &quot;/delete&quot;;// console.log(url);// const response = await fetch(url, &#123;// method: &#x27;post&#x27;// &#125;);// &#125;","text":"10. 포스트 삭제하기PostController.java @PostMapping(&quot;/post/&#123;postId&#125;/delete&quot;)public String deletePost(@PathVariable(&quot;postId&quot;) Long id)&#123; postService.deletePostById(id); return &quot;redirect:/&quot;;&#125; PostService.java @Transactionalpublic void deletePostById(Long id)&#123; postRepository.deleteById(id);&#125; Post.html &lt;tbody class=&quot;text-center&quot;&gt;&lt;tr th:each=&quot;Post:$&#123;PostList&#125;&quot; th:id=&quot;*&#123;Post.id&#125;&quot;&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;PostStat.index+1&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot;&gt; &lt;a th:href=&quot;@&#123;/post/&#123;id&#125;(id=$&#123;Post.id&#125;)&#125;&quot; th:text=&quot;$&#123;Post.title&#125;&quot;&gt;&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.name&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.writeTime&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-center align-middle&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; th:href=&quot;@&#123;/post/&#123;id&#125;/revise(id=$&#123;Post.id&#125;)&#125;&quot;&gt;수정&lt;/a&gt; &lt;a href=&quot;#&quot; th:href=&quot;&#x27;javascript:deletePost(&#x27;+$&#123;Post.id&#125;+&#x27;)&#x27;&quot; class=&quot;btn btn-danger&quot;&gt;삭제&lt;/a&gt;&lt;!--&lt;button id=&quot;delete-btn&quot; type=&quot;submit&quot; class=&quot;btn btn-danger&quot; th:onclick=&quot;deletePost([[ $&#123;Post.id&#125; ]]);&quot;&gt;삭제&lt;/button&gt;--&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; function deletePost(id) &#123; if(confirm(id + &quot;번 게시글을 삭제하시겠습니까?&quot;)) &#123; const action = &quot;/post/&quot; + id + &quot;/delete&quot; let form = document.createElement(&quot;form&quot;); form.setAttribute(&quot;method&quot;, &quot;post&quot;); form.setAttribute(&quot;action&quot;, action); document.body.appendChild(form); form.submit(); &#125;&#125;// var table = document.getElementById(&#x27;PostTable&#x27;);//// async function deletePost(id) &#123;// url = &quot;http://localhost:8080/post/&quot; + id + &quot;/delete&quot;;// console.log(url);// const response = await fetch(url, &#123;// method: &#x27;post&#x27;// &#125;);// &#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 9 - 페이지 수정하기","slug":"spring/sample-board/board-9-detail-revise","date":"2021-02-12T12:13:28.000Z","updated":"2024-02-26T15:46:59.572Z","comments":true,"path":"2021/02/12/spring/sample-board/board-9-detail-revise/","link":"","permalink":"https://ckck803.github.io/2021/02/12/spring/sample-board/board-9-detail-revise/","excerpt":"9. 페이지 수정하기데이터를 수정하기 위해서는 수정하고자 하는 데이터를 찾아야 하기 때문에 id값이 필요하다. input태그의 type속성을 hidden으로해 form을 작성한 후 나머지 데이터와 함께 id값을 넘겨주도록 한다. post.html &lt;h2&gt;게시글 작성&lt;/h2&gt;&lt;div class=&quot;card&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 20px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; th:action=&quot;@&#123;/post&#125;&quot; th:object=&quot;$&#123;postDto&#125;&quot;&gt; &lt;input type=&quot;hidden&quot; th:if=&quot;*&#123;id != null and id &gt; 0&#125;&quot; th:field=&quot;*&#123;id&#125;&quot;/&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;제목&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; style=&quot;border-radius: 5px;&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;title&#125;&quot; placeholder=&quot;제목을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;이름&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; style=&quot;border-radius: 5px;&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;name&#125;&quot;placeholder=&quot;이름을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;내용&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;textarea class=&quot;form-control&quot; style=&quot;height: 300px; border-radius: 5px;&quot; th:field=&quot;*&#123;content&#125;&quot; placeholder=&quot;내용을 입력해 주세요.&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a th:href=&quot;@&#123;/&#125;&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;저장하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 수정페이지로 이동하기데이터를 수정위해서 URL경로를 통해 수정할 데이터의 id값을 받아온 후 해당 id값을 이용해 데이터를 조회한 뒤 기존 데이터를 반환하도록 한다. 내부 로직은 상세페이지를 가져오는 것과 똑같고 반환하는 템플릿만 다르게 반환한다. PostController.java @GetMapping(&quot;/post/&#123;postId&#125;/revise&quot;)public String getPostDetailsToRevise(@PathVariable(&quot;postId&quot;) Long id, Model model) &#123; Post post = postService.getPostById(id); PostDto postDto = PostDto.builder() .id(post.getId()) .name(post.getName()) .title(post.getTitle()) .content(post.getContent()) .writeTime(post.getWriteTime()) .build(); model.addAttribute(&quot;postDto&quot;, postDto); return &quot;post&quot;;&#125; PostControllerTest.java","text":"9. 페이지 수정하기데이터를 수정하기 위해서는 수정하고자 하는 데이터를 찾아야 하기 때문에 id값이 필요하다. input태그의 type속성을 hidden으로해 form을 작성한 후 나머지 데이터와 함께 id값을 넘겨주도록 한다. post.html &lt;h2&gt;게시글 작성&lt;/h2&gt;&lt;div class=&quot;card&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 20px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; th:action=&quot;@&#123;/post&#125;&quot; th:object=&quot;$&#123;postDto&#125;&quot;&gt; &lt;input type=&quot;hidden&quot; th:if=&quot;*&#123;id != null and id &gt; 0&#125;&quot; th:field=&quot;*&#123;id&#125;&quot;/&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;제목&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; style=&quot;border-radius: 5px;&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;title&#125;&quot; placeholder=&quot;제목을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;이름&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; style=&quot;border-radius: 5px;&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;name&#125;&quot;placeholder=&quot;이름을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;내용&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;textarea class=&quot;form-control&quot; style=&quot;height: 300px; border-radius: 5px;&quot; th:field=&quot;*&#123;content&#125;&quot; placeholder=&quot;내용을 입력해 주세요.&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a th:href=&quot;@&#123;/&#125;&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;저장하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 수정페이지로 이동하기데이터를 수정위해서 URL경로를 통해 수정할 데이터의 id값을 받아온 후 해당 id값을 이용해 데이터를 조회한 뒤 기존 데이터를 반환하도록 한다. 내부 로직은 상세페이지를 가져오는 것과 똑같고 반환하는 템플릿만 다르게 반환한다. PostController.java @GetMapping(&quot;/post/&#123;postId&#125;/revise&quot;)public String getPostDetailsToRevise(@PathVariable(&quot;postId&quot;) Long id, Model model) &#123; Post post = postService.getPostById(id); PostDto postDto = PostDto.builder() .id(post.getId()) .name(post.getName()) .title(post.getTitle()) .content(post.getContent()) .writeTime(post.getWriteTime()) .build(); model.addAttribute(&quot;postDto&quot;, postDto); return &quot;post&quot;;&#125; PostControllerTest.java @Test@DisplayName(&quot;포스트 수정 페이지로 이동한다.&quot;)public void getPostDetailsToRevise() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.getPostById(1L)).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(get(&quot;/post/1/revise&quot;)); verify(postService).getPostById(1L); resultActions .andExpect(status().isOk());&#125; 데이터 수정 요청 처리를 위한 Control입력받은 데이터를 확인해 id값이 있을 경우에는 새로운 Post를 생성하게 id값이 없는 경우에는 기존 데이터를 Update하도록 한다. form 태그는 Get과 Post 메소드만 사용할 수 있다. Patch 사용하려고 method까지 다 만들어 놨는데 나중가서 생각남….. PostController.java @PostMapping(&quot;/post&quot;)public String creatNewPost(@Valid @ModelAttribute(&quot;postDto&quot;) PostDto postDto) &#123; if(postDto.getId() == null) &#123; postService.addPost(postDto); &#125;else&#123; postService.revisePostDetails(postDto); &#125; return &quot;redirect:/&quot;;&#125; 수정요청에 대한 테스트 코드 작성데이터 수정이 제대로 이루어진 경우 /로 redirection이 이루어진다. 결과값으로 상태코드가 302로 뜨는지 확인하도록 한다. PostControllerTest.java @Test@DisplayName(&quot;포스트를 수정한다.&quot;)public void creatOrUpdatePost() throws Exception &#123; PostDto postDto = PostDto.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .build(); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;id&quot;, &quot;1&quot;) .param(&quot;name&quot;, &quot;tester&quot;) .param(&quot;title&quot;, &quot;test&quot;) .param(&quot;content&quot;, &quot;test&quot;) ); verify(postService).updatePost(postDto); resultActions .andExpect(status().is3xxRedirection()) .andDo(print()) ;&#125; 데이터 수정을 위한 Service 로직여기서는 DB조회시 PostNotExistedException 예외가 일어날 일이 없다. Control에서 id값의 유무를 통해 create와 update로 나누어 실행하기 때문이다. PostService.java @Transactionalpublic Post updatePost(PostDto postDto) &#123; Post oldPost = postRepository.findById(postDto.getId()).orElseThrow(() -&gt; new PostNotExistedException(postDto.getId())); oldPost.revise(postDto); return oldPost;&#125; 데이터 수정에 대한 테스트 코드 작성PostServiceTest.java @Test@DisplayName(&quot;포스트 데이터를 업데이트 한다.&quot;)public void updatePost()&#123; PostDto postDto = PostDto.builder() .id(1L) .name(&quot;junit&quot;) .title(&quot;junitTest&quot;) .content(&quot;content&quot;) .build(); Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postRepository.findById(1L)).willReturn(Optional.of(mockPost)); Post post = postService.updatePost(postDto); verify(postRepository).findById(1L); assertThat(post.getName()).isEqualTo(postDto.getName()); assertThat(post.getTitle()).isEqualTo(postDto.getTitle()); assertThat(post.getContent()).isEqualTo(postDto.getContent());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 8 - 상세 페이지","slug":"spring/sample-board/board-8-detail-post","date":"2021-02-12T11:42:27.000Z","updated":"2024-02-26T15:46:55.903Z","comments":true,"path":"2021/02/12/spring/sample-board/board-8-detail-post/","link":"","permalink":"https://ckck803.github.io/2021/02/12/spring/sample-board/board-8-detail-post/","excerpt":"&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:replace=&quot;/fragments/head :: main-head&quot;&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav th:replace=&quot;/fragments/navbar :: main-nav&quot;&gt;&lt;/nav&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;h2&gt;상세 페이지&lt;/h2&gt; &lt;div class=&quot;card&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 20px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; th:object=&quot;$&#123;postDto&#125;&quot;&gt; &lt;h1 th:text=&quot;*&#123;title&#125;&quot;&gt;제목&lt;/h1&gt; &lt;span&gt;작성자 : &lt;/span&gt; &lt;span th:text=&quot;*&#123;name&#125;&quot;&gt;Tester &lt;/span&gt; &lt;hr&gt; &lt;p class=&quot;lead&quot; style=&quot;height: 300px; border-radius: 5px;&quot; th:text=&quot;*&#123;content&#125;&quot;&gt;&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;text-right&quot; style=&quot;padding-right: 10px;&quot;&gt; &lt;span class=&quot;text-right&quot;&gt;작성일 : &lt;/span&gt; &lt;span class=&quot;text-right&quot; th:text=&quot;*&#123;writeTime&#125;&quot;&gt;작성일 &lt;/span&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;수정하기&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-danger waves-effect waves-light&quot;&gt;삭제하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","text":"&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:replace=&quot;/fragments/head :: main-head&quot;&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav th:replace=&quot;/fragments/navbar :: main-nav&quot;&gt;&lt;/nav&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;h2&gt;상세 페이지&lt;/h2&gt; &lt;div class=&quot;card&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 20px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; th:object=&quot;$&#123;postDto&#125;&quot;&gt; &lt;h1 th:text=&quot;*&#123;title&#125;&quot;&gt;제목&lt;/h1&gt; &lt;span&gt;작성자 : &lt;/span&gt; &lt;span th:text=&quot;*&#123;name&#125;&quot;&gt;Tester &lt;/span&gt; &lt;hr&gt; &lt;p class=&quot;lead&quot; style=&quot;height: 300px; border-radius: 5px;&quot; th:text=&quot;*&#123;content&#125;&quot;&gt;&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;text-right&quot; style=&quot;padding-right: 10px;&quot;&gt; &lt;span class=&quot;text-right&quot;&gt;작성일 : &lt;/span&gt; &lt;span class=&quot;text-right&quot; th:text=&quot;*&#123;writeTime&#125;&quot;&gt;작성일 &lt;/span&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;수정하기&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-danger waves-effect waves-light&quot;&gt;삭제하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 7 - 특정 페이지를 가져오기","slug":"spring/sample-board/board-7-detail","date":"2021-02-12T08:17:44.000Z","updated":"2024-02-26T15:46:51.955Z","comments":true,"path":"2021/02/12/spring/sample-board/board-7-detail/","link":"","permalink":"https://ckck803.github.io/2021/02/12/spring/sample-board/board-7-detail/","excerpt":"7. 특정 포스트를 불러오기특정 포스트 불러오기 요청 처리하기 PostController @GetMapping(&quot;/post/&#123;postId&#125;&quot;)public String getPostDetails(@PathVariable(&quot;postId&quot;)Long id, Model model)&#123; Post post = postService.getPostById(id); PostDto postDto = PostDto.builder() .id(post.getId()) .name(post.getName()) .title(post.getTitle()) .content(post.getContent()) .writeTime(post.getWriteTime()) .build(); model.addAttribute(&quot;postDto&quot;, postDto); return &quot;details&quot;;&#125; PostControllerTest.java @Test@DisplayName(&quot;상세 페이지를 가져온다.&quot;)public void getPostDetails() throws Exception&#123; Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.getPostById(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(get(&quot;/post/1&quot;)); resultActions .andExpect(status().isOk()); verify(postService).getPostById(any());&#125; PostControllerTest.java @Test@DisplayName(&quot;상세 페이지를 못 가져온다.&quot;)public void getPostDetailsException() throws Exception&#123; given(postService.getPostById(any())).willThrow(new PostNotExistedException(1L)); ResultActions resultActions = mockMvc.perform(get(&quot;/post/1&quot;)); resultActions .andExpect(status().isNotFound()); verify(postService).getPostById(any());&#125; 포스트가 없는 경우에 대한 예외처리하기","text":"7. 특정 포스트를 불러오기특정 포스트 불러오기 요청 처리하기 PostController @GetMapping(&quot;/post/&#123;postId&#125;&quot;)public String getPostDetails(@PathVariable(&quot;postId&quot;)Long id, Model model)&#123; Post post = postService.getPostById(id); PostDto postDto = PostDto.builder() .id(post.getId()) .name(post.getName()) .title(post.getTitle()) .content(post.getContent()) .writeTime(post.getWriteTime()) .build(); model.addAttribute(&quot;postDto&quot;, postDto); return &quot;details&quot;;&#125; PostControllerTest.java @Test@DisplayName(&quot;상세 페이지를 가져온다.&quot;)public void getPostDetails() throws Exception&#123; Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.getPostById(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(get(&quot;/post/1&quot;)); resultActions .andExpect(status().isOk()); verify(postService).getPostById(any());&#125; PostControllerTest.java @Test@DisplayName(&quot;상세 페이지를 못 가져온다.&quot;)public void getPostDetailsException() throws Exception&#123; given(postService.getPostById(any())).willThrow(new PostNotExistedException(1L)); ResultActions resultActions = mockMvc.perform(get(&quot;/post/1&quot;)); resultActions .andExpect(status().isNotFound()); verify(postService).getPostById(any());&#125; 포스트가 없는 경우에 대한 예외처리하기BoardErrorAdvice.java @ControllerAdvicepublic class BoardErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.NOT_FOUND) @ExceptionHandler(PostNotExistedException.class) public void handleNotFound()&#123; &#125;&#125; PostNotExistedException.java public class PostNotExistedException extends RuntimeException&#123; public PostNotExistedException(Long id)&#123; super(&quot;Post id : &quot; + id + &quot; is not Existed&quot;); &#125;&#125; PostService.java public Post getPostById(Long id) &#123; Post post = postRepository.findById(id).orElseThrow(() -&gt; new PostNotExistedException(id)); return post;&#125; PostServiceTest.java @Test@DisplayName(&quot;특정 포스트를 가져온다.&quot;)public void getPostById()&#123; Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postRepository.findById(1L)).willReturn(Optional.of(mockPost)); Post post = postService.getPostById(1L); verify(postRepository).findById(1L); assertThat(post.getId()).isEqualTo(mockPost.getId()); assertThat(post.getTitle()).isEqualTo(mockPost.getTitle()); assertThat(post.getName()).isEqualTo(mockPost.getName()); assertThat(post.getContent()).isEqualTo(mockPost.getContent()); assertThat(post.getWriteTime()).isEqualTo(mockPost.getWriteTime());&#125;@Test@DisplayName(&quot;특정 포스트를 못 가져온다.&quot;)public void getPostByIdException()&#123; Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postRepository.findById(1L)).willThrow(new PostNotExistedException(1L)); assertThatThrownBy(() -&gt;&#123; postService.getPostById(1L); &#125;).isInstanceOf(PostNotExistedException.class); verify(postRepository).findById(1L);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 6 - 게시판 페이지 만들기","slug":"spring/sample-board/board-6-list","date":"2021-02-12T08:10:45.000Z","updated":"2024-02-26T15:46:45.341Z","comments":true,"path":"2021/02/12/spring/sample-board/board-6-list/","link":"","permalink":"https://ckck803.github.io/2021/02/12/spring/sample-board/board-6-list/","excerpt":"게시판 페이지 템플릿게시판 페이지도 게시판 작성페이지와 똑같이 Bootstrap 과 BootWatch 를 이용해 만들었다. &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/custom.min.css&quot;&gt; &lt;title&gt;게시글 작성 페이지&lt;/title&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-primary fixed-top&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;게시판&lt;/a&gt;&lt;/nav&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;form class=&quot;form-inline my-2 my-lg-0 float-right&quot; style=&quot;padding-bottom : 16px;&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;text&quot; placeholder=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-secondary my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;div class=&quot;table-responsive clearfix&quot;&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;등록일&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;btn_wrap text-right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;Write&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;text-center &quot;&gt; &lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item active&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;4&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 타임리프 문법 적용하기&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:replace=&quot;fragments/head :: main-head&quot;/&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav th:replace=&quot;fragments/navbar :: main-nav&quot;/&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;form class=&quot;form-inline my-2 my-lg-0 float-right&quot; style=&quot;padding-bottom : 16px;&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;text&quot; placeholder=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-secondary my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;div class=&quot;table-responsive clearfix&quot;&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead class=&quot;text-center&quot;&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;등록일&lt;/th&gt; &lt;th &gt;수정/삭제&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class=&quot;text-center&quot;&gt; &lt;tr th:each=&quot;Post:$&#123;PostList&#125;&quot;&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;PostStat.index+1&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot;&gt; &lt;a th:text=&quot;$&#123;Post.title&#125;&quot;&gt;&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.name&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.writeTime&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-center align-middle&quot;&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;수정&lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt;삭제&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;btn_wrap text-right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;Write&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;text-center &quot;&gt; &lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item active&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;4&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","text":"게시판 페이지 템플릿게시판 페이지도 게시판 작성페이지와 똑같이 Bootstrap 과 BootWatch 를 이용해 만들었다. &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/custom.min.css&quot;&gt; &lt;title&gt;게시글 작성 페이지&lt;/title&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-primary fixed-top&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;게시판&lt;/a&gt;&lt;/nav&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;form class=&quot;form-inline my-2 my-lg-0 float-right&quot; style=&quot;padding-bottom : 16px;&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;text&quot; placeholder=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-secondary my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;div class=&quot;table-responsive clearfix&quot;&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;등록일&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;btn_wrap text-right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;Write&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;text-center &quot;&gt; &lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item active&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;4&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 타임리프 문법 적용하기&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:replace=&quot;fragments/head :: main-head&quot;/&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav th:replace=&quot;fragments/navbar :: main-nav&quot;/&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;form class=&quot;form-inline my-2 my-lg-0 float-right&quot; style=&quot;padding-bottom : 16px;&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;text&quot; placeholder=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-secondary my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;div class=&quot;table-responsive clearfix&quot;&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead class=&quot;text-center&quot;&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;등록일&lt;/th&gt; &lt;th &gt;수정/삭제&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class=&quot;text-center&quot;&gt; &lt;tr th:each=&quot;Post:$&#123;PostList&#125;&quot;&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;PostStat.index+1&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot;&gt; &lt;a th:text=&quot;$&#123;Post.title&#125;&quot;&gt;&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.name&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.writeTime&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-center align-middle&quot;&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;수정&lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt;삭제&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;btn_wrap text-right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;Write&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;text-center &quot;&gt; &lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item active&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;4&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 5 - 모든 Post 가져오기","slug":"spring/sample-board/board-5-all","date":"2021-02-12T01:06:30.000Z","updated":"2024-02-26T15:46:31.466Z","comments":true,"path":"2021/02/12/spring/sample-board/board-5-all/","link":"","permalink":"https://ckck803.github.io/2021/02/12/spring/sample-board/board-5-all/","excerpt":"5. 모든 포스트 가져오기모든 포스트 가져오기 요청 처리하기BoardController.java @Controller@RequiredArgsConstructorpublic class BoardController &#123; private final PostService postService; @GetMapping(&quot;/&quot;) public String board(Model model)&#123; List&lt;Post&gt; posts = postService.getAllPost(); model.addAttribute(&quot;PostList&quot;, posts); return &quot;board&quot;; &#125;&#125; 모든 Post 가져오기 요청에 대한 테스트 코드 작성BoardControllerTest.java @WebMvcTestclass BoardControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private PostService postService; @Test @DisplayName(&quot;모든 Post를 가져온다.&quot;) public void board() throws Exception &#123; List&lt;Post&gt; posts = new ArrayList&lt;&gt;(); posts.add(Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build() ); given(postService.getAllPost()).willReturn(posts); ResultActions resultActions = mockMvc.perform(get(&quot;/&quot;)); resultActions .andExpect(status().isOk()) .andDo(print()); verify(postService).getAllPost(); &#125;&#125; 데이터 조회@Service@RequiredArgsConstructorpublic class PostService &#123; private final PostRepository postRepository; public Post addPost(Post newPost) &#123; return postRepository.save(newPost); &#125; public List&lt;Post&gt; getAllPost() &#123; return postRepository.findAll(); &#125;&#125;","text":"5. 모든 포스트 가져오기모든 포스트 가져오기 요청 처리하기BoardController.java @Controller@RequiredArgsConstructorpublic class BoardController &#123; private final PostService postService; @GetMapping(&quot;/&quot;) public String board(Model model)&#123; List&lt;Post&gt; posts = postService.getAllPost(); model.addAttribute(&quot;PostList&quot;, posts); return &quot;board&quot;; &#125;&#125; 모든 Post 가져오기 요청에 대한 테스트 코드 작성BoardControllerTest.java @WebMvcTestclass BoardControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private PostService postService; @Test @DisplayName(&quot;모든 Post를 가져온다.&quot;) public void board() throws Exception &#123; List&lt;Post&gt; posts = new ArrayList&lt;&gt;(); posts.add(Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build() ); given(postService.getAllPost()).willReturn(posts); ResultActions resultActions = mockMvc.perform(get(&quot;/&quot;)); resultActions .andExpect(status().isOk()) .andDo(print()); verify(postService).getAllPost(); &#125;&#125; 데이터 조회@Service@RequiredArgsConstructorpublic class PostService &#123; private final PostRepository postRepository; public Post addPost(Post newPost) &#123; return postRepository.save(newPost); &#125; public List&lt;Post&gt; getAllPost() &#123; return postRepository.findAll(); &#125;&#125; 데이터 조회에 대한 테스트 코드 작성@Test@DisplayName(&quot;모든 포스트를 가져온다.&quot;)public void getAllPosts() &#123; List&lt;Post&gt; mockPosts = new ArrayList&lt;&gt;(); mockPosts.add(Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build() ); given(postRepository.findAll()).willReturn(mockPosts); List&lt;Post&gt; posts = postService.getAllPosts(); verify(postRepository).findAll(); Post post = posts.get(0); assertThat(post.getId()).isEqualTo(mockPosts.get(0).getId()); assertThat(post.getTitle()).isEqualTo(mockPosts.get(0).getTitle()); assertThat(post.getName()).isEqualTo(mockPosts.get(0).getName()); assertThat(post.getContent()).isEqualTo(mockPosts.get(0).getContent()); assertThat(post.getWriteTime()).isEqualTo(mockPosts.get(0).getWriteTime());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 4 - My SQL과 연동하기","slug":"spring/sample-board/board-4-mysql","date":"2021-02-11T23:47:12.000Z","updated":"2024-02-26T15:46:26.511Z","comments":true,"path":"2021/02/12/spring/sample-board/board-4-mysql/","link":"","permalink":"https://ckck803.github.io/2021/02/12/spring/sample-board/board-4-mysql/","excerpt":"4. My SQL과 연동의존성 추가My Sql과 연동하기 위해서는 Springboot프로젝트에 의존성을 추가해야 한다. build.gradle implementation &#x27;mysql:mysql-connector-java&#x27; 데이터베이스 접속 설정하기application-mysql.yml spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/[DB]?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: [DB 접속 Id] password: [DB 접송 Password] 접속 설정 가져오기","text":"4. My SQL과 연동의존성 추가My Sql과 연동하기 위해서는 Springboot프로젝트에 의존성을 추가해야 한다. build.gradle implementation &#x27;mysql:mysql-connector-java&#x27; 데이터베이스 접속 설정하기application-mysql.yml spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/[DB]?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: [DB 접속 Id] password: [DB 접송 Password] 접속 설정 가져오기설정에 show_sql 과 format_sql 를 추가해 쿼리문들이 어떻게 출력되는지 눈으로 쉽게 확인할 수 있다. spring.jpa.properties.hibernate.show_sql=true : JPA(hibernamte)가 실행하는 SQL 쿼리문 로그를 출력한다. spring.jpa.properties.hibernate.format_sql=true : SQL문을 보기 좋게 정렬해 출력해준다. application.yml spring: jpa: hibernate: ddl-auto: create properties: hibernate: show_sql: true format_sql: true profiles: include: mysql Springboot를 실행하면 로그에 create 쿼리문이 찍히는 것을 확인할 수 있고 DB로 가게 되면 post 테이블이 생성됬음을 알 수 있다. 임의 데이터 추가하기CommandLineRunner를 사용해서 어플리케이션을 구동하면서 데이터를 데이터 베이스에 저장시킨다. 익명객체 생성 @Beanpublic CommandLineRunner runner(PostRepository postRepository) throws Exception &#123; return new CommandLineRunner() &#123; @Override public void run(String... args) throws Exception &#123; IntStream.rangeClosed(1, 200).forEach(index -&gt; postRepository.save(Post.builder() .title(&quot;게시글&quot; + index) .name(&quot;tester&quot;) .content(&quot;내용&quot; + index) .writeTime(LocalDateTime.now()) .build())); &#125; &#125;;&#125; 람다식으로 직성 @Beanpublic CommandLineRunner runner(PostRepository postRepository) throws Exception &#123; return args -&gt; &#123; IntStream.rangeClosed(1, 200).forEach(index -&gt; postRepository.save(Post.builder() .title(&quot;게시글&quot; + index) .name(&quot;tester&quot;) .content(&quot;내용&quot; + index) .writeTime(LocalDateTime.now()) .build())); &#125;;&#125; 데이터 베이스를 확인해 보니 데이터들이 정상적으로 입력된걸 확인할 수 있었다. 물론 수없이 많은 쿼리문들이 날라간 것도 눈으로 확인할 수 있다!","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 3 - 게시글 작성하기","slug":"spring/sample-board/board-3-post-write","date":"2021-02-11T13:53:28.000Z","updated":"2024-02-26T15:46:22.728Z","comments":true,"path":"2021/02/11/spring/sample-board/board-3-post-write/","link":"","permalink":"https://ckck803.github.io/2021/02/11/spring/sample-board/board-3-post-write/","excerpt":"3. 새로운 Post 생성 요청 처리하기데이터를 저장하는 로직은 DB에 접근을 하기 때문에 다음과 같은 로직을 추가해 DB에 데이터들이 제대로 저장되는지 확인한다. 어플리케이션을 실핸한 후 http://localhost:8080/h2-console 를 통해 데이터 베이스에 접근할 수 있다. application.yml spring: h2: console: enabled: true path: /h2-console datasource: username: sa password: url: jdbc:h2:mem:testdb driver-class-name: org.h2.Driver /post경로로 post 요청이 들어올 경우 입력된 정보들이 제대로 들어왔는지 Validation을 진행하고 문제가 없을 경우 데이터를 저장한다. PostController.java @PostMapping(&quot;/post&quot;)public String creatNewPost(@Valid @ModelAttribute(&quot;postDto&quot;) PostDto postDto) &#123; postService.addPost(postDto); return &quot;redirect:/&quot;;&#125; 생성 요청 테스트 코드 작성하기MockBean 추가하기","text":"3. 새로운 Post 생성 요청 처리하기데이터를 저장하는 로직은 DB에 접근을 하기 때문에 다음과 같은 로직을 추가해 DB에 데이터들이 제대로 저장되는지 확인한다. 어플리케이션을 실핸한 후 http://localhost:8080/h2-console 를 통해 데이터 베이스에 접근할 수 있다. application.yml spring: h2: console: enabled: true path: /h2-console datasource: username: sa password: url: jdbc:h2:mem:testdb driver-class-name: org.h2.Driver /post경로로 post 요청이 들어올 경우 입력된 정보들이 제대로 들어왔는지 Validation을 진행하고 문제가 없을 경우 데이터를 저장한다. PostController.java @PostMapping(&quot;/post&quot;)public String creatNewPost(@Valid @ModelAttribute(&quot;postDto&quot;) PostDto postDto) &#123; postService.addPost(postDto); return &quot;redirect:/&quot;;&#125; 생성 요청 테스트 코드 작성하기MockBean 추가하기PostController의 creatNewPost메소드 내에서는 PostService객체를 사용하기 때문에 테스트코드를 작성하기 위해서 해당 Mock 을 추가해줄 필요가 있다. PostControllerTest.java @MockBeanprivate PostService postService; PostService객체의 MockBean을 생성해주지 않으면 아래와 같은 오류로 테스트가 진행되지 않는다. creatNewPost메소드 /post경로로 post 요청에 대한 테스트 코드를 작성할 것이다. given메소드를 이용해 PostService가 반환할 객체에 대해 정의를 한다. /post경로로 post요청을 보내도록한다. 데이터를 보내기 위해서는 flashAttr 메소드를 이용해 플래시 스코프에 객체를 설정하도록한다. 요청이 완료된 후 리다이렉션(Status Code : 302) 이 제대로 이루어지는지 확인한다. PostControllerTest.java @Test@DisplayName(&quot;새로운 게시글 생성을 성공한다.&quot;)public void successCreateNewPost() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.addPost(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto())// .sessionAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;title&quot;, &quot;test&quot;) .param(&quot;name&quot;, &quot;tester&quot;) .param(&quot;content&quot;, &quot;test&quot;) ); resultActions .andExpect(status().is3xxRedirection()) // Response Header에 있는 Location 정보를 비교한다. .andDo(print()); verify(postService).addPost(any());&#125; 실패에 대한 테스트 코드 진행Controller단에서의 Data Validation이 제대로 작동하는지 확인하기 위한 테스트 코드들이다. title, name, content 에 대한 값의 검증을 해줘야 하기 때문에 세가지 경우로 확인했다. PostControllerTest.java @Test@DisplayName(&quot;새로운 게시글 생성을 실패한다.&quot;)public void failCreateNewFailWithNoTitle() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.addPost(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;name&quot;, &quot;tester&quot;) .param(&quot;content&quot;, &quot;test&quot;) ); resultActions .andExpect(status().isBadRequest()) .andDo(print());&#125;@Test@DisplayName(&quot;새로운 게시글 생성을 실패한다.&quot;)public void failCreateNewFailWithNoName() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.addPost(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;title&quot;, &quot;test&quot;) .param(&quot;content&quot;, &quot;test&quot;) ); resultActions .andExpect(status().isBadRequest()) .andDo(print());&#125;@Test@DisplayName(&quot;새로운 게시글 생성을 실패한다.&quot;)public void failCreateNewFailWithNoContent() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.addPost(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;title&quot;, &quot;test&quot;) .param(&quot;name&quot;, &quot;tester&quot;) ); resultActions .andExpect(status().isBadRequest()) .andDo(print());&#125; 데이터 저장하기PostRepository 객체를 통해 데이터 저장을 진행한다. PostService.java @Service@RequiredArgsConstructorpublic class PostService &#123; private final PostRepository postRepository; @Transactional public Post addPost(PostDto postDto) &#123; Post post = Post.builder() .title(postDto.getTitle()) .name(postDto.getName()) .content(postDto.getContent()) .writeTime(LocalDateTime.now()) .build(); return postRepository.save(post); &#125;&#125; 저장로직에 대한 테스트 코드 작성PostService 객체의 addPost가 실행된 후 값이 제대로 반환됐는지 확인한 후 PostRepository 객체에서 save 메소드가 호출됐는지 확인한다. PostServiceTest.java class PostServiceTest &#123; @Mock private PostRepository postRepository; private PostService postService; @BeforeEach public void init() &#123; MockitoAnnotations.openMocks(this); postService = new PostService(postRepository); &#125; @Test @DisplayName(&quot;새로운 포스트를 추가한다.&quot;) @Transactional public void addPost() &#123; PostDto postDto = PostDto.builder() .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postRepository.save(any())).willReturn(mockPost); Post returnPost = postService.addPost(postDto); assertThat(returnPost.getId()).isEqualTo(mockPost.getId()); assertThat(returnPost.getTitle()).isEqualTo(mockPost.getTitle()); assertThat(returnPost.getName()).isEqualTo(mockPost.getName()); assertThat(returnPost.getContent()).isEqualTo(mockPost.getContent()); assertThat(returnPost.getWriteTime()).isEqualTo(mockPost.getWriteTime()); verify(postRepository).save(any()); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 2 - 게시글 작성페이지 만들기","slug":"spring/sample-board/board-2-post","date":"2021-02-11T10:53:28.000Z","updated":"2024-02-26T15:46:12.192Z","comments":true,"path":"2021/02/11/spring/sample-board/board-2-post/","link":"","permalink":"https://ckck803.github.io/2021/02/11/spring/sample-board/board-2-post/","excerpt":"2. 게시글 작성페이지 설계도메인 설계하기사용자로부터 게시글 제목, 작성자 이름, 게시글 내용과 게시글들을 구별해주기 위해 Id값과 게시글이 언제 작성되었는지 알기 위한 작성시간을 추가해 도메인을 만든다. Post.java @Entity@NoArgsConstructor@AllArgsConstructor@Builder@Getterpublic class Post &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotEmpty private String title; @NotEmpty private String name; @NotEmpty private String content; @NotNull private LocalDateTime writeTime;&#125; DTO 작성하기사용자로부터 Form을 통해 title, name, content를 입력 받는다. Post 객체를 사용해 데이터를 전달받을 수 있지만 View로직이 추가되게 된다. Entity는 DB와 데이터를 주고 받는 객체이기에 DTO를 만들어 Entity를 View로직으로부터 분리해 추후 생길 수 있는 문제를 없애도록 한다.","text":"2. 게시글 작성페이지 설계도메인 설계하기사용자로부터 게시글 제목, 작성자 이름, 게시글 내용과 게시글들을 구별해주기 위해 Id값과 게시글이 언제 작성되었는지 알기 위한 작성시간을 추가해 도메인을 만든다. Post.java @Entity@NoArgsConstructor@AllArgsConstructor@Builder@Getterpublic class Post &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotEmpty private String title; @NotEmpty private String name; @NotEmpty private String content; @NotNull private LocalDateTime writeTime;&#125; DTO 작성하기사용자로부터 Form을 통해 title, name, content를 입력 받는다. Post 객체를 사용해 데이터를 전달받을 수 있지만 View로직이 추가되게 된다. Entity는 DB와 데이터를 주고 받는 객체이기에 DTO를 만들어 Entity를 View로직으로부터 분리해 추후 생길 수 있는 문제를 없애도록 한다. @Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class PostDto &#123; @NotEmpty private String title; @NotEmpty private String name; @NotEmpty private String content;&#125; View에 Thymeleaf문법 적용하기xmlns:th=&quot;http://www.thymeleaf.org&quot;를 추가하면 Thymeleaf문법을 사용할 수 있다. Thymeleaf는 html속성에 th: 를 붙여 사용한다. th:replace=&quot;/fragments/head :: main-head&quot; : 따로 선언돼 있는 html파일로 치환할 수 있다. th:action=&quot;@&#123;/post&#125;&quot; : Thymeleaf를 사용해 URL을 기입하기 위해서는 @를 추가해준다. th:object=&quot;$&#123;postDto&#125;&quot; : 서버로부터 받은 데이터를 사용하기 위해서는 $를 붙여서 사용한다. th:field=&quot;*&#123;title&#125;&quot; : 서버로부터 받은 데이터내의 field값을 사용하기 위해서는 *를 붙여서 사용한다. post.html &lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:replace=&quot;/fragments/head :: main-head&quot;&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav th:replace=&quot;/fragments/navbar :: main-nav&quot;&gt;&lt;/nav&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;h2&gt;게시글 작성&lt;/h2&gt; &lt;div class=&quot;card&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 20px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; th:action=&quot;@&#123;/post&#125;&quot; th:object=&quot;$&#123;postDto&#125;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;제목&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;title&#125;&quot; placeholder=&quot;제목을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;이름&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;name&#125;&quot; placeholder=&quot;이름을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;내용&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;textarea class=&quot;form-control&quot; style=&quot;height: 300px;&quot; th:field=&quot;*&#123;content&#125;&quot; placeholder=&quot;내용을 입력해 주세요.&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;저장하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 공통적으로 사용하는 Html header부분을 따로 정의해 구성요소를 나누어 관리한다. head.html &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:fragment=&quot;main-head&quot;&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;./css/bootstrap.css&#125;&quot;&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;./css/custom.min.css&#125;&quot;&gt; &lt;title&gt;게시글 작성 페이지&lt;/title&gt;&lt;/head&gt;&lt;/html&gt; navigation bar의 경우에도 모든 페이지에서 동일하게 사용함으로 fragment형식으로 만들어 사용한다. navbar.html &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;nav th:fragment=&quot;main-nav&quot; class=&quot;navbar navbar-expand-lg navbar-dark bg-primary fixed-top&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;게시판&lt;/a&gt;&lt;/nav&gt;&lt;/html&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"Spring Boot 게시판 만들기 1 - 게시글 작성 페이지","slug":"spring/sample-board/board-1-init","date":"2021-02-11T07:53:15.000Z","updated":"2024-02-26T15:46:07.674Z","comments":true,"path":"2021/02/11/spring/sample-board/board-1-init/","link":"","permalink":"https://ckck803.github.io/2021/02/11/spring/sample-board/board-1-init/","excerpt":"1. 게시글 작성 페이지 만들기간단하게 게시글 제목, 사용자 이름, 게시글 내용 세가지만 입력 받는 폼을 만들 것이다. 게시글 작성페이지는 Bootstrap을 이용해 만들건데, BootsWatch의 Cosmo navbar가 마음에 들어 이것도 사용할 것이다. 먼저, Bootstrap 사이트에서 css, js, fonts를 다운 받고 BootsWatch사이트 Cosmo 페이지에서 custom.min.css을 다운 받은 후 springboot 프로젝트내의 resources/static위치에 폴더들은 넣는다. Bootstrap 사이트 : https://getbootstrap.com/docs/4.6/getting-started/introduction/Bootswatch 사이트 : https://bootswatch.com/","text":"1. 게시글 작성 페이지 만들기간단하게 게시글 제목, 사용자 이름, 게시글 내용 세가지만 입력 받는 폼을 만들 것이다. 게시글 작성페이지는 Bootstrap을 이용해 만들건데, BootsWatch의 Cosmo navbar가 마음에 들어 이것도 사용할 것이다. 먼저, Bootstrap 사이트에서 css, js, fonts를 다운 받고 BootsWatch사이트 Cosmo 페이지에서 custom.min.css을 다운 받은 후 springboot 프로젝트내의 resources/static위치에 폴더들은 넣는다. Bootstrap 사이트 : https://getbootstrap.com/docs/4.6/getting-started/introduction/Bootswatch 사이트 : https://bootswatch.com/ Post 페이지&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/custom.min.css&quot;&gt; &lt;title&gt;게시글 작성 페이지&lt;/title&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-primary fixed-top&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;게시판&lt;/a&gt; &lt;/nav&gt; &lt;!-- &lt;div class=&quot;container bg-white&quot; style=&quot;padding: 20px; border-radius: 15px;&quot;&gt; --&gt; &lt;div class=&quot;card col-lg-6&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 50px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; onsubmit=&quot;return registerBoard(this)&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;제목&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;제목을 입력해 주세요.&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;이름&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;이름을 입력해 주세요.&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;내용&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;textarea class=&quot;form-control&quot; style=&quot;height: 300px;&quot; placeholder=&quot;내용을 입력해 주세요.&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;저장하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 스프링 프로젝트 만들기게시판 만들기 프로젝트를 진행하면서 Thymeleaf라는 템플릿 엔진을 사용할 것이고, 총 7가지 의존성을 사용할 것이다. JPA Thymeleaf Web Lombok Devtools H2 validation build.gradle dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-validation&#x27; compileOnly &#x27;org.projectlombok:lombok&#x27; developmentOnly &#x27;org.springframework.boot:spring-boot-devtools&#x27; runtimeOnly &#x27;com.h2database:h2&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27;&#125; 게시글 작성 페이지로 이동하기/post경로를 통해 요청이 들어오면 게시글을 작성하는 페이지로 이동시킬 예정이다. 테스트 코드 작성/post경로로 요청이 들어왔을 때 정상적으로 control이 작동하는 경우 ok(status code : 200)을 반환한다. @WebMvcTestclass PostControllerTest &#123; @Autowired MockMvc mockMvc; @Test @DisplayName(&quot;게시글 작성페이지로 이동하는지 확인한다.&quot;) public void movePost() throws Exception&#123; ResultActions resultActions = mockMvc.perform(get(&quot;/post&quot;)); resultActions .andExpect(status().isOk()) .andDo(print()); &#125;&#125; control 구현/post경로로 요청이 들어왔을 때 post.html을 반환해 사용자에게 게시글 작성 페이지를 보여준다. @Controllerpublic class PostController &#123; @GetMapping(&quot;/post&quot;) public String post()&#123; return &quot;post&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[]},{"title":"JPA 란?","slug":"jpa/jpa","date":"2021-02-09T19:31:46.000Z","updated":"2024-02-18T16:19:54.531Z","comments":true,"path":"2021/02/10/jpa/jpa/","link":"","permalink":"https://ckck803.github.io/2021/02/10/jpa/jpa/","excerpt":"JPA 란?객체를 이용해 DataBase 테이블을 다루기 위해 만들어진 ORM(Object Relation Mapping) 기술","text":"JPA 란?객체를 이용해 DataBase 테이블을 다루기 위해 만들어진 ORM(Object Relation Mapping) 기술","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"레스토랑 예약 사이트 만들기 14 - 테이블 예약","slug":"spring/fastcampus-eatgo/eat-go14-table-reservation","date":"2021-02-07T09:46:44.000Z","updated":"2024-02-26T15:43:39.180Z","comments":true,"path":"2021/02/07/spring/fastcampus-eatgo/eat-go14-table-reservation/","link":"","permalink":"https://ckck803.github.io/2021/02/07/spring/fastcampus-eatgo/eat-go14-table-reservation/","excerpt":"패스트 캠퍼스에서 @RestController@RequiredArgsConstructorpublic class ReservationController &#123; private final ReservationService reservationService; @GetMapping(&quot;/reservations&quot;) public List&lt;Reservation&gt; list(Authentication authentication)&#123; Claims claims = (Claims) authentication.getPrincipal(); Long restaurantId = claims.get(&quot;restaurantId&quot;, Long.class);// Long restaurantId = 1004L; List&lt;Reservation&gt; reservations = reservationService.getReservations(restaurantId); return reservations; &#125;&#125; @WebMvcTest(ReservationController.class)class ReservationControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private ReservationService reservationService; @Test @DisplayName(&quot;예약목록을 가져온다.&quot;) public void list() throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiJPd25lciIsInJlc3RhdXJhbnRJZCI6MTAwNH0.cQTXhzTW48F5Nj3eXa80Y9J4OJryzFvoHtT8ELl4kTw&quot;; ResultActions resultActions = mockMvc.perform(get(&quot;/reservations&quot;) .header(&quot;Authorization&quot;, &quot;Bearer &quot; + token)); resultActions .andExpect(status().isOk()); verify(reservationService).getReservations(1004L); &#125;&#125; @Service@RequiredArgsConstructorpublic class ReservationService &#123; private final ReservationRepository reservationRepository; public List&lt;Reservation&gt; getReservations(Long restaurantId) &#123; return reservationRepository.findAllByRestaurantId(restaurantId); &#125;&#125; class ReservationServiceTest &#123; @Mock private ReservationRepository reservationRepository; private ReservationService reservationService; @BeforeEach public void setUp()&#123; MockitoAnnotations.openMocks(this); this.reservationService = new ReservationService(reservationRepository); &#125; @Test @DisplayName(&quot;예약목록들을 가져온다.&quot;) public void getReservation()&#123; Long restaurantId = 1004L; List&lt;Reservation&gt; reservations = reservationService.getReservations(restaurantId); verify(reservationRepository).findAllByRestaurantId(restaurantId); &#125;&#125; public class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123; private final JwtUtil jwtUtil; public JwtAuthenticationFilter(AuthenticationManager authenticationManager, JwtUtil jwtUtil) &#123; super(authenticationManager); this.jwtUtil = jwtUtil; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; Authentication authentication = getAuthentication(request); if(authentication != null)&#123; SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(authentication); &#125; chain.doFilter(request, response); &#125; private Authentication getAuthentication(HttpServletRequest request)&#123; // Header에서 Data를 얻어야 한다. String token = request.getHeader(&quot;Authorization&quot;); if(token == null)&#123; return null; &#125; Claims claims = jwtUtil.getClaims(token.substring(&quot;Bearer &quot;.length())); Authentication authentication = new UsernamePasswordAuthenticationToken(claims, null); return authentication; &#125;&#125; @Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secret; @Override protected void configure(HttpSecurity http) throws Exception &#123; Filter filter = new JwtAuthenticationFilter(authenticationManager(), jwtUtil()); http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); http .addFilter(filter) .sessionManagement() // Session을 사용하지 않음 .sessionCreationPolicy(SessionCreationPolicy.STATELESS); &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Bean public JwtUtil jwtUtil()&#123; return new JwtUtil(secret); &#125;&#125;","text":"패스트 캠퍼스에서 @RestController@RequiredArgsConstructorpublic class ReservationController &#123; private final ReservationService reservationService; @GetMapping(&quot;/reservations&quot;) public List&lt;Reservation&gt; list(Authentication authentication)&#123; Claims claims = (Claims) authentication.getPrincipal(); Long restaurantId = claims.get(&quot;restaurantId&quot;, Long.class);// Long restaurantId = 1004L; List&lt;Reservation&gt; reservations = reservationService.getReservations(restaurantId); return reservations; &#125;&#125; @WebMvcTest(ReservationController.class)class ReservationControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private ReservationService reservationService; @Test @DisplayName(&quot;예약목록을 가져온다.&quot;) public void list() throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiJPd25lciIsInJlc3RhdXJhbnRJZCI6MTAwNH0.cQTXhzTW48F5Nj3eXa80Y9J4OJryzFvoHtT8ELl4kTw&quot;; ResultActions resultActions = mockMvc.perform(get(&quot;/reservations&quot;) .header(&quot;Authorization&quot;, &quot;Bearer &quot; + token)); resultActions .andExpect(status().isOk()); verify(reservationService).getReservations(1004L); &#125;&#125; @Service@RequiredArgsConstructorpublic class ReservationService &#123; private final ReservationRepository reservationRepository; public List&lt;Reservation&gt; getReservations(Long restaurantId) &#123; return reservationRepository.findAllByRestaurantId(restaurantId); &#125;&#125; class ReservationServiceTest &#123; @Mock private ReservationRepository reservationRepository; private ReservationService reservationService; @BeforeEach public void setUp()&#123; MockitoAnnotations.openMocks(this); this.reservationService = new ReservationService(reservationRepository); &#125; @Test @DisplayName(&quot;예약목록들을 가져온다.&quot;) public void getReservation()&#123; Long restaurantId = 1004L; List&lt;Reservation&gt; reservations = reservationService.getReservations(restaurantId); verify(reservationRepository).findAllByRestaurantId(restaurantId); &#125;&#125; public class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123; private final JwtUtil jwtUtil; public JwtAuthenticationFilter(AuthenticationManager authenticationManager, JwtUtil jwtUtil) &#123; super(authenticationManager); this.jwtUtil = jwtUtil; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; Authentication authentication = getAuthentication(request); if(authentication != null)&#123; SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(authentication); &#125; chain.doFilter(request, response); &#125; private Authentication getAuthentication(HttpServletRequest request)&#123; // Header에서 Data를 얻어야 한다. String token = request.getHeader(&quot;Authorization&quot;); if(token == null)&#123; return null; &#125; Claims claims = jwtUtil.getClaims(token.substring(&quot;Bearer &quot;.length())); Authentication authentication = new UsernamePasswordAuthenticationToken(claims, null); return authentication; &#125;&#125; @Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secret; @Override protected void configure(HttpSecurity http) throws Exception &#123; Filter filter = new JwtAuthenticationFilter(authenticationManager(), jwtUtil()); http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); http .addFilter(filter) .sessionManagement() // Session을 사용하지 않음 .sessionCreationPolicy(SessionCreationPolicy.STATELESS); &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Bean public JwtUtil jwtUtil()&#123; return new JwtUtil(secret); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 13 - 인가","slug":"spring/fastcampus-eatgo/eat-go13-authorization","date":"2021-02-07T03:53:14.000Z","updated":"2024-02-26T15:43:34.136Z","comments":true,"path":"2021/02/07/spring/fastcampus-eatgo/eat-go13-authorization/","link":"","permalink":"https://ckck803.github.io/2021/02/07/spring/fastcampus-eatgo/eat-go13-authorization/","excerpt":"JWT로부터 데이터 가져오기public class JwtUtil &#123; private Key key; public JwtUtil(String secret) &#123; this.key = Keys.hmacShaKeyFor(secret.getBytes()); &#125; public String createToken(Long userId, String name) &#123; String token = Jwts.builder() .claim(&quot;userId&quot;, 1004L) .claim(&quot;name&quot;, name) .signWith(key, SignatureAlgorithm.HS256) .compact(); return token; &#125; public Claims getClaims(String token)&#123; Claims claims = Jwts.parserBuilder() .setSigningKey(key) .build() .parseClaimsJws(token) .getBody(); return claims; &#125;&#125; @Test@DisplayName(&quot;Claims를 가져온다.&quot;)public void getClaims()&#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiJUZXN0ZXIifQ.I4DNdunio2m54tfUEaXHC_E-gvCQo6ZhHO15Ewkat6U&quot;; Claims claims = jwtUtil.getClaims(token); assertThat(claims.get(&quot;userId&quot;, Long.class)).isEqualTo(1004L); assertThat(claims.get(&quot;name&quot;)).isEqualTo(&quot;Tester&quot;);&#125; JWTFilter추가@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secret; @Override protected void configure(HttpSecurity http) throws Exception &#123; Filter filter = new JwtAuthenticationFilter(authenticationManager(), jwtUtil()); http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); http .addFilter(filter) .sessionManagement() // Session을 사용하지 않음 .sessionCreationPolicy(SessionCreationPolicy.STATELESS); ; &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Bean public JwtUtil jwtUtil()&#123; return new JwtUtil(secret); &#125;&#125; JWT 인증 Filterpublic class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123; private JwtUtil jwtUtil; public JwtAuthenticationFilter(AuthenticationManager authenticationManager, JwtUtil jwtUtil) &#123; super(authenticationManager); this.jwtUtil = jwtUtil; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; Authentication authentication = getAuthentication(request); if(authentication != null)&#123; SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(authentication); &#125; chain.doFilter(request, response); &#125; private Authentication getAuthentication(HttpServletRequest request)&#123; // Header에서 Data를 얻어야 한다. String token = request.getHeader(&quot;Authorization&quot;); if(token == null)&#123; return null; &#125; Claims claims = jwtUtil.getClaims(token.substring(&quot;Bearer &quot;.length())); Authentication authentication = new UsernamePasswordAuthenticationToken(claims, null); return authentication; &#125;&#125; 요청시 Token값을 가지고 있는지 확인@RestController@RequiredArgsConstructorpublic class ReviewController &#123; private final ReviewService reviewService; @PostMapping(&quot;/restaurants/&#123;restaurantId&#125;/reviews&quot;) public ResponseEntity&lt;?&gt; create( Authentication authentication, @PathVariable Long restaurantId, @Valid @RequestBody Review resource ) throws URISyntaxException &#123; Claims claims = (Claims) authentication.getPrincipal(); String name = claims.get(&quot;name&quot;, String.class); Review review = reviewService.addReview(restaurantId, resource); String url = &quot;/restaurants/&quot; + restaurantId + &quot;/reviews/&quot; + review.getId(); return ResponseEntity.created(new URI (url)).body(&quot;&#123;&#125;&quot;); &#125;&#125;","text":"JWT로부터 데이터 가져오기public class JwtUtil &#123; private Key key; public JwtUtil(String secret) &#123; this.key = Keys.hmacShaKeyFor(secret.getBytes()); &#125; public String createToken(Long userId, String name) &#123; String token = Jwts.builder() .claim(&quot;userId&quot;, 1004L) .claim(&quot;name&quot;, name) .signWith(key, SignatureAlgorithm.HS256) .compact(); return token; &#125; public Claims getClaims(String token)&#123; Claims claims = Jwts.parserBuilder() .setSigningKey(key) .build() .parseClaimsJws(token) .getBody(); return claims; &#125;&#125; @Test@DisplayName(&quot;Claims를 가져온다.&quot;)public void getClaims()&#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiJUZXN0ZXIifQ.I4DNdunio2m54tfUEaXHC_E-gvCQo6ZhHO15Ewkat6U&quot;; Claims claims = jwtUtil.getClaims(token); assertThat(claims.get(&quot;userId&quot;, Long.class)).isEqualTo(1004L); assertThat(claims.get(&quot;name&quot;)).isEqualTo(&quot;Tester&quot;);&#125; JWTFilter추가@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secret; @Override protected void configure(HttpSecurity http) throws Exception &#123; Filter filter = new JwtAuthenticationFilter(authenticationManager(), jwtUtil()); http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); http .addFilter(filter) .sessionManagement() // Session을 사용하지 않음 .sessionCreationPolicy(SessionCreationPolicy.STATELESS); ; &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Bean public JwtUtil jwtUtil()&#123; return new JwtUtil(secret); &#125;&#125; JWT 인증 Filterpublic class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123; private JwtUtil jwtUtil; public JwtAuthenticationFilter(AuthenticationManager authenticationManager, JwtUtil jwtUtil) &#123; super(authenticationManager); this.jwtUtil = jwtUtil; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; Authentication authentication = getAuthentication(request); if(authentication != null)&#123; SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(authentication); &#125; chain.doFilter(request, response); &#125; private Authentication getAuthentication(HttpServletRequest request)&#123; // Header에서 Data를 얻어야 한다. String token = request.getHeader(&quot;Authorization&quot;); if(token == null)&#123; return null; &#125; Claims claims = jwtUtil.getClaims(token.substring(&quot;Bearer &quot;.length())); Authentication authentication = new UsernamePasswordAuthenticationToken(claims, null); return authentication; &#125;&#125; 요청시 Token값을 가지고 있는지 확인@RestController@RequiredArgsConstructorpublic class ReviewController &#123; private final ReviewService reviewService; @PostMapping(&quot;/restaurants/&#123;restaurantId&#125;/reviews&quot;) public ResponseEntity&lt;?&gt; create( Authentication authentication, @PathVariable Long restaurantId, @Valid @RequestBody Review resource ) throws URISyntaxException &#123; Claims claims = (Claims) authentication.getPrincipal(); String name = claims.get(&quot;name&quot;, String.class); Review review = reviewService.addReview(restaurantId, resource); String url = &quot;/restaurants/&quot; + restaurantId + &quot;/reviews/&quot; + review.getId(); return ResponseEntity.created(new URI (url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; 테스트 코드 작성@Testpublic void 리뷰를_생성한다() throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiJUZXN0ZXIifQ.I4DNdunio2m54tfUEaXHC_E-gvCQo6ZhHO15Ewkat6U&quot;; given(reviewService.addReview(eq(1L), any())).willReturn( Review.builder() .id(1004L) .name(&quot;JOKER&quot;) .score(3) .description(&quot;Mat-it-da&quot;) .build()); mockMvc.perform(post(&quot;/restaurants/1/reviews&quot;) .header(&quot;Authorization&quot;, &quot;Bearer &quot; + token) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;name\\&quot;:\\&quot;JOKER\\&quot;, \\&quot;score\\&quot;:3,\\&quot;description\\&quot; : \\&quot;Mat-it-da\\&quot;&#125;&quot;)) .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/restaurants/1/reviews/1004&quot;)); verify(reviewService).addReview(eq(1L), any());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 12 - JWT","slug":"spring/fastcampus-eatgo/eat-go12-jwt","date":"2021-02-06T16:03:35.000Z","updated":"2024-02-26T15:43:29.669Z","comments":true,"path":"2021/02/07/spring/fastcampus-eatgo/eat-go12-jwt/","link":"","permalink":"https://ckck803.github.io/2021/02/07/spring/fastcampus-eatgo/eat-go12-jwt/","excerpt":"JWT를 이용해 AccesToken관리하기JwtUtil 클래스에서는 JWT를 생성하기 위한 createToken메서드가 존재한다. JWT에는 userId와 name을 넣을 것이고 HMAC-SHA256 해싱 알고리즘을 사용해 토큰의 유효성을 검사할 것이다. public class JwtUtil &#123; private String secret; public JwtUtil(String secret) &#123; this.secret = secret; &#125; public String createToken(Long userId, String name) &#123; Key key = Keys.hmacShaKeyFor(secret.getBytes()); String token = Jwts.builder() .claim(&quot;userId&quot;, 1004L) .claim(&quot;name&quot;, name) .signWith(key, SignatureAlgorithm.HS256) .compact(); return token; &#125;&#125; JWT가 올바르게 생성됐는지 확인하는 테스트 코드class JwtUtilTest &#123; @Test public void createToken()&#123; String secret = &quot;12345678901234567890123456789012&quot;; JwtUtil jwtUtil = new JwtUtil(secret); String token = jwtUtil.createToken(1004L, &quot;&quot;); assertThat(token).contains(&quot;.&quot;); &#125;&#125; JwtUtil을 Bean으로 등록@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; // application.yml에 정의된 JWT Secret값을 가져온다. @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secret; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Bean public JwtUtil jwtUtil()&#123; return new JwtUtil(secret); &#125;&#125; 사용자 요청 결과로 JWT반환하는 로직을 구현/session 경로로 사용자 정보를 받으면 우선 사용자 유효성을 확인한 뒤, 등록된 사용자인 경우 사용자 정보를 JWT에 일부 담아 Response Body에 넣어 사용자에게 반환한다.","text":"JWT를 이용해 AccesToken관리하기JwtUtil 클래스에서는 JWT를 생성하기 위한 createToken메서드가 존재한다. JWT에는 userId와 name을 넣을 것이고 HMAC-SHA256 해싱 알고리즘을 사용해 토큰의 유효성을 검사할 것이다. public class JwtUtil &#123; private String secret; public JwtUtil(String secret) &#123; this.secret = secret; &#125; public String createToken(Long userId, String name) &#123; Key key = Keys.hmacShaKeyFor(secret.getBytes()); String token = Jwts.builder() .claim(&quot;userId&quot;, 1004L) .claim(&quot;name&quot;, name) .signWith(key, SignatureAlgorithm.HS256) .compact(); return token; &#125;&#125; JWT가 올바르게 생성됐는지 확인하는 테스트 코드class JwtUtilTest &#123; @Test public void createToken()&#123; String secret = &quot;12345678901234567890123456789012&quot;; JwtUtil jwtUtil = new JwtUtil(secret); String token = jwtUtil.createToken(1004L, &quot;&quot;); assertThat(token).contains(&quot;.&quot;); &#125;&#125; JwtUtil을 Bean으로 등록@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; // application.yml에 정의된 JWT Secret값을 가져온다. @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secret; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Bean public JwtUtil jwtUtil()&#123; return new JwtUtil(secret); &#125;&#125; 사용자 요청 결과로 JWT반환하는 로직을 구현/session 경로로 사용자 정보를 받으면 우선 사용자 유효성을 확인한 뒤, 등록된 사용자인 경우 사용자 정보를 JWT에 일부 담아 Response Body에 넣어 사용자에게 반환한다. @PostMapping(&quot;/session&quot;)public ResponseEntity&lt;SessionResponseDto&gt; create(@RequestBody SessionRequestDto resource)&#123; String email = resource.getEmail(); String password = resource.getPassword(); User user = userService.authenticate(email, password); String url = &quot;/session&quot;; String accessToken = jwtUtil.createToken(user.getId(), user.getName()); SessionResponseDto sessionResponseDto = SessionResponseDto.builder() .accessToken(accessToken) .build(); return ResponseEntity.created(URI.create(url)).body(sessionResponseDto);&#125; 사용자 요청에 JWT를 반환하는지 확인하는 테스트 코드 작성@Autowiredprivate ObjectMapper objectMapper;...@MockBeanprivate JwtUtil jwtUtil;@Test@DisplayName(&quot;AccessToken을 반환하는지 확인한다.&quot;)public void create() throws Exception &#123; Long id = 1004L; String email = &quot;tester@example.com&quot;; String password = &quot;test&quot;; String name = &quot;Tester&quot;; User mockUser = User.builder() .id(id) .email(email) .name(name) .password(password) .level(3L) .build(); String content = objectMapper.writeValueAsString(mockUser); given(userService.authenticate(email, password)).willReturn(mockUser); given(jwtUtil.createToken(id, name)).willReturn(&quot;header.payload.signature&quot;); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON)// .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;tester@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;test\\&quot;&#125;&quot;) .content(content) ); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/session&quot;)) // AccessToken을 사용하는지 확인한다. .andExpect(content().string(containsString(&quot;&#123;\\&quot;accessToken\\&quot;:\\&quot;header.payload.signature\\&quot;&#125;&quot;))); verify(userService).authenticate(eq(email), eq(password));&#125; @Test@DisplayName(&quot;사용자를 생성한다.&quot;)public void create() throws Exception &#123; String email = &quot;tester@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .id(1004L) .email(email) .password(password) .name(name) .build(); given(userService.registerUser(email, name, password)) .willReturn(mockUser); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot; : \\&quot;tester@example.com\\&quot;, \\&quot;name\\&quot; : \\&quot;Tester\\&quot;, \\&quot;password\\&quot; : \\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/users/1004&quot;)); verify(userService).registerUser(any(), any(), any());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 11 - 인증","slug":"spring/fastcampus-eatgo/eat-go11-authentication","date":"2021-02-06T10:17:28.000Z","updated":"2024-02-26T15:43:25.098Z","comments":true,"path":"2021/02/06/spring/fastcampus-eatgo/eat-go11-authentication/","link":"","permalink":"https://ckck803.github.io/2021/02/06/spring/fastcampus-eatgo/eat-go11-authentication/","excerpt":"AccessToken을 이용한 인증@RestController@RequiredArgsConstructorpublic class SessionController &#123; private final UserService userService; @PostMapping(&quot;/session&quot;) public ResponseEntity&lt;SessionResponseDto&gt; create(@RequestBody SessionRequestDto resource)&#123; String email = resource.getEmail(); String password = resource.getPassword(); User user = userService.authenticate(email, password); String url = &quot;/session&quot;; String accessToken = user.getAccessToken(); SessionResponseDto sessionResponseDto = SessionResponseDto.builder() .accessToken(accessToken) .build(); return ResponseEntity.created(URI.create(url)).body(sessionResponseDto); &#125;&#125; @WebMvcTest(SessionController.class)class SessionControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test @DisplayName(&quot;AccessToken을 반환하는지 확인한다.&quot;) public void create() throws Exception &#123; String email = &quot;tester@example.com&quot;; String password = &quot;test&quot;; User mockUser = User.builder().password(&quot;ACCESSTOKEN&quot;).build(); given(userService.authenticate(email, password)).willReturn(mockUser); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;tester@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/session&quot;)) // AccessToken을 사용하는지 확인한다. .andExpect(content().string(&quot;&#123;\\&quot;accessToken\\&quot;:\\&quot;ACCESSTOKE\\&quot;&#125;&quot;)); verify(userService).authenticate(eq(email), eq(password)); &#125; @Test @DisplayName(&quot;올바르지 않은 이메일을 이용한 요청을 시도&quot;) public void createWithNotExistedEmail() throws Exception &#123; String email = &quot;x@example.com&quot;; String password = &quot;test&quot;; given(userService.authenticate(email, password)).willThrow(EmailNotExistedException.class); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;x@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isBadRequest()); verify(userService).authenticate(eq(email), eq(password)); &#125; @Test @DisplayName(&quot;올바르지 않은 패스워드를 이용한 요청을 시도&quot;) public void createWithInvalidAttributes() throws Exception &#123; String email = &quot;tester@example.com&quot;; String password = &quot;x&quot;; given(userService.authenticate(email, password)).willThrow(PasswordWrongException.class); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;tester@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;x\\&quot;&#125;&quot;)); resultActions .andExpect(status().isBadRequest()); verify(userService).authenticate(eq(email), eq(password)); &#125;&#125; public class EmailNotExistedException extends RuntimeException&#123; public EmailNotExistedException()&#123; super(&quot;Email is Not registered&quot;); &#125;&#125; public class PasswordWrongException extends RuntimeException&#123; public PasswordWrongException()&#123; super(&quot;Password is Wrong&quot;); &#125;&#125; @ControllerAdvicepublic class SessionErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(PasswordWrongException.class) public String handlePasswordWrong()&#123; return &quot;&#123;&#125;&quot;; &#125; @ResponseBody @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(EmailNotExistedException.class) public String handleEmailNotExisted()&#123; return &quot;&#123;&#125;&quot;; &#125;&#125; @Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; private final PasswordEncoder passwordEncoder; public User registerUser(String email, String name, String password) &#123; // 회원이 이미 등록되어 있는지 Email을 통해 유효성 검사 Optional&lt;User&gt; optional = userRepository.findByEmail(email); // 회원이 이미 존재하는 경우 예외처리를 한다. if(optional.isPresent())&#123; throw new EmailExistedException(email); &#125;// // 패스워드를 암호화해서 저장한다.// // 암호화 방식은 BCrypt방식을 이용해 암호화를 진행// BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encodedPassword = passwordEncoder.encode(password); User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125; public User authenticate(String email, String password) &#123; User user = userRepository.findByEmail(email) .orElseThrow(() -&gt; new EmailNotExistedException()); String encodedPassword = passwordEncoder.encode(password); if(!passwordEncoder.matches(password, user.getPassword()))&#123; throw new PasswordWrongException(); &#125; return user; &#125;&#125; @Test@DisplayName(&quot;올바른 파라미터를 이용해 사용자 유효성 검사를 한다.&quot;)public void authenticateWithValidAttributes()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .Id(1004L) .email(email) .name(name) .password(password) .build(); given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser)); given(passwordEncoder.matches(any(), any())).willReturn(true); User user = userService.authenticate(email, password); assertThat(user.getEmail()).isEqualTo(email);&#125;@Test@DisplayName(&quot;올바르지 않은 이메일을 이용해 사용자 유효성 검사를 한다.&quot;)public void authenticateNotValidEmail()&#123; String email = &quot;x@example.com&quot;; String password = &quot;test&quot;; given(userRepository.findByEmail(email)).willThrow(EmailNotExistedException.class); assertThatThrownBy(()-&gt;&#123; User user = userService.authenticate(email, password); &#125;).isInstanceOf(EmailNotExistedException.class);&#125;@Test@DisplayName(&quot;올바르지 않은 이메일을 이용해 사용자 유효성 검사를 한다.&quot;)public void authenticateNotValidPassword()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;x&quot;; User mockUser = User.builder() .Id(1004L) .email(email) .name(name) .password(password) .build(); given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser)); given(passwordEncoder.matches(password, mockUser.getPassword())).willReturn(false); assertThatThrownBy(()-&gt;&#123; User user = userService.authenticate(email, password); &#125;).isInstanceOf(PasswordWrongException.class);&#125; @Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125;","text":"AccessToken을 이용한 인증@RestController@RequiredArgsConstructorpublic class SessionController &#123; private final UserService userService; @PostMapping(&quot;/session&quot;) public ResponseEntity&lt;SessionResponseDto&gt; create(@RequestBody SessionRequestDto resource)&#123; String email = resource.getEmail(); String password = resource.getPassword(); User user = userService.authenticate(email, password); String url = &quot;/session&quot;; String accessToken = user.getAccessToken(); SessionResponseDto sessionResponseDto = SessionResponseDto.builder() .accessToken(accessToken) .build(); return ResponseEntity.created(URI.create(url)).body(sessionResponseDto); &#125;&#125; @WebMvcTest(SessionController.class)class SessionControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test @DisplayName(&quot;AccessToken을 반환하는지 확인한다.&quot;) public void create() throws Exception &#123; String email = &quot;tester@example.com&quot;; String password = &quot;test&quot;; User mockUser = User.builder().password(&quot;ACCESSTOKEN&quot;).build(); given(userService.authenticate(email, password)).willReturn(mockUser); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;tester@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/session&quot;)) // AccessToken을 사용하는지 확인한다. .andExpect(content().string(&quot;&#123;\\&quot;accessToken\\&quot;:\\&quot;ACCESSTOKE\\&quot;&#125;&quot;)); verify(userService).authenticate(eq(email), eq(password)); &#125; @Test @DisplayName(&quot;올바르지 않은 이메일을 이용한 요청을 시도&quot;) public void createWithNotExistedEmail() throws Exception &#123; String email = &quot;x@example.com&quot;; String password = &quot;test&quot;; given(userService.authenticate(email, password)).willThrow(EmailNotExistedException.class); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;x@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isBadRequest()); verify(userService).authenticate(eq(email), eq(password)); &#125; @Test @DisplayName(&quot;올바르지 않은 패스워드를 이용한 요청을 시도&quot;) public void createWithInvalidAttributes() throws Exception &#123; String email = &quot;tester@example.com&quot;; String password = &quot;x&quot;; given(userService.authenticate(email, password)).willThrow(PasswordWrongException.class); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;tester@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;x\\&quot;&#125;&quot;)); resultActions .andExpect(status().isBadRequest()); verify(userService).authenticate(eq(email), eq(password)); &#125;&#125; public class EmailNotExistedException extends RuntimeException&#123; public EmailNotExistedException()&#123; super(&quot;Email is Not registered&quot;); &#125;&#125; public class PasswordWrongException extends RuntimeException&#123; public PasswordWrongException()&#123; super(&quot;Password is Wrong&quot;); &#125;&#125; @ControllerAdvicepublic class SessionErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(PasswordWrongException.class) public String handlePasswordWrong()&#123; return &quot;&#123;&#125;&quot;; &#125; @ResponseBody @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(EmailNotExistedException.class) public String handleEmailNotExisted()&#123; return &quot;&#123;&#125;&quot;; &#125;&#125; @Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; private final PasswordEncoder passwordEncoder; public User registerUser(String email, String name, String password) &#123; // 회원이 이미 등록되어 있는지 Email을 통해 유효성 검사 Optional&lt;User&gt; optional = userRepository.findByEmail(email); // 회원이 이미 존재하는 경우 예외처리를 한다. if(optional.isPresent())&#123; throw new EmailExistedException(email); &#125;// // 패스워드를 암호화해서 저장한다.// // 암호화 방식은 BCrypt방식을 이용해 암호화를 진행// BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encodedPassword = passwordEncoder.encode(password); User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125; public User authenticate(String email, String password) &#123; User user = userRepository.findByEmail(email) .orElseThrow(() -&gt; new EmailNotExistedException()); String encodedPassword = passwordEncoder.encode(password); if(!passwordEncoder.matches(password, user.getPassword()))&#123; throw new PasswordWrongException(); &#125; return user; &#125;&#125; @Test@DisplayName(&quot;올바른 파라미터를 이용해 사용자 유효성 검사를 한다.&quot;)public void authenticateWithValidAttributes()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .Id(1004L) .email(email) .name(name) .password(password) .build(); given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser)); given(passwordEncoder.matches(any(), any())).willReturn(true); User user = userService.authenticate(email, password); assertThat(user.getEmail()).isEqualTo(email);&#125;@Test@DisplayName(&quot;올바르지 않은 이메일을 이용해 사용자 유효성 검사를 한다.&quot;)public void authenticateNotValidEmail()&#123; String email = &quot;x@example.com&quot;; String password = &quot;test&quot;; given(userRepository.findByEmail(email)).willThrow(EmailNotExistedException.class); assertThatThrownBy(()-&gt;&#123; User user = userService.authenticate(email, password); &#125;).isInstanceOf(EmailNotExistedException.class);&#125;@Test@DisplayName(&quot;올바르지 않은 이메일을 이용해 사용자 유효성 검사를 한다.&quot;)public void authenticateNotValidPassword()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;x&quot;; User mockUser = User.builder() .Id(1004L) .email(email) .name(name) .password(password) .build(); given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser)); given(passwordEncoder.matches(password, mockUser.getPassword())).willReturn(false); assertThatThrownBy(()-&gt;&#123; User user = userService.authenticate(email, password); &#125;).isInstanceOf(PasswordWrongException.class);&#125; @Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; @Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long Id; @NotEmpty private String email; @NotEmpty private String name; @NotNull private Long level; @NotEmpty private String password; public boolean isAdmin() &#123; return level &gt; 2L; &#125; public void deactivate()&#123; level = 0L; &#125; public boolean isActive() &#123; return level &gt; 0L; &#125; @JsonIgnore public String getAccessToken() &#123; if(password == null)&#123; return &quot;&quot;; &#125; return password.substring(0, 10); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 10 - 회원 가입","slug":"spring/fastcampus-eatgo/eat-go10-signup","date":"2021-02-06T03:30:41.000Z","updated":"2024-02-26T15:43:20.400Z","comments":true,"path":"2021/02/06/spring/fastcampus-eatgo/eat-go10-signup/","link":"","permalink":"https://ckck803.github.io/2021/02/06/spring/fastcampus-eatgo/eat-go10-signup/","excerpt":"Security 설정하기@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); &#125;&#125; @Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public User registerUser(String email, String name, String password) &#123; User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125;&#125; 패스워드에 암호화 하기@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public User registerUser(String email, String name, String password) &#123; // 패스워드를 암호화해서 저장한다. BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encodedPassword = passwordEncoder.encode(password); User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125;&#125; class UserServiceTest &#123; @Mock private UserRepository userRepository; private UserService userService; @BeforeEach public void setUp()&#123; MockitoAnnotations.openMocks(this); userService = new UserService(userRepository); &#125; @Test @DisplayName(&quot;사용자를 등록한다.&quot;) public void registerUser()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User user = userService.registerUser(email, name, password); assertThat(user.getEmail()).isEqualTo(email); assertThat(user.getName()).isEqualTo(name); assertThat(user.getPassword()).isEqualTo(password); verify(userRepository).save(any()); &#125;&#125; @RestController@RequiredArgsConstructorpublic class UserController &#123; private final UserService userService; @PostMapping(&quot;/users&quot;) public ResponseEntity&lt;?&gt; create(@RequestBody User resource)&#123; String email = resource.getEmail(); String name = resource.getName(); String password = resource.getPassword(); User user = userService.registerUser(email, name, password); String url = &quot;/users/&quot; + user.getId(); return ResponseEntity.created(URI.create(url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; @WebMvcTest(UserController.class)class UserControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test @DisplayName(&quot;사용자를 생성한다.&quot;) public void create() throws Exception &#123; String email = &quot;tester@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .Id(1004L) .email(email) .password(password) .name(name) .build(); given(userService.registerUser(email, name, password)) .willReturn(mockUser); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot; : \\&quot;tester@example.com\\&quot;, \\&quot;name\\&quot; : \\&quot;Tester\\&quot;, \\&quot;password\\&quot; : \\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/users/1004&quot;)); verify(userService).registerUser(any(), any(), any()); &#125;&#125; 존재하는 회원에 대한 예외처리","text":"Security 설정하기@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); &#125;&#125; @Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public User registerUser(String email, String name, String password) &#123; User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125;&#125; 패스워드에 암호화 하기@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public User registerUser(String email, String name, String password) &#123; // 패스워드를 암호화해서 저장한다. BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encodedPassword = passwordEncoder.encode(password); User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125;&#125; class UserServiceTest &#123; @Mock private UserRepository userRepository; private UserService userService; @BeforeEach public void setUp()&#123; MockitoAnnotations.openMocks(this); userService = new UserService(userRepository); &#125; @Test @DisplayName(&quot;사용자를 등록한다.&quot;) public void registerUser()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User user = userService.registerUser(email, name, password); assertThat(user.getEmail()).isEqualTo(email); assertThat(user.getName()).isEqualTo(name); assertThat(user.getPassword()).isEqualTo(password); verify(userRepository).save(any()); &#125;&#125; @RestController@RequiredArgsConstructorpublic class UserController &#123; private final UserService userService; @PostMapping(&quot;/users&quot;) public ResponseEntity&lt;?&gt; create(@RequestBody User resource)&#123; String email = resource.getEmail(); String name = resource.getName(); String password = resource.getPassword(); User user = userService.registerUser(email, name, password); String url = &quot;/users/&quot; + user.getId(); return ResponseEntity.created(URI.create(url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; @WebMvcTest(UserController.class)class UserControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test @DisplayName(&quot;사용자를 생성한다.&quot;) public void create() throws Exception &#123; String email = &quot;tester@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .Id(1004L) .email(email) .password(password) .name(name) .build(); given(userService.registerUser(email, name, password)) .willReturn(mockUser); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot; : \\&quot;tester@example.com\\&quot;, \\&quot;name\\&quot; : \\&quot;Tester\\&quot;, \\&quot;password\\&quot; : \\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/users/1004&quot;)); verify(userService).registerUser(any(), any(), any()); &#125;&#125; 존재하는 회원에 대한 예외처리public class EmailExistedException extends RuntimeException&#123; public EmailExistedException(String email)&#123; super(&quot;Email is already registered: &quot; + email); &#125;&#125; @Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public User registerUser(String email, String name, String password) &#123; // 회원이 이미 등록되어 있는지 Email을 통해 유효성 검사 Optional&lt;User&gt; optional = userRepository.findByEmail(email); // 회원이 이미 존재하는 경우 예외처리를 한다. if(optional.isPresent())&#123; throw new EmailExistedException(email); &#125; // 패스워드를 암호화해서 저장한다. // 암호화 방식은 BCrypt방식을 이용해 암호화를 진행 BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encodedPassword = passwordEncoder.encode(password); User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125;&#125; @Test@DisplayName(&quot;사용자가 이미 등록돼 있는경우 예외처리를 한다.&quot;)public void registerUserWithExistedEmail()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .email(email) .name(name) .password(password) .build(); given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser)); // 예외처리가 발생되는지 확인한다. assertThatThrownBy(() -&gt; &#123; userService.registerUser(email, name, password); &#125;).isInstanceOf(EmailExistedException.class); verify(userRepository).findByEmail(any());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 9 - 사용자 관리","slug":"spring/fastcampus-eatgo/eat-go9-user","date":"2021-02-05T15:01:54.000Z","updated":"2024-02-26T15:43:14.726Z","comments":true,"path":"2021/02/06/spring/fastcampus-eatgo/eat-go9-user/","link":"","permalink":"https://ckck803.github.io/2021/02/06/spring/fastcampus-eatgo/eat-go9-user/","excerpt":"@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long Id; @NotEmpty private String email; @NotEmpty private String name; @NotNull private Long level; public boolean isAdmin() &#123; return level &gt; 2L; &#125; public void deactivate()&#123; level = 0L; &#125; public boolean isActive() &#123; return level &gt; 0L; &#125;&#125; @Repositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; @Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public List&lt;User&gt; getUsers() &#123; return userRepository.findAll(); &#125; public User addUser(String email, String name) &#123; User user = User.builder() .email(email) .name(name) .level(1L) .build(); userRepository.save(user); return user; &#125; public User updateUser(Long id, String email, String name, Long level ) &#123; User user = userRepository.findById(id).orElse(null); user.setEmail(email); user.setName(name); user.setLevel(level); return user; &#125; public User deactivateUser(Long userId) &#123; User user = userRepository.findById(userId).orElse(null); user.deactivate(); return user; &#125;&#125; class UserServiceTest &#123; @Mock private UserRepository userRepository; private UserService userService; @BeforeEach private void setUp() &#123; MockitoAnnotations.openMocks(this); userService = new UserService(userRepository); &#125; @Test @DisplayName(&quot;유저목록을 가져온다.&quot;) public void getUsers() &#123; List&lt;User&gt; mockUsers = new ArrayList&lt;&gt;(); mockUsers.add(User.builder() .name(&quot;tester&quot;) .email(&quot;test@example.com&quot;) .level(3L) .build()); given(userRepository.findAll()).willReturn(mockUsers); List&lt;User&gt; users = userService.getUsers(); User user = users.get(0); assertThat(user.getName()).isEqualTo(&quot;tester&quot;); assertThat(user.getEmail()).isEqualTo(&quot;test@example.com&quot;); &#125; @Test @DisplayName(&quot;유저를 추가한다.&quot;) public void addUser()&#123; String email = &quot;test@example.com&quot;; String name = &quot;tester&quot;; User mockUser = User.builder() .name(name) .email(email) .build(); given(userRepository.save(any())).willReturn(mockUser); User user = userService.addUser(email, name); assertThat(user.getName()).isEqualTo(name); assertThat(user.getEmail()).isEqualTo(email); &#125; @Test @DisplayName(&quot;유저를 업데이트 한다.&quot;) public void updateUser()&#123; Long id = 1004L; Long level = 3L; String email = &quot;test@example.com&quot;; String name = &quot;Superman&quot;; User mockUser = User.builder() .Id(id) .name(&quot;Administrator&quot;) .level(1L) .email(email) .build(); given(userRepository.findById(id)).willReturn(Optional.of(mockUser)); User user = userService.updateUser(id, email, name, level); verify(userRepository).findById(id); assertThat(user.getName()).isEqualTo(&quot;Superman&quot;); assertThat(user.isAdmin()).isEqualTo(true); &#125; @Test @DisplayName(&quot;유저를 삭제한다.&quot;) public void deactiveUser()&#123; Long id = 1004L; Long level = 2L; String email = &quot;test@example.com&quot;; String name = &quot;Superman&quot;; User mockUser = User.builder() .Id(id) .level(level) .email(email) .name(name) .build(); given(userRepository.findById(id)).willReturn(Optional.of(mockUser)); User user = userService.deactivateUser(1004L); verify(userRepository).findById(1004L); assertThat(user.isAdmin()).isEqualTo(false); assertThat(user.isActive()).isEqualTo(false); &#125;&#125; @RestController@RequiredArgsConstructorpublic class UserController &#123; // 1. User list // 2. User create -&gt; 회원가입 // 3. User update // 4. User delete -&gt; level: 0 =&gt; 아무것도 못 함. // (1: customer 2: restaurant owner 3: admin) private final UserService userService; @GetMapping(&quot;/users&quot;) public List&lt;User&gt; list()&#123; return userService.getUsers(); &#125; @PostMapping(&quot;/users&quot;) public ResponseEntity&lt;?&gt; create(@RequestBody User resource) throws URISyntaxException &#123; User user = userService.addUser(resource.getEmail(), resource.getName()); String url = &quot;/users&quot; + user.getId(); return ResponseEntity.created(URI.create(url)).body(&quot;&#123;&#125;&quot;); &#125; @PatchMapping(&quot;/users/&#123;userId&#125;&quot;) public void udpate(@PathVariable(&quot;userId&quot;) Long id, @RequestBody User user)&#123; userService.updateUser(id, user.getEmail(), user.getName(), user.getLevel()); &#125; @DeleteMapping(&quot;/users/&#123;userId&#125;&quot;) public String deactivate(@PathVariable(&quot;userId&quot;)Long userId)&#123; userService.deactivateUser(userId); return &quot;&#123;&#125;&quot;; &#125;&#125; @WebMvcTest(UserController.class)class UserControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test @DisplayName(&quot;유저목록을_가져온다&quot;) public void list() throws Exception &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(User.builder() .email(&quot;tester@example.com&quot;) .name(&quot;tester&quot;) .level(1L) .build()); given(userService.getUsers()).willReturn(users); mockMvc.perform(get(&quot;/users&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;tester&quot;))); &#125; @Test @DisplayName(&quot;유저를 추가한다.&quot;) public void create() throws Exception &#123; String email = &quot;admin@example.com&quot;; String name = &quot;Administrator&quot;; User user = User.builder() .email(email) .name(name) .build(); given(userService.addUser(email, name)).willReturn(user); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot; : \\&quot;admin@example.com\\&quot;, \\&quot;name\\&quot; : \\&quot;Administrator\\&quot;&#125;&quot;)); verify(userService).addUser(email, name) ; resultActions .andExpect(status().isCreated()); &#125; @Test @DisplayName(&quot;유저상태를 업데이트 한다&quot;) public void update() throws Exception &#123; Long id = 1004L; String email = &quot;admin@example.com&quot;; String name = &quot;Administrator&quot;; Long level = 3L; User user = User.builder() .email(email) .name(name) .level(level) .build(); given(userService.updateUser(id, email, name, level)).willReturn(user); ResultActions resultActions = mockMvc.perform(patch(&quot;/users/1004&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;level\\&quot;: 3&quot; + &quot;,\\&quot;email\\&quot; : \\&quot;admin@example.com\\&quot;&quot; + &quot;, \\&quot;name\\&quot; : \\&quot;Administrator\\&quot;&#125;&quot;)); verify(userService).updateUser(eq(id), eq(email), eq(name), eq(level)); resultActions .andExpect(status().isOk()); &#125; @Test @DisplayName(&quot;유저를 삭제한다.&quot;) public void deactivate() throws Exception &#123; mockMvc.perform(delete(&quot;/users/1004&quot;)) .andExpect(status().isOk()); verify(userService).deactivateUser(1004L); &#125;&#125;","text":"@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long Id; @NotEmpty private String email; @NotEmpty private String name; @NotNull private Long level; public boolean isAdmin() &#123; return level &gt; 2L; &#125; public void deactivate()&#123; level = 0L; &#125; public boolean isActive() &#123; return level &gt; 0L; &#125;&#125; @Repositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; @Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public List&lt;User&gt; getUsers() &#123; return userRepository.findAll(); &#125; public User addUser(String email, String name) &#123; User user = User.builder() .email(email) .name(name) .level(1L) .build(); userRepository.save(user); return user; &#125; public User updateUser(Long id, String email, String name, Long level ) &#123; User user = userRepository.findById(id).orElse(null); user.setEmail(email); user.setName(name); user.setLevel(level); return user; &#125; public User deactivateUser(Long userId) &#123; User user = userRepository.findById(userId).orElse(null); user.deactivate(); return user; &#125;&#125; class UserServiceTest &#123; @Mock private UserRepository userRepository; private UserService userService; @BeforeEach private void setUp() &#123; MockitoAnnotations.openMocks(this); userService = new UserService(userRepository); &#125; @Test @DisplayName(&quot;유저목록을 가져온다.&quot;) public void getUsers() &#123; List&lt;User&gt; mockUsers = new ArrayList&lt;&gt;(); mockUsers.add(User.builder() .name(&quot;tester&quot;) .email(&quot;test@example.com&quot;) .level(3L) .build()); given(userRepository.findAll()).willReturn(mockUsers); List&lt;User&gt; users = userService.getUsers(); User user = users.get(0); assertThat(user.getName()).isEqualTo(&quot;tester&quot;); assertThat(user.getEmail()).isEqualTo(&quot;test@example.com&quot;); &#125; @Test @DisplayName(&quot;유저를 추가한다.&quot;) public void addUser()&#123; String email = &quot;test@example.com&quot;; String name = &quot;tester&quot;; User mockUser = User.builder() .name(name) .email(email) .build(); given(userRepository.save(any())).willReturn(mockUser); User user = userService.addUser(email, name); assertThat(user.getName()).isEqualTo(name); assertThat(user.getEmail()).isEqualTo(email); &#125; @Test @DisplayName(&quot;유저를 업데이트 한다.&quot;) public void updateUser()&#123; Long id = 1004L; Long level = 3L; String email = &quot;test@example.com&quot;; String name = &quot;Superman&quot;; User mockUser = User.builder() .Id(id) .name(&quot;Administrator&quot;) .level(1L) .email(email) .build(); given(userRepository.findById(id)).willReturn(Optional.of(mockUser)); User user = userService.updateUser(id, email, name, level); verify(userRepository).findById(id); assertThat(user.getName()).isEqualTo(&quot;Superman&quot;); assertThat(user.isAdmin()).isEqualTo(true); &#125; @Test @DisplayName(&quot;유저를 삭제한다.&quot;) public void deactiveUser()&#123; Long id = 1004L; Long level = 2L; String email = &quot;test@example.com&quot;; String name = &quot;Superman&quot;; User mockUser = User.builder() .Id(id) .level(level) .email(email) .name(name) .build(); given(userRepository.findById(id)).willReturn(Optional.of(mockUser)); User user = userService.deactivateUser(1004L); verify(userRepository).findById(1004L); assertThat(user.isAdmin()).isEqualTo(false); assertThat(user.isActive()).isEqualTo(false); &#125;&#125; @RestController@RequiredArgsConstructorpublic class UserController &#123; // 1. User list // 2. User create -&gt; 회원가입 // 3. User update // 4. User delete -&gt; level: 0 =&gt; 아무것도 못 함. // (1: customer 2: restaurant owner 3: admin) private final UserService userService; @GetMapping(&quot;/users&quot;) public List&lt;User&gt; list()&#123; return userService.getUsers(); &#125; @PostMapping(&quot;/users&quot;) public ResponseEntity&lt;?&gt; create(@RequestBody User resource) throws URISyntaxException &#123; User user = userService.addUser(resource.getEmail(), resource.getName()); String url = &quot;/users&quot; + user.getId(); return ResponseEntity.created(URI.create(url)).body(&quot;&#123;&#125;&quot;); &#125; @PatchMapping(&quot;/users/&#123;userId&#125;&quot;) public void udpate(@PathVariable(&quot;userId&quot;) Long id, @RequestBody User user)&#123; userService.updateUser(id, user.getEmail(), user.getName(), user.getLevel()); &#125; @DeleteMapping(&quot;/users/&#123;userId&#125;&quot;) public String deactivate(@PathVariable(&quot;userId&quot;)Long userId)&#123; userService.deactivateUser(userId); return &quot;&#123;&#125;&quot;; &#125;&#125; @WebMvcTest(UserController.class)class UserControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test @DisplayName(&quot;유저목록을_가져온다&quot;) public void list() throws Exception &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(User.builder() .email(&quot;tester@example.com&quot;) .name(&quot;tester&quot;) .level(1L) .build()); given(userService.getUsers()).willReturn(users); mockMvc.perform(get(&quot;/users&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;tester&quot;))); &#125; @Test @DisplayName(&quot;유저를 추가한다.&quot;) public void create() throws Exception &#123; String email = &quot;admin@example.com&quot;; String name = &quot;Administrator&quot;; User user = User.builder() .email(email) .name(name) .build(); given(userService.addUser(email, name)).willReturn(user); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot; : \\&quot;admin@example.com\\&quot;, \\&quot;name\\&quot; : \\&quot;Administrator\\&quot;&#125;&quot;)); verify(userService).addUser(email, name) ; resultActions .andExpect(status().isCreated()); &#125; @Test @DisplayName(&quot;유저상태를 업데이트 한다&quot;) public void update() throws Exception &#123; Long id = 1004L; String email = &quot;admin@example.com&quot;; String name = &quot;Administrator&quot;; Long level = 3L; User user = User.builder() .email(email) .name(name) .level(level) .build(); given(userService.updateUser(id, email, name, level)).willReturn(user); ResultActions resultActions = mockMvc.perform(patch(&quot;/users/1004&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;level\\&quot;: 3&quot; + &quot;,\\&quot;email\\&quot; : \\&quot;admin@example.com\\&quot;&quot; + &quot;, \\&quot;name\\&quot; : \\&quot;Administrator\\&quot;&#125;&quot;)); verify(userService).updateUser(eq(id), eq(email), eq(name), eq(level)); resultActions .andExpect(status().isOk()); &#125; @Test @DisplayName(&quot;유저를 삭제한다.&quot;) public void deactivate() throws Exception &#123; mockMvc.perform(delete(&quot;/users/1004&quot;)) .andExpect(status().isOk()); verify(userService).deactivateUser(1004L); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 8 - 가게목록 필터링","slug":"spring/fastcampus-eatgo/eat-go8-category","date":"2021-02-05T03:21:36.000Z","updated":"2024-02-26T15:43:07.619Z","comments":true,"path":"2021/02/05/spring/fastcampus-eatgo/eat-go8-category/","link":"","permalink":"https://ckck803.github.io/2021/02/05/spring/fastcampus-eatgo/eat-go8-category/","excerpt":"@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Region &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;&#125; @Repositorypublic interface RegionRepository extends JpaRepository&lt;Region,Long&gt; &#123;&#125; @Service@RequiredArgsConstructorpublic class RegionService &#123; private final RegionRepository regionRepository; public List&lt;Region&gt; getRegions() &#123; return regionRepository.findAll(); &#125;&#125; @Service@RequiredArgsConstructorpublic class RegionService &#123; private final RegionRepository regionRepository; public List&lt;Region&gt; getRegions() &#123; return regionRepository.findAll(); &#125;&#125; class RegionServiceTest &#123; private RegionService regionService; @Mock private RegionRepository regionRepository; @BeforeEach public void setUp()&#123; MockitoAnnotations.openMocks(this ); regionService = new RegionService(regionRepository); &#125; @Test public void 지역정보들을_가져온다() &#123; List&lt;Region&gt; mockRegions = new ArrayList&lt;&gt;(); mockRegions.add(Region.builder() .name(&quot;Seoul&quot;) .build()); given(regionRepository.findAll()).willReturn(mockRegions); List&lt;Region&gt; regions = regionService.getRegions(); Region region = regions.get(0); assertThat(region.getName()).isEqualTo(&quot;Seoul&quot;); &#125;&#125; @RestController@RequiredArgsConstructorpublic class RegionController &#123; private final RegionService regionService; @GetMapping(&quot;/regions&quot;) public List&lt;Region&gt; list()&#123; List&lt;Region&gt; regions = regionService.getRegions(); return regions; &#125;&#125; @WebMvcTest(RegionController.class)class RegionControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private RegionService regionService; @Test public void 지역목록들을_가져온다() throws Exception &#123; List&lt;Region&gt; regions = new ArrayList&lt;&gt;(); regions.add(Region.builder().name(&quot;Seoul&quot;).build()); given(regionService.getRegions()).willReturn(regions); mockMvc.perform(get(&quot;/regions&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;Seoul&quot;))); &#125;&#125; 카테고리 만들기@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Category &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) public Long id; public String name;&#125;","text":"@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Region &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;&#125; @Repositorypublic interface RegionRepository extends JpaRepository&lt;Region,Long&gt; &#123;&#125; @Service@RequiredArgsConstructorpublic class RegionService &#123; private final RegionRepository regionRepository; public List&lt;Region&gt; getRegions() &#123; return regionRepository.findAll(); &#125;&#125; @Service@RequiredArgsConstructorpublic class RegionService &#123; private final RegionRepository regionRepository; public List&lt;Region&gt; getRegions() &#123; return regionRepository.findAll(); &#125;&#125; class RegionServiceTest &#123; private RegionService regionService; @Mock private RegionRepository regionRepository; @BeforeEach public void setUp()&#123; MockitoAnnotations.openMocks(this ); regionService = new RegionService(regionRepository); &#125; @Test public void 지역정보들을_가져온다() &#123; List&lt;Region&gt; mockRegions = new ArrayList&lt;&gt;(); mockRegions.add(Region.builder() .name(&quot;Seoul&quot;) .build()); given(regionRepository.findAll()).willReturn(mockRegions); List&lt;Region&gt; regions = regionService.getRegions(); Region region = regions.get(0); assertThat(region.getName()).isEqualTo(&quot;Seoul&quot;); &#125;&#125; @RestController@RequiredArgsConstructorpublic class RegionController &#123; private final RegionService regionService; @GetMapping(&quot;/regions&quot;) public List&lt;Region&gt; list()&#123; List&lt;Region&gt; regions = regionService.getRegions(); return regions; &#125;&#125; @WebMvcTest(RegionController.class)class RegionControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private RegionService regionService; @Test public void 지역목록들을_가져온다() throws Exception &#123; List&lt;Region&gt; regions = new ArrayList&lt;&gt;(); regions.add(Region.builder().name(&quot;Seoul&quot;).build()); given(regionService.getRegions()).willReturn(regions); mockMvc.perform(get(&quot;/regions&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;Seoul&quot;))); &#125;&#125; 카테고리 만들기@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Category &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) public Long id; public String name;&#125; @Service@RequiredArgsConstructorpublic class CategoryService &#123; private final CategoryRepository categoryRepository; public List&lt;Category&gt; getCategories() &#123; List&lt;Category&gt; categories = categoryRepository.findAll(); return categories; &#125; public Category addCategory(String name) &#123; Category category = Category.builder().name(name).build(); categoryRepository.save(category); return category; &#125;&#125; @RestController@RequiredArgsConstructorpublic class CategoryController &#123; @Autowired private final CategoryService categoryService; @GetMapping(&quot;/categories&quot;) public List&lt;Category&gt; list()&#123; List&lt;Category&gt; categories = categoryService.getCategories(); return categories; &#125; @PostMapping(&quot;/categories&quot;) public ResponseEntity&lt;?&gt; create(@RequestBody Category resource)&#123; String name = resource.getName(); Category category = categoryService.addCategory(name); String url = &quot;/categories&quot; + category.getId(); return ResponseEntity.created(URI.create(url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; @WebMvcTest(CategoryController.class)class CategoryControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private CategoryService categoryService; @Test public void 카테고리들_가져오기() throws Exception &#123; List&lt;Category&gt; categories = new ArrayList&lt;&gt;(); categories.add(Category.builder() .name(&quot;Korean Food&quot;) .build()); given(categoryService.getCategories()).willReturn(categories); mockMvc.perform(get(&quot;/categories&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;Korean Food&quot;))); &#125; @Test public void 카테고리_생성하기() throws Exception &#123; Category category = Category.builder() .name(&quot;Korean Food&quot;) .build(); given(categoryService.addCategory(&quot;Korean Food&quot;)).willReturn(category); mockMvc.perform(post(&quot;/categories&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123; \\&quot;name\\&quot; :\\&quot;Korean Food\\&quot; &#125;&quot;)) .andExpect(status().isCreated()) .andExpect(content().string(&quot;&#123;&#125;&quot;)); &#125;&#125; class CategoryServiceTest &#123; private CategoryService categoryService; @Mock private CategoryRepository categoryRepository; @BeforeEach public void setUp() &#123; MockitoAnnotations.openMocks(this); categoryService = new CategoryService(categoryRepository); &#125; @Test public void 카테고리_목록을_가져온다() &#123; List&lt;Category&gt; mockCategories = new ArrayList&lt;&gt;(); mockCategories.add(Category.builder() .name(&quot;Korean Food&quot;) .build()); given(categoryRepository.findAll()).willReturn(mockCategories); List&lt;Category&gt; categories = categoryService.getCategories(); Category category = categories.get(0); assertThat(category.getName()).isEqualTo(&quot;Korean Food&quot;); &#125; @Test public void 카테고리를_추가한다()&#123; Category category = categoryService.addCategory(&quot;Korean Food&quot;); verify(categoryRepository).save(any()); assertThat(category.getName()).isEqualTo(&quot;Korean Food&quot;); &#125;&#125; Request Parameter를 이용한 요청이 들어오는 경우public List&lt;Restaurant&gt; getRestaurants(String region) &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAllByAddressContaining(region); return restaurants;&#125; @Testpublic void 모든_레스토랑을_가져온다() &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(&quot;Seoul&quot;); Restaurant restaurant = restaurants.get(0); assertThat(restaurant.getId()).isEqualTo(1004L);&#125; @GetMapping(&quot;/restaurants&quot;)public List&lt;Restaurant&gt; list(@RequestParam(&quot;region&quot;) String region) &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(region); return restaurants;&#125; @Testpublic void list를_확인한다() throws Exception &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(Restaurant.builder() .id(1004L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build()); given(restaurantService.getRestaurants(&quot;Seoul&quot;)).willReturn(restaurants); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants?region=Seoul&quot;)); resultActions .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;))) .andDo(print());&#125; @Testpublic void RequestHeader를_이용한_list를_확인한다() throws Exception &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(Restaurant.builder() .id(1004L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build()); given(restaurantService.getRestaurants(&quot;Seoul&quot;)).willReturn(restaurants); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants?region=Seoul&quot;)); resultActions .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;))) .andDo(print());&#125;```java@Testpublic void 새로운_레스토랑_저장_및_조회하기() throws Exception &#123; String BobZip = &quot;BobZip&quot;; String Seoul = &quot;Seoul&quot;; Restaurant restaurant = Restaurant.builder() .name(BobZip) .address(Seoul) .build(); String content = objectMapper.writeValueAsString(restaurant); ResultActions postResultActions = mockMvc.perform(post(&quot;/restaurants&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); postResultActions .andExpect(status().isCreated()) .andDo(print()); List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(restaurant); given(restaurantService.getRestaurants(&quot;Seoul&quot;)).willReturn(restaurants); ResultActions getResultActions = mockMvc.perform(get(&quot;/restaurants?region=Seoul&quot;)); getResultActions .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$[0].name&quot;).value(BobZip)) .andExpect(jsonPath(&quot;$[0].address&quot;).value(Seoul)) .andDo(print());&#125; private void mockRestaurantRepository() &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); Restaurant restaurant = Restaurant.builder() .id(1004L) .address(&quot;Seoul&quot;) .name(&quot;Bob zip&quot;) .build(); restaurants.add(restaurant); given(restaurantRepository.findAllByAddressContaining(&quot;Seoul&quot;)).willReturn(restaurants); given(restaurantRepository.findById(1004L)) .willReturn(Optional.of(restaurant));&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 7 - 멀티모듈","slug":"spring/fastcampus-eatgo/eat-go7-multimodule","date":"2021-02-04T17:42:22.000Z","updated":"2024-02-26T15:43:03.291Z","comments":true,"path":"2021/02/05/spring/fastcampus-eatgo/eat-go7-multimodule/","link":"","permalink":"https://ckck803.github.io/2021/02/05/spring/fastcampus-eatgo/eat-go7-multimodule/","excerpt":"dependencies &#123; implementation project(&#x27;:eatgo-common&#x27;) implementation &#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; // https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-validation implementation &#x27;org.springframework.boot:spring-boot-starter-validation&#x27; compileOnly &#x27;org.projectlombok:lombok&#x27; developmentOnly &#x27;org.springframework.boot:spring-boot-devtools&#x27; runtimeOnly &#x27;com.h2database:h2&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27;&#125; jar &#123; enabled = true&#125;bootJar &#123; enabled = false&#125; @Testpublic void 레스토랑에_해당되는_메뉴들을_반환한다() &#123; List&lt;MenuItem&gt; mockMenuItems = new ArrayList&lt;&gt;(); mockMenuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); given(menuItemRepository.findAllByRestaurantId(1004L)).willReturn(mockMenuItems); List&lt;MenuItem&gt; menuItems = menuItemService.getMenuItems(1004L); MenuItem menuItem = menuItems.get(0); assertThat(menuItem.getName()).isEqualTo(&quot;Kimchi&quot;);&#125; public List&lt;MenuItem&gt; getMenuItems(Long restaurantId) &#123; return menuItemRepository.findAllByRestaurantId(restaurantId);&#125; 리뷰 정보 가져오기@GetMapping(&quot;/reviews&quot;)public List&lt;Review&gt; list()&#123; List&lt;Review&gt; reviews = reivewService.getReviews(); return reviews;&#125; @Testpublic void 레스토랑에_해당되는_리뷰들을_가져온다() throws Exception &#123; List&lt;Review&gt; mockReviews = new ArrayList&lt;&gt;(); mockReviews.add(Review.builder() .description(&quot;Cool!&quot;) .build()); given(reviewService.getReviews()).willReturn(mockReviews); mockMvc.perform(get(&quot;/reviews&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;Cool!&quot;)));&#125; public List&lt;Review&gt; getReviews() &#123; return reviewRepository.findAll();&#125; @Testpublic void 리뷰들을_가져온다()&#123; List&lt;Review&gt; mockReviews = new ArrayList&lt;&gt;(); mockReviews.add(Review.builder() .description(&quot;Cool!&quot;) .build()); given(reviewRepository.findAll()).willReturn(mockReviews); List&lt;Review&gt; reviews = reviewService.getReviews(); Review review = reviews.get(0); assertThat(review.getDescription()).isEqualTo(&quot;Cool!&quot;);&#125;","text":"dependencies &#123; implementation project(&#x27;:eatgo-common&#x27;) implementation &#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; // https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-validation implementation &#x27;org.springframework.boot:spring-boot-starter-validation&#x27; compileOnly &#x27;org.projectlombok:lombok&#x27; developmentOnly &#x27;org.springframework.boot:spring-boot-devtools&#x27; runtimeOnly &#x27;com.h2database:h2&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27;&#125; jar &#123; enabled = true&#125;bootJar &#123; enabled = false&#125; @Testpublic void 레스토랑에_해당되는_메뉴들을_반환한다() &#123; List&lt;MenuItem&gt; mockMenuItems = new ArrayList&lt;&gt;(); mockMenuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); given(menuItemRepository.findAllByRestaurantId(1004L)).willReturn(mockMenuItems); List&lt;MenuItem&gt; menuItems = menuItemService.getMenuItems(1004L); MenuItem menuItem = menuItems.get(0); assertThat(menuItem.getName()).isEqualTo(&quot;Kimchi&quot;);&#125; public List&lt;MenuItem&gt; getMenuItems(Long restaurantId) &#123; return menuItemRepository.findAllByRestaurantId(restaurantId);&#125; 리뷰 정보 가져오기@GetMapping(&quot;/reviews&quot;)public List&lt;Review&gt; list()&#123; List&lt;Review&gt; reviews = reivewService.getReviews(); return reviews;&#125; @Testpublic void 레스토랑에_해당되는_리뷰들을_가져온다() throws Exception &#123; List&lt;Review&gt; mockReviews = new ArrayList&lt;&gt;(); mockReviews.add(Review.builder() .description(&quot;Cool!&quot;) .build()); given(reviewService.getReviews()).willReturn(mockReviews); mockMvc.perform(get(&quot;/reviews&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;Cool!&quot;)));&#125; public List&lt;Review&gt; getReviews() &#123; return reviewRepository.findAll();&#125; @Testpublic void 리뷰들을_가져온다()&#123; List&lt;Review&gt; mockReviews = new ArrayList&lt;&gt;(); mockReviews.add(Review.builder() .description(&quot;Cool!&quot;) .build()); given(reviewRepository.findAll()).willReturn(mockReviews); List&lt;Review&gt; reviews = reviewService.getReviews(); Review review = reviews.get(0); assertThat(review.getDescription()).isEqualTo(&quot;Cool!&quot;);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 6 - 리뷰 기능","slug":"spring/fastcampus-eatgo/eat-go6-review","date":"2021-02-04T06:17:44.000Z","updated":"2024-02-26T15:42:56.503Z","comments":true,"path":"2021/02/04/spring/fastcampus-eatgo/eat-go6-review/","link":"","permalink":"https://ckck803.github.io/2021/02/04/spring/fastcampus-eatgo/eat-go6-review/","excerpt":"새로운 리뷰 생성 오청을 처리하기 위한 control@RestController@RequiredArgsConstructorpublic class ReviewController &#123; private final ReviewService reivewService; @PostMapping(&quot;/restaurants/&#123;restaurantId&#125;/reviews&quot;) public ResponseEntity&lt;?&gt; create( @PathVariable Long restaurantId, @Valid @RequestBody Review resource ) throws URISyntaxException &#123; Review review = reivewService.addReview(restaurantId, resource); String url = &quot;/restaurants/&quot; + restaurantId + &quot;/reviews/&quot; + review.getId(); return ResponseEntity.created(new URI (url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; @WebMvcTest(ReviewController.class)class ReviewControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private ReviewService reviewService; @Test public void 리뷰를_생성한다() throws Exception &#123; given(reviewService.addReview(eq(1L), any())).willReturn( Review.builder() .id(1004L) .name(&quot;JOKER&quot;) .score(3) .description(&quot;Mat-it-da&quot;) .build()); mockMvc.perform(post(&quot;/restaurants/1/reviews&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;name\\&quot;:\\&quot;JOKER\\&quot;, \\&quot;score\\&quot;:3,\\&quot;description\\&quot; : \\&quot;Mat-it-da\\&quot;&#125;&quot;)) .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/restaurants/1/reviews/1004&quot;)); verify(reviewService).addReview(eq(1L), any()); &#125;&#125; Review 도메인 객체를 생성@Entity@Builder@NoArgsConstructor@AllArgsConstructor@Getter@Setterpublic class Review &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotNull private Long restaurantId; @NotEmpty private String name; @NotNull private Integer score; @NotEmpty private String description;&#125; Review를 저장하기 위한 Repository 생성@Repositorypublic interface ReviewRepository extends JpaRepository&lt;Review, Long&gt; &#123; List&lt;Review&gt; findAllByRestaurantId(Long restaurantId);&#125; Review Service 클래스를 생성한다.@Service@RequiredArgsConstructorpublic class ReviewService &#123; private final ReviewRepository reviewRepository; public Review addReview(Long restaurantId, Review review) &#123; review.setRestaurantId(restaurantId); reviewRepository.save(review); return review; &#125;&#125;","text":"새로운 리뷰 생성 오청을 처리하기 위한 control@RestController@RequiredArgsConstructorpublic class ReviewController &#123; private final ReviewService reivewService; @PostMapping(&quot;/restaurants/&#123;restaurantId&#125;/reviews&quot;) public ResponseEntity&lt;?&gt; create( @PathVariable Long restaurantId, @Valid @RequestBody Review resource ) throws URISyntaxException &#123; Review review = reivewService.addReview(restaurantId, resource); String url = &quot;/restaurants/&quot; + restaurantId + &quot;/reviews/&quot; + review.getId(); return ResponseEntity.created(new URI (url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; @WebMvcTest(ReviewController.class)class ReviewControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private ReviewService reviewService; @Test public void 리뷰를_생성한다() throws Exception &#123; given(reviewService.addReview(eq(1L), any())).willReturn( Review.builder() .id(1004L) .name(&quot;JOKER&quot;) .score(3) .description(&quot;Mat-it-da&quot;) .build()); mockMvc.perform(post(&quot;/restaurants/1/reviews&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;name\\&quot;:\\&quot;JOKER\\&quot;, \\&quot;score\\&quot;:3,\\&quot;description\\&quot; : \\&quot;Mat-it-da\\&quot;&#125;&quot;)) .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/restaurants/1/reviews/1004&quot;)); verify(reviewService).addReview(eq(1L), any()); &#125;&#125; Review 도메인 객체를 생성@Entity@Builder@NoArgsConstructor@AllArgsConstructor@Getter@Setterpublic class Review &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotNull private Long restaurantId; @NotEmpty private String name; @NotNull private Integer score; @NotEmpty private String description;&#125; Review를 저장하기 위한 Repository 생성@Repositorypublic interface ReviewRepository extends JpaRepository&lt;Review, Long&gt; &#123; List&lt;Review&gt; findAllByRestaurantId(Long restaurantId);&#125; Review Service 클래스를 생성한다.@Service@RequiredArgsConstructorpublic class ReviewService &#123; private final ReviewRepository reviewRepository; public Review addReview(Long restaurantId, Review review) &#123; review.setRestaurantId(restaurantId); reviewRepository.save(review); return review; &#125;&#125; 서비스 클래스를 테스트하기 위한 테스트 코드 작성class ReviewServiceTest &#123; @Mock private ReviewRepository reviewRepository; private ReviewService reviewService; @BeforeEach public void setUp()&#123; MockitoAnnotations.initMocks(this); reviewService = new ReviewService(reviewRepository); &#125; @Test public void 리뷰를_추가한다()&#123; Review review = Review.builder() .name(&quot;JOKER&quot;) .score(3) .description(&quot;Mat-it-da&quot;) .build(); reviewService.addReview(1004L, review); verify(reviewRepository).save(any()); &#125;&#125; 올바르지 않는 리뷰 요청에 대한 예외처리를 위한 테스트 코드 작성@Testpublic void 올바르지_않는_리뷰생성_요청() throws Exception &#123; mockMvc.perform(post(&quot;/restaurants/1/reviews&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;&#125;&quot;)) .andExpect(status().isBadRequest()); verify(reviewService, never()).addReview(1004L, any());&#125; Restaurant 서비스 클래스내에 review 컨텐츠public Restaurant getRestaurant(Long id) &#123; Optional&lt;Restaurant&gt; optional = restaurantRepository.findById(id); if (optional.isPresent()) &#123; Restaurant restaurant = optional.get(); // 해당 restaurant id값을 갖는 모든 Menu들을 가져온다. List&lt;MenuItem&gt; menuItems = menuItemRepository.findAllByRestaurantId(id); restaurant.setMenuItems(menuItems); // 해당 restaurant id값을 갖는 모든 review들을 가져온다. List&lt;Review&gt; reviews = reviewRepository.findAllByRestaurantId(id); restaurant.setReviews(reviews); return restaurant; &#125;else&#123; throw new RestaurantNotFoundException(id); &#125;&#125; 테스트 코드 작성@Testpublic void 특정_레스토랑을_가져온다() &#123; Restaurant restaurant = restaurantService.getRestaurant(1004L); // 레스토랑 정보를 가져오는지 확인한다. verify(restaurantRepository).findById(eq(1004L)); // 메뉴정보도 가져오는지 확인한다. verify(menuItemRepository).findAllByRestaurantId(eq(1004L)); // 리뷰정보도 가져오는지 확인한다. verify(reviewRepository).findAllByRestaurantId(eq(1004L)); // 가져온 정보들을 확인한다. // 레스토랑 정보를 확인한다. assertThat(restaurant.getId()).isEqualTo(1004L); // 메뉴정보들을 확인한다. MenuItem menuItem = restaurant.getMenuItems().get(0); assertThat(menuItem.getName()).isEqualTo(&quot;Kimchi&quot;); // 리뷰정보들을 확인한다. Review review = restaurant.getReviews().get(0); assertThat(review.getDescription()).isEqualTo(&quot;Bad&quot;);&#125; 레스토랑 요청에서 Review정보가 조회되는지 확인하는 테스트 코드 작성@Testpublic void 특정_가게_상세정보를_가져온다() throws Exception &#123; Restaurant restaurant = Restaurant.builder() .id(1004L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build(); // 메뉴 정보를 생성 MenuItem menuItem = MenuItem.builder() .name(&quot;Kimchi&quot;) .build(); // 리뷰 정보를 생성 Review review = Review.builder() .name(&quot;JOKER&quot;) .score(5) .description(&quot;Great!&quot;) .build(); // 레스토랑 객체에 메뉴 정보들을 저장한다. restaurant.setMenuItems(Arrays.asList(menuItem)); // 레스토랑 객체에 리뷰 정보들을 저장한다. restaurant.setReviews(Arrays.asList(review)); given(restaurantService.getRestaurant(1004L)).willReturn(restaurant); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants/1004&quot;)); resultActions .andExpect(status().isOk()) // 레스토랑 정보가 들어있는지 확인한다. .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;))) // 메뉴 정보가 들어있는지 확인한다. .andExpect(content().string(containsString(&quot;Kimchi&quot;))) // 리뷰 정보가 들어있는지 확인한다. .andExpect(content().string(containsString(&quot;Great!&quot;))) .andDo(print());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 5 - 메뉴 관리","slug":"spring/fastcampus-eatgo/eat-go5-menuitems","date":"2021-02-04T03:27:21.000Z","updated":"2024-02-26T15:42:50.203Z","comments":true,"path":"2021/02/04/spring/fastcampus-eatgo/eat-go5-menuitems/","link":"","permalink":"https://ckck803.github.io/2021/02/04/spring/fastcampus-eatgo/eat-go5-menuitems/","excerpt":"메뉴를 추가하는 요청을 처리하기 위한 control@RestController@RequiredArgsConstructorpublic class MenuItemController &#123; private final MenuItemService menuItemService; @PatchMapping(&quot;/restaurants/&#123;restaurantId&#125;/menuitems&quot;) public String buikUpdate()&#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItemService.bulkUpdate(menuItems); return &quot;&quot;; &#125;&#125; @WebMvcTest(MenuItemController.class)class MenuItemControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private MenuItemService menuItemService; @Test public void bulkUpdate() throws Exception &#123; ResultActions resultActions = mockMvc.perform(patch(&quot;/restaurants/1/menuitems&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;[]&quot;)); resultActions .andExpect(status().isOk()); verify(menuItemService).bulkUpdate(any()); &#125;&#125; @Service@RequiredArgsConstructorpublic class MenuItemService &#123; private final MenuItemRepository menuItemRepository; public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123; for(MenuItem menuItem : menuItems)&#123; menuItem.setRestaurantId(restaurantId); menuItemRepository.save(menuItem); &#125; &#125;&#125; class MenuItemServiceTest &#123; private MenuItemService menuItemService; @Mock private MenuItemRepository menuItemRepository; @BeforeEach public void setUp()&#123; MockitoAnnotations.initMocks(this); menuItemService = new MenuItemService(menuItemRepository); &#125; @Test public void bulkUpdate() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any());; &#125;&#125; 메뉴 삭제 요청@Builder@Entity@Setter@Getter@NoArgsConstructor@AllArgsConstructorpublic class MenuItem &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long restaurantId; private String name; @Transient private boolean destroy; public MenuItem(String name)&#123; this.name = name; &#125;&#125; @Service@RequiredArgsConstructorpublic class MenuItemService &#123; private final MenuItemRepository menuItemRepository; public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123; for(MenuItem menuItem : menuItems)&#123; updateOrDeleteMenuItems(restaurantId, menuItem); &#125; &#125; private void updateOrDeleteMenuItems(Long restaurantId, MenuItem menuItem) &#123; if(menuItem.isDestroy())&#123; menuItemRepository.deleteById(menuItem.getId()); &#125;else &#123; menuItem.setRestaurantId(restaurantId); menuItemRepository.save(menuItem); &#125; &#125;&#125; @Testpublic void 메뉴를_삭제한다() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItems.add(MenuItem.builder() .id(1004L) .destroy(true) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any()); verify(menuItemRepository, times(1)).deleteById(eq(1004L));&#125;","text":"메뉴를 추가하는 요청을 처리하기 위한 control@RestController@RequiredArgsConstructorpublic class MenuItemController &#123; private final MenuItemService menuItemService; @PatchMapping(&quot;/restaurants/&#123;restaurantId&#125;/menuitems&quot;) public String buikUpdate()&#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItemService.bulkUpdate(menuItems); return &quot;&quot;; &#125;&#125; @WebMvcTest(MenuItemController.class)class MenuItemControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private MenuItemService menuItemService; @Test public void bulkUpdate() throws Exception &#123; ResultActions resultActions = mockMvc.perform(patch(&quot;/restaurants/1/menuitems&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;[]&quot;)); resultActions .andExpect(status().isOk()); verify(menuItemService).bulkUpdate(any()); &#125;&#125; @Service@RequiredArgsConstructorpublic class MenuItemService &#123; private final MenuItemRepository menuItemRepository; public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123; for(MenuItem menuItem : menuItems)&#123; menuItem.setRestaurantId(restaurantId); menuItemRepository.save(menuItem); &#125; &#125;&#125; class MenuItemServiceTest &#123; private MenuItemService menuItemService; @Mock private MenuItemRepository menuItemRepository; @BeforeEach public void setUp()&#123; MockitoAnnotations.initMocks(this); menuItemService = new MenuItemService(menuItemRepository); &#125; @Test public void bulkUpdate() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any());; &#125;&#125; 메뉴 삭제 요청@Builder@Entity@Setter@Getter@NoArgsConstructor@AllArgsConstructorpublic class MenuItem &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long restaurantId; private String name; @Transient private boolean destroy; public MenuItem(String name)&#123; this.name = name; &#125;&#125; @Service@RequiredArgsConstructorpublic class MenuItemService &#123; private final MenuItemRepository menuItemRepository; public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123; for(MenuItem menuItem : menuItems)&#123; updateOrDeleteMenuItems(restaurantId, menuItem); &#125; &#125; private void updateOrDeleteMenuItems(Long restaurantId, MenuItem menuItem) &#123; if(menuItem.isDestroy())&#123; menuItemRepository.deleteById(menuItem.getId()); &#125;else &#123; menuItem.setRestaurantId(restaurantId); menuItemRepository.save(menuItem); &#125; &#125;&#125; @Testpublic void 메뉴를_삭제한다() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItems.add(MenuItem.builder() .id(1004L) .destroy(true) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any()); verify(menuItemRepository, times(1)).deleteById(eq(1004L));&#125; @Builder@Entity@Setter@Getter@NoArgsConstructor@AllArgsConstructorpublic class MenuItem &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long restaurantId; private String name; @Transient @JsonInclude(JsonInclude.Include.NON_DEFAULT) private boolean destroy; public MenuItem(String name)&#123; this.name = name; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 4 - 예외 처리","slug":"spring/fastcampus-eatgo/eat-go4-exception","date":"2021-02-04T00:37:02.000Z","updated":"2024-02-26T15:42:39.467Z","comments":true,"path":"2021/02/04/spring/fastcampus-eatgo/eat-go4-exception/","link":"","permalink":"https://ckck803.github.io/2021/02/04/spring/fastcampus-eatgo/eat-go4-exception/","excerpt":"없는 페이지 요청에 대한 예외처리@Testpublic void 없는_페이지에대한_예외처리를_한다() throws Exception&#123; given(restaurantService.getRestaurant(404L)).willThrow(new RestaurantNotFoundException(404L)); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants/404&quot;)); resultActions .andExpect(status().isNotFound()) .andExpect(content().string(&quot;&#123;&#125;&quot;));&#125; public class RestaurantNotFoundException extends RuntimeException&#123; public RestaurantNotFoundException(Long id) &#123; super(&quot;Could not find Restaurant&quot; + id ); &#125;&#125; @ControllerAdvicepublic class RestaurantErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.NOT_FOUND) @ExceptionHandler(RestaurantNotFoundException.class) public String handleNotFound()&#123; return &quot;&#123;&#125;&quot;; &#125;&#125; Service 계층에서의 예외처리@Testpublic void 없는_레스토랑을_가져온다() &#123; assertThatThrownBy(() -&gt; &#123; Restaurant restaurant = restaurantService.getRestaurant(404L); &#125;).isInstanceOf(RestaurantNotFoundException.class);// Restaurant restaurant = restaurantService.getRestaurant(404L);&#125; public Restaurant getRestaurant(Long id) &#123; Optional&lt;Restaurant&gt; optional = restaurantRepository.findById(id); if (optional.isPresent()) &#123; List&lt;MenuItem&gt; menuItems = menuItemRepository.findAllByRestaurantId(id); Restaurant restaurant = new Restaurant(); restaurant.setMenuItems(menuItems); return restaurant; &#125;else&#123; throw new RestaurantNotFoundException(id); &#125;&#125;","text":"없는 페이지 요청에 대한 예외처리@Testpublic void 없는_페이지에대한_예외처리를_한다() throws Exception&#123; given(restaurantService.getRestaurant(404L)).willThrow(new RestaurantNotFoundException(404L)); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants/404&quot;)); resultActions .andExpect(status().isNotFound()) .andExpect(content().string(&quot;&#123;&#125;&quot;));&#125; public class RestaurantNotFoundException extends RuntimeException&#123; public RestaurantNotFoundException(Long id) &#123; super(&quot;Could not find Restaurant&quot; + id ); &#125;&#125; @ControllerAdvicepublic class RestaurantErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.NOT_FOUND) @ExceptionHandler(RestaurantNotFoundException.class) public String handleNotFound()&#123; return &quot;&#123;&#125;&quot;; &#125;&#125; Service 계층에서의 예외처리@Testpublic void 없는_레스토랑을_가져온다() &#123; assertThatThrownBy(() -&gt; &#123; Restaurant restaurant = restaurantService.getRestaurant(404L); &#125;).isInstanceOf(RestaurantNotFoundException.class);// Restaurant restaurant = restaurantService.getRestaurant(404L);&#125; public Restaurant getRestaurant(Long id) &#123; Optional&lt;Restaurant&gt; optional = restaurantRepository.findById(id); if (optional.isPresent()) &#123; List&lt;MenuItem&gt; menuItems = menuItemRepository.findAllByRestaurantId(id); Restaurant restaurant = new Restaurant(); restaurant.setMenuItems(menuItems); return restaurant; &#125;else&#123; throw new RestaurantNotFoundException(id); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 3","slug":"spring/fastcampus-eatgo/eat-go-client","date":"2021-02-03T15:59:58.000Z","updated":"2024-02-26T15:42:33.690Z","comments":true,"path":"2021/02/04/spring/fastcampus-eatgo/eat-go-client/","link":"","permalink":"https://ckck803.github.io/2021/02/04/spring/fastcampus-eatgo/eat-go-client/","excerpt":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;Hello, world!&lt;/div&gt;&lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; (async () =&gt; &#123; const url = &quot;http://localhost:8080/restaurants&quot;; const response = await fetch(url); const restaurants = await response.json(); console.log(restaurants); const element = document.getElementById(&#x27;app&#x27;); element.innerHTML = JSON.stringify(restaurants);&#125;)(); (async () =&gt; &#123; const url = &quot;http://localhost:8080/restaurants&quot;; const response = await fetch(url); const restaurants = await response.json(); console.log(restaurants); const element = document.getElementById(&#x27;app&#x27;); element.innerHTML = ` $&#123;restaurants[0].id&#125; $&#123;restaurants[0].name&#125; `&#125;)(); (async () =&gt; &#123; const url = &quot;http://localhost:8080/restaurants&quot;; const response = await fetch(url); const restaurants = await response.json(); console.log(restaurants); const element = document.getElementById(&#x27;app&#x27;); element.innerHTML = ` $&#123;restaurants.map(restaurant =&gt; ` &lt;p&gt; $&#123;restaurant.id&#125; $&#123;restaurant.name&#125; $&#123;restaurant.address&#125; &lt;/p&gt; `).join(&#x27;&#x27;)&#125; `;&#125;)();","text":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;Hello, world!&lt;/div&gt;&lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; (async () =&gt; &#123; const url = &quot;http://localhost:8080/restaurants&quot;; const response = await fetch(url); const restaurants = await response.json(); console.log(restaurants); const element = document.getElementById(&#x27;app&#x27;); element.innerHTML = JSON.stringify(restaurants);&#125;)(); (async () =&gt; &#123; const url = &quot;http://localhost:8080/restaurants&quot;; const response = await fetch(url); const restaurants = await response.json(); console.log(restaurants); const element = document.getElementById(&#x27;app&#x27;); element.innerHTML = ` $&#123;restaurants[0].id&#125; $&#123;restaurants[0].name&#125; `&#125;)(); (async () =&gt; &#123; const url = &quot;http://localhost:8080/restaurants&quot;; const response = await fetch(url); const restaurants = await response.json(); console.log(restaurants); const element = document.getElementById(&#x27;app&#x27;); element.innerHTML = ` $&#123;restaurants.map(restaurant =&gt; ` &lt;p&gt; $&#123;restaurant.id&#125; $&#123;restaurant.name&#125; $&#123;restaurant.address&#125; &lt;/p&gt; `).join(&#x27;&#x27;)&#125; `;&#125;)();","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 2 - 메뉴 정보 추가(관리자)","slug":"spring/fastcampus-eatgo/2. menuitem/eat-go2-restaurant","date":"2021-02-03T04:46:52.000Z","updated":"2024-02-26T15:42:29.516Z","comments":true,"path":"2021/02/03/spring/fastcampus-eatgo/2. menuitem/eat-go2-restaurant/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/fastcampus-eatgo/2.%20menuitem/eat-go2-restaurant/","excerpt":"레스토랑에 메뉴정보를 담기@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Restaurant &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotNull private Long categoryId; @NotEmpty private String name; @NotEmpty private String address; @Transient @JsonInclude(JsonInclude.Include.NON_NULL) private List&lt;MenuItem&gt; menuItems; public void addMenuItem(MenuItem menuItem)&#123; menuItems.add(menuItem); &#125; public void setMenuItems(List&lt;MenuItem&gt; menuItems)&#123; this.menuItems = new ArrayList&lt;&gt;(menuItems); &#125; public String getInformation()&#123; return name + &quot; in &quot; + address; &#125;&#125; 메뉴에 대한 정보를 담고있는 MenuItem 클래스@Builder@Entity@Setter@Getter@NoArgsConstructor@AllArgsConstructorpublic class MenuItem &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long restaurantId; private String name; @Transient @JsonInclude(JsonInclude.Include.NON_DEFAULT) private boolean destroy; public MenuItem(String name)&#123; this.name = name; &#125;&#125; 레스토랑에서 메뉴정보 가져오기public interface MenuItemRepository extends JpaRepository&lt;MenuItem, Long&gt; &#123; List&lt;MenuItem&gt; findAllByRestaurantId(Long restaurantId);&#125; 레스토랑에 메뉴등록 요청 보내기추가하고자 하는 데이터는 Http Body에 넣어서 보낸다.","text":"레스토랑에 메뉴정보를 담기@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Restaurant &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotNull private Long categoryId; @NotEmpty private String name; @NotEmpty private String address; @Transient @JsonInclude(JsonInclude.Include.NON_NULL) private List&lt;MenuItem&gt; menuItems; public void addMenuItem(MenuItem menuItem)&#123; menuItems.add(menuItem); &#125; public void setMenuItems(List&lt;MenuItem&gt; menuItems)&#123; this.menuItems = new ArrayList&lt;&gt;(menuItems); &#125; public String getInformation()&#123; return name + &quot; in &quot; + address; &#125;&#125; 메뉴에 대한 정보를 담고있는 MenuItem 클래스@Builder@Entity@Setter@Getter@NoArgsConstructor@AllArgsConstructorpublic class MenuItem &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long restaurantId; private String name; @Transient @JsonInclude(JsonInclude.Include.NON_DEFAULT) private boolean destroy; public MenuItem(String name)&#123; this.name = name; &#125;&#125; 레스토랑에서 메뉴정보 가져오기public interface MenuItemRepository extends JpaRepository&lt;MenuItem, Long&gt; &#123; List&lt;MenuItem&gt; findAllByRestaurantId(Long restaurantId);&#125; 레스토랑에 메뉴등록 요청 보내기추가하고자 하는 데이터는 Http Body에 넣어서 보낸다. @RestController@RequiredArgsConstructorpublic class MenuItemController &#123; private final MenuItemService menuItemService; @PatchMapping(&quot;/restaurants/&#123;restaurantId&#125;/menuitems&quot;) public String bulkUpdate(@PathVariable Long restaurantId , @RequestBody List&lt;MenuItem&gt; menuItems)&#123; menuItemService.bulkUpdate(restaurantId, menuItems); return &quot;&quot;; &#125;&#125; 레스토랑 메뉴등록 요청에 대한 테스트 코드@WebMvcTest(MenuItemController.class)class MenuItemControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private MenuItemService menuItemService; @Test public void bulkUpdate() throws Exception &#123; ResultActions resultActions = mockMvc.perform(patch(&quot;/restaurants/1/menuitems&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;[]&quot;)); resultActions .andExpect(status().isOk()); verify(menuItemService).bulkUpdate(eq(1L), any()); &#125;&#125; 레스토랑 정보를 가져와 메뉴정보 넣기@Service@RequiredArgsConstructorpublic class MenuItemService &#123; private final MenuItemRepository menuItemRepository; public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123; for(MenuItem menuItem : menuItems)&#123; updateOrDeleteMenuItems(restaurantId, menuItem); &#125; &#125; private void updateOrDeleteMenuItems(Long restaurantId, MenuItem menuItem) &#123; if(menuItem.isDestroy())&#123; menuItemRepository.deleteById(menuItem.getId()); &#125;else &#123; menuItem.setRestaurantId(restaurantId); menuItemRepository.save(menuItem); &#125; &#125;&#125; @Testpublic void bulkUpdate() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any());&#125;@Testpublic void 메뉴를_삭제한다() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItems.add(MenuItem.builder() .id(1004L) .destroy(true) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any()); verify(menuItemRepository, times(1)).deleteById(eq(1004L));&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(사용자) 레스토랑 정보 가져오기","slug":"spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-customer","date":"2021-02-03T01:20:02.000Z","updated":"2024-02-26T15:42:14.859Z","comments":true,"path":"2021/02/03/spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-customer/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-customer/","excerpt":"사용자 페이지사용자의 경우 레스토랑을 관리하지 않으므로 레스토랑 정보를 추가하거나 수정할필요는 없고 조회하는 기능만 있으면 된다. 모든 Restaurant정보 가져오기 특정 Restaurant정보 가져오기 Request Parameter를 통한 레스토랑 조회 control요청시 RequestParameter를 통해 원하는 지역, 카테고리를 통해 해당 조건을 만족하는 레스토랑 정보를 모두 가져올 수 있도록 한다. 특정 Restaurant 정보를 가져오는 함수들은 관리자에서 만들었던 내용과 같으므로 생각한다. @CrossOrigin@RestController@RequiredArgsConstructorpublic class RestaurantController &#123; private final RestaurantService restaurantService; @GetMapping(&quot;/restaurants&quot;) public List&lt;Restaurant&gt; list(@RequestParam(&quot;region&quot;) String region, @RequestParam(&quot;category&quot;) Long category) &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(region, category); return restaurants; &#125; @GetMapping(&quot;/restaurants/&#123;id&#125;&quot;) public Restaurant detail(@PathVariable Long id) throws Exception &#123; Restaurant restaurant = restaurantService.getRestaurant(id); return restaurant; &#125;&#125; Request Parameter를 통한 레스토랑 조회 테스트 코드 작성@Testpublic void RequestParameter를_이용한_list를_확인한다() throws Exception &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(Restaurant.builder() .id(1004L) .categoryId(1L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build()); given(restaurantService.getRestaurants(&quot;Seoul&quot;, 1L)).willReturn(restaurants); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants?region=Seoul&amp;category=1&quot;)); resultActions .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;))) .andDo(print());&#125;","text":"사용자 페이지사용자의 경우 레스토랑을 관리하지 않으므로 레스토랑 정보를 추가하거나 수정할필요는 없고 조회하는 기능만 있으면 된다. 모든 Restaurant정보 가져오기 특정 Restaurant정보 가져오기 Request Parameter를 통한 레스토랑 조회 control요청시 RequestParameter를 통해 원하는 지역, 카테고리를 통해 해당 조건을 만족하는 레스토랑 정보를 모두 가져올 수 있도록 한다. 특정 Restaurant 정보를 가져오는 함수들은 관리자에서 만들었던 내용과 같으므로 생각한다. @CrossOrigin@RestController@RequiredArgsConstructorpublic class RestaurantController &#123; private final RestaurantService restaurantService; @GetMapping(&quot;/restaurants&quot;) public List&lt;Restaurant&gt; list(@RequestParam(&quot;region&quot;) String region, @RequestParam(&quot;category&quot;) Long category) &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(region, category); return restaurants; &#125; @GetMapping(&quot;/restaurants/&#123;id&#125;&quot;) public Restaurant detail(@PathVariable Long id) throws Exception &#123; Restaurant restaurant = restaurantService.getRestaurant(id); return restaurant; &#125;&#125; Request Parameter를 통한 레스토랑 조회 테스트 코드 작성@Testpublic void RequestParameter를_이용한_list를_확인한다() throws Exception &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(Restaurant.builder() .id(1004L) .categoryId(1L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build()); given(restaurantService.getRestaurants(&quot;Seoul&quot;, 1L)).willReturn(restaurants); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants?region=Seoul&amp;category=1&quot;)); resultActions .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;))) .andDo(print());&#125; Service에서 Region과 CategoryId를 이용한 조회 메소드 구현control로부터 받은 region과 categoryId를 갖고 해당 조건을 만족하는 레스토랑 정보를 가져와 반환한다. 만약 레스토랑 정보가 없다고 하면 RestaurantNotFoundException예외를 일으킨다. @Service@RequiredArgsConstructorpublic class RestaurantService &#123; private final RestaurantRepository restaurantRepository; public List&lt;Restaurant&gt; getRestaurants(String region, long categoryId) &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAllByAddressContainingAndCategoryId(region, categoryId); return restaurants; &#125; public Restaurant getRestaurant(Long id) &#123; Optional&lt;Restaurant&gt; optional = restaurantRepository.findById(id); if (optional.isPresent()) &#123; Restaurant restaurant = optional.get(); return restaurant; &#125;else&#123; throw new RestaurantNotFoundException(id); &#125; &#125;&#125; public List&lt;Restaurant&gt; getRestaurants(String region, long categoryId) &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAllByAddressContainingAndCategoryId(region, categoryId); return restaurants;&#125; Repository에 method추가@Repositorypublic interface RestaurantRepository extends JpaRepository&lt;Restaurant, Long&gt; &#123; List&lt;Restaurant&gt; findAllByAddressContainingAndCategoryId(String region, long categoryId);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(관리자) 레스토랑 정보 업데이트","slug":"spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-update","date":"2021-02-03T00:22:02.000Z","updated":"2024-02-26T15:41:57.164Z","comments":true,"path":"2021/02/03/spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-update/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-admin-update/","excerpt":"4. 레스토랑 정보 업데이트레스토랑 업데이트 하기 위한 control 추가레스토랑 정보를 업데이트 하기 위해서는 업데이트 하고자 하는 레스토랑을 가지고 와야 한다. /restaurants경로뒤에 레스토랑 id를 붙여 요청이 들어오면 id를 이용해 레스토랑을 찾고 request body에 들어있는 정보로 레스토랑을 업데이트 한다. 업데이트 요청을 처리하기 위해 Http 메소드 중에서 patch메소드를 이용할 것이다. @PatchMapping(&quot;/restaurants/&#123;id&#125;&quot;)public String update(@PathVariable(&quot;id&quot;) Long id, @RequestBody Restaurant restaurant) throws Exception &#123; restaurantService.updateRestaurant(id, restaurant.getName(), restaurant.getAddress()); return &quot;&#123;&#125;&quot;;&#125; 업데이트 요청에 대한 테스트 코드 작성@Testpublic void 레스토랑정보_업데이트() throws Exception &#123; String JOKER = &quot;JOKER Bar&quot;; String Busan = &quot;Busan&quot;; Restaurant restaurant = Restaurant.builder() .categoryId(1L) .name(JOKER) .address(Busan) .build(); String content = objectMapper.writeValueAsString(restaurant); ResultActions resultActions = mockMvc.perform(patch(&quot;/restaurants/1004&quot;) .contentType(MediaType.APPLICATION_JSON) .content(content)); resultActions .andExpect(status().isOk()) .andDo(print()); verify(restaurantService).updateRestaurant(1004L, JOKER, Busan);&#125; 레스토랑 업데이트를 하기 위한 Service 메소드먼저 id를 갖고 저장돼 있는 해당 레스토랑을 가져온 후 전달 받은 name값과 address값으로 업데이트 한다. 만약 해당 레스토랑이 없을 경우 RestaurantNotFoundException예외를 일으키도록 한다.","text":"4. 레스토랑 정보 업데이트레스토랑 업데이트 하기 위한 control 추가레스토랑 정보를 업데이트 하기 위해서는 업데이트 하고자 하는 레스토랑을 가지고 와야 한다. /restaurants경로뒤에 레스토랑 id를 붙여 요청이 들어오면 id를 이용해 레스토랑을 찾고 request body에 들어있는 정보로 레스토랑을 업데이트 한다. 업데이트 요청을 처리하기 위해 Http 메소드 중에서 patch메소드를 이용할 것이다. @PatchMapping(&quot;/restaurants/&#123;id&#125;&quot;)public String update(@PathVariable(&quot;id&quot;) Long id, @RequestBody Restaurant restaurant) throws Exception &#123; restaurantService.updateRestaurant(id, restaurant.getName(), restaurant.getAddress()); return &quot;&#123;&#125;&quot;;&#125; 업데이트 요청에 대한 테스트 코드 작성@Testpublic void 레스토랑정보_업데이트() throws Exception &#123; String JOKER = &quot;JOKER Bar&quot;; String Busan = &quot;Busan&quot;; Restaurant restaurant = Restaurant.builder() .categoryId(1L) .name(JOKER) .address(Busan) .build(); String content = objectMapper.writeValueAsString(restaurant); ResultActions resultActions = mockMvc.perform(patch(&quot;/restaurants/1004&quot;) .contentType(MediaType.APPLICATION_JSON) .content(content)); resultActions .andExpect(status().isOk()) .andDo(print()); verify(restaurantService).updateRestaurant(1004L, JOKER, Busan);&#125; 레스토랑 업데이트를 하기 위한 Service 메소드먼저 id를 갖고 저장돼 있는 해당 레스토랑을 가져온 후 전달 받은 name값과 address값으로 업데이트 한다. 만약 해당 레스토랑이 없을 경우 RestaurantNotFoundException예외를 일으키도록 한다. @Transactionalpublic Restaurant updateRestaurant(Long id, String name, String address) throws Exception &#123; Optional&lt;Restaurant&gt; optional = restaurantRepository.findById(id); if (optional.isPresent()) &#123; Restaurant restaurant = optional.get(); restaurant.setName(name); restaurant.setAddress(address); return restaurant; &#125; else &#123; throw new RestaurantNotFoundException(id); &#125;&#125; 업데이트에 대한 테스트 코드@Testpublic void 레스토랑정보_업데이트() throws Exception &#123; Restaurant restaurant = Restaurant.builder() .id(1004L) .name(&quot;Bob zip&quot;) .address(&quot;Seoul&quot;) .build(); given(restaurantRepository.findById(1004L)) .willReturn(Optional.of(restaurant)); Restaurant updated = restaurantService.updateRestaurant(1004L, &quot;Sool zip&quot;, &quot;Busan&quot;); assertThat(updated.getName()).isEqualTo(&quot;Sool zip&quot;); assertThat(updated.getAddress()).isEqualTo(&quot;Busan&quot;);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(관리자) 레스토랑 생성","slug":"spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-create","date":"2021-02-03T00:21:02.000Z","updated":"2024-02-26T15:41:45.084Z","comments":true,"path":"2021/02/03/spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-create/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-admin-create/","excerpt":"3. 레스토랑 추가하기레스토랑 생성 요청을 처리하기 위한 control 추가Http 메소드들 중에서 post메소드를 사용해 새로운 레스토랑을 추가하는 요청을 처리할 것이고, /restaurnt경로로 요청이 들어올 경우 request body에 들어가 있는 데이터를 가져와 새로운 레스토랑을 생성한다. @PostMapping(&quot;/restaurants&quot;)public ResponseEntity&lt;?&gt; create(@RequestBody Restaurant resource) throws URISyntaxException &#123; String name = resource.getName(); String address = resource.getAddress(); Restaurant restaurant = Restaurant.builder() .name(name) .address(address) .build(); restaurantService.addRestaurant(restaurant); URI location = new URI(&quot;/restaurants/&quot; + restaurant.getId()); return ResponseEntity.created(location).body(&quot;&#123;&#125;&quot;);&#125; 요청에 대한 레스토랑 생성 테스트 코드 작성POJO를 JSON형태로 변환하기 위해 Jackson라이브러리의 ObjectMapper를 사용할 것이다.ObjectMapper를 통해 Restaurant객체를 JSON String 형태로 변환해 request body에 넣어 /restaurants경로로 post요청을 한다. @Autowiredprivate ObjectMapper objectMapper;@Testpublic void 새로운_레스토랑_저장하기() throws Exception &#123; String BobZip = &quot;BobZip&quot;; String Seoul = &quot;Seoul&quot;; Restaurant restaurant = Restaurant.builder() .categoryId(1L) .name(BobZip) .address(Seoul) .build(); // POJO를 JSON형태로 변환해준다. String content = objectMapper.writeValueAsString(restaurant); ResultActions resultActions = mockMvc.perform(post(&quot;/restaurants&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); resultActions .andExpect(status().isCreated()) .andDo(print());&#125; 새로운 레스토랑을 생성하는 요청을 한 후 레스토랑의 정보를 가져오는 요청을 해 해당 정보가 제대로 생성 됐는지 확인한다. @Testpublic void 새로운_레스토랑_저장_및_조회하기() throws Exception &#123; String BobZip = &quot;BobZip&quot;; String Seoul = &quot;Seoul&quot;; Restaurant restaurant = Restaurant.builder() .categoryId(1L) .name(BobZip) .address(Seoul) .build(); String content = objectMapper.writeValueAsString(restaurant); ResultActions postResultActions = mockMvc.perform(post(&quot;/restaurants&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); postResultActions .andExpect(status().isCreated()) .andDo(print()); List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(restaurant); given(restaurantService.getRestaurants()).willReturn(restaurants); ResultActions getResultActions = mockMvc.perform(get(&quot;/restaurants&quot;)); getResultActions .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$[0].name&quot;).value(BobZip)) .andExpect(jsonPath(&quot;$[0].address&quot;).value(Seoul)) .andDo(print());&#125;","text":"3. 레스토랑 추가하기레스토랑 생성 요청을 처리하기 위한 control 추가Http 메소드들 중에서 post메소드를 사용해 새로운 레스토랑을 추가하는 요청을 처리할 것이고, /restaurnt경로로 요청이 들어올 경우 request body에 들어가 있는 데이터를 가져와 새로운 레스토랑을 생성한다. @PostMapping(&quot;/restaurants&quot;)public ResponseEntity&lt;?&gt; create(@RequestBody Restaurant resource) throws URISyntaxException &#123; String name = resource.getName(); String address = resource.getAddress(); Restaurant restaurant = Restaurant.builder() .name(name) .address(address) .build(); restaurantService.addRestaurant(restaurant); URI location = new URI(&quot;/restaurants/&quot; + restaurant.getId()); return ResponseEntity.created(location).body(&quot;&#123;&#125;&quot;);&#125; 요청에 대한 레스토랑 생성 테스트 코드 작성POJO를 JSON형태로 변환하기 위해 Jackson라이브러리의 ObjectMapper를 사용할 것이다.ObjectMapper를 통해 Restaurant객체를 JSON String 형태로 변환해 request body에 넣어 /restaurants경로로 post요청을 한다. @Autowiredprivate ObjectMapper objectMapper;@Testpublic void 새로운_레스토랑_저장하기() throws Exception &#123; String BobZip = &quot;BobZip&quot;; String Seoul = &quot;Seoul&quot;; Restaurant restaurant = Restaurant.builder() .categoryId(1L) .name(BobZip) .address(Seoul) .build(); // POJO를 JSON형태로 변환해준다. String content = objectMapper.writeValueAsString(restaurant); ResultActions resultActions = mockMvc.perform(post(&quot;/restaurants&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); resultActions .andExpect(status().isCreated()) .andDo(print());&#125; 새로운 레스토랑을 생성하는 요청을 한 후 레스토랑의 정보를 가져오는 요청을 해 해당 정보가 제대로 생성 됐는지 확인한다. @Testpublic void 새로운_레스토랑_저장_및_조회하기() throws Exception &#123; String BobZip = &quot;BobZip&quot;; String Seoul = &quot;Seoul&quot;; Restaurant restaurant = Restaurant.builder() .categoryId(1L) .name(BobZip) .address(Seoul) .build(); String content = objectMapper.writeValueAsString(restaurant); ResultActions postResultActions = mockMvc.perform(post(&quot;/restaurants&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); postResultActions .andExpect(status().isCreated()) .andDo(print()); List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(restaurant); given(restaurantService.getRestaurants()).willReturn(restaurants); ResultActions getResultActions = mockMvc.perform(get(&quot;/restaurants&quot;)); getResultActions .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$[0].name&quot;).value(BobZip)) .andExpect(jsonPath(&quot;$[0].address&quot;).value(Seoul)) .andDo(print());&#125; 레스토랑 정보를 저장하는 Service 메소드 추가@Service@RequiredArgsConstructorpublic class RestaurantService &#123; private final RestaurantRepository restaurantRepository; // 전달받은 Restaurant정보를 저장하기 위한 서비스 public Restaurant addRestaurant(Restaurant restaurant) &#123; restaurantRepository.save(restaurant); return restaurant; &#125; public List&lt;Restaurant&gt; getRestaurants() &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAll(); return restaurants; &#125; public Restaurant getRestaurant(Long id) &#123; Restaurant restaurant = restaurantRepository.findById(id) .orElseThrow(() -&gt; new RestaurantNotFoundException(id)); return restaurant; &#125;&#125; 레스토랑을 추가하는 테스트 코드 추가@Testpublic void 레스토랑_추가하기() &#123; given(restaurantRepository.save(any())).will(invocation -&gt; &#123; Restaurant restaurant = invocation.getArgument(0); restaurant.setId(1234L); return restaurant; &#125;); Restaurant restaurant = Restaurant.builder() .name(&quot;BeRyong&quot;) .address(&quot;Busan&quot;) .build(); Restaurant created = restaurantService.addRestaurant(restaurant); assertThat(created.getId()).isEqualTo(1234L);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(관리자) 특정 레스토랑 가져오기","slug":"spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-specific","date":"2021-02-03T00:20:02.000Z","updated":"2024-02-26T15:41:53.025Z","comments":true,"path":"2021/02/03/spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-specific/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-admin-specific/","excerpt":"2. 특정 레스토랑에 대한 정보 가져오기특정가게에 대한 상세정보 요청을 처리하기 위한 control 추가특정 레스토랑의 정보를 가져오고 싶을 경우 restaurant의 Id값을 이용할 수 있다. /restaurant경로에 사용자가 원하는 restaurantId 를 더해 해당 레스토랑에 대한 정보를 반환하도록 한다. @GetMapping(&quot;/restaurants/&#123;id&#125;&quot;)public Restaurant detail(@PathVariable Long id) throws Exception &#123; Restaurant restaurant = restaurantService.getRestaurant(id); return restaurant;&#125; 테스트 코드 작성특정 id값으로 갖는 restaurant에 대한 정보를 가져오는 테스트를 구현한다. 요청이 정상적으로 진행된 경우에는 Status으로 200과 함께 해당 레스토랑에 대한 정보를 받을 수 있다. @Testpublic void 특정_가게_상세정보를_가져온다() throws Exception &#123; Restaurant restaurant = Restaurant.builder() .id(1004L) .categoryId(1L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build(); given(restaurantService.getRestaurant(1004L)).willReturn(restaurant); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants/1004&quot;)); resultActions .andExpect(status().isOk()) // 레스토랑 정보가 들어있는지 확인한다. .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;)));&#125; 특정 레스토랑을 가져오는 Service로직RestaurantRepository 객체를 이용해 DB로부터 id값이 일치하는 레스토랑 정보를 가져온다. 만약 해당되는 Restaurant정보가 없다면 RestaurantNotFoundException을 발생시킨다.","text":"2. 특정 레스토랑에 대한 정보 가져오기특정가게에 대한 상세정보 요청을 처리하기 위한 control 추가특정 레스토랑의 정보를 가져오고 싶을 경우 restaurant의 Id값을 이용할 수 있다. /restaurant경로에 사용자가 원하는 restaurantId 를 더해 해당 레스토랑에 대한 정보를 반환하도록 한다. @GetMapping(&quot;/restaurants/&#123;id&#125;&quot;)public Restaurant detail(@PathVariable Long id) throws Exception &#123; Restaurant restaurant = restaurantService.getRestaurant(id); return restaurant;&#125; 테스트 코드 작성특정 id값으로 갖는 restaurant에 대한 정보를 가져오는 테스트를 구현한다. 요청이 정상적으로 진행된 경우에는 Status으로 200과 함께 해당 레스토랑에 대한 정보를 받을 수 있다. @Testpublic void 특정_가게_상세정보를_가져온다() throws Exception &#123; Restaurant restaurant = Restaurant.builder() .id(1004L) .categoryId(1L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build(); given(restaurantService.getRestaurant(1004L)).willReturn(restaurant); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants/1004&quot;)); resultActions .andExpect(status().isOk()) // 레스토랑 정보가 들어있는지 확인한다. .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;)));&#125; 특정 레스토랑을 가져오는 Service로직RestaurantRepository 객체를 이용해 DB로부터 id값이 일치하는 레스토랑 정보를 가져온다. 만약 해당되는 Restaurant정보가 없다면 RestaurantNotFoundException을 발생시킨다. @Service@RequiredArgsConstructorpublic class RestaurantService &#123; private final RestaurantRepository restaurantRepository; public List&lt;Restaurant&gt; getRestaurants() &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAll(); return restaurants; &#125; public Restaurant getRestaurant(Long id) &#123; Restaurant restaurant = restaurantRepository.findById(id) .orElseThrow(() -&gt; new RestaurantNotFoundException(id)); return restaurant; &#125;&#125; Service로직 테스트코드 구현특정 레스토랑정보를 정상적으로 가져오는 경우와 특정 레스토랑정보를 못가져오는 경우 두가지에 대한 테스트 코드를 작성해야 한다. @Testpublic void 특정_레스토랑을_가져온다() &#123; Restaurant restaurant = restaurantService.getRestaurant(1004L); // restaurantRepository객체의 findById메서드가 실행됬는지 확인한다. verify(restaurantRepository).findById(eq(1004L)); // 레스토랑 정보를 확인한다. assertThat(restaurant.getId()).isEqualTo(1004L);&#125;@Testpublic void 없는_레스토랑을_가져온다() &#123; assertThatThrownBy(() -&gt; &#123; Restaurant restaurant = restaurantService.getRestaurant(404L); &#125;).isInstanceOf(RestaurantNotFoundException.class);&#125; public class RestaurantNotFoundException extends RuntimeException&#123; public RestaurantNotFoundException(Long id) &#123; super(&quot;Could not find Restaurant &quot; + id ); &#125;&#125; @ControllerAdvicepublic class RestaurantErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.NOT_FOUND) @ExceptionHandler(RestaurantNotFoundException.class) public String handleNotFound()&#123; return &quot;&#123;&#125;&quot;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(관리자) 모든 레스토랑 가져오기","slug":"spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin","date":"2021-02-03T00:19:02.000Z","updated":"2024-02-26T15:42:06.341Z","comments":true,"path":"2021/02/03/spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-admin/","excerpt":"패스트 캠퍼스에서 레스토량 예약 사이트 만드는 Toy project를 진행 했다. 해당 프로젝트를 진행하면서 배울 수 있었던 것은 TDD, 스프링부트를 이용한 Rest-Api작성 Multi-Module을 이용한 프로젝트 진행을 배울 수 있었다. 강의 내용들을 블로그 포스팅을 통해 다시 되집어 보려고 한다. 관리자 페이지 모든 Restaurant정보 가져오기 특정 Restaurant정보 가져오기 Restaurant 추가하기 Restaurant정보 수정하기 1. 모든 레스토랑에 대한 정보를 가져오기Restaurant Controller 생성레스토랑을 예약하기 위해서 예약할 수 있는 레스토랑 목록을 알아야 한다. /restaurant로 접근하면 모든 레스토랑의 정보를 가져올 수 있도록 한다. RestaurantRepository 로부터 바로 데이터를 가져와 사용자에게 넘겨줘도 되지만, Service 계층을 넣어 데이터를 처리하는 로직과 사용자에게 View를 보여주는 control로직을 분리하도록 한다. @RestController@RequiredArgsConstructorpublic class RestaurantController &#123; private final RestaurantService restaurantService; @GetMapping(&quot;/restaurants&quot;) public List&lt;Restaurant&gt; list() &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(); return restaurants; &#125;&#125;","text":"패스트 캠퍼스에서 레스토량 예약 사이트 만드는 Toy project를 진행 했다. 해당 프로젝트를 진행하면서 배울 수 있었던 것은 TDD, 스프링부트를 이용한 Rest-Api작성 Multi-Module을 이용한 프로젝트 진행을 배울 수 있었다. 강의 내용들을 블로그 포스팅을 통해 다시 되집어 보려고 한다. 관리자 페이지 모든 Restaurant정보 가져오기 특정 Restaurant정보 가져오기 Restaurant 추가하기 Restaurant정보 수정하기 1. 모든 레스토랑에 대한 정보를 가져오기Restaurant Controller 생성레스토랑을 예약하기 위해서 예약할 수 있는 레스토랑 목록을 알아야 한다. /restaurant로 접근하면 모든 레스토랑의 정보를 가져올 수 있도록 한다. RestaurantRepository 로부터 바로 데이터를 가져와 사용자에게 넘겨줘도 되지만, Service 계층을 넣어 데이터를 처리하는 로직과 사용자에게 View를 보여주는 control로직을 분리하도록 한다. @RestController@RequiredArgsConstructorpublic class RestaurantController &#123; private final RestaurantService restaurantService; @GetMapping(&quot;/restaurants&quot;) public List&lt;Restaurant&gt; list() &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(); return restaurants; &#125;&#125; 요청에 대한 테스트 코드 작성@WebMvcTest(RestaurantController.class)@AutoConfigureMockMvcclass RestaurantControllerTest &#123; @Autowired MockMvc mockMvc; @Test public void list를_확인한다() throws Exception&#123; ResultActions resultActions = mockMvc.perform(get(&quot;/restaurant&quot;)); resultActions .andExpect(status().isOk()) .andDo(print()); &#125;&#125; Restaurant Service 생성@Service@RequiredArgsConstructorpublic class RestaurantService &#123; private final RestaurantRepository restaurantRepository; public List&lt;Restaurant&gt; getRestaurants() &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAll(); return restaurants; &#125;&#125; Service 계층에 대한 Test코드 작성class RestaurantServiceTest &#123; @Autowired private MockMvc mockMvc; @InjectMocks private RestaurantService restaurantService; @Mock private RestaurantRepository restaurantRepository; @Mock private MenuItemRepository menuItemRepository; @Mock private ReviewRepository reviewRepository; @BeforeEach public void setUp() &#123; MockitoAnnotations.openMocks(this); mockRestaurantRepository(); mockMenuItemRepository(); mockReviewRepository(); &#125; private void mockRestaurantRepository() &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); Restaurant restaurant = Restaurant.builder() .id(1004L) .address(&quot;Seoul&quot;) .categoryId(1L) .name(&quot;Bob zip&quot;) .build(); restaurants.add(restaurant); // address와 category를 사용해 검색한다. given(restaurantRepository .findAllByAddressContainingAndCategoryId(&quot;Seoul&quot;, 1L)) .willReturn(restaurants); given(restaurantRepository.findById(1004L)) .willReturn(Optional.of(restaurant)); &#125; private void mockMenuItemRepository() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add((MenuItem.builder() .name(&quot;Kimchi&quot;) .build())); given(menuItemRepository.findAllByRestaurantId(1004L)).willReturn(menuItems); &#125; private void mockReviewRepository() &#123; List&lt;Review&gt; reviews = new ArrayList&lt;&gt;(); reviews.add(Review.builder() .name(&quot;BeRyong&quot;) .score(1) .description(&quot;Bad&quot;) .build()); given(reviewRepository.findAllByRestaurantId(1004L)).willReturn(reviews); &#125; @Test @DisplayName(&quot;모든 레스토랑을 가져온다.&quot;) public void list() &#123; String region = &quot;Seoul&quot;; Long categoryId = 1L; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(region, categoryId); Restaurant restaurant = restaurants.get(0); assertThat(restaurant.getId()).isEqualTo(1004L); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"Spring Rest API - ExceptionHandling","slug":"spring/spring-rest/rest-api-04-exceptionhandling","date":"2021-02-02T18:02:37.000Z","updated":"2024-02-26T16:14:05.568Z","comments":true,"path":"2021/02/03/spring/spring-rest/rest-api-04-exceptionhandling/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/spring-rest/rest-api-04-exceptionhandling/","excerpt":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - ExceptionHandling존재하지 않는 id값에 대한 예외처리 추가저장되지 않은 User를 조회할 경우 UserNotFoundException 예외가 발생하도록 예외처리한다. UserController.java @GetMapping(&quot;/users/&#123;id&#125;&quot;)public User retrieveUser(@PathVariable int id)&#123; User user = service.findOne(id); if(user == null)&#123; throw new UserNotFoundException(String.format(&quot;ID[%s] not found&quot;, id )); &#125; return user;&#125; 예외처리하는 Exception 클래스 생성ResponseStatus 를 이용해 HttpStatus.NOT_FOUND 옵션을 설정할 경우 UserNotFoundException 예외가 발생했을때 Http Status Code 404(Not Found) 가 반환된다.","text":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - ExceptionHandling존재하지 않는 id값에 대한 예외처리 추가저장되지 않은 User를 조회할 경우 UserNotFoundException 예외가 발생하도록 예외처리한다. UserController.java @GetMapping(&quot;/users/&#123;id&#125;&quot;)public User retrieveUser(@PathVariable int id)&#123; User user = service.findOne(id); if(user == null)&#123; throw new UserNotFoundException(String.format(&quot;ID[%s] not found&quot;, id )); &#125; return user;&#125; 예외처리하는 Exception 클래스 생성ResponseStatus 를 이용해 HttpStatus.NOT_FOUND 옵션을 설정할 경우 UserNotFoundException 예외가 발생했을때 Http Status Code 404(Not Found) 가 반환된다. UserNotFoundException.java @ResponseStatus(HttpStatus.NOT_FOUND)public class UserNotFoundException extends RuntimeException &#123; public UserNotFoundException(String message) &#123; super(message); &#125;&#125; 예외시 보내는 새로운 메시지 형식을 정의위와 같이 에러 메시지가 반환되면 불필요한 내용들이 많다. 언제, 어떤 메시지가 발생했는지, 어떤 원인에 의해 발생했는지 필요한 정보만 담는 ExceptionResponse 클래스를 생성한다. ExceptionResponse.java @Data@AllArgsConstructor@NoArgsConstructorpublic class ExceptionResponse &#123; private Date timestamp; private String message; private String details;&#125; ExceptionHandler 를 이용한 예외 처리하기 Controller에서 발생한 Exception을 다루기 위한 방법, ExceptionHandler 어노테이션을 이용해 명시된 예외, 명시된 예외 자식 클래스 예외가 발생했을 때 예외 처리를 해준다. 예외를 생략한 경우에는 Method 파라미터에 명시된 예외가 지정된다. Controller 에서 등록되지 않은 사용자에 대한 조회 요청이 들어왔을 때 UserNotFoundException 이 발생한다. UserNotFoundException 예외를 처리하기 위해서 ExceptionHandler 어노테이션을 통해 해당 예외를 처리한다. UserController.class // path variable을 이용한 요청을 처리@GetMapping(&quot;/users/&#123;id&#125;&quot;)public User retrieveUser(@PathVariable int id)&#123; User user = service.findOne(id); if(user == null)&#123; throw new UserNotFoundException(String.format(&quot;ID[%s] not found&quot;, id )); &#125; return user;&#125;@ExceptionHandler(UserNotFoundException.class)public final ExceptionResponse handleUserNotFoundException(Exception ex, WebRequest request)&#123; ExceptionResponse exceptionResponse = new ExceptionResponse(new Date(), ex.getMessage(), request.getDescription(false)); return exceptionResponse;&#125; Http Status Code 다루기ExceptionHandler 를 이용해 Controller에서 발생한 예외를 처리하는 경우 예외가 발생했음에도 Http Status Code가 200 으로 떨어지게 된다. ResponseStatus 어노테이션, ResponseEntity 를 사용해 클리언트에게 적절한 상태 코드를 반환해줄 수 있다. ResponseStatus 어노테이션 사용한 방법@ResponseStatus(HttpStatus.NOT_FOUND)@ExceptionHandler(UserNotFoundException.class)public final ExceptionResponse handleUserNotFoundException(Exception ex, WebRequest request)&#123; ExceptionResponse exceptionResponse = new ExceptionResponse(new Date(), ex.getMessage(), request.getDescription(false)); return exceptionResponse;&#125; ResponseEntity 사용한 방법@ExceptionHandler(UserNotFoundException.class)public final ResponseEntity&lt;Object&gt; handleUserNotFoundException(Exception ex, WebRequest request)&#123; ExceptionResponse exceptionResponse = new ExceptionResponse(new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND);&#125; @ControllerAdvice @RestControllerAdvice @ControllerAdvice @RestControllerAdvice 는 Controller, RestController 마다 정의된 ExceptionHandler를 한 곳에 모아 관리하고 처리할 수 있게 도와준다. 지정된 Controller, RestController 에 ExceptionHandler, InitBinder 기능을 부여한다. 지정된 Controller가 없을 경우 모든 Controller에 적용한다. 우선순위는 자세한 것이 높은 우선순위를 갖는다. CustomizedResponseEntityExceptionHandler.java @RestController@ControllerAdvicepublic class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler &#123; @ExceptionHandler(Exception.class) public final ResponseEntity&lt;Object&gt; handleAllExceptions(Exception ex, WebRequest request)&#123; ExceptionResponse exceptionResponse = new ExceptionResponse(new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.INTERNAL_SERVER_ERROR); &#125; @ExceptionHandler(UserNotFoundException.class) public final ResponseEntity&lt;Object&gt; handleUserNotFoundException(Exception ex, WebRequest request)&#123; ExceptionResponse exceptionResponse = new ExceptionResponse(new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Rest","slug":"Spring/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring/Spring-Rest/"}],"tags":[]},{"title":"Spring Rest API - HTTP Status Code 다루기","slug":"spring/spring-rest/rest-api-03-http-status-code","date":"2021-02-02T17:02:37.000Z","updated":"2024-02-26T16:13:53.600Z","comments":true,"path":"2021/02/03/spring/spring-rest/rest-api-03-http-status-code/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/spring-rest/rest-api-03-http-status-code/","excerpt":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - HTTP Status Code 다루기201(Created) 코드 반환하기 사용자가 요청으로 새로운 User가 생성됨을 확인하기 위해 201(Created) 코드를 반환한다. @PostMapping(&quot;/users&quot;)public ResponseEntity&lt;User&gt; createUser(@RequestBody @Valid User user)&#123; User savedUser = service.save(user); URI location = ServletUriComponentsBuilder.fromCurrentRequest() .path(&quot;/&#123;id&#125;&quot;) .buildAndExpand(savedUser.getId()) .toUri(); return ResponseEntity.created(location).build();&#125; 201(Created) 코드를 확인하기 위한 Test Code 작성@Testpublic void 유저를_등록하고_상태코드_201을_확인한다() throws Exception &#123; User user = new User(); String name = &quot;dongwoo&quot;; Date date = new Date(); user.setName(name); user.setJoinDate(date); String content = objectMapper.writeValueAsString(user); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); resultActions .andExpect(status().isCreated()) .andDo(print());&#125;","text":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - HTTP Status Code 다루기201(Created) 코드 반환하기 사용자가 요청으로 새로운 User가 생성됨을 확인하기 위해 201(Created) 코드를 반환한다. @PostMapping(&quot;/users&quot;)public ResponseEntity&lt;User&gt; createUser(@RequestBody @Valid User user)&#123; User savedUser = service.save(user); URI location = ServletUriComponentsBuilder.fromCurrentRequest() .path(&quot;/&#123;id&#125;&quot;) .buildAndExpand(savedUser.getId()) .toUri(); return ResponseEntity.created(location).build();&#125; 201(Created) 코드를 확인하기 위한 Test Code 작성@Testpublic void 유저를_등록하고_상태코드_201을_확인한다() throws Exception &#123; User user = new User(); String name = &quot;dongwoo&quot;; Date date = new Date(); user.setName(name); user.setJoinDate(date); String content = objectMapper.writeValueAsString(user); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); resultActions .andExpect(status().isCreated()) .andDo(print());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Rest","slug":"Spring/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring/Spring-Rest/"}],"tags":[]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리 Domain 생성","slug":"spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-common","date":"2021-02-02T15:21:08.000Z","updated":"2024-02-26T15:42:10.928Z","comments":true,"path":"2021/02/03/spring/fastcampus-eatgo/1. restaurant/eat-go-restaurant-common/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-common/","excerpt":"Restaurant Entity 클래스Restaurant 클래스에는 id , name, address를 저장한다. id : 레스토랑을 구분하기 위한 Id값 name : 레스토랑의 이름 address : 레스토랑의 위치 @Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Restaurant &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotEmpty private String name; @NotEmpty private String address;&#125; Restaurant 클래스에 대한 테스트 코드 작성@Testpublic void creation()&#123; String name = &quot;OutBack&quot;; String address = &quot;Seoul&quot;; long id = 1004L; Restaurant restaurant = new Restaurant(id, name, address); assertThat(restaurant).isNotNull(); assertThat(restaurant.getId()).isEqualTo(id); assertThat(restaurant.getName()).isEqualTo(name); assertThat(restaurant.getAddress()).isEqualTo(address);&#125; Restaurant Repository 생성Restaurant에 대한 정보를 가져오고 저장하고 수정하기 위한 Repository를 생성한다. Repository는 DB에 접근해 CRUD를 실행할 수 있다. @Repositorypublic interface RestaurantRepository extends JpaRepository&lt;Restaurant, Long&gt; &#123;&#125;","text":"Restaurant Entity 클래스Restaurant 클래스에는 id , name, address를 저장한다. id : 레스토랑을 구분하기 위한 Id값 name : 레스토랑의 이름 address : 레스토랑의 위치 @Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Restaurant &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotEmpty private String name; @NotEmpty private String address;&#125; Restaurant 클래스에 대한 테스트 코드 작성@Testpublic void creation()&#123; String name = &quot;OutBack&quot;; String address = &quot;Seoul&quot;; long id = 1004L; Restaurant restaurant = new Restaurant(id, name, address); assertThat(restaurant).isNotNull(); assertThat(restaurant.getId()).isEqualTo(id); assertThat(restaurant.getName()).isEqualTo(name); assertThat(restaurant.getAddress()).isEqualTo(address);&#125; Restaurant Repository 생성Restaurant에 대한 정보를 가져오고 저장하고 수정하기 위한 Repository를 생성한다. Repository는 DB에 접근해 CRUD를 실행할 수 있다. @Repositorypublic interface RestaurantRepository extends JpaRepository&lt;Restaurant, Long&gt; &#123;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[]},{"title":"Spring Rest API - 도메인 및 서비스 로직 작성하기","slug":"spring/spring-rest/rest-api-02-service","date":"2021-02-02T15:04:00.000Z","updated":"2024-02-26T16:13:57.822Z","comments":true,"path":"2021/02/03/spring/spring-rest/rest-api-02-service/","link":"","permalink":"https://ckck803.github.io/2021/02/03/spring/spring-rest/rest-api-02-service/","excerpt":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - 도메인 및 서비스 로직 작성하기User 도메인 클래스 생성@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer id; private String name; private Date joinDate;&#125; 서비스 클래스 생성@Servicepublic class UserDaoService &#123; // 관계형 데이터베이스를 사용하지 않고 Memory 데이터를 사용 private static List&lt;User&gt; users = new ArrayList&lt;&gt;(); private static int usersCount = 3; static&#123; users.add(new User(1, &quot;Kenneth&quot;, new Date())); users.add(new User(2, &quot;Alice&quot;, new Date())); users.add(new User(3, &quot;Elena&quot;, new Date())); &#125; // 전체 사용자 조회 public List&lt;User&gt; findAll()&#123; return users; &#125; // 개별 사용자 조회 public User save(User user)&#123; if(user.getId() == null)&#123; user.setId(++usersCount); &#125; users.add(user); return user; &#125; // id값을 이용한 사용자 조회 public User findOne(int id)&#123; for (User user : users)&#123; if(user.getId() == id)&#123; return user; &#125; &#125; return null; &#125;&#125; 사용자 요청 처리 Controller 추가@RestController@RequiredArgsConstructorpublic class UserController &#123; private final UserDaoService service; @GetMapping(&quot;/users&quot;) public List&lt;User&gt; retrieveAllUsers()&#123; return service.findAll(); &#125; // path variable을 이용한 요청을 처리 @GetMapping(&quot;/users/&#123;id&#125;&quot;) public User retrieveUser(@PathVariable int id)&#123; User user = service.findOne(id); return user; &#125;&#125;","text":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - 도메인 및 서비스 로직 작성하기User 도메인 클래스 생성@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer id; private String name; private Date joinDate;&#125; 서비스 클래스 생성@Servicepublic class UserDaoService &#123; // 관계형 데이터베이스를 사용하지 않고 Memory 데이터를 사용 private static List&lt;User&gt; users = new ArrayList&lt;&gt;(); private static int usersCount = 3; static&#123; users.add(new User(1, &quot;Kenneth&quot;, new Date())); users.add(new User(2, &quot;Alice&quot;, new Date())); users.add(new User(3, &quot;Elena&quot;, new Date())); &#125; // 전체 사용자 조회 public List&lt;User&gt; findAll()&#123; return users; &#125; // 개별 사용자 조회 public User save(User user)&#123; if(user.getId() == null)&#123; user.setId(++usersCount); &#125; users.add(user); return user; &#125; // id값을 이용한 사용자 조회 public User findOne(int id)&#123; for (User user : users)&#123; if(user.getId() == id)&#123; return user; &#125; &#125; return null; &#125;&#125; 사용자 요청 처리 Controller 추가@RestController@RequiredArgsConstructorpublic class UserController &#123; private final UserDaoService service; @GetMapping(&quot;/users&quot;) public List&lt;User&gt; retrieveAllUsers()&#123; return service.findAll(); &#125; // path variable을 이용한 요청을 처리 @GetMapping(&quot;/users/&#123;id&#125;&quot;) public User retrieveUser(@PathVariable int id)&#123; User user = service.findOne(id); return user; &#125;&#125; Service 로직 확인을 위한 Test 코드 작성하기@Testpublic void 모든_유저들을_가져온다() throws Exception &#123; ResultActions resultActions = mockMvc.perform(get(&quot;/users&quot;)); resultActions .andExpect(status().isOk()) .andDo(print());&#125; PathVariable 로 보낸 요청으로 Service 로직이 정상적으로 수행되고 반환 값이 정상적으로 왔는지 확인한다. @Testpublic void 특정_유저를_가져온다() throws Exception &#123; ResultActions resultActions = mockMvc.perform(get(&quot;/users/1&quot;)); resultActions .andExpect(status().isOk()) .andExpect(jsonPath(&quot;id&quot;).value(1)) .andDo(print());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Rest","slug":"Spring/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring/Spring-Rest/"}],"tags":[]},{"title":"Spring Rest API - Rest API 시작하기 Controller 작성","slug":"spring/spring-rest/rest-api-01-controller","date":"2021-02-02T14:47:05.000Z","updated":"2024-02-26T16:13:18.099Z","comments":true,"path":"2021/02/02/spring/spring-rest/rest-api-01-controller/","link":"","permalink":"https://ckck803.github.io/2021/02/02/spring/spring-rest/rest-api-01-controller/","excerpt":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - Rest API 시작하기 Controller 작성@RestControllerpublic class HelloWorldController &#123; @GetMapping(&quot;/hello-world&quot;) public String Hello()&#123; return &quot;Hello World&quot;; &#125; // SpringBoot에서는 HelloWorldBean이라는 객체를 JSON타입의 형태로 반환해준다. @GetMapping(&quot;/hello-world-bean/&quot;) public HelloWorldBean helloWorldBean()&#123; return new HelloWorldBean(&quot;Hello World&quot;); &#125; @GetMapping(&quot;/hello-world-bean/path-variable/&#123;name&#125;&quot;) public HelloWorldBean helloWorldBean(@PathVariable String name)&#123; return new HelloWorldBean(String.format(&quot;Hello World, %s&quot;, name)); &#125;&#125; HelloWorldBean 클래스 생성@Data@NoArgsConstructor@AllArgsConstructorpublic class HelloWorldBean &#123; private String message;&#125; 테스트 코드 작성 MockMvc 객체를 이용해 각 Controller에 대한 Test 코드를 작성한다. MockMvc 객체의 반환 값으로는 ResultActions 를 이용해 받는다. ResultActions 객체내 andExpect 메소드를 이용해 요청이 정상적(200) 으로 수행 됐는지 반환 값이 정상적으로 왔는지 검증한다. @Testpublic void Hello_World가_리턴된다() throws Exception&#123; ResultActions actions = mockMvc.perform(get(&quot;/hello-world&quot;)); actions .andExpect(status().isOk()) .andExpect(content().string(&quot;Hello World&quot;)) .andDo(print()) ;&#125;","text":"목차 Spring Rest API - Spring Boot Swagger 사용하기 Spring Rest API - ExceptionHandling Spring Rest API - HTTP Status Code 다루기 Spring Rest API - 도메인 및 서비스 로직 작성하기 Spring Rest API - Rest API 시작하기 Controller 작성 Spring Boot Rest API - Rest API 시작하기 Controller 작성@RestControllerpublic class HelloWorldController &#123; @GetMapping(&quot;/hello-world&quot;) public String Hello()&#123; return &quot;Hello World&quot;; &#125; // SpringBoot에서는 HelloWorldBean이라는 객체를 JSON타입의 형태로 반환해준다. @GetMapping(&quot;/hello-world-bean/&quot;) public HelloWorldBean helloWorldBean()&#123; return new HelloWorldBean(&quot;Hello World&quot;); &#125; @GetMapping(&quot;/hello-world-bean/path-variable/&#123;name&#125;&quot;) public HelloWorldBean helloWorldBean(@PathVariable String name)&#123; return new HelloWorldBean(String.format(&quot;Hello World, %s&quot;, name)); &#125;&#125; HelloWorldBean 클래스 생성@Data@NoArgsConstructor@AllArgsConstructorpublic class HelloWorldBean &#123; private String message;&#125; 테스트 코드 작성 MockMvc 객체를 이용해 각 Controller에 대한 Test 코드를 작성한다. MockMvc 객체의 반환 값으로는 ResultActions 를 이용해 받는다. ResultActions 객체내 andExpect 메소드를 이용해 요청이 정상적(200) 으로 수행 됐는지 반환 값이 정상적으로 왔는지 검증한다. @Testpublic void Hello_World가_리턴된다() throws Exception&#123; ResultActions actions = mockMvc.perform(get(&quot;/hello-world&quot;)); actions .andExpect(status().isOk()) .andExpect(content().string(&quot;Hello World&quot;)) .andDo(print()) ;&#125; 반환되는 JSON 객체 에 대해 jsonPath 를 이용해 반환 값에 대한 검증을 한다. @Testpublic void Hello_World_Bean_test() throws Exception&#123; ResultActions action = mockMvc.perform(get(&quot;/hello-world-bean&quot;)); action .andExpect(status().isOk()) .andExpect(jsonPath(&quot;message&quot;).value(&quot;Hello World&quot;)) .andDo(print());&#125; @Testpublic void Hello_World_Bean_Name_test() throws Exception&#123; ResultActions actions = mockMvc.perform(get(&quot;/hello-world-bean/path-variable/dongwoo&quot;)); actions .andExpect(status().isOk()) .andExpect(jsonPath(&quot;message&quot;).value(&quot;Hello World, dongwoo&quot;)) .andDo(print());&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Rest","slug":"Spring/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring/Spring-Rest/"}],"tags":[]},{"title":"Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기","slug":"spring/spring-security/oauth2/oauth2-05-config","date":"2021-02-01T04:56:10.000Z","updated":"2024-02-26T16:23:56.067Z","comments":true,"path":"2021/02/01/spring/spring-security/oauth2/oauth2-05-config/","link":"","permalink":"https://ckck803.github.io/2021/02/01/spring/spring-security/oauth2/oauth2-05-config/","excerpt":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 2. Resource Server로부터 사용자 정보 가져오기Spring Security 설정하기OAuth2 인증을 마친 후에 Resource Server로부터 사용자 정보를 가져오기 위해서는 UserInfo EndPoint에 접근할 필요가 있다. HttpSecurity객체의 oauth2Login().userInfoEndpoint().userService() 메소드를 이용해서 UserInfo EndPoint로부터 사용자 정보를 가져올 Service를 등록한다. @EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final CustomOAuth2UserService customOAuth2UserService; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .antMatcher(&quot;/**&quot;).authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .anyRequest().authenticated(); http .oauth2Login() .userInfoEndpoint() .userService(customOAuth2UserService); &#125;&#125; 스프링에서 기본적으로 제공하는 OAuth2ProviderGoogle, Facebook, Github 등을 통해 OAuth2인증하기 위한 기본적인 설정값들이 들어가 있다. 해당 정보를 통해 ClientRegistration 객체를 생성한다. authorizationUri 인증을 진행하기 위해 사용하는 URI tokenUri Resource server로부터 access token을 받기 위해 사용하는 URI jwkSetUri token의 유효성(서명)을 확인할 수 있는 public key(JSON Web Key)를 받을 수 있는 URI userInfoUri Resource Server(ex. Google)로부터 사용자 정보를 가져오기 위한 URI userNameAttributeName Resource server가 제공하는 id값 clientName Resource Server 이름(client Name을 사용할 때도 있다.)","text":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 2. Resource Server로부터 사용자 정보 가져오기Spring Security 설정하기OAuth2 인증을 마친 후에 Resource Server로부터 사용자 정보를 가져오기 위해서는 UserInfo EndPoint에 접근할 필요가 있다. HttpSecurity객체의 oauth2Login().userInfoEndpoint().userService() 메소드를 이용해서 UserInfo EndPoint로부터 사용자 정보를 가져올 Service를 등록한다. @EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final CustomOAuth2UserService customOAuth2UserService; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .antMatcher(&quot;/**&quot;).authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .anyRequest().authenticated(); http .oauth2Login() .userInfoEndpoint() .userService(customOAuth2UserService); &#125;&#125; 스프링에서 기본적으로 제공하는 OAuth2ProviderGoogle, Facebook, Github 등을 통해 OAuth2인증하기 위한 기본적인 설정값들이 들어가 있다. 해당 정보를 통해 ClientRegistration 객체를 생성한다. authorizationUri 인증을 진행하기 위해 사용하는 URI tokenUri Resource server로부터 access token을 받기 위해 사용하는 URI jwkSetUri token의 유효성(서명)을 확인할 수 있는 public key(JSON Web Key)를 받을 수 있는 URI userInfoUri Resource Server(ex. Google)로부터 사용자 정보를 가져오기 위한 URI userNameAttributeName Resource server가 제공하는 id값 clientName Resource Server 이름(client Name을 사용할 때도 있다.) CommonOAuth2Provider.enum public enum CommonOAuth2Provider &#123; GOOGLE &#123; @Override public Builder getBuilder(String registrationId) &#123; ClientRegistration.Builder builder = getBuilder(registrationId, ClientAuthenticationMethod.BASIC, DEFAULT_REDIRECT_URL); builder.scope(&quot;openid&quot;, &quot;profile&quot;, &quot;email&quot;); builder.authorizationUri(&quot;https://accounts.google.com/o/oauth2/v2/auth&quot;); builder.tokenUri(&quot;https://www.googleapis.com/oauth2/v4/token&quot;); builder.jwkSetUri(&quot;https://www.googleapis.com/oauth2/v3/certs&quot;); builder.issuerUri(&quot;https://accounts.google.com&quot;); builder.userInfoUri(&quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;); builder.userNameAttributeName(IdTokenClaimNames.SUB); builder.clientName(&quot;Google&quot;); return builder; &#125; &#125;, ... private static final String DEFAULT_REDIRECT_URL = &quot;&#123;baseUrl&#125;/&#123;action&#125;/oauth2/code/&#123;registrationId&#125;&quot;; protected final ClientRegistration.Builder getBuilder(String registrationId, ClientAuthenticationMethod method, String redirectUri) &#123; ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(registrationId); builder.clientAuthenticationMethod(method); builder.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE); builder.redirectUri(redirectUri); return builder; &#125;&#125; Service 생성하기아래 서비스는 DefaultOAuth2UserService 에 구현된 코드들을 가져와 다시 정의 했다. Spring Boot에서 OAuth2 인증 방식을 사용하기 위해서는 OAuth2UserService인터페이스를 구현해 loadUser 메소드를 정의해야 한다. OAuth2UserService 인터페이스를 구현해 사용자가 원하는 서비스를 만든다. DefaultOAuth2UserService 는 스프링에서 제공하는 OAuth2UserService 를 구현한 기본 Class이다. CustomOAuth2UserService.class @Service@RequiredArgsConstructorpublic class CustomOAuth2UserService implements OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; &#123; private final OAuth2Repository oAuth2Repository; private RestTemplate restTemplate = new RestTemplate(); private final Converter&lt;OAuth2UserRequest, RequestEntity&lt;?&gt;&gt; requestEntityConverter = new OAuth2UserRequestEntityConverter(); @Override public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException &#123; String userNameAttributeName = userRequest .getClientRegistration() .getProviderDetails() .getUserInfoEndpoint() .getUserNameAttributeName(); // userRequest객체를 request객체로 변환해 Resouce Server에 요청을 보내 User 정보를 가져온다. RequestEntity&lt;?&gt; request = this.requestEntityConverter.convert(userRequest); ResponseEntity&lt;Map&lt;String, Object&gt;&gt; response = restTemplate.exchange(request, new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;); Map&lt;String, Object&gt; userAttributes = response.getBody(); // 사용자 권한 목록을 저장한다. Set&lt;GrantedAuthority&gt; authorities = new LinkedHashSet&lt;&gt;(); authorities.add(new OAuth2UserAuthority(userAttributes)); // token값으로 접근 가능한 scope를 같이 저장한다. OAuth2AccessToken token = userRequest.getAccessToken(); for (String authority : token.getScopes()) &#123; authorities.add(new SimpleGrantedAuthority(&quot;SCOPE_&quot; + authority)); &#125; OAuth2User oAuth2User = new DefaultOAuth2User(authorities, userAttributes, userNameAttributeName); return oAuth2User; &#125;&#125; OAuth2UserService 는 clinetRegistration 객체와 accessToken 을 가지고 있는 OAuth2UserRequest 를 이용해 UserInfo EndPoint로부터 사용자 정보를 가져올 수 있다. 디버깅을 통해 Spring OAuth2 자세히 살펴보기 userNameAttributeName 사용자를 인식할 수 있는 field 구글에서는 sub필드를 이용한다. OAuth2User 스프링에서는 기본 구현체로 DefaultOAuth2User 객체를 제공한다. authorities, userAttributes, userNameAttributeName 3가지 속성을 가진 OAuth2 User객체이다. OAuth2AccessToken OAuth2 Access Token을 표현하기 위한 객체 tokenType : OAuth 인증을 위한 Bearer Token 타입임을 나타낸다. scope : 해당 토큰 값으로 접근할 수 있는 정보들을 나타낸다. toeknValue : 토큰 값이 들어 있다. OAuth2UserRequest OAuth2UserRequest객체는 ClientRegistration 객체와, OAuth2AccessToken 객체 그리고 추가적인 데이터를 담기 위한 Map&lt;String, Object&gt; 객체가 존재한다. ClientRegistration 객체에는 Resource Server에 등록 정보와 Resource에 접근하기 위한 URI들이 있다. OAuth2AccessToken 객체에는 Resource Server로부터 데이터를 가져오기 위해 필요한 Token값이 담겨 있다. request 객체를 보면 Header값에 Access Token값이 있다. UserInfo URI에 접근해 Access Token을 이용해 인증을 받고 사용자 정보를 받아올 수 있다. OAuth2UserRequest 객체내 additionalParamater 에 id_token으로 JWT(JSON Web Token) 이 들어있는 것을 확인할 수 있다. JWT 에 대한 유효성 검사는 jwkSetUri 에서 Public Key 값을 가져와 유효성 검사를 진행한다. https://jwt.io/ 사이트에 전달 받은 JWT 와 Public Key를 이용하면 유효성 검증과 JWT 내용을 볼 수 있다. response 객체를 살펴 보면 UserInfo URI로 접근해 인증을 성공적으로 마쳤을 때 사용자 정보를 가져옴을 확인 할 수 있다. 가져오는 사용자 정보는 scope로 명시한 데이터만 가져온다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Oauth2","slug":"Spring/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Oauth2/"}],"tags":[]},{"title":"Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기","slug":"spring/spring-security/oauth2/oauth2-03-modeling","date":"2021-02-01T04:26:33.000Z","updated":"2024-02-26T16:23:14.700Z","comments":true,"path":"2021/02/01/spring/spring-security/oauth2/oauth2-03-modeling/","link":"","permalink":"https://ckck803.github.io/2021/02/01/spring/spring-security/oauth2/oauth2-03-modeling/","excerpt":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 1. OAuth2를 이용한 인증 사용하기참고 https://www.docs4dev.com/docs/en/spring-security/5.1.2.RELEASE/reference/jc.html#oauth2client Google에 Web Application 등록하기Google의 OAuth2 서비스를 이용하기 위해서 사용할 Web Application을 등록해 Client Id와 Client Secret을 받아야 한다. 구글 클라우드 플랫폼 : https://console.cloud.google.com/ API및 서비스 &gt; OAuth 동의 화면을 클릭","text":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 1. OAuth2를 이용한 인증 사용하기참고 https://www.docs4dev.com/docs/en/spring-security/5.1.2.RELEASE/reference/jc.html#oauth2client Google에 Web Application 등록하기Google의 OAuth2 서비스를 이용하기 위해서 사용할 Web Application을 등록해 Client Id와 Client Secret을 받아야 한다. 구글 클라우드 플랫폼 : https://console.cloud.google.com/ API및 서비스 &gt; OAuth 동의 화면을 클릭 사용자 인증 정보 만들기 &gt; OAuth 클라이언트 ID를 선택 애플리케이션 유형으로는 웹 애플리케이션을 선택한다.승인된 리디랙션 URI로는 http://localhost:8080/login/oauth2/code/google 를 기입해준다. OAuth 클라이언트가 생성됐다는 알림과 함께 Client ID와 Client Secret이 생성된다. OAuth2 설정 적용하기SpringBoot에서 Google OAuth2 인증을 사용하기 위해서 Google로부터 생성된 Client ID와 Client Secret을 기입해준다. application.yml spring: security: oauth2: client: registration: google: client-id: Google로부터 받은 Client ID client-secret: Google로부터 받은 Client Secret Control 구현/ 경로는 누구나 접근이 가능하도록 해 Hello World 문구가 반환되지만 /restricted 경로는 인증된 사용자만 restricted 문구를 받을 수 있도록 할 것이다. Oauth2Controller.class @RestControllerpublic class Oauth2Controller &#123; @GetMapping(&quot;/&quot;) public String Hello()&#123; return &quot;Hello World&quot;; &#125; @GetMapping(&quot;/restricted&quot;) public String restricted()&#123; return &quot;restricted&quot;; &#125;&#125; Spring Security 설정하기/ 경로는 누구나 접근이 가능하도록 하고 그외 모든 경로는 인증된 사용자만 사용할 수 있도록 설정한다.HttpSecurity객체의 oauth2Login() 메소드를 사용해 OAuth2 인증방식을 사용하도록 한다. SecurityConfig.class @EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final CustomOAuth2UserService customOAuth2UserService; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .antMatcher(&quot;/**&quot;).authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .anyRequest().authenticated(); http .oauth2Login(); &#125;&#125; 어플리케이션 실행설정을 완료한 후 어플리케이션을 실행한 다음 localhost:8080/restricted 로 이동하면 아래와 같은 Google OAuth2인증 페이지로 이동하게 된다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Oauth2","slug":"Spring/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Oauth2/"}],"tags":[]},{"title":"Google OAuth2 인증 방식 이해하기","slug":"spring/spring-security/oauth2/oauth2-02-google","date":"2021-02-01T03:56:10.000Z","updated":"2024-02-26T16:22:56.229Z","comments":true,"path":"2021/02/01/spring/spring-security/oauth2/oauth2-02-google/","link":"","permalink":"https://ckck803.github.io/2021/02/01/spring/spring-security/oauth2/oauth2-02-google/","excerpt":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 Google Oauth2 인증 시나리오 살펴보기 Web Server가 Google에 Access Token 을 요청한다. 사용자가 구글 ID와 Password를 이용해 로그인을 한다. Web Server쪽으로 Authorization code 가 반환된다. Authorization code를 이용해 Access Token을 요청 구글에서 Access Token값을 반환한다. Access Token을 이용해 사용자의 profile과 같은 정보들을 가져온다. 스프링에서 기본적으로 제공하는 OAuth2Provider https://docs.aws.amazon.com/ko_kr/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html Google, Facebook, Github 등을 통해 OAuth2인증하기 위한 기본적인 설정값들이 들어가 있다. authorizationUri 인증을 진행하기 위해 사용하는 URI tokenUri Resource server 로부터 Access token 을 받기 위해 사용하는 URI jwkSetUri Google로 부터 받은 JWT(JSON Web Token) 의 유효성을 확인할 수 있는 Public key(JSON Web Key) 를 받을 수 있는 URI userInfoUri Resource Server (ex. Google) 로부터 사용자 정보를 가져오기 위한 URI userNameAttributeName Resource server 가 제공하는 id값 clientName Resource Server 이름 (client Name을 사용할 때도 있다.) public enum CommonOAuth2Provider &#123; GOOGLE &#123; @Override public Builder getBuilder(String registrationId) &#123; ClientRegistration.Builder builder = getBuilder(registrationId, ClientAuthenticationMethod.BASIC, DEFAULT_REDIRECT_URL); builder.scope(&quot;openid&quot;, &quot;profile&quot;, &quot;email&quot;); builder.authorizationUri(&quot;https://accounts.google.com/o/oauth2/v2/auth&quot;); builder.tokenUri(&quot;https://www.googleapis.com/oauth2/v4/token&quot;); builder.jwkSetUri(&quot;https://www.googleapis.com/oauth2/v3/certs&quot;); builder.issuerUri(&quot;https://accounts.google.com&quot;); builder.userInfoUri(&quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;); builder.userNameAttributeName(IdTokenClaimNames.SUB); builder.clientName(&quot;Google&quot;); return builder; &#125; &#125;, ... private static final String DEFAULT_REDIRECT_URL = &quot;&#123;baseUrl&#125;/&#123;action&#125;/oauth2/code/&#123;registrationId&#125;&quot;; protected final ClientRegistration.Builder getBuilder(String registrationId, ClientAuthenticationMethod method, String redirectUri) &#123; ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(registrationId); builder.clientAuthenticationMethod(method); builder.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE); builder.redirectUri(redirectUri); return builder; &#125;&#125;","text":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 Google Oauth2 인증 시나리오 살펴보기 Web Server가 Google에 Access Token 을 요청한다. 사용자가 구글 ID와 Password를 이용해 로그인을 한다. Web Server쪽으로 Authorization code 가 반환된다. Authorization code를 이용해 Access Token을 요청 구글에서 Access Token값을 반환한다. Access Token을 이용해 사용자의 profile과 같은 정보들을 가져온다. 스프링에서 기본적으로 제공하는 OAuth2Provider https://docs.aws.amazon.com/ko_kr/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html Google, Facebook, Github 등을 통해 OAuth2인증하기 위한 기본적인 설정값들이 들어가 있다. authorizationUri 인증을 진행하기 위해 사용하는 URI tokenUri Resource server 로부터 Access token 을 받기 위해 사용하는 URI jwkSetUri Google로 부터 받은 JWT(JSON Web Token) 의 유효성을 확인할 수 있는 Public key(JSON Web Key) 를 받을 수 있는 URI userInfoUri Resource Server (ex. Google) 로부터 사용자 정보를 가져오기 위한 URI userNameAttributeName Resource server 가 제공하는 id값 clientName Resource Server 이름 (client Name을 사용할 때도 있다.) public enum CommonOAuth2Provider &#123; GOOGLE &#123; @Override public Builder getBuilder(String registrationId) &#123; ClientRegistration.Builder builder = getBuilder(registrationId, ClientAuthenticationMethod.BASIC, DEFAULT_REDIRECT_URL); builder.scope(&quot;openid&quot;, &quot;profile&quot;, &quot;email&quot;); builder.authorizationUri(&quot;https://accounts.google.com/o/oauth2/v2/auth&quot;); builder.tokenUri(&quot;https://www.googleapis.com/oauth2/v4/token&quot;); builder.jwkSetUri(&quot;https://www.googleapis.com/oauth2/v3/certs&quot;); builder.issuerUri(&quot;https://accounts.google.com&quot;); builder.userInfoUri(&quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;); builder.userNameAttributeName(IdTokenClaimNames.SUB); builder.clientName(&quot;Google&quot;); return builder; &#125; &#125;, ... private static final String DEFAULT_REDIRECT_URL = &quot;&#123;baseUrl&#125;/&#123;action&#125;/oauth2/code/&#123;registrationId&#125;&quot;; protected final ClientRegistration.Builder getBuilder(String registrationId, ClientAuthenticationMethod method, String redirectUri) &#123; ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(registrationId); builder.clientAuthenticationMethod(method); builder.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE); builder.redirectUri(redirectUri); return builder; &#125;&#125; jwkSetUri의 URI로 접속https://www.googleapis.com/oauth2/v3/certs // 20210131104458// https://www.googleapis.com/oauth2/v3/certs&#123; &quot;keys&quot;: [ &#123; &quot;use&quot;: &quot;sig&quot;, &quot;kid&quot;: &quot;eea1b1f42807a8cc136a03a3c16d29db8296daf0&quot;, &quot;n&quot;: &quot;0zNdxOgV5VIpoeAfj8TMEGRBFg-gaZWz94ePR1yxTKzScHakH4F4wcMEyL0vNE-yW_u4pOl9E-hAalPa2tFv4fCVNMMkmKwcf0gm9wNFWXGakVQ8wER4iUg33MyUGOWj2RGX1zlZxCdFoZRtshLx8xcpL3F5Hlh6m8MqIAowWtusTf5TtYMXFlPaWLQgRXvoOlLZ-muzEuutsZRu-agdOptnUiAZ74e8BgaKN8KNEZ2SqP6vE4w16mgGHQjEPUKz9exxcsnbLru6hZdTDvXbX9IduabyvHy8vQRZsqlE9lTiOOOC9jwh27TXsD05HAXmNYiR6voekzEvfS88vnot2Q&quot;, &quot;e&quot;: &quot;AQAB&quot;, &quot;kty&quot;: &quot;RSA&quot;, &quot;alg&quot;: &quot;RS256&quot; &#125;, &#123; &quot;n&quot;: &quot;rKZ-1zdz_CoLekSynOtyWv6cPSSkV28Kb9kZZHyYL-yhkKnH_bHl8OpWiGxQiKP0ulLRIaq1IhSMetkZ8FfXH-iptIDu4lPb8gt0HQYkjcy3HoaKRXBw2F8fJQO4jQ-ufR4l-E0HRqwLywzdtAImNWmju3A4kx8s0iSGHGSHyE4EUdh5WKt-NMtfUPfB5v9_2bC-w6wH7zAEsI5nscMXnvz1u8w7g2_agyhKSK0D9OkJ02w3I4xLMlrtKEv2naoBGerWckKcQ1kBYUh6WASPdvTqX4pcAJi7Tg6jwQXIP1aEq0JU8C0zE3d33kaMoCN3SenIxpRczRzUHpbZ-gk5PQ&quot;, &quot;e&quot;: &quot;AQAB&quot;, &quot;use&quot;: &quot;sig&quot;, &quot;kid&quot;: &quot;03b2d22c2fecf873ed19e5b8cf704afb7e2ed4be&quot;, &quot;kty&quot;: &quot;RSA&quot;, &quot;alg&quot;: &quot;RS256&quot; &#125; ]&#125; userInfoUri EndPoint에 접속token_uri로부터 받은 access token을 사용하여 https://www.googleapis.com/oauth2/v3/userinfo?access_token=&#123;Google로부터 받은 Access Token&#125; 해당 형식으로 URI에 접속하게 되면 User와 관련된 JSON값을 받을 수 있다. &#123; &quot;sub&quot;: &quot;&quot;, &quot;name&quot;: &quot;사용자 성+이름&quot;, &quot;given_name&quot;: &quot;사용자 이름&quot;, &quot;family_name&quot;: &quot;사용자 성&quot;, &quot;picture&quot;: &quot;구글에서 사용하는 내 사진&quot;, &quot;email&quot;: &quot;구글 email&quot;, &quot;email_verified&quot;: true, &quot;locale&quot;: &quot;ko&quot;&#125; sub 필드는 Google서비스에서 계정마다 부여하는 id 값이다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Oauth2","slug":"Spring/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Oauth2/"}],"tags":[]},{"title":"OAuth2를 이용한 로그인 구현 이해하기","slug":"spring/spring-security/oauth2/oauth2-01","date":"2021-01-29T11:47:30.000Z","updated":"2024-02-26T16:22:30.852Z","comments":true,"path":"2021/01/29/spring/spring-security/oauth2/oauth2-01/","link":"","permalink":"https://ckck803.github.io/2021/01/29/spring/spring-security/oauth2/oauth2-01/","excerpt":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 OAuth2를 이용한 로그인 구현 이해하기OAuth란? OAuth란 Open Authorization의 약자이며 사용자 인증을 대신해서 해주고 Client에게 Access Token을 발급해 사용자 Resource에 대한 접근 권한(Authorization)을 제공하는 방법이다. OAuth가 등장하기 이전에는 각 사이트 별로 사용자 Id와 Password를 입력해 인증을 하고 정보를 저장하는 방식이였다. 때문에 사용자 입장에서는 본인의 Id와 Password를 각 사이트에 등록해야 한다는 신뢰성 적인 문제와 각 사이트에서는 사용자 정보를 관리하고 책임져야 하는 문제점이 있었다. 해당 문제를 해결하기 위해 등장한 방법이 OAuth 인증 방식이다. OAuth2 사용하기Web Application을 기준으로 OAuth2를 사용하기 위한 방법은 크게 3가지가 있다. Resource Server(Google, Naver 등) 에 Application을 등록 Resource Owner 사용자 인증을 통해 Autorization Code 를 가져오기 Client가 획득한 Autorization Code를 이용해 Access Token 을 발급 받기","text":"목차 Spring Security OAuth2 - Handler Spring Security OAuth2 - Login 페이지 Customizing 하기 Spring Security OAuth2를 이용한 로그인 구현 - 사용자 정보 가져오기 Spring Security OAuth2를 이용한 로그인 구현 - Spring boot OAuth2 인증 살펴보기 Spring Security OAuth2를 이용한 로그인 구현 - OAuth2를 이용한 인증 사용하기 Google OAuth2 인증 방식 이해하기 OAuth2를 이용한 로그인 구현 이해하기 OAuth2를 이용한 로그인 구현 이해하기OAuth란? OAuth란 Open Authorization의 약자이며 사용자 인증을 대신해서 해주고 Client에게 Access Token을 발급해 사용자 Resource에 대한 접근 권한(Authorization)을 제공하는 방법이다. OAuth가 등장하기 이전에는 각 사이트 별로 사용자 Id와 Password를 입력해 인증을 하고 정보를 저장하는 방식이였다. 때문에 사용자 입장에서는 본인의 Id와 Password를 각 사이트에 등록해야 한다는 신뢰성 적인 문제와 각 사이트에서는 사용자 정보를 관리하고 책임져야 하는 문제점이 있었다. 해당 문제를 해결하기 위해 등장한 방법이 OAuth 인증 방식이다. OAuth2 사용하기Web Application을 기준으로 OAuth2를 사용하기 위한 방법은 크게 3가지가 있다. Resource Server(Google, Naver 등) 에 Application을 등록 Resource Owner 사용자 인증을 통해 Autorization Code 를 가져오기 Client가 획득한 Autorization Code를 이용해 Access Token 을 발급 받기 1. Resource Server에 Application 등록하기 Resource Server에 Application을 등록하게 되면 Clinet Id 와 Client Secret 그리고 Authorized redirect URIs 를 받을 수 있다. 2. Resource Owner 인증 URI Reousrce Owner가 OAuth 방식으로 Client에 사용자 인증을 시도하면 특정 URL로 리다이렉트를 진행한다.Client에서 Resource Server로 Redirect한 주소는 아래와 같다. https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount? response_type=code &amp;client_id=406416755620-r1h48em5g68qqh34pq277o80sc9qpb05.apps.googleusercontent.com &amp;scope=profile%20email &amp;state=qc0AqQVml_2waASthQKINHS6vGvC2HbjdWKmfWBFSkk%3D &amp;redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Flogin%2Foauth2%2Fcode%2Fgoogle &amp;flowName=GeneralOAuthFlow Request Parameter response_type Google OAuth 2.0 End-Point 가 인증 코드를 반환하는지 여부를 결정한다. 웹 서버 애플리케이션의 경우 매개 변수 값을 code로 설정(resource server가 authorization code 를 발행) client_id Resource Server에서 Client에 발행해준 Id scope client가 resource server에 필요한 리소스에 대한 access범위 를 지정한다. state 애플리케이션이 권한 요청과 권한 서버의 응답 사이의 상태를 유지하기 위해 사용하는 문자열 값을 지정합니다. 사용자가 권한을 인증한 후 동일한 값이 반환되는지 확인한다. CSRF 공격을 막는데 사용되는 값 redirect_uri Oauth2를 이용해 Resource Server로부터 인증을 마친 사용가자 이동할 URI authorization code 를 받기 위한 URI 일반적인 redirect_uri는 {baseUrl}&#x2F;login&#x2F;oauth2&#x2F;code&#x2F;{registrationId} 의 형식을 띈다. google의 경우 redirect_uri의 경우 localhost:8080&#x2F;login&#x2F;oauth2&#x2F;code&#x2F;google 이다. flowName 무엇을 위한 접근인지 나타내기 위한 parameter 3. Authorization code 사용자가 Resource Server ID 와 Password 를 이용해 인증을 마치게 되면 Client로 Authorization code가 전송된다. 4. Access Token 획득하기 Resource Server로부터 Access Token을 발급 받기 위한 요청으로 Resource Server로부터 받은Authorization Code 와 Client Id , Client Secret , Redirect URI 를 Parameter로 보낸다. 서버측으로 Acces Token을 획득하기 위한 요청 https://www.googleapis.com/oauth2/v4/token? code=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7 &amp;client_id=your_client_id &amp;client_secret=your_client_secret &amp;redirect_uri=https%3A//oauth2.example.com/code &amp;grant_type=authorization_code 응답값으로 Resource Server로부터 Access Token획득 &#123; &quot;access_token&quot;: &quot;1/fFAGRNJru1FTz70BzhT3Zg&quot;, &quot;expires_in&quot;: 3920, &quot;token_type&quot;: &quot;Bearer&quot;, &quot;scope&quot;: &quot;https://www.googleapis.com/auth/drive.metadata.readonly&quot;, &quot;refresh_token&quot;: &quot;1//xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI&quot;&#125; 참고Open-Id : https://openid.net/specs/openid-connect-discovery-1_0.htmlOauth2 : https://tools.ietf.org/html/rfc6749구글 Oauth2 API : https://developers.google.com/identity/protocols/oauth2생활코딩 Oauth2(구) : https://www.youtube.com/watch?v=y5nNX5w0eqc&amp;t=1s생활코딩 Oauth2 : https://www.youtube.com/watch?v=hm2r6LtUbk8&amp;list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Oauth2","slug":"Spring/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Oauth2/"}],"tags":[]},{"title":"Spring Security Form Login - 4. 회원가입 페이지 만들기","slug":"spring/spring-security/form-login/form-signup-md","date":"2021-01-29T02:10:40.000Z","updated":"2024-02-26T16:21:08.940Z","comments":true,"path":"2021/01/29/spring/spring-security/form-login/form-signup-md/","link":"","permalink":"https://ckck803.github.io/2021/01/29/spring/spring-security/form-login/form-signup-md/","excerpt":"회원가입을 처리하기 위한 Controller 추가 요청으로 들어온 데이터를 받기 위한 DTO객체 생성 회원가입 page생성하기 회원 가입을 처리하기 위한 Controller 추가/signup으로 들어온 사용자 정보를 DTO객체로 받고 Account객체를 생성한 후 DB에 저장한다. @Controller@RequiredArgsConstructorpublic class SecurityController &#123; private final CustomUserDetailsService customUserDetailsService; private final PasswordEncoder passwordEncoder; @GetMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @GetMapping(&quot;/login&quot;) public String login()&#123; return &quot;login&quot;; &#125; @GetMapping(&quot;/logout&quot;) public void logout()&#123; &#125; @GetMapping(&quot;/signup&quot;) public String signup(@ModelAttribute(&quot;signupDto&quot;) AccountDto accountDto, Model model)&#123; return &quot;signup&quot;; &#125; @PostMapping(&quot;/signup&quot;) public String createNewAccount(@ModelAttribute(&quot;signupDto&quot;) @Validated AccountDto accountDto, Model model)&#123; Account account = Account.builder() .username(accountDto.getUsername()) .email(accountDto.getEmail()) .password(passwordEncoder.encode(accountDto.getPassword())) .role(Role.USER) .build(); customUserDetailsService.saveAccount(account); return &quot;redirect:&quot;; &#125;&#125; User정보를 받기위한 DTO만들기@Datapublic class AccountDto &#123; private String username; private String email; private String password;&#125; 회원가입 template 만들기&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Bootstrap Registration Page with Floating Labels&lt;/title&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot;&gt; &lt;meta name=&quot;googlebot&quot; content=&quot;noindex, nofollow&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/result-light.css&quot;&gt;--&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/dummy.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/jquery.slim.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/bootstrap.bundle.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/all.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/css/signup.css&#125;&quot;/&gt; &lt;script id=&quot;insert&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-10 col-xl-9 mx-auto&quot;&gt; &lt;div class=&quot;card card-signin flex-row my-5&quot;&gt; &lt;div class=&quot;card-img-left d-none d-md-flex&quot;&gt; &lt;!-- Background image for card set in CSS! --&gt; &lt;/div&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title text-center&quot;&gt;Register&lt;/h5&gt; &lt;form class=&quot;form-signin&quot; th:object=&quot;$&#123;signupDto&#125;&quot; th:action=&quot;@&#123;/signup&#125;&quot; th:method=&quot;post&quot;&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input th:field=&quot;*&#123;username&#125;&quot; type=&quot;text&quot; id=&quot;inputUserame&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required autofocus&gt; &lt;label for=&quot;inputUserame&quot;&gt;Username&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input th:field=&quot;*&#123;email&#125;&quot; type=&quot;email&quot; id=&quot;inputEmail&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required&gt; &lt;label for=&quot;inputEmail&quot;&gt;Email address&lt;/label&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input th:field=&quot;*&#123;password&#125;&quot; type=&quot;password&quot; id=&quot;inputPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;label for=&quot;inputPassword&quot;&gt;Password&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;inputConfirmPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;label for=&quot;inputConfirmPassword&quot;&gt;Confirm password&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block text-uppercase&quot; type=&quot;submit&quot;&gt;Register&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[//]]&gt;&lt;/script&gt;&lt;script&gt; // tell the embed parent frame the height of the content if (window.parent &amp;&amp; window.parent.parent) &#123; window.parent.parent.postMessage([&quot;resultsFrame&quot;, &#123; height: document.body.getBoundingClientRect().height, slug: &quot;1nu8g6e5&quot; &#125;], &quot;*&quot;) &#125; // always overwrite window.name, in case users try to set it manually window.name = &quot;result&quot;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Form에서 기입된 데이터 보내기","text":"회원가입을 처리하기 위한 Controller 추가 요청으로 들어온 데이터를 받기 위한 DTO객체 생성 회원가입 page생성하기 회원 가입을 처리하기 위한 Controller 추가/signup으로 들어온 사용자 정보를 DTO객체로 받고 Account객체를 생성한 후 DB에 저장한다. @Controller@RequiredArgsConstructorpublic class SecurityController &#123; private final CustomUserDetailsService customUserDetailsService; private final PasswordEncoder passwordEncoder; @GetMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @GetMapping(&quot;/login&quot;) public String login()&#123; return &quot;login&quot;; &#125; @GetMapping(&quot;/logout&quot;) public void logout()&#123; &#125; @GetMapping(&quot;/signup&quot;) public String signup(@ModelAttribute(&quot;signupDto&quot;) AccountDto accountDto, Model model)&#123; return &quot;signup&quot;; &#125; @PostMapping(&quot;/signup&quot;) public String createNewAccount(@ModelAttribute(&quot;signupDto&quot;) @Validated AccountDto accountDto, Model model)&#123; Account account = Account.builder() .username(accountDto.getUsername()) .email(accountDto.getEmail()) .password(passwordEncoder.encode(accountDto.getPassword())) .role(Role.USER) .build(); customUserDetailsService.saveAccount(account); return &quot;redirect:&quot;; &#125;&#125; User정보를 받기위한 DTO만들기@Datapublic class AccountDto &#123; private String username; private String email; private String password;&#125; 회원가입 template 만들기&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Bootstrap Registration Page with Floating Labels&lt;/title&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot;&gt; &lt;meta name=&quot;googlebot&quot; content=&quot;noindex, nofollow&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/result-light.css&quot;&gt;--&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/dummy.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/jquery.slim.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/bootstrap.bundle.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/all.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/css/signup.css&#125;&quot;/&gt; &lt;script id=&quot;insert&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-10 col-xl-9 mx-auto&quot;&gt; &lt;div class=&quot;card card-signin flex-row my-5&quot;&gt; &lt;div class=&quot;card-img-left d-none d-md-flex&quot;&gt; &lt;!-- Background image for card set in CSS! --&gt; &lt;/div&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title text-center&quot;&gt;Register&lt;/h5&gt; &lt;form class=&quot;form-signin&quot; th:object=&quot;$&#123;signupDto&#125;&quot; th:action=&quot;@&#123;/signup&#125;&quot; th:method=&quot;post&quot;&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input th:field=&quot;*&#123;username&#125;&quot; type=&quot;text&quot; id=&quot;inputUserame&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required autofocus&gt; &lt;label for=&quot;inputUserame&quot;&gt;Username&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input th:field=&quot;*&#123;email&#125;&quot; type=&quot;email&quot; id=&quot;inputEmail&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required&gt; &lt;label for=&quot;inputEmail&quot;&gt;Email address&lt;/label&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input th:field=&quot;*&#123;password&#125;&quot; type=&quot;password&quot; id=&quot;inputPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;label for=&quot;inputPassword&quot;&gt;Password&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;inputConfirmPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;label for=&quot;inputConfirmPassword&quot;&gt;Confirm password&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block text-uppercase&quot; type=&quot;submit&quot;&gt;Register&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[//]]&gt;&lt;/script&gt;&lt;script&gt; // tell the embed parent frame the height of the content if (window.parent &amp;&amp; window.parent.parent) &#123; window.parent.parent.postMessage([&quot;resultsFrame&quot;, &#123; height: document.body.getBoundingClientRect().height, slug: &quot;1nu8g6e5&quot; &#125;], &quot;*&quot;) &#125; // always overwrite window.name, in case users try to set it manually window.name = &quot;result&quot;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Form에서 기입된 데이터 보내기@ModelAttribute를 통해 accountDTO객체의 데이터가 회원가입 페이지의signupDto에게 전달되고 전달 받을 수 있다. Thymeleaf의 field속성을 통해 기입된 값들은 accountDTO객체로 변환되어 요청이 들어가게 된다. &lt;form class=&quot;form-signin&quot; th:object=&quot;$&#123;signupDto&#125;&quot; th:action=&quot;@&#123;/signup&#125;&quot; th:method=&quot;post&quot;&gt;...&lt;input th:field=&quot;*&#123;username&#125;&quot; type=&quot;text&quot; id=&quot;inputUserame&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required autofocus&gt;...&lt;input th:field=&quot;*&#123;email&#125;&quot; type=&quot;email&quot; id=&quot;inputEmail&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required&gt;...&lt;input type=&quot;password&quot; id=&quot;inputConfirmPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Form login","slug":"Spring/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Form-login/"}],"tags":[]},{"title":"Spring Security Form Login - 3. 템플릿 만들기","slug":"spring/spring-security/form-login/form-template-md","date":"2021-01-29T00:48:42.000Z","updated":"2024-02-26T16:21:12.758Z","comments":true,"path":"2021/01/29/spring/spring-security/form-login/form-template-md/","link":"","permalink":"https://ckck803.github.io/2021/01/29/spring/spring-security/form-login/form-template-md/","excerpt":"Spring에서 제공하는 Thymeleaf템플릿 엔진을 이용해 로그인 페이지를 구현했다. Form Login Page&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Bootstrap Login Page Card with Floating Labels&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/dummy.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/jquery.slim.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/bootstrap.bundle.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/all.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9 col-md-7 col-lg-5 mx-auto&quot;&gt; &lt;div class=&quot;card card-signin my-5&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title text-center&quot;&gt;Sign In&lt;/h5&gt; &lt;form class=&quot;form-signin&quot; th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input type=&quot;text&quot; th:name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required autofocus&gt; &lt;label th:for=&quot;username&quot;&gt;Email address&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input type=&quot;password&quot; th:name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;label th:for=&quot;password&quot;&gt;Password&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;custom-control custom-checkbox mb-3&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;custom-control-input&quot; id=&quot;customCheck1&quot;&gt; &lt;label class=&quot;custom-control-label&quot; for=&quot;customCheck1&quot;&gt;Remember password&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block text-uppercase&quot; type=&quot;submit&quot;&gt;Sign in&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Form 로그인을 처리하는 url로 post요청을 보낸다. &lt;form class=&quot;form-signin&quot; th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; username과 password를 받는 input태그에서 name속성에 username과 password를 확실히 기입해줘야 Security가 해당 데이터를 얻어올 수 있다. &lt;input type=&quot;text&quot; th:name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required autofocus&gt;...&lt;input type=&quot;password&quot; th:name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; 로그인 후 진입 화면&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;시작페이지&lt;/h1&gt;&lt;form action=&quot;/logout&quot; th:action=&quot;@&#123;/logout&#125;&quot; th:method=&quot;post&quot; sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;button type=&quot;submit&quot; value=&quot;logout&quot;&gt;로그 아웃&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","text":"Spring에서 제공하는 Thymeleaf템플릿 엔진을 이용해 로그인 페이지를 구현했다. Form Login Page&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Bootstrap Login Page Card with Floating Labels&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/dummy.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/jquery.slim.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/bootstrap.bundle.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/all.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9 col-md-7 col-lg-5 mx-auto&quot;&gt; &lt;div class=&quot;card card-signin my-5&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title text-center&quot;&gt;Sign In&lt;/h5&gt; &lt;form class=&quot;form-signin&quot; th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input type=&quot;text&quot; th:name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required autofocus&gt; &lt;label th:for=&quot;username&quot;&gt;Email address&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input type=&quot;password&quot; th:name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;label th:for=&quot;password&quot;&gt;Password&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;custom-control custom-checkbox mb-3&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;custom-control-input&quot; id=&quot;customCheck1&quot;&gt; &lt;label class=&quot;custom-control-label&quot; for=&quot;customCheck1&quot;&gt;Remember password&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block text-uppercase&quot; type=&quot;submit&quot;&gt;Sign in&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Form 로그인을 처리하는 url로 post요청을 보낸다. &lt;form class=&quot;form-signin&quot; th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; username과 password를 받는 input태그에서 name속성에 username과 password를 확실히 기입해줘야 Security가 해당 데이터를 얻어올 수 있다. &lt;input type=&quot;text&quot; th:name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required autofocus&gt;...&lt;input type=&quot;password&quot; th:name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; 로그인 후 진입 화면&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;시작페이지&lt;/h1&gt;&lt;form action=&quot;/logout&quot; th:action=&quot;@&#123;/logout&#125;&quot; th:method=&quot;post&quot; sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;button type=&quot;submit&quot; value=&quot;logout&quot;&gt;로그 아웃&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 인증시에만 보이는 form태그xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;을 이용하면 security를 통해 인증된 사용자에게만 보이는 화면을 구성할 수 있다. &lt;form action=&quot;/logout&quot; th:action=&quot;@&#123;/logout&#125;&quot; th:method=&quot;post&quot; sec:authorize=&quot;isAuthenticated()&quot;&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Form login","slug":"Spring/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Form-login/"}],"tags":[]},{"title":"Spring Security Form Login - 2. Security 설정 및 UserDetailsService 정의하기","slug":"spring/spring-security/form-login/form-login-config","date":"2021-01-29T00:38:37.000Z","updated":"2024-02-26T16:20:48.782Z","comments":true,"path":"2021/01/29/spring/spring-security/form-login/form-login-config/","link":"","permalink":"https://ckck803.github.io/2021/01/29/spring/spring-security/form-login/form-login-config/","excerpt":"로그인 로그아웃을 처리를 위한 Controller 생성 Spring Security 설정하기 UserDetailsService 구현하기 로그인 로그아웃을 처리를 위한 Controller/login으로 사용자 로그인 요청을 처리하고 /logout으로 사용자 로그아웃 요청을 처리한다. @Controller@RequiredArgsConstructorpublic class SecurityController &#123; private final CustomUserDetailsService customUserDetailsService; private final PasswordEncoder passwordEncoder; @GetMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @GetMapping(&quot;/login&quot;) public String login()&#123; return &quot;login&quot;; &#125; @GetMapping(&quot;/logout&quot;) public void logout()&#123; &#125;&#125; Spring Security 설정하기Spring Security를 설정하고 싶으면 EnableWebSecurity어노테이션과 WebSecurityConfigurerAdapter 클래스를 상속해 method들을 overriding한다. configure(AuthenticationManagerBuilder auth) AuthenticationManager를 설정하기 위해 사용하는 method configure(WebSecurity web) 전역적인 security를 설정할 때 사용하는 method, 보통은 보안 예외처리에 사용한다. configure(HttpSecurity http) request 단위로 보안을 걸때 사용하는 method configure(HttpSecurity http)을 이용해 허가를 하는 경우에는 Spring Filter Chain을 거처야 하지만 configure(WebSecurity web)를 이용하면 Spring Filter Chain을 거치지 않는다. @EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final CustomUserDetailsService customUserDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserDetailsService); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; web .ignoring() .antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;) .antMatchers(&quot;/favicon.ico&quot;, &quot;/resources/**&quot;, &quot;/error&quot;) ; &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http. authorizeRequests() .anyRequest().authenticated(); http .formLogin() // Form Login을 이용한 인증 방식을 사용 .loginPage(&quot;/login&quot;) // Login Page로 redirect할 경로를 적어준다. .defaultSuccessUrl(&quot;/&quot;, true) // 로그인 성공후 이동할 경로 .permitAll() ; &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125;","text":"로그인 로그아웃을 처리를 위한 Controller 생성 Spring Security 설정하기 UserDetailsService 구현하기 로그인 로그아웃을 처리를 위한 Controller/login으로 사용자 로그인 요청을 처리하고 /logout으로 사용자 로그아웃 요청을 처리한다. @Controller@RequiredArgsConstructorpublic class SecurityController &#123; private final CustomUserDetailsService customUserDetailsService; private final PasswordEncoder passwordEncoder; @GetMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @GetMapping(&quot;/login&quot;) public String login()&#123; return &quot;login&quot;; &#125; @GetMapping(&quot;/logout&quot;) public void logout()&#123; &#125;&#125; Spring Security 설정하기Spring Security를 설정하고 싶으면 EnableWebSecurity어노테이션과 WebSecurityConfigurerAdapter 클래스를 상속해 method들을 overriding한다. configure(AuthenticationManagerBuilder auth) AuthenticationManager를 설정하기 위해 사용하는 method configure(WebSecurity web) 전역적인 security를 설정할 때 사용하는 method, 보통은 보안 예외처리에 사용한다. configure(HttpSecurity http) request 단위로 보안을 걸때 사용하는 method configure(HttpSecurity http)을 이용해 허가를 하는 경우에는 Spring Filter Chain을 거처야 하지만 configure(WebSecurity web)를 이용하면 Spring Filter Chain을 거치지 않는다. @EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final CustomUserDetailsService customUserDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserDetailsService); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; web .ignoring() .antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;) .antMatchers(&quot;/favicon.ico&quot;, &quot;/resources/**&quot;, &quot;/error&quot;) ; &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http. authorizeRequests() .anyRequest().authenticated(); http .formLogin() // Form Login을 이용한 인증 방식을 사용 .loginPage(&quot;/login&quot;) // Login Page로 redirect할 경로를 적어준다. .defaultSuccessUrl(&quot;/&quot;, true) // 로그인 성공후 이동할 경로 .permitAll() ; &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; UserDetailsService 등록하기AuthenticationManagerBuilder객체를 이용해 인증시 사용하는 UserDetailsService를 지정해준다. @Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserDetailsService);&#125; 정적파일을 Security Filter에서 제외 시키기css파일이나 js파일에 대한 예외처리를 하지 않는 경우 화면을 그릴때 해당 자원에 대한 접근을 하지 못하므로 화면이 깨져 나오게 된다. @Overridepublic void configure(WebSecurity web) throws Exception &#123; web .ignoring() .antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;) .antMatchers(&quot;/favicon.ico&quot;, &quot;/resources/**&quot;, &quot;/error&quot;) ;&#125; 요청에 따라서 인증&#x2F;인가를 설정로그인을 하기 위한 login페이지에 대한 접근은 허용하고, 그 외의 모든 자원에 대한 요청은 인증을 요구하도록 한다. @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http. authorizeRequests() .anyRequest().authenticated(); http .formLogin() // Form Login을 이용한 인증 방식을 사용 .loginPage(&quot;/login&quot;) // Login Page로 redirect할 경로를 적어준다. .defaultSuccessUrl(&quot;/&quot;, true) // 로그인 성공후 이동할 경로 .permitAll() ;&#125; Service생성하기Spring Security는 인증 과정에서 UserDetails를 구현한 객체를 이용한다. 따라서 Service를 생성하기 위해서는 UserDetailsService를 이용해 Service를 만든다. UserDetialsService 인터페이스는 loadUserByUsername 메서드가 있는데, username을 이용해 DB로부터 사용자 정보를 얻어와 UserDetails를 반환하는 메서드이다. @Service@RequiredArgsConstructorpublic class CustomUserDetailsService implements UserDetailsService &#123; private final AccountRepository accountRepository; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException &#123; // return new User(&quot;user&quot;, passwordEncoder.encode( &quot;1234&quot;), new ArrayList&lt;&gt;()); Optional&lt;Account&gt; optional = accountRepository.findByEmail(email); if(optional.isPresent())&#123; Account account = optional.get(); return new SecurityAccount(account); &#125;else&#123; throw new UsernameNotFoundException(email + &quot;사용자 없음&quot;); &#125; &#125; public void saveAccount(Account account)&#123; accountRepository.save(account); &#125;&#125; DB로부터 User정보를 가져와 UserDetails객체로 반환UserDetailsService인터페이스를 구현하면서username을 매게변수로 받는 loadUserByUsername메소드를 Overriding해,DB에 접근해 User정보를 가져오고 해당 객체를 UserDetails객체를 반환하도록 Overriding 해준다. loadUserByUsername메소드를 Overriding 해줘야 한다. loadUserByUsername메소드는 username을 매게변수로 받아 username을 이용해 DB로부터 User정보를 가져오고 해당 객체를 UserDetails객체로 반환하도록 Overriding 해준다. @Overridepublic UserDetails loadUserByUsername(String email) throws UsernameNotFoundException &#123; // return new User(&quot;user&quot;, passwordEncoder.encode( &quot;1234&quot;), new ArrayList&lt;&gt;()); Optional&lt;Account&gt; optional = accountRepository.findByEmail(email); if(optional.isPresent())&#123; Account account = optional.get(); return new SecurityAccount(account); &#125;else&#123; throw new UsernameNotFoundException(email + &quot;사용자 없음&quot;); &#125;&#125; User객체 생성하기Spring Security는 인증시 UserDetails객체를 사용하므로 Account객체를 UserDetails객체로 변환해줘야 한다. Spring Security에서는 UserDetails를 객체를 쉽게 만들 수 있도록 UserDetails를 구현한 User객체를 지원한다. public class SecurityAccount extends User &#123; public SecurityAccount(Account account)&#123; super(account.getEmail() , account.getPassword() , AuthorityUtils.createAuthorityList(account.getRole().getValue())); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Form login","slug":"Spring/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Form-login/"}],"tags":[]},{"title":"Spring Security Form Login - 1. 기본적인 모델 정의하기","slug":"spring/spring-security/form-login/form-login-modeling","date":"2021-01-27T18:54:27.000Z","updated":"2024-02-26T16:21:04.187Z","comments":true,"path":"2021/01/28/spring/spring-security/form-login/form-login-modeling/","link":"","permalink":"https://ckck803.github.io/2021/01/28/spring/spring-security/form-login/form-login-modeling/","excerpt":"Spring properties 설정하기Spring Security에서 사용하는 기본적인 user정보를 등록한다. jpa를 사용하므로 관련 옵션도 추가해준다. application.ymlspring: security: user: name: user password: 1234 jpa: hibernate: ddl-auto: create-drop properties: hibernate: show_sql: true format_sql: true profiles: include: mysqllogging: level: org.springframework.security: DEBUG application-mysql.ymlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/&#123;테이블명&#125;?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: user_id password: user_password jpa: database: mysql database-platform: org.hibernate.dialect.MySQL5InnoDBDialect Entity 생성하기사용자 정보를 저장하기 위한 Account Entity를 만든다. @Entity@NoArgsConstructor@AllArgsConstructor@Getterpublic class Account &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long idx; private String username; @Column(unique = true, nullable = false) private String email; private String password; @Enumerated(EnumType.STRING) private Role role; private String getRoleValue()&#123; return this.role.getValue(); &#125; @Builder public Account(String username, String email, String password, Role role)&#123; this.username = username; this.email = email; this.password = password; this.role = role; &#125;&#125;","text":"Spring properties 설정하기Spring Security에서 사용하는 기본적인 user정보를 등록한다. jpa를 사용하므로 관련 옵션도 추가해준다. application.ymlspring: security: user: name: user password: 1234 jpa: hibernate: ddl-auto: create-drop properties: hibernate: show_sql: true format_sql: true profiles: include: mysqllogging: level: org.springframework.security: DEBUG application-mysql.ymlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/&#123;테이블명&#125;?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: user_id password: user_password jpa: database: mysql database-platform: org.hibernate.dialect.MySQL5InnoDBDialect Entity 생성하기사용자 정보를 저장하기 위한 Account Entity를 만든다. @Entity@NoArgsConstructor@AllArgsConstructor@Getterpublic class Account &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long idx; private String username; @Column(unique = true, nullable = false) private String email; private String password; @Enumerated(EnumType.STRING) private Role role; private String getRoleValue()&#123; return this.role.getValue(); &#125; @Builder public Account(String username, String email, String password, Role role)&#123; this.username = username; this.email = email; this.password = password; this.role = role; &#125;&#125; 권한을 지정하기위한 Rolepublic enum Role &#123; USER(&quot;ROLE_USER&quot;), ADMIN(&quot;ROLE_ADMIN&quot;); private String value; Role(String value)&#123; this.value = value; &#125; public String getValue()&#123; return this.value; &#125;&#125; DB로부터 사용자 정보를 가져오기 위한 Repository@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, Long&gt; &#123; public Optional&lt;Account&gt; findByEmail(String email);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Form login","slug":"Spring/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Form-login/"}],"tags":[]},{"title":"백준 1726 - 로봇","slug":"algorithm/baekjoon/BFS/1726","date":"2020-01-29T06:28:53.000Z","updated":"2024-02-18T16:19:54.509Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/BFS/1726/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/BFS/1726/","excerpt":"링크https://www.acmicpc.net/problem/1726 채점 현황 전체 소스 코드#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int M, N;int map[101][101];bool check[101][101][4];int dx[4] = &#123;0, 1, -1, 0&#125;;int dy[4] = &#123;-1, 0, 0, 1&#125;;// char dir[4] = &#123; &#x27;N&#x27;, &#x27;E&#x27;, &#x27;W&#x27;, &#x27;S&#x27; &#125;;struct point &#123; int y; int x; int dir;&#125;;int main(void) &#123; cin &gt;&gt; M &gt;&gt; N; for (int i = 1; i &lt;= M; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; point start, goal; int tempY, tempX, tempD; cin &gt;&gt; tempY &gt;&gt; tempX &gt;&gt; tempD; start.y = tempY; start.x = tempX; start.dir = tempD % 4; cin &gt;&gt; tempY &gt;&gt; tempX &gt;&gt; tempD; goal.y = tempY; goal.x = tempX; goal.dir = tempD % 4; queue&lt;point&gt; q; q.push(start); check[start.y][start.x][start.dir] = true; int num = 0; while (!q.empty()) &#123; int q_size = q.size(); while (q_size--) &#123; int y = q.front().y; int x = q.front().x; int d = q.front().dir; q.pop(); if (y == goal.y &amp;&amp; x == goal.x &amp;&amp; d == goal.dir) &#123; cout &lt;&lt; num &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; int nextR, nextL; if (d == 0) &#123; nextR = 1; nextL = 2; &#125; else if (d == 1) &#123; nextR = 3; nextL = 0; &#125; else if (d == 2) &#123; nextR = 0; nextL = 3; &#125; else if (d == 3) &#123; nextR = 2; nextL = 1; &#125; if (check[y][x][nextR] == false) &#123; check[y][x][nextR] = true; q.push(&#123;y, x, nextR&#125;); &#125; if (check[y][x][nextL] == false) &#123; check[y][x][nextL] = true; q.push(&#123;y, x, nextL&#125;); &#125; for (int i = 1; i &lt;= 3; i++) &#123; int nx = x + dx[d] * i; int ny = y + dy[d] * i; if (1 &lt;= ny &amp;&amp; ny &lt;= M &amp;&amp; 1 &lt;= nx &amp;&amp; nx &lt;= N) &#123; if (map[ny][nx] == 1) &#123; break; &#125; if (check[ny][nx][d] == false) &#123; check[ny][nx][d] = true; q.push(&#123;ny, nx, d&#125;); &#125; &#125; &#125; &#125; num++; // for (int i = 1; i &lt;= M; i++) &#123; // for (int j = 1; j &lt;= N; j++) &#123; // cout &lt;&lt; check[i][j][3] &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; // &#125; // cout &lt;&lt; endl; &#125;&#125;","text":"링크https://www.acmicpc.net/problem/1726 채점 현황 전체 소스 코드#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int M, N;int map[101][101];bool check[101][101][4];int dx[4] = &#123;0, 1, -1, 0&#125;;int dy[4] = &#123;-1, 0, 0, 1&#125;;// char dir[4] = &#123; &#x27;N&#x27;, &#x27;E&#x27;, &#x27;W&#x27;, &#x27;S&#x27; &#125;;struct point &#123; int y; int x; int dir;&#125;;int main(void) &#123; cin &gt;&gt; M &gt;&gt; N; for (int i = 1; i &lt;= M; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; point start, goal; int tempY, tempX, tempD; cin &gt;&gt; tempY &gt;&gt; tempX &gt;&gt; tempD; start.y = tempY; start.x = tempX; start.dir = tempD % 4; cin &gt;&gt; tempY &gt;&gt; tempX &gt;&gt; tempD; goal.y = tempY; goal.x = tempX; goal.dir = tempD % 4; queue&lt;point&gt; q; q.push(start); check[start.y][start.x][start.dir] = true; int num = 0; while (!q.empty()) &#123; int q_size = q.size(); while (q_size--) &#123; int y = q.front().y; int x = q.front().x; int d = q.front().dir; q.pop(); if (y == goal.y &amp;&amp; x == goal.x &amp;&amp; d == goal.dir) &#123; cout &lt;&lt; num &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; int nextR, nextL; if (d == 0) &#123; nextR = 1; nextL = 2; &#125; else if (d == 1) &#123; nextR = 3; nextL = 0; &#125; else if (d == 2) &#123; nextR = 0; nextL = 3; &#125; else if (d == 3) &#123; nextR = 2; nextL = 1; &#125; if (check[y][x][nextR] == false) &#123; check[y][x][nextR] = true; q.push(&#123;y, x, nextR&#125;); &#125; if (check[y][x][nextL] == false) &#123; check[y][x][nextL] = true; q.push(&#123;y, x, nextL&#125;); &#125; for (int i = 1; i &lt;= 3; i++) &#123; int nx = x + dx[d] * i; int ny = y + dy[d] * i; if (1 &lt;= ny &amp;&amp; ny &lt;= M &amp;&amp; 1 &lt;= nx &amp;&amp; nx &lt;= N) &#123; if (map[ny][nx] == 1) &#123; break; &#125; if (check[ny][nx][d] == false) &#123; check[ny][nx][d] = true; q.push(&#123;ny, nx, d&#125;); &#125; &#125; &#125; &#125; num++; // for (int i = 1; i &lt;= M; i++) &#123; // for (int j = 1; j &lt;= N; j++) &#123; // cout &lt;&lt; check[i][j][3] &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; // &#125; // cout &lt;&lt; endl; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"틀렸습니다 1","slug":"틀렸습니다-1","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-1/"}]},{"title":"1707 이분 그래프","slug":"algorithm/baekjoon/BFS/1707","date":"2020-01-29T06:23:28.000Z","updated":"2024-02-18T16:19:54.509Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/BFS/1707/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/BFS/1707/","excerpt":"링크https://www.acmicpc.net/problem/1707 채점 현황 전체 소스 코드#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int T, V, E;vector&lt;vector&lt;int&gt;&gt; arr;bool check[20002];bool colorCheck[20002];int color[20002];void paintColor(int cnt, int cntColor) &#123; for (int i = 0; i &lt; arr[cnt].size(); i++) &#123; int next = arr[cnt][i]; if (check[next] == false) &#123; if (cntColor == 1) &#123; color[next] = 2; check[next] = true; paintColor(next, 2); &#125; else &#123; color[next] = 1; check[next] = true; paintColor(next, 1); &#125; &#125; &#125;&#125;bool confirmColor(int cnt) &#123; bool isTrue = true; for (int i = 0; i &lt; arr[cnt].size(); i++) &#123; int next = arr[cnt][i]; if (color[cnt] != color[next]) &#123; if (colorCheck[next] == false) &#123; colorCheck[next] = true; isTrue = confirmColor(next); &#125; &#125; else &#123; return false; &#125; &#125; return isTrue;&#125;int main(void) &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; V &gt;&gt; E; arr = vector&lt;vector&lt;int&gt;&gt;(V + 1); for (int i = 0; i &lt; E; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; arr[x].push_back(y); arr[y].push_back(x); &#125; for (int i = 1; i &lt;= V; i++) &#123; if (check[i] == false) &#123; check[i] = true; color[i] = 1; paintColor(i, 1); &#125; &#125; bool isTrue; for (int i = 1; i &lt;= V; i++) &#123; if (colorCheck[i] == false) &#123; colorCheck[i] = true; isTrue = confirmColor(i); if (isTrue == false) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;; break; &#125; &#125; &#125; if (isTrue == true) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; for (int i = 1; i &lt;= V; i++) &#123; check[i] = 0; colorCheck[i] = false; color[i] = 0; &#125; &#125;&#125;","text":"링크https://www.acmicpc.net/problem/1707 채점 현황 전체 소스 코드#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int T, V, E;vector&lt;vector&lt;int&gt;&gt; arr;bool check[20002];bool colorCheck[20002];int color[20002];void paintColor(int cnt, int cntColor) &#123; for (int i = 0; i &lt; arr[cnt].size(); i++) &#123; int next = arr[cnt][i]; if (check[next] == false) &#123; if (cntColor == 1) &#123; color[next] = 2; check[next] = true; paintColor(next, 2); &#125; else &#123; color[next] = 1; check[next] = true; paintColor(next, 1); &#125; &#125; &#125;&#125;bool confirmColor(int cnt) &#123; bool isTrue = true; for (int i = 0; i &lt; arr[cnt].size(); i++) &#123; int next = arr[cnt][i]; if (color[cnt] != color[next]) &#123; if (colorCheck[next] == false) &#123; colorCheck[next] = true; isTrue = confirmColor(next); &#125; &#125; else &#123; return false; &#125; &#125; return isTrue;&#125;int main(void) &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; V &gt;&gt; E; arr = vector&lt;vector&lt;int&gt;&gt;(V + 1); for (int i = 0; i &lt; E; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; arr[x].push_back(y); arr[y].push_back(x); &#125; for (int i = 1; i &lt;= V; i++) &#123; if (check[i] == false) &#123; check[i] = true; color[i] = 1; paintColor(i, 1); &#125; &#125; bool isTrue; for (int i = 1; i &lt;= V; i++) &#123; if (colorCheck[i] == false) &#123; colorCheck[i] = true; isTrue = confirmColor(i); if (isTrue == false) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;; break; &#125; &#125; &#125; if (isTrue == true) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; for (int i = 1; i &lt;= V; i++) &#123; check[i] = 0; colorCheck[i] = false; color[i] = 0; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"DFS","slug":"Programming/Beakjoon/DFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/DFS/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"틀렸습니다 4","slug":"틀렸습니다-4","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-4/"}]},{"title":"백준 1600 - 말이 되고픈 원숭이","slug":"algorithm/baekjoon/BFS/1600","date":"2020-01-29T06:19:42.000Z","updated":"2024-02-18T16:19:54.509Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/BFS/1600/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/BFS/1600/","excerpt":"링크https://www.acmicpc.net/problem/1600 체점 현황 문제 풀이 말처럼 뛸 수 있는 횟수(k), width, height를 입력 받는다. field에 대한 정보를 입력 받는다. (0, 0)에서 시작해 (width-1, height-1)까지 갈 수 있는 최소 횟수를 탐색한다. 원숭이가 움직일 수 있는 방법은 두가지가 존재한다. 말처럼 뛸 수 있는 방법(k내의 횟수에서) 상하좌우로 움직일 수 있는 방법 말이 (width-1, height-1)에 도착하면 그 횟수를 반환한다. 만약 도착하지 못할 경우 -1을 반환한다. 말이 움직인 횟수를 출력해준다. 전체 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;int numOfKnight;int width, height;int field[202][202];bool check[31][202][202];int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;int horse_dx[8] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;int horse_dy[8] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;struct point &#123; int k; int y; int x;&#125;;int bfs(int y, int x) &#123; check[0][y][x] = true; queue&lt;point&gt; q; q.push(&#123;0, y, x&#125;); int count = 0; while (!q.empty()) &#123; int q_size = q.size(); while (q_size--) &#123; int cntK = q.front().k; int cntY = q.front().y; int cntX = q.front().x; q.pop(); if (cntY == height - 1 &amp;&amp; cntX == width - 1) &#123; return count; &#125; if (cntK &lt; numOfKnight) &#123; for (int i = 0; i &lt; 8; i++) &#123; int ny = cntY + horse_dy[i]; int nx = cntX + horse_dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) continue; if (field[ny][nx] == 0 &amp;&amp; check[cntK + 1][ny][nx] == false) &#123; check[cntK + 1][ny][nx] = true; q.push(&#123;cntK + 1, ny, nx&#125;); &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) continue; if (field[ny][nx] == 0 &amp;&amp; check[cntK][ny][nx] == false) &#123; check[cntK][ny][nx] = true; q.push(&#123;cntK, ny, nx&#125;); &#125; &#125; &#125; count++; &#125; return -1;&#125;int main(void) &#123; cin &gt;&gt; numOfKnight &gt;&gt; width &gt;&gt; height; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; cin &gt;&gt; field[i][j]; &#125; &#125; int minValueOfMove = bfs(0, 0); cout &lt;&lt; minValueOfMove &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","text":"링크https://www.acmicpc.net/problem/1600 체점 현황 문제 풀이 말처럼 뛸 수 있는 횟수(k), width, height를 입력 받는다. field에 대한 정보를 입력 받는다. (0, 0)에서 시작해 (width-1, height-1)까지 갈 수 있는 최소 횟수를 탐색한다. 원숭이가 움직일 수 있는 방법은 두가지가 존재한다. 말처럼 뛸 수 있는 방법(k내의 횟수에서) 상하좌우로 움직일 수 있는 방법 말이 (width-1, height-1)에 도착하면 그 횟수를 반환한다. 만약 도착하지 못할 경우 -1을 반환한다. 말이 움직인 횟수를 출력해준다. 전체 소스 코드#include &lt;bits/stdc++.h&gt;using namespace std;int numOfKnight;int width, height;int field[202][202];bool check[31][202][202];int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;int horse_dx[8] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;int horse_dy[8] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;struct point &#123; int k; int y; int x;&#125;;int bfs(int y, int x) &#123; check[0][y][x] = true; queue&lt;point&gt; q; q.push(&#123;0, y, x&#125;); int count = 0; while (!q.empty()) &#123; int q_size = q.size(); while (q_size--) &#123; int cntK = q.front().k; int cntY = q.front().y; int cntX = q.front().x; q.pop(); if (cntY == height - 1 &amp;&amp; cntX == width - 1) &#123; return count; &#125; if (cntK &lt; numOfKnight) &#123; for (int i = 0; i &lt; 8; i++) &#123; int ny = cntY + horse_dy[i]; int nx = cntX + horse_dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) continue; if (field[ny][nx] == 0 &amp;&amp; check[cntK + 1][ny][nx] == false) &#123; check[cntK + 1][ny][nx] = true; q.push(&#123;cntK + 1, ny, nx&#125;); &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) continue; if (field[ny][nx] == 0 &amp;&amp; check[cntK][ny][nx] == false) &#123; check[cntK][ny][nx] = true; q.push(&#123;cntK, ny, nx&#125;); &#125; &#125; &#125; count++; &#125; return -1;&#125;int main(void) &#123; cin &gt;&gt; numOfKnight &gt;&gt; width &gt;&gt; height; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; cin &gt;&gt; field[i][j]; &#125; &#125; int minValueOfMove = bfs(0, 0); cout &lt;&lt; minValueOfMove &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"틀렸습니다 5","slug":"틀렸습니다-5","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-5/"}]},{"title":"백준 1260 - DFS와 BFS","slug":"algorithm/baekjoon/DFS/1260","date":"2020-01-29T06:16:03.000Z","updated":"2024-02-18T16:19:54.510Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/DFS/1260/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/DFS/1260/","excerpt":"링크https://www.acmicpc.net/problem/1260 문제 풀이그래프탐색에 있어 가장 기본적인 DFS, BFS를 사용해볼 수 있는 유형이다. 좌표 자체가 존재하지 않아 1차원적인 check방식을 통해 탐색해 나간다. cpp 코드#include &lt;bits/stdc++.h&gt;using namespace std;// 점점의 개수 : N, 간산의 개수 M, 탐색을 시작할 정점의 번호 Vint N, M, V;bool check_dfs[1010];bool check_bfs[1010];int graph[1010][1010];void bfs(int start) &#123; queue&lt;int&gt; q; q.push(start); check_bfs[start] = true; while (!q.empty()) &#123; int cnt = q.front(); q.pop(); cout &lt;&lt; cnt &lt;&lt; &#x27; &#x27;; for (int i = 1; i &lt;= N; i++) &#123; if (graph[cnt][i] == 1 &amp;&amp; check_bfs[i] == false) &#123; check_bfs[i] = true; q.push(i); &#125; &#125; &#125;&#125;void dfs(int depth, int cnt) &#123; check_dfs[cnt] = true; if (N &lt;= depth) &#123; return; &#125; cout &lt;&lt; cnt &lt;&lt; &#x27; &#x27;; for (int i = 1; i &lt;= N; i++) &#123; if (graph[cnt][i] == 1 &amp;&amp; check_dfs[i] == false) &#123; dfs(depth + 1, i); &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; V; for (int i = 0; i &lt; M; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; graph[a][b] = 1; graph[b][a] = 1; &#125; dfs(0, V); cout &lt;&lt; &#x27;\\n&#x27;; bfs(V); return 0;&#125; java 코드import java.io.IOException;import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class Main &#123; static int n, m, v; static int map[][]; static boolean bfs_check[]; static boolean dfs_check[]; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); v = sc.nextInt(); map = new int[n + 1][n + 1]; for (int i = 0; i &lt; m; i++) &#123; int from, to; from = sc.nextInt(); to = sc.nextInt(); map[from][to] = 1; map[to][from] = 1; &#125; bfs_check = new boolean[n + 1]; dfs_check = new boolean[n + 1]; dfs(v); System.out.println(); bfs(v); sc.close(); &#125; static void dfs(int node) &#123; System.out.print(Integer.toString(node) + &#x27; &#x27;); dfs_check[node] = true; for (int i = 1; i &lt;= n; i++) &#123; if (map[node][i] == 1 &amp;&amp; dfs_check[i] == false) &#123; dfs(i); &#125; &#125; &#125; static void bfs(int start) &#123; Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;(); q.offer(start); bfs_check[start] = true; System.out.print(Integer.toString(start) + &#x27; &#x27;); while (!q.isEmpty()) &#123; int cnt = q.remove(); for (int i = 1; i &lt;= n; i++) &#123; if (map[cnt][i] == 1 &amp;&amp; bfs_check[i] == false) &#123; bfs_check[i] = true; q.offer(i); System.out.print(Integer.toString(i) + &#x27; &#x27;); &#125; &#125; &#125; &#125;&#125; python 코드","text":"링크https://www.acmicpc.net/problem/1260 문제 풀이그래프탐색에 있어 가장 기본적인 DFS, BFS를 사용해볼 수 있는 유형이다. 좌표 자체가 존재하지 않아 1차원적인 check방식을 통해 탐색해 나간다. cpp 코드#include &lt;bits/stdc++.h&gt;using namespace std;// 점점의 개수 : N, 간산의 개수 M, 탐색을 시작할 정점의 번호 Vint N, M, V;bool check_dfs[1010];bool check_bfs[1010];int graph[1010][1010];void bfs(int start) &#123; queue&lt;int&gt; q; q.push(start); check_bfs[start] = true; while (!q.empty()) &#123; int cnt = q.front(); q.pop(); cout &lt;&lt; cnt &lt;&lt; &#x27; &#x27;; for (int i = 1; i &lt;= N; i++) &#123; if (graph[cnt][i] == 1 &amp;&amp; check_bfs[i] == false) &#123; check_bfs[i] = true; q.push(i); &#125; &#125; &#125;&#125;void dfs(int depth, int cnt) &#123; check_dfs[cnt] = true; if (N &lt;= depth) &#123; return; &#125; cout &lt;&lt; cnt &lt;&lt; &#x27; &#x27;; for (int i = 1; i &lt;= N; i++) &#123; if (graph[cnt][i] == 1 &amp;&amp; check_dfs[i] == false) &#123; dfs(depth + 1, i); &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; V; for (int i = 0; i &lt; M; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; graph[a][b] = 1; graph[b][a] = 1; &#125; dfs(0, V); cout &lt;&lt; &#x27;\\n&#x27;; bfs(V); return 0;&#125; java 코드import java.io.IOException;import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class Main &#123; static int n, m, v; static int map[][]; static boolean bfs_check[]; static boolean dfs_check[]; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); v = sc.nextInt(); map = new int[n + 1][n + 1]; for (int i = 0; i &lt; m; i++) &#123; int from, to; from = sc.nextInt(); to = sc.nextInt(); map[from][to] = 1; map[to][from] = 1; &#125; bfs_check = new boolean[n + 1]; dfs_check = new boolean[n + 1]; dfs(v); System.out.println(); bfs(v); sc.close(); &#125; static void dfs(int node) &#123; System.out.print(Integer.toString(node) + &#x27; &#x27;); dfs_check[node] = true; for (int i = 1; i &lt;= n; i++) &#123; if (map[node][i] == 1 &amp;&amp; dfs_check[i] == false) &#123; dfs(i); &#125; &#125; &#125; static void bfs(int start) &#123; Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;(); q.offer(start); bfs_check[start] = true; System.out.print(Integer.toString(start) + &#x27; &#x27;); while (!q.isEmpty()) &#123; int cnt = q.remove(); for (int i = 1; i &lt;= n; i++) &#123; if (map[cnt][i] == 1 &amp;&amp; bfs_check[i] == false) &#123; bfs_check[i] = true; q.offer(i); System.out.print(Integer.toString(i) + &#x27; &#x27;); &#125; &#125; &#125; &#125;&#125; python 코드def bfs(start): queue = [start] bfs_check = [start] while queue: cnt_node = queue.pop(0) for next_node in range(len(matrix[cnt_node])): if(matrix[cnt_node][next_node] == 1 and next_node not in bfs_check): bfs_check.append(next_node) queue.append(next_node) return bfs_checkdef dfs(cnt_node): dfs_check.append(cnt_node) for next_node in range(len(matrix[cnt_node])): if(matrix[cnt_node][next_node] == 1 and next_node not in dfs_check): dfs(next_node)N, M, V = map(int, input().split())matrix = [[0] * (N+1) for i in range(N+1)]dfs_check = []for i in range(M): point = list(map(int, input().split())) matrix[point[0]][point[1]] = 1 matrix[point[1]][point[0]] = 1dfs(V)print(*dfs_check)print(*bfs(V))","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"DFS","slug":"Programming/Beakjoon/DFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/DFS/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"C++","slug":"C","permalink":"https://ckck803.github.io/tags/C/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"DFS","slug":"DFS","permalink":"https://ckck803.github.io/tags/DFS/"},{"name":"Python","slug":"Python","permalink":"https://ckck803.github.io/tags/Python/"}]},{"title":"백준 1012 - 유기농 배추","slug":"algorithm/baekjoon/BFS/1012","date":"2020-01-29T04:08:11.000Z","updated":"2024-02-18T16:19:54.509Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/BFS/1012/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/BFS/1012/","excerpt":"링크https://www.acmicpc.net/problem/1012 채점 현황 문제 풀이전형적인 색칠하기 유형히다.이 문제는 testcase문제이기 때문에 각 case마다 데이터를 초기화 해줘야 한다. field를 탐색하면서 배추가 심어져 있는 위치를 찾는다. 배추가 심어져 있는 곳을 찾았다면 이전에 탐색을 했는지 확인한다. 탐색한 적이 없다면 다음으로 넘어간다. 탐색한 적이 있다면 1로 돌아간다. 배추가 심어져 있는 주변에 다른 배추들이 있는지 탐색한다. 탐색횟수가 배추 흰 지렁이의 갯수가 된다. BFS를 이용한 코드","text":"링크https://www.acmicpc.net/problem/1012 채점 현황 문제 풀이전형적인 색칠하기 유형히다.이 문제는 testcase문제이기 때문에 각 case마다 데이터를 초기화 해줘야 한다. field를 탐색하면서 배추가 심어져 있는 위치를 찾는다. 배추가 심어져 있는 곳을 찾았다면 이전에 탐색을 했는지 확인한다. 탐색한 적이 없다면 다음으로 넘어간다. 탐색한 적이 있다면 1로 돌아간다. 배추가 심어져 있는 주변에 다른 배추들이 있는지 탐색한다. 탐색횟수가 배추 흰 지렁이의 갯수가 된다. BFS를 이용한 코드#include &lt;bits/stdc++.h&gt;using namespace std;int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;int field[55][55];bool check[55][55];int width, height;int test_case;int num_of_cabbage;int num_of_warm;void init() &#123; for (int i = 0; i &lt; 55; i++) &#123; for (int j = 0; j &lt; 55; j++) &#123; field[i][j] = 0; check[i][j] = false; &#125; &#125; num_of_warm = 0;&#125;void bfs(int y, int x) &#123; num_of_warm++; check[y][x] = true; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;y, x&#125;); while (!q.empty()) &#123; int cnt_y = q.front().first; int cnt_x = q.front().second; q.pop(); for (int i = 0; i &lt; 4; i++) &#123; int ny = cnt_y + dy[i]; int nx = cnt_x + dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) &#123; continue; &#125; if (check[ny][nx] == true) &#123; continue; &#125; if (field[ny][nx] == 0) &#123; continue; &#125; check[ny][nx] = true; q.push(&#123;ny, nx&#125;); &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; test_case; while (test_case--) &#123; cin &gt;&gt; width &gt;&gt; height &gt;&gt; num_of_cabbage; init(); for (int i = 0; i &lt; num_of_cabbage; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; field[y][x] = 1; &#125; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; if (field[i][j] == 1 &amp;&amp; check[i][j] == false) &#123; bfs(i, j); &#125; &#125; &#125; cout &lt;&lt; num_of_warm &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; DFS를 이용한 코드#include &lt;bits/stdc++.h&gt;using namespace std;int field[55][55];bool check[55][55];int test_case, width, height;int num_of_cabbage;int num_of_warm;int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;void init() &#123; for (int i = 0; i &lt; 55; i++) &#123; for (int j = 0; j &lt; 55; j++) &#123; field[i][j] = 0; check[i][j] = false; &#125; &#125; num_of_warm = 0;&#125;void dfs(int y, int x) &#123; check[y][x] = true; for (int i = 0; i &lt; 4; i++) &#123; int ny = y + dy[i]; int nx = x + dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) &#123; continue; &#125; if (check[ny][nx] == true) &#123; continue; &#125; if (field[ny][nx] == 0) &#123; continue; &#125; dfs(ny, nx); &#125;&#125;int main(void) &#123; cin &gt;&gt; test_case; while (test_case--) &#123; cin &gt;&gt; width &gt;&gt; height &gt;&gt; num_of_cabbage; init(); for (int i = 0; i &lt; num_of_cabbage; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; field[y][x] = true; &#125; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; if (field[i][j] == 1 &amp;&amp; check[i][j] == false) &#123; num_of_warm++; dfs(i, j); &#125; &#125; &#125; cout &lt;&lt; num_of_warm &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 자바를 이용한 풀이import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class Main &#123; static int Map[][] = new int[55][55]; static boolean check[][] = new boolean[55][55]; static int dy[] = &#123; 1, 0, -1, 0 &#125;; static int dx[] = &#123; 0, 1, 0, -1 &#125;; static int testCase; static int row; static int col; static int num; static int result; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); testCase = sc.nextInt(); while (testCase-- &gt; 0) &#123; result = 0; for (int i = 0; i &lt; 55; i++) &#123; for (int j = 0; j &lt; 55; j++) &#123; Map[i][j] = 0; check[i][j] = false; &#125; &#125; row = sc.nextInt(); col = sc.nextInt(); num = sc.nextInt(); for (int i = 0; i &lt; num; i++) &#123; int x, y; x = sc.nextInt(); y = sc.nextInt(); Map[y][x] = 1; &#125; for (int i = 0; i &lt; col; i++) &#123; for (int j = 0; j &lt; row; j++) &#123; if (Map[i][j] == 1 &amp;&amp; check[i][j] == false) &#123; bfs(i, j); &#125; &#125; &#125; System.out.println(result); &#125; &#125; static void bfs(int y, int x) &#123; result++; Queue&lt;int[]&gt; q = new LinkedList(); q.add(new int[] &#123; y, x &#125;); check[y][x] = true; while (!q.isEmpty()) &#123; int point[] = q.remove(); int cntY = point[0]; int cntX = point[1]; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; 0 &lt;= nx &amp;&amp; nx &lt; row) &#123; if (check[ny][nx] == false &amp;&amp; Map[ny][nx] == 1) &#123; check[ny][nx] = true; q.add(new int[] &#123; ny, nx &#125;); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"DFS","slug":"Programming/Beakjoon/DFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/DFS/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"틀렸습니다 2","slug":"틀렸습니다-2","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-2/"},{"name":"C++","slug":"C","permalink":"https://ckck803.github.io/tags/C/"}]}],"categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"https://ckck803.github.io/categories/CS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"},{"name":"Frontend","slug":"Frontend","permalink":"https://ckck803.github.io/categories/Frontend/"},{"name":"Vue3","slug":"Frontend/Vue3","permalink":"https://ckck803.github.io/categories/Frontend/Vue3/"},{"name":"Vue","slug":"Frontend/Vue","permalink":"https://ckck803.github.io/categories/Frontend/Vue/"},{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring Core","slug":"Spring/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring/Spring-Core/"},{"name":"Vite","slug":"Frontend/Vite","permalink":"https://ckck803.github.io/categories/Frontend/Vite/"},{"name":"Spring Security","slug":"Spring/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/"},{"name":"Filter","slug":"Spring/Spring-Security/Filter","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Filter/"},{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Django","slug":"Programming/Django","permalink":"https://ckck803.github.io/categories/Programming/Django/"},{"name":"React Query","slug":"Frontend/React-Query","permalink":"https://ckck803.github.io/categories/Frontend/React-Query/"},{"name":"JPA","slug":"Programming/JPA","permalink":"https://ckck803.github.io/categories/Programming/JPA/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"Spring Cloud","slug":"Spring/Spring-Cloud","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/"},{"name":"Service Discovery","slug":"Spring/Spring-Cloud/Service-Discovery","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Service-Discovery/"},{"name":"Spring Batch","slug":"Spring/Spring-Batch","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://ckck803.github.io/categories/Kubernetes/"},{"name":"Config","slug":"Kubernetes/Config","permalink":"https://ckck803.github.io/categories/Kubernetes/Config/"},{"name":"Istio","slug":"Kubernetes/Istio","permalink":"https://ckck803.github.io/categories/Kubernetes/Istio/"},{"name":"Custom","slug":"Kubernetes/Custom","permalink":"https://ckck803.github.io/categories/Kubernetes/Custom/"},{"name":"Autoscaler","slug":"Kubernetes/Autoscaler","permalink":"https://ckck803.github.io/categories/Kubernetes/Autoscaler/"},{"name":"Develop","slug":"Develop","permalink":"https://ckck803.github.io/categories/Develop/"},{"name":"MySQL","slug":"Develop/MySQL","permalink":"https://ckck803.github.io/categories/Develop/MySQL/"},{"name":"Step","slug":"Spring/Spring-Batch/Step","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/"},{"name":"Chunk","slug":"Spring/Spring-Batch/Step/Chunk","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Step/Chunk/"},{"name":"Helm","slug":"Kubernetes/Helm","permalink":"https://ckck803.github.io/categories/Kubernetes/Helm/"},{"name":"서비스","slug":"Kubernetes/서비스","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"Job","slug":"Spring/Spring-Batch/Job","permalink":"https://ckck803.github.io/categories/Spring/Spring-Batch/Job/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"Scan","slug":"CS/DataBase/Scan","permalink":"https://ckck803.github.io/categories/CS/DataBase/Scan/"},{"name":"워크로드","slug":"Kubernetes/워크로드","permalink":"https://ckck803.github.io/categories/Kubernetes/%EC%9B%8C%ED%81%AC%EB%A1%9C%EB%93%9C/"},{"name":"AWS","slug":"AWS","permalink":"https://ckck803.github.io/categories/AWS/"},{"name":"EKS","slug":"AWS/EKS","permalink":"https://ckck803.github.io/categories/AWS/EKS/"},{"name":"Docker","slug":"Docker","permalink":"https://ckck803.github.io/categories/Docker/"},{"name":"구성요소","slug":"Kubernetes/구성요소","permalink":"https://ckck803.github.io/categories/Kubernetes/%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C/"},{"name":"Redux","slug":"Frontend/Redux","permalink":"https://ckck803.github.io/categories/Frontend/Redux/"},{"name":"React","slug":"Frontend/React","permalink":"https://ckck803.github.io/categories/Frontend/React/"},{"name":"TypeScript","slug":"Frontend/React/TypeScript","permalink":"https://ckck803.github.io/categories/Frontend/React/TypeScript/"},{"name":"Spring WebSocket","slug":"Spring/Spring-WebSocket","permalink":"https://ckck803.github.io/categories/Spring/Spring-WebSocket/"},{"name":"Spring Resource","slug":"Spring/Spring-Resource","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring/Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Boot/Spring-Framework/"},{"name":"Redis","slug":"Programming/Redis","permalink":"https://ckck803.github.io/categories/Programming/Redis/"},{"name":"Spring Data JPA","slug":"Spring/Spring-Data-JPA","permalink":"https://ckck803.github.io/categories/Spring/Spring-Data-JPA/"},{"name":"QueryDSL","slug":"Programming/QueryDSL","permalink":"https://ckck803.github.io/categories/Programming/QueryDSL/"},{"name":"연관관계","slug":"Programming/JPA/연관관계","permalink":"https://ckck803.github.io/categories/Programming/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/"},{"name":"Oauth2","slug":"Spring/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Oauth2/"},{"name":"컴퓨터 구조","slug":"CS/컴퓨터-구조","permalink":"https://ckck803.github.io/categories/CS/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0/"},{"name":"메모리 관리","slug":"CS/컴퓨터-구조/메모리-관리","permalink":"https://ckck803.github.io/categories/CS/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC/"},{"name":"Spring Test","slug":"Spring/Spring-Test","permalink":"https://ckck803.github.io/categories/Spring/Spring-Test/"},{"name":"프로그래머스","slug":"Programming/프로그래머스","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"문자열","slug":"Programming/프로그래머스/문자열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"정규 표현식","slug":"Programming/프로그래머스/문자열/정규-표현식","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%AC%B8%EC%9E%90%EC%97%B4/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/"},{"name":"Oracle","slug":"Programming/Oracle","permalink":"https://ckck803.github.io/categories/Programming/Oracle/"},{"name":"경우의 수","slug":"Programming/프로그래머스/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"},{"name":"중복 순열","slug":"Programming/프로그래머스/경우의-수/중복-순열","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/%EC%A4%91%EB%B3%B5-%EC%88%9C%EC%97%B4/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"그래프","slug":"Programming/Beakjoon/그래프","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EA%B7%B8%EB%9E%98%ED%94%84/"},{"name":"Kafka","slug":"Spring/Kafka","permalink":"https://ckck803.github.io/categories/Spring/Kafka/"},{"name":"Kafka","slug":"Develop/Kafka","permalink":"https://ckck803.github.io/categories/Develop/Kafka/"},{"name":"경우의 수","slug":"Programming/Beakjoon/경우의-수","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/"},{"name":"Security","slug":"CS/Network/Security","permalink":"https://ckck803.github.io/categories/CS/Network/Security/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"},{"name":"MySQL","slug":"Programming/MySQL","permalink":"https://ckck803.github.io/categories/Programming/MySQL/"},{"name":"SAMSUNG","slug":"Programming/Beakjoon/SAMSUNG","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/SAMSUNG/"},{"name":"시뮬레이션","slug":"Programming/Beakjoon/SAMSUNG/시뮬레이션","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/SAMSUNG/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"HTTP","slug":"CS/Network/HTTP","permalink":"https://ckck803.github.io/categories/CS/Network/HTTP/"},{"name":"Redis","slug":"Spring/Redis","permalink":"https://ckck803.github.io/categories/Spring/Redis/"},{"name":"Spring AOP","slug":"Spring/Spring-AOP","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/"},{"name":"포인트 컷","slug":"Spring/Spring-AOP/포인트-컷","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%BB%B7/"},{"name":"Pointcut","slug":"Spring/Spring-AOP/Pointcut","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Pointcut/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"},{"name":"Collection","slug":"Programming/JAVA/Collection","permalink":"https://ckck803.github.io/categories/Programming/JAVA/Collection/"},{"name":"AOP Aspect","slug":"Spring/Spring-AOP/AOP-Aspect","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/AOP-Aspect/"},{"name":"Programming Lanuage","slug":"CS/Programming-Lanuage","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/"},{"name":"JAVA","slug":"CS/Programming-Lanuage/JAVA","permalink":"https://ckck803.github.io/categories/CS/Programming-Lanuage/JAVA/"},{"name":"AspectJ","slug":"Spring/Spring-AOP/AspectJ","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/AspectJ/"},{"name":"Bean Post Processor","slug":"Spring/Spring-AOP/Bean-Post-Processor","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Bean-Post-Processor/"},{"name":"Spring Proxy","slug":"Spring/Spring-AOP/Spring-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-AOP/Spring-Proxy/"},{"name":"Spring 고급편","slug":"Spring/Spring-고급편","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/"},{"name":"CGLIB","slug":"Spring/Spring-고급편/CGLIB","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/CGLIB/"},{"name":"Dynamic Proxy","slug":"Spring/Spring-고급편/Dynamic-Proxy","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Dynamic-Proxy/"},{"name":"Decorator 패턴","slug":"Spring/Spring-고급편/Decorator-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Decorator-%ED%8C%A8%ED%84%B4/"},{"name":"Proxy 패턴","slug":"Spring/Spring-고급편/Proxy-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Proxy-%ED%8C%A8%ED%84%B4/"},{"name":"Template Callback 패턴","slug":"Spring/Spring-고급편/Template-Callback-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Template-Callback-%ED%8C%A8%ED%84%B4/"},{"name":"Strategy 패턴","slug":"Spring/Spring-고급편/Strategy-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Strategy-%ED%8C%A8%ED%84%B4/"},{"name":"Template Method 패턴","slug":"Spring/Spring-고급편/Template-Method-패턴","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/Template-Method-%ED%8C%A8%ED%84%B4/"},{"name":"ThreadLocal","slug":"Spring/Spring-고급편/ThreadLocal","permalink":"https://ckck803.github.io/categories/Spring/Spring-%EA%B3%A0%EA%B8%89%ED%8E%B8/ThreadLocal/"},{"name":"Cpp","slug":"Programming/Cpp","permalink":"https://ckck803.github.io/categories/Programming/Cpp/"},{"name":"STL","slug":"Programming/Cpp/STL","permalink":"https://ckck803.github.io/categories/Programming/Cpp/STL/"},{"name":"Transaction","slug":"CS/DataBase/Transaction","permalink":"https://ckck803.github.io/categories/CS/DataBase/Transaction/"},{"name":"Docker","slug":"Programming/Docker","permalink":"https://ckck803.github.io/categories/Programming/Docker/"},{"name":"Docker Compose","slug":"Programming/Docker/Docker-Compose","permalink":"https://ckck803.github.io/categories/Programming/Docker/Docker-Compose/"},{"name":"Process","slug":"CS/Process","permalink":"https://ckck803.github.io/categories/CS/Process/"},{"name":"Spring Rest","slug":"Spring/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring/Spring-Rest/"},{"name":"인증 과정","slug":"Spring/Spring-Security/인증-과정","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95/"},{"name":"Login","slug":"Frontend/Login","permalink":"https://ckck803.github.io/categories/Frontend/Login/"},{"name":"Security","slug":"Spring/Spring-Security/Security","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Security/"},{"name":"Config","slug":"Spring/Spring-Security/Security/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Security/Config/"},{"name":"File","slug":"Spring/Spring-Resource/File","permalink":"https://ckck803.github.io/categories/Spring/Spring-Resource/File/"},{"name":"Rest","slug":"Programming/JAVA/Rest","permalink":"https://ckck803.github.io/categories/Programming/JAVA/Rest/"},{"name":"REST","slug":"Programming/JAVA/REST","permalink":"https://ckck803.github.io/categories/Programming/JAVA/REST/"},{"name":"Spring MVC","slug":"Spring/Spring-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring-MVC/"},{"name":"Spring Framework","slug":"Spring/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/"},{"name":"lifecycle","slug":"Spring/Spring-Framework/lifecycle","permalink":"https://ckck803.github.io/categories/Spring/Spring-Framework/lifecycle/"},{"name":"자료구조","slug":"Programming/Beakjoon/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"List","slug":"Programming/Beakjoon/자료구조/List","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/List/"},{"name":"Kafka","slug":"Spring/Spring-Cloud/Kafka","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Kafka/"},{"name":"Feign Client","slug":"Spring/Spring-Cloud/Feign-Client","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Feign-Client/"},{"name":"Config","slug":"Spring/Spring-Cloud/Config","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Config/"},{"name":"Gateway","slug":"Spring/Spring-Cloud/Gateway","permalink":"https://ckck803.github.io/categories/Spring/Spring-Cloud/Gateway/"},{"name":"JPA 프로그래밍(기본편)","slug":"Programming/JPA/JPA-프로그래밍-기본편","permalink":"https://ckck803.github.io/categories/Programming/JPA/JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EB%B3%B8%ED%8E%B8/"},{"name":"ToastUI","slug":"Frontend/ToastUI","permalink":"https://ckck803.github.io/categories/Frontend/ToastUI/"},{"name":"로그인","slug":"Frontend/로그인","permalink":"https://ckck803.github.io/categories/Frontend/%EB%A1%9C%EA%B7%B8%EC%9D%B8/"},{"name":"To do List","slug":"Frontend/To-do-List","permalink":"https://ckck803.github.io/categories/Frontend/To-do-List/"},{"name":"블로그","slug":"Frontend/블로그","permalink":"https://ckck803.github.io/categories/Frontend/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"자료구조","slug":"Programming/프로그래머스/자료구조","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"SET","slug":"Programming/프로그래머스/자료구조/SET","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/SET/"},{"name":"SET","slug":"Programming/Beakjoon/자료구조/SET","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/SET/"},{"name":"시뮬레이션","slug":"Programming/Beakjoon/시뮬레이션","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"이분탐색","slug":"Programming/Beakjoon/이분탐색","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/"},{"name":"스택","slug":"Programming/Beakjoon/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"},{"name":"카테고리","slug":"Programming/Beakjoon/카테고리","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC/"},{"name":"스택","slug":"Programming/프로그래머스/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"},{"name":"JWT","slug":"Spring/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/JWT/"},{"name":"Logging","slug":"Spring/Logging","permalink":"https://ckck803.github.io/categories/Spring/Logging/"},{"name":"게시판 만들기","slug":"Spring/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"},{"name":"Spring 5","slug":"Spring/Spring-5","permalink":"https://ckck803.github.io/categories/Spring/Spring-5/"},{"name":"다익스트라","slug":"Programming/Beakjoon/다익스트라","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"},{"name":"강의","slug":"Spring/강의","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"},{"name":"Form login","slug":"Spring/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring/Spring-Security/Form-login/"},{"name":"DFS","slug":"Programming/Beakjoon/DFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/DFS/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"},{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"},{"name":"React","slug":"React","permalink":"https://ckck803.github.io/tags/React/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"https://ckck803.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"Cpp","slug":"Cpp","permalink":"https://ckck803.github.io/tags/Cpp/"},{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://ckck803.github.io/tags/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://ckck803.github.io/tags/%EC%82%BC%EC%84%B1-%EA%B8%B0%EC%B6%9C/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"},{"name":"틀렸습니다 5","slug":"틀렸습니다-5","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-5/"},{"name":"틀렸습니다 1","slug":"틀렸습니다-1","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-1/"},{"name":"틀렸습니다 4","slug":"틀렸습니다-4","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-4/"},{"name":"C++","slug":"C","permalink":"https://ckck803.github.io/tags/C/"},{"name":"DFS","slug":"DFS","permalink":"https://ckck803.github.io/tags/DFS/"},{"name":"Python","slug":"Python","permalink":"https://ckck803.github.io/tags/Python/"},{"name":"틀렸습니다 2","slug":"틀렸습니다-2","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-2/"}]}